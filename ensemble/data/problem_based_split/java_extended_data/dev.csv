content,label,problem,from,idx,problem_title,problem_description,input_output_specification,tags
"import java.util.Scanner;
public class solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		
		for(int i=0; i<t; i++) {
			String s = sc.next(); 
			int indexOfC = s.indexOf('C');
			if(s.charAt(0)=='R' && s.charAt(1)-'0'<=9 && indexOfC>0) {
				int row, col;
				row = Integer.parseInt(s.substring(1, indexOfC));
				col = Integer.parseInt(s.substring(indexOfC+1));
				
				StringBuilder colStr = new StringBuilder();
                while (col > 0) {
                    colStr.insert(0, (char)((col - 1) % 26 + 'A'));
                    col = (col - 1) / 26;
                }
                System.out.println(colStr.toString()+""""+row);
			}
			else {
				int k,row,col = 0;

				for(k=0; s.charAt(k)-'A'>=0; k++) {
                    col *= 26;
                    col += s.charAt(k) - 'A' + 1;
				}
				row = Integer.parseInt(s.substring(k));
				System.out.println(""R""+row+""C""+col);
			}
		}
	}
}
",3,0001_B,CODEFORCES,1488,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
 public class Main{
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int tr = sc.nextInt();
		while (tr-- > 0){
			String s = sc.next();
			if (s.matches(""R[0-9]+C[0-9]+"")){
				String[] ss = s.split(""R|C"");
				long x = Long.parseLong(ss[2]);
				String t = """";
				while (x != 0){
					long m = x % 26;
					if (m == 0){
						t = 'Z' + t;
						x /= 26;
						x -= 1;
					}
					else{
						char temp = (char)(m + 'A' - 1);
						t = temp + t;
						x /= 26;
					}
					
				}
				System.out.println(t + """" + ss[1]);
			} else {
				String x1 = s.replaceAll(""[0-9]"", """");
				String x2 = s.replaceAll(""[A-Z]"", """");
				long ans = 0, base = 1;
				for (int i = x1.length() - 1; i >= 0; i--){
					ans += ((long)x1.charAt(i) - (long)'A' + 1) * base;	
					base *= 26;
				}
				System.out.println(""R"" + x2 + ""C"" + ans);
			}
		}
	}
}
",3,0001_B,CODEFORCES,1485,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
import java.lang.*;
import java.io.*;
public class CodeForces{
      public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		for(int i=0;i<n;i++){
			String s=scan.next();
			if(s.matches(""R[0-9]+C[0-9]+"")){
				String[] nums=s.split(""R|C"");
				int x=Integer.parseInt(nums[2]);
				String t="""";
				while(x!=0){
					int m=x%26;
					if(m==0){
						t=""Z""+t;
						x-=26;
					}
					else
						t=(char)(m+'A'-1)+t;
					x/=26;
				}
				System.out.println(t+nums[1]);
			}
			else{
				String x1 = s.replaceAll(""[0-9]"", """");
				String x2 = s.replaceAll(""[A-Z]"", """");
				int base=1;
				int t=0;
				for(int j=x1.length()-1;j>=0;j--) {
					t+=base*(x1.charAt(j)-'A'+1);
					base*=26;
				}
				System.out.println(""R""+ x2 + ""C""+t);
			}
		}
	}
  

}",3,0001_B,CODEFORCES,1491,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

import static java.lang.System.*;

public class B {

	public static void main(String[] args) {

		Scanner sc = new Scanner(in);

		int n = sc.nextInt();

		while(n-->0){

			String s = sc.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

				out.println(""R""+r+""C""+num);

			}

		}

	}



}

",3,0001_B,CODEFORCES,1477,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

public class SpreadSheet {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		int t=Integer.parseInt(sc.nextLine());
		while(t-->0) {
			String str=sc.nextLine();
			StringBuilder stb=new StringBuilder();
			if(str.charAt(0)=='R' && Character.isDigit(str.charAt(1)) && str.contains(""C"")) {
				int substr=Integer.parseInt(str.substring(str.indexOf('C')+1));
				while(substr>0) {
					if(substr%26!=0) {
						stb=stb.append((char)(substr%26+64));
						substr=substr/26;
					}else {
						stb=stb.append('Z');
						substr=substr/26-1;
					}
				}
				System.out.println(stb.reverse()+(str.substring(1, str.indexOf('C'))));
			}else {
				StringBuilder stb1=new StringBuilder();
				int ln=0;
				while(Character.isLetter(str.charAt(ln))){
					ln++;
				}
				int i=0;
				stb1=stb1.append('R').append(str.substring(ln)).append('C');
				long lng=0;
				while(Character.isLetter(str.charAt(i))){
					int temp=str.charAt(i)-64;
					lng=lng+temp*(long)Math.pow(26, ln-1);
					ln--;
					i++;
				}
				System.out.println(stb1.append(lng));
			}
			
		}
	}

}",3,0001_B,CODEFORCES,1479,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

import java.io.*;



public class Spreadsheets {

	public static void main(String[] args) throws IOException {

		Scanner in = new Scanner(System.in);

		int n = in.nextInt();

		in.nextLine();



		while (n-- > 0) {

			String coord = in.nextLine();

			if (coord.matches(""R[0-9]+C[0-9]+"")) {

				int c = Integer

						.parseInt(coord.substring(coord.indexOf('C') + 1));

				System.out.println(numToCharCoord(c)

						+ coord.substring(1, coord.indexOf('C')));

			} else {

				System.out.println(""R"" + coord.replaceAll(""\\D"", """") + ""C""

						+ charToNumCoord(coord.replaceAll(""\\d"", """")));

			}

		}

		in.close();

	}



	public static String numToCharCoord(int num) {

		String out = """";

		while (num > 0) {

			num--;

			out = (char) (num % 26 + 'A') + out;

			num /= 26;

		}

		return out;

	}



	public static int charToNumCoord(String str) {

		int num = 0;

		for (int i = 0; i < str.length(); i++) {

			num = num * 26 + (str.charAt(i) - 'A' + 1);

		}

		return num;

	}

}",3,0001_B,CODEFORCES,1451,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Solution {

	public static void main(String[] args) {
		final Scanner in = new Scanner(System.in);
		final int n = in.nextInt();

		final Pattern a1 = Pattern.compile(""([A-Z]+)(\\d+)"");
		final Pattern rxcy = Pattern.compile(""R(\\d+)C(\\d+)"");
		for (int i = 0; i < n; i++) {
			final String coord = in.next();
			Matcher matcher;
			if ((matcher = rxcy.matcher(coord)).matches()) {
				int col = Integer.parseInt(matcher.group(2));
				final StringBuilder colstring = new StringBuilder();
				do
					colstring.append(col-- % 26 == 0 ? 'Z' : (char) (++col % 26 + 64));
				while ((col /= 26) != 0);
				System.out.println(colstring.reverse() + matcher.group(1));
			} else if ((matcher = a1.matcher(coord)).matches()) {
				final String colstring = matcher.group(1);
				int col = 0;
				for (int j = colstring.length() - 1, pow = 1; j >= 0; j--, pow *= 26)
					col += (colstring.charAt(j) - 64) * pow;
				System.out.println(""R"" + matcher.group(2) + ""C"" + col);
			} else
				throw new IllegalArgumentException(coord);
		}
	}

}
",3,0001_B,CODEFORCES,1482,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
public class Solution{
         public static void main(String[] arg){
		    Scanner sc=new Scanner(System.in);
			int t=sc.nextInt();
			for(int i=0;i<t;i++){
			   String in=sc.next();
			   String out="""";
			   String[] args=in.split(""(?<=\\D)(?=\\d)"");
			   if(args.length>2){
				   String[] nn=args[1].split(""(?<=\\d)(?=\\D)"");
				   String row=nn[0];
				   int col=Integer.parseInt(args[2]);
				   while(col>0){
					   if(col%26==0){
						   out=(char)(64+26)+out;
						   col-=26;
					   }else{
						   out=(char)(col%26+64)+out;
					   }
					   col=col/26;
				   }
				   out=out+row;
			   }
			   else{
				   int sum=0;
				   int len=args[0].length();
				   for(int j=0;j<len-1;j++){
					   sum+=((int)(args[0].charAt(j))-64)*Math.pow(26,len-j-1);
				   }
				   sum+=((int)(args[0].charAt(len-1))-64);
				   String row=args[1];
				   out+=""R""+row+""C""+sum;
			   }
			   System.out.println(out);
			}
        }
    }",3,0001_B,CODEFORCES,1480,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"

import java.io.*;

import java.util.*;



public class B1_2 {

	public static void main(String args[]) throws IOException {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();

		for (int i = 0; i < n; i ++) {

			String s = sc.next();

			if (s.matches(""R[0-9]+C[0-9]+"")) {

				String ss[] = s.replaceAll(""[R|C]"", "" "").trim().split("" ""), r = """";

				int c = Integer.parseInt(ss[1]);

				while (c > 0) {

					c --;

					r = (char) (c % 26 + 'A') + r;

					c = c / 26;

				}

				System.out.println(r.concat(ss[0]));

			} else {

				String r = s.replaceAll(""[A-Z]"", """"), c = s.replaceAll(""[0-9]"", """");

				int k = 0;

				for (int j = 0; j < c.length(); j ++) {

					k = k*26 + (c.charAt(j) - 'A' + 1);

				}

				System.out.println(""R"" + r + ""C"" + k);

			}

		}

	}

}",3,0001_B,CODEFORCES,1487,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;



public class Main {

	public static void main(String[] args){

		Scanner scan=new Scanner(System.in);

		int n=scan.nextInt();

		for(int i=0;i<n;i++){

			String s=scan.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] nums=s.split(""R|C"");

				int x=Integer.parseInt(nums[2]);

				String t="""";

				while(x!=0){

					int m=x%26;

					if(m==0){

						t=""Z""+t;

						x-=26;

					}

					else

						t=(char)(m+'A'-1)+t;

					x/=26;

				}

				System.out.println(t+nums[1]);

			}

			else{

				String x1 = s.replaceAll(""[0-9]"", """");

				String x2 = s.replaceAll(""[A-Z]"", """");

				int base=1;

				int t=0;

				for(int j=x1.length()-1;j>=0;j--) {

					t+=base*(x1.charAt(j)-'A'+1);

					base*=26;

				}

				System.out.println(""R""+ x2 + ""C""+t);

			}

		}

	}

}

",3,0001_B,CODEFORCES,1456,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;



public class code_1B {

	public static void main(String[] args) {

		Scanner scan = new Scanner(System.in);

		int count = scan.nextInt();

		String[] strs = new String[count]; 

		for(int i=0;i<count;i++){

			strs[i] = scan.next();

		}

		for(int i=0;i<count;i++){

			StringBuffer sb = new StringBuffer();

			String str = strs[i];

			if(str.matches(""R\\d+C\\d+"")){

				int col = Integer.valueOf(str.split(""C"")[1]);

				while(col>26){

					col--;

					sb.append((char)(col%26+65));

					col /=26;

				}

				sb.append((char)(col+64));

				sb.reverse();

				int rIndex = str.indexOf(""R"");

				int cIndex = str.indexOf(""C"");

				sb.append(str.substring(rIndex+1, cIndex));

			}else{

				String row = str.split(""\\d"")[0];

				sb.append(""R"");

				sb.append(str.split(row)[1]);

				sb.append(""C"");

				int col = 0;

				for(int j=0;j<row.length();j++){

					col = col*26+(int)row.charAt(j)-64;

				}

				sb.append(col);

			}

			System.out.println(sb.toString());

		}

	}

}

",3,0001_B,CODEFORCES,1483,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"
import java.util.*;
public class Main {
	static char kk[] = new char[100010];
	static String to26(int x){
		int t = 0;
		int cnt = 0;
		while(x != 0){
			int k = x%26;
			if(k != 0)
			    kk[cnt++] = (char)(k+'A'-1);
			else{
				kk[cnt++] = 'Z';
				x -= 26;
			}
			x /= 26;
		}
		char tt[] = new char[cnt];
		int j = 0;
		for(int i = cnt-1;i >= 0;i--)
			tt[j++] = kk[i];
		return String.valueOf(tt);
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		for(int i = 1;i <= n;i++){
			String s = sc.next();
			if(s.charAt(0) == 'R' && s.charAt(1) >= '0' && s.charAt(1) <= '9' && s.indexOf('C') != -1){
				String a[] = s.split(""\\D+"");
				int t = Integer.valueOf(a[2]);
				System.out.println(to26(t)+a[1]);
			}
			else{
				int ans = 0;
				String t1[] = s.split(""\\D+"");
				int k = 0;
				for(int j = s.length()-1;j >= 0;j--)
					if(s.charAt(j) >= 'A' && s.charAt(j) <= 'Z')
						ans += (s.charAt(j)-'A'+1)*Math.pow(26,k++);
				System.out.print(""R""+t1[1]+""C"");
				System.out.println(ans);
			}
		}
	}
}",3,0001_B,CODEFORCES,1489,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

import java.util.regex.Pattern;

import java.util.regex.PatternSyntaxException;



public class Main {

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);

		

		int n = s.nextInt();

		

		for(int i = 0; i < n; i++){

			String in = s.next();

			if(in.matches(""^R\\d+C\\d+"")){

				//rc

				String a[] = in.split(""C"");

				int r = Integer.parseInt(a[1]);

				String ans = """";

				while(r > 0){

					r--;

					char c = (char) ('A'+(r%26)-1);

					r /= 26;

					if(c == 'Z'){

						c = 'A';

					} else {

						c++;

					}

					ans = c+ans;

				}

				ans += a[0].substring(1);

				System.out.println(ans);

			} else {

				//ab

				String chars = """";

				String nums = """";

				for(int j = 0; j < in.length(); j++){

					if(Character.isDigit(in.charAt(j))){

						nums += in.charAt(j);

					} else {

						chars += in.charAt(j);

					}

				}

				String ans = ""R""+nums+""C"";

				

				int r = 0;

				for(int j = 0; j <  chars.length(); j++){

					r = r*26+chars.charAt(j)-'A'+1;

				}

				System.out.println(ans+r);

				

			}

			

		}

		

	}

}

",3,0001_B,CODEFORCES,1469,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

public class SpreadSheet {

	public static void main(String [] args){

		Scanner in= new Scanner(System.in);

		int n=in.nextInt();

		while(--n>=0)

		{

			String crood=in.next();

			int cIndex= crood.indexOf(""C"");

			if(crood.startsWith(""R"") && Character.isDigit(crood.charAt(1)) && cIndex != -1)

			{

				int row=Integer.valueOf(crood.substring(1,cIndex));

				int col= Integer.valueOf(crood.substring(cIndex+1));

				StringBuilder colstr= new StringBuilder();

				while(col>0){

					colstr.insert(0, (char)((col-1)%26+'A'));

					col=(col-1)/26;

				}

				System.out.println(colstr.toString()+row);

			}

			else{

				int split =1;

				while(!Character.isDigit(crood.charAt(split)))

					split++;

				String colstr=crood.substring(0,split);

				int row=Integer.valueOf(crood.substring(split));

				int col=0;

				for(int i=0;i<colstr.length();i++){

					col *=26;

					col += colstr.charAt(i)-'A'+1;

				}

				System.out.println(""R""+row+""C""+col);

						

			}

			

		}

	}



}

",3,0001_B,CODEFORCES,1467,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

public class b {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		for(int t = in.nextInt(); t>0; t--) {
			String str = in.next();
			int i = 0;
			while(!Character.isDigit(str.charAt(i))) i++;
			while(i < str.length() && Character.isDigit(str.charAt(i))) i++;
			if(i == str.length())
				System.out.println(YtoX(str));
			else
				System.out.println(XtoY(str));
		}
	}
	public static String XtoY(String arg) {
		int i = 0;
		while(arg.charAt(i) != 'C') i++;
		int row = Integer.parseInt(arg.substring(1,i));
		int col = Integer.parseInt(arg.substring(i+1));
		String res = """";
		do {
			col--;
			res = (char)(col%26+'A') + res;
			col /= 26;
		}while(col > 0);
		res = res + row;
		return res;
	}
	public static String YtoX(String arg) {
		int i = 0;
		while(!Character.isDigit(arg.charAt(i))) i++;
		String col = arg.substring(0,i);
		int row = Integer.parseInt(arg.substring(i));
		int c = 0;
		for(i=0; i<col.length(); i++) {
			c = c*26 + col.charAt(i)-'A'+1;
		}
		return ""R"" + row + ""C"" + c;
	}
}
",3,0001_B,CODEFORCES,1474,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

public class Main {



	public static void main(String[] args) {

		Scanner kb = new Scanner(System.in);

		int n = kb.nextInt();

		while(n-->0){

			String s = kb.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				System.out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

				System.out.println(""R""+r+""C""+num);

			}

		}

		

	}

}

",3,0001_B,CODEFORCES,1461,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"

import java.util.Scanner;



/**

 *

 * @author Warwic

 */

public class ACM {



   public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		int n = in.nextInt();

		while(n-->0){

			String s = in.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				System.out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

			System.out.println(""R""+r+""C""+num);

			}

		}

	}



}",3,0001_B,CODEFORCES,1476,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;





public class Main {

	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		int N = in.nextInt();

		for(int kase=0;kase<N;kase++) {

			String s= in.next();

			if(s.matches(""R[0-9]+C[0-9]+"")) {

				String [] nums = s.split(""R|C"");

				int x = Integer.parseInt(nums[2]);

				String t="""";

				while(x!=0) {

					int m = x%26;

					if(m==0) {

						t='Z'+t;

						x-=26;

					}

					else

						t=(char)(m+'A'-1)+t;

					x/=26;

				}

				System.out.println(t+nums[1]);

			}

			else {

				String x1 = s.replaceAll(""[0-9]"", """");

				String x2 = s.replaceAll(""[A-Z]"", """");

				int base=1;

				int t=0;

				for(int i=x1.length()-1;i>=0;i--) {

					t+=base*(x1.charAt(i)-'A'+1);

					base*=26;

				}

				System.out.println(""R""+ x2 + ""C""+t);

			}

		}

	}



}",3,0001_B,CODEFORCES,1455,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

public class ABC {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			for (int t = 0; t < n; t++) {
				one(sc);
			}
		}
	}

	private static void one(Scanner sc) {
		String s = sc.next();
		if (s.matches(""R\\d+C\\d+"")) {
			String[] rc = s.split(""\\D"");
			int column = Integer.valueOf(rc[2]);
			String res = new String();
			while (column > 0) {
				int remainder = column % 26;
				column = column / 26;
				if (remainder == 0) {
					res = ""Z"" + res;
					column -= 1;
				} else {
					res = String.valueOf((char) (remainder - 1 + 'A')) + res;
				}
			}
			System.out.println(res + rc[1]);
		} else {
			char[] chars = s.toCharArray();
			int letterCount = 0;
			while (chars[letterCount] >= 'A') {
				letterCount++;
			}
			char[] letters = s.substring(0, letterCount).toCharArray();
			int res = 0;
			for (int i = 0; i < letters.length; i++) {
				res = res * 26 + letters[i] - 'A' + 1;
			}
			System.out.println(""R"" + s.substring(letterCount) + ""C"" + res);

		}
	}
}",3,0001_B,CODEFORCES,1490,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

public class RoundN111 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();

		while(n-->0){

			String s = sc.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				System.out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

				System.out.println(""R""+r+""C""+num);

			}

		}	}



}



",3,0001_B,CODEFORCES,1454,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;



public class b {



    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);



        int n = in.nextInt();



        for (int i = 0; i < n; i++) {

            String s = in.next();

            if (s.matches(""R+[0-9]+C+[0-9]+"")) {

                int x = Integer.parseInt(s.substring(s.indexOf(""C"") + 1, s.length()));

                String ans = """";

                while (x > 0) {

                    ans = ((char) ((x - 1) % 26 + 65)) + ans;

                    x = (x - 1) / 26;

                }

                System.out.println(ans + s.substring(s.indexOf(""R"") + 1, s.indexOf(""C"")));

            } else {

                int x = 0;

                int ans = 0;

                while (Character.isLetter(s.charAt(x))) {

                    ans = ans * 26 + (s.charAt(x) - 64);

                    x++;

                }

                System.out.println(""R"" + s.substring(x, s.length()) + ""C"" + ans);

            }

        }

    }

}",3,0001_B,CODEFORCES,1468,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;



public class Spreadsheet {

	public static void main(String[] args){

		Scanner scan=new Scanner(System.in);

		int n = scan.nextInt();

		for(int i = 0; i < n; i++){

			String s = scan.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] nums = s.split(""R|C"");

				int x = Integer.parseInt(nums[2]);

				String t = """";

				while(x != 0){

					int m = x%26;

					if(m == 0){

						t = ""Z""+t;

						x-=26;

					}

					else t = (char)(m+'A'-1)+t;

					x/=26;

				}

				System.out.println(t+nums[1]);

			}

			else{

				String x1 = s.replaceAll(""[0-9]"", """");

				String x2 = s.replaceAll(""[A-Z]"", """");

				int base = 1;

				int t = 0;

				for(int j = x1.length()-1;j>=0;j--) {

					t+=base*(x1.charAt(j)-'A'+1);

					base*=26;

				}

				System.out.println(""R""+ x2 + ""C""+t);

			}

		}

	}

}",3,0001_B,CODEFORCES,1457,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
import java.io.*;

public class Spreadsheets {
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		in.nextLine();

		while (n-- > 0) {
			String coord = in.nextLine();
			if (coord.matches(""R[0-9]+C[0-9]+"")) {
				int c = Integer
						.parseInt(coord.substring(coord.indexOf('C') + 1));
				System.out.println(numToCharCoord(c)
						+ coord.substring(1, coord.indexOf('C')));
			} else {
				System.out.println(""R"" + coord.replaceAll(""\\D"", """") + ""C""
						+ charToNumCoord(coord.replaceAll(""\\d"", """")));
			}
		}
		in.close();
	}

	public static String numToCharCoord(int num) {
		String out = """";
		while (num > 0) {
			num--;
			out = (char) (num % 26 + 'A') + out;
			num /= 26;
		}
		return out;
	}

	public static int charToNumCoord(String str) {
		int num = 0;
		for (int i = 0; i < str.length(); i++) {
			num = num * 26 + (str.charAt(i) - 'A' + 1);
		}
		return num;
	}
}
",3,0001_B,CODEFORCES,1450,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;



public class Main {



    public static void main(String[] args) {

        Scanner kb = new Scanner(System.in);

        int n = kb.nextInt();

        while (n-- > 0) {

            String s = kb.next();

            if (s.matches(""R[0-9]+C[0-9]+"")) {

                String[] ss = s.replaceAll(""[R|C]"", "" "").trim().split("" "");

                int c = new Integer(ss[1]);

                String ans = """";

                while (c > 0) {

                    c--;

                    ans = (char) (c % 26 + 'A') + ans;

                    c /= 26;

                }

                System.out.println(ans + """" + ss[0]);

            } else {

                String c = s.replaceAll(""[0-9]"", """");

                String r = s.replaceAll(""[A-Z]"", """");

                int num = 0;

                for (int i = 0; i < c.length(); i++) {

                    num = num * 26 + (c.charAt(i) - 'A' + 1);

                }

                System.out.println(""R"" + r + ""C"" + num);

            }

        }



    }

}",3,0001_B,CODEFORCES,1464,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

import java.io.*;

public class spreadsheet 

{

	static String col(long a)

	{

		int i=1,j;

		long temp=a;

		String ans="""";

		while(temp>Math.pow(26, i))

		{

			temp-=Math.pow(26, i);

			i++;

		}

		for( ;i>1;i--)

		{

			long l=(temp-1)/(long)Math.pow(26, i-1);

			ans+=(char) (l+65);

			temp-=l*Math.pow(26, i-1);

		}		

		ans+=(char) (temp+64);

		return ans;

	}		

	static long rev(String t)

	{

		long ans=0;

		int i,n=t.length(),j;

		for(i=n-1,j=0;i>=0;i--,j++)

		{

			ans+=Math.pow(26, j)*(t.charAt(i)-64);

		}

		return ans;

	}

	public static void main(String[] args) 

	{

		// TODO Auto-generated method stub

		Scanner in=new Scanner(System.in);

		int n=in.nextInt(),i;

		String t;

		for(i=0;i<n;i++)

		{

			t=in.next();

			String[] l=t.split(""(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)"");

			if(l.length==4)

				System.out.println(col(Long.parseLong(l[3]))+l[1]);

			else

			{			

				System.out.println(""R""+l[1]+""C""+rev(l[0]));

			}

		}

	}

}",3,0001_B,CODEFORCES,1459,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"//1B
import java.util.*;
public class Spreadsheets {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int t = s.nextInt();
		
		for(int i=0; i<t; i++) {
			String x = s.next(); 
			int indexOfC = x.indexOf('C');
			if(x.charAt(0)=='R' && x.charAt(1)-'0'<=9 && indexOfC>0) {
				int row, col;
				row = Integer.parseInt(x.substring(1, indexOfC));
				col = Integer.parseInt(x.substring(indexOfC+1));
				StringBuilder line = new StringBuilder();
                while (col > 0) {
                    line.insert(0, (char)((col - 1) % 26 + 'A'));
                    col = (col - 1) / 26;
                }
                System.out.println(line.toString()+""""+row);
			} else {
				int k,row,col = 0;
				for(k=0; x.charAt(k)-'A'>=0; k++) {
                    col *= 26;
                    col += x.charAt(k) - 'A' + 1;
				}
				row = Integer.parseInt(x.substring(k));
				System.out.println(""R""+row+""C""+col);
			}
		}
	}
}
",3,0001_B,CODEFORCES,1452,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class B {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		Pattern rcp = Pattern.compile(""R(\\d+)C(\\d+)"");
		Pattern op = Pattern.compile(""(\\D+)(\\d+)"");
		for (int n = s.nextInt(); n-- > 0;) {
			String line = s.next();
			Matcher m1 = rcp.matcher(line);
			Matcher m2 = op.matcher(line);
			if (m1.matches()) {
				int a = new Integer(m1.group(2));
				String r = """";
				for (; a > 0;) {
					int b = a % 26;
					a /= 26;
					if (b < 1) {
						b = 26;
						--a;
					}
					r = (char) (b + 64) + r;
				}
				line = r + m1.group(1);
			} else if (m2.matches()) {
				int r = 0;
				for (int a : m2.group(1).toCharArray()) {
					r = r * 26 + (a - 64);
				}
				line = ""R"" + m2.group(2) + ""C"" + r;
			}
			System.out.println(line);
		}
	}
}
",3,0001_B,CODEFORCES,1465,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Arrays;
import java.util.Scanner;

public class AA {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		for(int i =0; i < n; i++){
			String line = in.next();
			if(line.charAt(0)=='R'&&line.charAt(1)>='0'&&line.charAt(1)<='9'&&line.contains(""C"")){
				int row = Integer.parseInt(line.substring(1, line.indexOf('C')));
				int col = Integer.parseInt(line.substring(line.indexOf('C')+1))-1;
				StringBuilder c = new StringBuilder();
				while(true){
					c.append((char)(col%26+'A'));
					col/=26;
					col--;
					if(col<0)break;
					
				}
				c.reverse();
				System.out.println(c.toString()+row);
			}else{
				StringBuilder c = new StringBuilder();
				int idx = 0;
				while(line.charAt(idx)>='A'&&line.charAt(idx)<='Z'){
					idx++;
				}
				c.append(line.substring(0,idx));
				int row = Integer.parseInt(line.substring(idx));
				c.reverse();
				int col =0;
				idx = 0;
				for(Character ch : c.toString().toCharArray()){
					col+=((int)ch-'A'+1)*Math.pow(26, idx);
					idx++;
				}
				System.out.println(""R""+row+""C""+col);
			}
		}
	}

}",3,0001_B,CODEFORCES,1462,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

public class Main
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		int cases = sc.nextInt();

		for(int i = 0; i < cases; i++)
		{
			String test = sc.next();
			if(test.matches(""R[0-9]+C[0-9]+""))
			{
				//String[] nums = new String[test.length()];
				String[] nums = test.split(""R|C"");
				//System.out.println(Arrays.toString(nums));
				int x = Integer.parseInt(nums[2]);

				String column = """";
				while(x != 0)
				{
					if(x%26==0)
					{
						column = 'Z' + column;
						x -= 26;
					}
					else
					{
						column = (char)('A' - 1 + x%26) + column;
					}
					x/=26;
				}
				//System.out.println();
				System.out.println(column+nums[1]);
			}
			else
			{
				String letters = test.replaceAll(""[0-9]"", """");
				String numbers = test.replaceAll(""[A-Z]"", """");
				
				int base=1;
				int t=0;
				for(int j=letters.length()-1;j>=0;j--)
				{
					t+=base*(letters.charAt(j)-'A'+1);
					base*=26;
				}
				System.out.println(""R"" + numbers + ""C"" + t);
			}
		}
	}
}

/*
2
R23C55
BC23
*/",3,0001_B,CODEFORCES,1475,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		for(int i=0;i<n;i++){
			String s=scan.next();
			if(s.matches(""R[0-9]+C[0-9]+"")){
				String[] nums=s.split(""R|C"");
				int x=Integer.parseInt(nums[2]);
				String t="""";
				while(x!=0){
					int m=x%26;
					if(m==0){
						t=""Z""+t;
						x-=26;
					}
					else
						t=(char)(m+'A'-1)+t;
					x/=26;
				}
				System.out.println(t+nums[1]);
			}
			else{
				String x1 = s.replaceAll(""[0-9]"", """");
				String x2 = s.replaceAll(""[A-Z]"", """");
				int base=1;
				int t=0;
				for(int j=x1.length()-1;j>=0;j--) {
					t+=base*(x1.charAt(j)-'A'+1);
					base*=26;
				}
				System.out.println(""R""+ x2 + ""C""+t);
			}
		}
	}
}",3,0001_B,CODEFORCES,1473,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;
public class Spread {

	public static void main (String[]args) {
		Scanner sc= new Scanner(System.in);
		int x= sc.nextInt();
		
	while (x-->0) {
		String k="""";
		String letters="""";
		int row=0;
		int col=0;
		String cf="""";
		String num="""";
		int fin=0;
		String a=sc.next();
		if ((a.charAt(0)=='R')&&(a.charAt(1)>='0')&&(a.charAt(1)<='9')&&(a.contains(""C""))) {
		
					int m=1;
					while (a.charAt(m)!='C') {
					k=k+a.charAt(m);
					m++;
				}
					String nex=a.substring(m+1);
					col= Integer.parseInt(k);
				row= Integer.parseInt(nex);	
			while (row>0) {
				int rem= row%26;
						if (rem==0) {
							row=row-26;
							rem=26;
						}
				row=row/26;
				 cf=(char)('A'+rem-1)+cf;
				 
			}
			System.out.println(cf+col);
		}
		else {
			int fo=0;
		for(int m=0;(!((int)a.charAt(m)<=57 &&(int)a.charAt(m)>=48));m++){
				letters=letters+a.charAt(m);
				fo=m;
			}
		 num =num+a.substring(++fo);
		 for(int i=0; i<letters.length();i++) {
			 fin=fin*26;
			 fin=fin+(letters.charAt(i)-'A'+1);
			 
		 }
			System.out.println(""R""+num+""C""+fin)	;
			
		}
		
			
		}
		

		
}
	}

",3,0001_B,CODEFORCES,1472,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Arrays;
import java.util.Scanner;


public class Main {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			for(int t = 0 ; t < n ; ++t) {
				one(sc);
			}
		}
	}
	
	private static void one(Scanner sc) {
		String s = sc.next();
		if(s.matches(""R\\d+C\\d+"")) {
			String[] rc = s.substring(1).split(""C"");
			int c = Integer.valueOf(rc[1]);
			String res = """";
			while(c > 0) {
				if(c % 26 == 0) {
					res = 'Z' + res;
					c = c / 26 - 1;
				} else {
					res = ((char) ((c % 26) + 'A' - 1)) + res;
					c /= 26;
				}
			}
			System.out.println(String.valueOf(res).toUpperCase() + rc[0]);
		} else {
			char[] cs = s.toCharArray();
			int splitIndex = 0;
			while(cs[splitIndex] >= 'A') { 
				splitIndex++;
			}
			char[] letters = Arrays.copyOf(cs, splitIndex);
			int res = 0;
			for(int i = 0 ; i < letters.length; ++i) {
				res = 26 * res + (letters[i] - 'A' + 1);
			}
			
			System.out.println(""R"" + String.valueOf(Arrays.copyOfRange(cs, splitIndex, cs.length)) + ""C"" + res);
		}
	}
}
",3,0001_B,CODEFORCES,1453,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;
public class Problem0001b {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		for(int i = 0; i < n; i++) {
			String s = sc.next();
			if(s.matches(""R[0-9]+C[0-9]+"")) {
				String[] nums = s.split(""R|C"");
				int x = Integer.parseInt(nums[2]);
				String t = """";
				while(x!=0) {
					int m = x%26;
					if(m==0) {
						t='Z'+t;
						x-=26;
					}
					else
						t=(char)(m+'A'-1)+t;
					x/=26;
				}
				System.out.println(t+nums[1]);
			}
			else {
				String x1 = s.replaceAll(""[0-9]"", """");
				String x2 = s.replaceAll(""[A-Z]"", """");
				int base = 1;
				int t = 0;
				for(int j = x1.length() - 1; j >= 0; j--) {
					t += base*(x1.charAt(j)-'A'+1);
					base *= 26;
				}
				System.out.println(""R""+ x2 + ""C""+t);
			}
		}
	}
}",3,0001_B,CODEFORCES,1486,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;



public class CF_1B {

	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		String line = in.nextLine();

		int n = Integer.parseInt(line);

		for (int k = 0; k < n; k++) {

			line = in.next();

			if (line.matches(""R[0-9]+C[0-9]+"")) {

				String[] nums = line.split(""R|C"");

				int x = Integer.parseInt(nums[2]);

				String t = """";

				while (x > 0) {

					int m = x % 26;

					if (m == 0) {

						t = 'Z' + t;

						x -= 26;

					} else {

						t = (char)('A' + m - 1) + t;

					}

					x /= 26;

				}

				System.out.println(t + nums[1]);

			} else {

				String x1 = line.replaceAll(""[0-9]"", """");

				String x2 = line.replaceAll(""[A-Z]"", """");

				int base = 1;

				int t = 0;

				for (int i = x1.length() - 1; i >= 0; i--) {

					t += base * (x1.charAt(i) - 'A' + 1);

					base *= 26;

				}

				System.out.println(""R"" + x2 + ""C"" + t);

			}

		}

		in.close();

	}



}

",3,0001_B,CODEFORCES,1463,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

import java.io.*;

public class Spreadsheets

{

	public static void main(String args[]) throws Exception

	{

		BufferedReader f=new BufferedReader(new InputStreamReader(System.in));

		int runs=Integer.parseInt(f.readLine());

		for(int x=0;x<runs;x++)

		{

			String in=f.readLine();

			if(in.matches(""R\\d+C\\d+""))

			{

				String[] arr=in.split(""[RC]"");

				int temp=Integer.parseInt(arr[2]);

				String res="""";

				while(temp!=0)

				{

				    if(temp%26==0)

				    {

				        res+=""Z"";

				        temp/=26;

				        temp--;

				    }

				    else

				    {

						res+=(char)(temp%26+64);

						temp/=26;

				    }

				}

				StringBuilder a=new StringBuilder(res);

				System.out.println(a.reverse().toString()+arr[1]);

			}

			else

			{

				int pos=in.replaceFirst(""\\d"",""@"").indexOf(""@"");

				String temp=in.substring(0,pos);

				int res=0;

				for(int y=0;y<temp.length();y++)

					res=res*26+temp.charAt(y)-64;

				System.out.println(""R""+in.substring(pos)+""C""+res);

			}

		}

	}

}",3,0001_B,CODEFORCES,1466,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;

import java.lang.Math;

public class Main{

    public static void main(String[]args){

        Scanner scan = new Scanner(System.in);

        int n = scan.nextInt();

        for(int i=0; i<n; i++){

            String s = scan.next();

            if(s.matches(""[A-Z]+[0-9]+"")){

                int len = s.length(); String s1=""""; String s2=""""; int l1=0;

                for(int j=0; j<len; j++){

                    char c = s.charAt(j);

                    if(c>='A'&&c<='Z'){l1=26*(l1)+(c-'A'+1);}

                    else s2+=c;

                }

                System.out.println(""R""+s2+""C""+l1);

            }else{

                int index = s.lastIndexOf('C');

                int l1 = Integer.parseInt(s.substring(index+1,s.length())); String st = """";

                while(l1!=0){

                    st=(char)((l1%26==0?26:l1%26)+64)+st; l1=(l1-1)/26;

                }

                System.out.println(st+s.substring(1,index));

            }

        }

    }

}",3,0001_B,CODEFORCES,1458,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;
 
public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		for(int i=0;i<n;i++){
			String s=scan.next();
			if(s.matches(""R[0-9]+C[0-9]+"")){
				String[] nums=s.split(""R|C"");
				int x=Integer.parseInt(nums[2]);
				String t="""";
				while(x!=0){
					int m=x%26;
					if(m==0){
						t=""Z""+t;
						x-=26;
					}
					else
						t=(char)(m+'A'-1)+t;
					x/=26;
				}
				System.out.println(t+nums[1]);
			}
			else{
				String x1 = s.replaceAll(""[0-9]"", """");
				String x2 = s.replaceAll(""[A-Z]"", """");
				int base=1;
				int t=0;
				for(int j=x1.length()-1;j>=0;j--) {
					t+=base*(x1.charAt(j)-'A'+1);
					base*=26;
				}
				System.out.println(""R""+ x2 + ""C""+t);
			}
		}
	}
}",3,0001_B,CODEFORCES,1481,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();

        for(int i=0; i<t; i++) {
            String s = sc.next();
            int indexOfC = s.indexOf('C');
            if(s.charAt(0)=='R' && s.charAt(1)-'0'<=9 && indexOfC>0) {
                int row, col;
                row = Integer.parseInt(s.substring(1, indexOfC));
                col = Integer.parseInt(s.substring(indexOfC+1));

                StringBuilder colStr = new StringBuilder();
                while (col > 0) {
                    colStr.insert(0, (char)((col - 1) % 26 + 'A'));
                    col = (col - 1) / 26;
                }
                System.out.println(colStr.toString()+""""+row);
            }
            else {
                int k,row,col = 0;

                for(k=0; s.charAt(k)-'A'>=0; k++) {
                    col *= 26;
                    col += s.charAt(k) - 'A' + 1;
                }
                row = Integer.parseInt(s.substring(k));
                System.out.println(""R""+row+""C""+col);
            }
        }
    }
}
",3,0001_B,CODEFORCES,1492,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"

import java.util.Scanner;



public class Spreadsheets {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();

		while(n-- > 0)

		{

			String s = sc.next();

			if(s.matches(""R[0-9]+C[0-9]+""))

			{

				String[] ss = s.replaceAll(""[R|C]"", "" "").trim().split("" "");

				int a = new Integer(ss[1]);

				String str = """";

				while(a > 0)

				{

					a--;

					str = (char)(a % 26 + 'A') + str;

					a /= 26;

				}

				System.out.println(str + ss[0]);

			}

			else

			{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0; i < c.length(); ++i)

				{

					num = num * 26 + c.charAt(i) - 'A' + 1;

				}

				System.out.println(""R"" + r + ""C"" + num);

			}

		}

	}



}",3,0001_B,CODEFORCES,1471,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class B001 {
	static String conv(String s) {
		if (s.matches(""[A-Z]+\\d+"")) {
			int row = 0, col = 0;
			for (int x = 0; x < s.length(); x++) {
				char c = s.charAt(x);
				if (Character.isDigit(c)) {
					row = Integer.parseInt(s.substring(x));
					break;
				}
				col *= 26;
				col += c - 'A' + 1;
			}
			return String.format(""R%dC%d"", row, col);
		} else {
			String[] ss = s.split(""[RC]"");
			int row = Integer.parseInt(ss[1]), col = Integer.parseInt(ss[2]);
			StringBuffer coll = new StringBuffer();
			while (col > 0) {
				coll.append((char)('A' + (col - 1 + 26) % 26));
				col--;
				col /= 26;
			}
			return String.format(""%s%d"", coll.reverse().toString(), row);
		}
	}

	public static void main(String[] args) throws Exception {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(r.readLine());
		for (int x = 0; x < n; x++) {
			System.out.println(conv(r.readLine()));
		}
	}
}
",3,0001_B,CODEFORCES,1493,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.io.*;

public class BH

{

public static void main(String args[])throws IOException

{

BufferedReader obj=new BufferedReader(new InputStreamReader(System.in));

int n=Integer.parseInt(obj.readLine());

int c=0,f,l;

while(c<n)

{

String s=obj.readLine();

char ch=s.charAt(0);

String p="""",q="""";

l=s.length();

for(f=1;f<l;f++)

{

if(s.charAt(f)=='C')

break;

}

if(ch=='R'&&(s.charAt(1)>='0'&&s.charAt(1)<='9')&&f!=l)

{

p=s.substring(1,f);

int y=Integer.parseInt(s.substring(f+1));

while(y!=0)

{

int d=y%26;

if(d==0)

{

d=26;

y=(y/26)-1;

}

else

y=y/26;

q=((char)(64+d))+q;

}

}

else

{

for(f=0;f<l;f++)

{

char t=s.charAt(f);

if(t>='1'&& t<='9')

break;

}

p=s.substring(0,f);

q=""R""+s.substring(f);

f--;

int w=0;

int e=0;

while(w<=f)

{

e=e+((int)Math.pow(26,w))*((int)p.charAt(f-w)-64);

w++;

}

p=""C""+e;

}

System.out.println(q+p);

c++;

}

}

}











",3,0001_B,CODEFORCES,1460,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;


public class Main {

	public static void main(String[] args) throws Exception {
		Scanner scan= new Scanner(System.in);
		int a= scan.nextInt();
		for(int i=0; i < a; i++)
		{
			String check= scan.next();
			if(check.matches(""R[0-9]+C[0-9]+"")){
				String rowstr= check.substring(check.indexOf('R') + 1, check.indexOf('C'));
				String columnstr= check.substring(check.indexOf('C') + 1);
				int row= Integer.parseInt(rowstr); 
				int column= Integer.parseInt(columnstr); 
				String str="""";
				while(column !=0) {
					int mod = column % 26; //
					if(mod==0) {
						str='Z'+ str;
						column -= 26;
					}
					else
						str=(char)(mod+'A'-1)+ str;
					column/=26;
				}
				System.out.println(str + """" + row);
			}
			//BC23 == R23C55
			else {
				String rowstr= """";
				int len = check.length(); 
				int col=0;
				for(int j=0; j<len; j++){
					char c = check.charAt(j);
					if(c>='A'&&c<='Z') {
						col=26* (col) + (c-'A'+1);
						}
					else rowstr+=c;
				}
				System.out.println(""R""+ rowstr +""C""+ col);

			}
		}
	}
}",3,0001_B,CODEFORCES,1470,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.*;

public class Main {



	public static void main(String[] args) {

		Scanner kb = new Scanner(System.in);

		int n = kb.nextInt();

		while(n-->0){

			String s = kb.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				System.out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

				System.out.println(""R""+r+""C""+num);

			}

		}

		

	}

}",3,0001_B,CODEFORCES,1484,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.util.HashMap;

import java.util.Map;

import java.util.Scanner;



public class forces {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);



		int n = sc.nextInt();

		

		while (n-- > 0) {

			String coor = sc.next();

			String str = """";

			if (coor.matches(""R[0-9]+C[0-9]+"")) {

				String temp[] = coor.replaceAll(""R|C"", "" "").trim().split("" "");

				int a = new Integer(temp[1]);

				while (a > 0) {

					a--;

					str = (char)(a%26 + 'A') + str;

					a /= 26;

				}

				System.out.println(str+temp[0]);

			} else {

				String temp1 = coor.replaceAll(""[0-9]"", """");

				int num = 0;

				for(int i = 0; i<temp1.length(); i++) {

					num = num * 26 + temp1.charAt(i) - 'A' + 1;

				}

				System.out.println(""R"" + coor.replaceAll(""[A-Z]"", """") + ""C"" + num);

			}

		}

	}

}

",3,0001_B,CODEFORCES,1478,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import java.io.*;
import java.util.*;

public class A implements Runnable {
    private MyScanner in;
    private PrintWriter out;

    private void solve() {
        int n = in.nextInt();
        int[] a = new int[n];
        int max = -1, maxp = -1;
        for (int i = 0; i < n; ++i) {
            a[i] = in.nextInt();
            if (a[i] > max) {
                max = a[i];
                maxp = i;
            }
        }
        if (max == 1) {
            for (int i = 0; i < n - 1; ++i) {
                out.print(1 + "" "");
            }
            out.println(2);
            return;
        }
        a[maxp] = 1;
        Arrays.sort(a);
        for (int i = 0; i < n; ++i) {
            out.print(a[i] + "" "");
        }
        out.println();
    }

    @Override
    public void run() {
        in = new MyScanner();
        out = new PrintWriter(System.out);
        solve();
        in.close();
        out.close();
    }

    public static void main(String[] args) {
        new A().run();
    }

    static class MyScanner {
        private BufferedReader br;
        private StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public void close() {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }
            return st.nextToken();
        }

        public String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }

        public String next() {
            return nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public long nextLong() {
            return Long.parseLong(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}",4,0135_A,CODEFORCES,2409,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;

public class C implements Runnable {

	private void Solution() throws IOException {
		int n = nextInt(), max = 0, maxi = 0;
		ArrayList<Integer> mas = new ArrayList<Integer>();
		for (int i = 0; i < n; i++) {
			int num = nextInt();
			if (num > max) {
				max = num;
				maxi = i;
			}
			mas.add(num);
		}
		mas.remove(maxi);
		mas.add(max == 1 ? 2 : 1);
		Collections.shuffle(mas);
		Collections.sort(mas);
		for (int i = 0; i < n; i++)
			System.out.print(mas.get(i) + "" "");
	}

	public static void main(String[] args) {
		new C().run();
	}

	BufferedReader in;
	StringTokenizer tokenizer;

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			Solution();
			in.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(in.readLine());
		return tokenizer.nextToken();
	}
}",4,0135_A,CODEFORCES,2402,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"//package round97;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class A {

	static BufferedReader bf = new BufferedReader(new InputStreamReader(
			System.in));
	static StringTokenizer st;
	static PrintWriter out = new PrintWriter(System.out);

	static String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String s = bf.readLine();
			if (s == null)
				return null;
			st = new StringTokenizer(s);
		}

		return st.nextToken();
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	static long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	static String nextStr() throws IOException {
		return nextToken();
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		Arrays.sort(a);
		
		for (int q = 0; q < n; q++) {
			if (a[q] != 1) {
				out.print(""1"");
				for (int i = 1; i < n; i++) {
					out.print("" "" + a[i - 1]);
				}
				out.flush();
				return;
			}
		}
		
		for (int i = 0; i < n - 1; i++) {
			out.print(""1 "");
		}
		out.println(""2"");
		out.flush();
		
		
	}
}
",4,0135_A,CODEFORCES,2416,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class C {
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	StringTokenizer st = null;

	private void solution() throws IOException {
		int n = nextInt();
		int[] mas = new int[n];
		for (int i = 0; i < n; i++) {
			mas[i] = nextInt();
		}

		Arrays.sort(mas);

		if (mas[n - 1] == 1) {
			mas[n - 1] = 2;
		} else {
			mas[n - 1] = 1;
		}
		Arrays.sort(mas);
		for (int i = 0; i < n; i++) {
			System.out.print(mas[i] + "" "");
		}

	}

	String nextToken() throws IOException {
		if (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(bf.readLine());
		}
		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public static void main(String args[]) throws IOException {
		new C().solution();
	}
}",4,0135_A,CODEFORCES,2404,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import static java.lang.Math.*;
import static java.lang.System.currentTimeMillis;
import static java.lang.System.exit;
import static java.lang.System.arraycopy;
import static java.util.Arrays.sort;
import static java.util.Arrays.binarySearch;
import static java.util.Arrays.fill;
import java.util.*;
import java.io.*;

public class Main {

	public static void main(String[] args) throws IOException {
		try {
			if (new File(""input.txt"").exists())
				System.setIn(new FileInputStream(""input.txt""));
		} catch (SecurityException e) {
		}
		new Main().run();
	}

	BufferedReader in;
	PrintWriter out;
	StringTokenizer st = new StringTokenizer("""");

	private void run() throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);

		int n = nextInt();
		int m[] = new int[n];
		for(int i = 0; i < n; i++)
			m[i] = nextInt();
		sort(m);
		m[n - 1] = m[n - 1] != 1 ? 1 : 2;
		sort(m);
		for(int i = 0; i < n; i++){
			if(i != 0) out.print("" "");
			out.print(m[i]);
		}
		out.println();
		in.close();
		out.close();
	}

	void chk(boolean b) {
		if (b)
			return;
		System.out.println(new Error().getStackTrace()[1]);
		exit(999);
	}
	void deb(String fmt, Object... args) {
		System.out.printf(Locale.US, fmt + ""%n"", args);
	}
	String nextToken() throws IOException {
		while (!st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}
	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
	String nextLine() throws IOException {
		st = new StringTokenizer("""");
		return in.readLine();
	}
	boolean EOF() throws IOException {
		while (!st.hasMoreTokens()) {
			String s = in.readLine();
			if (s == null)
				return true;
			st = new StringTokenizer(s);
		}
		return false;
	}
}
",4,0135_A,CODEFORCES,2387,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;


public class A {
    static final Scanner sc = new Scanner(System.in);
    
    void run() {
        int n = sc.nextInt();
        int[] xs = new int[n];
        for(int i = 0; i < n; i++) {
            xs[i] = sc.nextInt();
        }
        Arrays.sort(xs);
        xs[n-1] = xs[n-1] == 1 ? 2 : 1;
        Arrays.sort(xs);
        for(int i = 0; i < n; i++)
            System.out.print(xs[i] + "" "");
    }
    
    public static void main(String[] args) {
        new A().run();
    }
}
",4,0135_A,CODEFORCES,2426,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {

	final String filename = new String(""A"").toLowerCase();

	void solve() throws Exception {
		int n = nextInt();
		int[] a = new int[n];
		int m = -1;
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
			if (m == -1 || a[i] > a[m]) {
				m = i;
			}
		}
		if (a[m] == 1)
			a[m] = 2;
		else
			a[m] = 1;
		Arrays.sort(a);
		for (int i = 0; i < n; i++) {
			out.print(a[i] + "" "");
		}

	}

	void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			// in = new BufferedReader(new FileReader(""input.txt""));
			// out = new PrintWriter(""output.txt"");

			solve();

			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	BufferedReader in;
	StringTokenizer st;
	PrintWriter out;

	String nextToken() throws Exception {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	int nextInt() throws Exception {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws Exception {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws Exception {
		return Double.parseDouble(nextToken());
	}

	public static void main(String[] args) {
		new A().run();
	}

}
",4,0135_A,CODEFORCES,2420,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.*;

public class Main {

  public static void main(String args[]) {
    (new Main()).solve();
  }

  void solve() {

    Scanner cin = new Scanner(System.in);

    while( cin.hasNextInt() ) {

      int n = cin.nextInt();
      int arr[] = new int[n];
      for(int i=0; i<n; ++i) {
        arr[i] = cin.nextInt();
      }

      Arrays.sort(arr);

      int ret[] = new int[n];
      ret[0] = 1;
      for(int i=0; i<n-1; ++i) { ret[i + 1] = arr[i]; }
      if( arr[n - 1] == 1 ) { ret[n - 1] = 2; }

      String glue = """";
      for(int i=0; i<n; ++i) {
        System.out.print(glue + ret[i]);
        glue = "" "";
      }

      System.out.println();

    }

  }

}
",4,0135_A,CODEFORCES,2422,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

public class A {

    void run(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        boolean dif = false;
        for(int i=0;i<n;i++)a[i]=sc.nextInt();
        Arrays.sort(a);
        if(n==1){
            System.out.println(a[0]==1?2:1);return;
        }
        int[] m = new int[n];
        for(int i=1;i<n;i++)if(a[i]!=a[i-1])dif=true;
        m[0] = 1;
        for(int i=1;i<n;i++)m[i]=a[i-1];
        if(!dif&&a[0]==1)m[n-1]++;
        
        for(int i=0;i<n;i++)System.out.print(m[i]+(i==n-1?""\n"":"" ""));
    }
    
    public static void main(String[] args) {
        new A().run();
    }
}",4,0135_A,CODEFORCES,2417,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.math.*;
import java.util.*;
import java.awt.geom.*;

import static java.lang.Math.*;

public class Solution implements Runnable {
	

	public void solve() throws Exception {
		int n = nextInt();
		int a [] = new int [n];
		for (int i = 0 ;i < n; i++) {
			a[i] = nextInt();
		}
		Arrays.sort(a);
		if (n == 1) {
			if (a[0] == 1) {
				out.print(2);
			} else {
				out.print(1);
			}
		} else {
			out.print(1);
			for (int i = 1; i < n; i++) {
				if (i == n-1 && a[i] == 1) {
					out.print("" ""+2);
				} else {
					out.print("" ""+a[i-1]);
				}
			}
		}
	}
	
		
	/********************************************************************************************/
	/* THERE IS INPUT */

	BufferedReader in;
	PrintWriter out;
	StringTokenizer st;

	long stime=0;
	
	private String next() throws Exception {
		while (st == null || !st.hasMoreElements())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	private int nextInt() throws Exception {
		return Integer.parseInt(next());
	}

	private long nextLong() throws Exception {
		return Long.parseLong(next());
	}

	private double nextDouble() throws Exception {
		return Double.parseDouble(next());
	}
	
	public void run() {
		try {
			//Locale.setDefault(Locale.US);
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(new OutputStreamWriter(System.out));
			solve();
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		} finally {
			out.close();
		}
	}
	
	public static void main(String[] args) throws Exception {
		new Thread(null, new Solution(), """", 1 << 25).start();
	}

	
}
",4,0135_A,CODEFORCES,2407,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {

    BufferedReader in;
    StringTokenizer st;
    PrintWriter out;

    String next() throws IOException {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(in.readLine());
        return st.nextToken();
    }

    int nextInt() throws Exception {
        return Integer.parseInt(next());
    }

    long nextLong() throws Exception {
        return Long.parseLong(next());
    }

    double nextDouble() throws Exception {
        return Double.parseDouble(next());
    }

    void solve() throws Exception {
        // int min = 1;
        // int max = 1000000000;
        int n = nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = nextInt();

        Arrays.sort(a);

        if (a[n - 1] == 1) {
            for (int i = 1; i < n; i++)
                out.print(""1 "");
            out.print(2);
            return;
        }

        // a[0]=max;

        Arrays.sort(a);
        out.print(1);
        for (int i = 1; i < n; i++)
            out.print("" "" + a[i-1]);

    }

    void run() {
        try {
            Locale.setDefault(Locale.US);
            boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
            Reader reader = oj ? new InputStreamReader(System.in)
                    : new FileReader(""input.txt"");
            Writer writer = oj ? new OutputStreamWriter(System.out)
                    : new FileWriter(""output.txt"");
            in = new BufferedReader(reader);
            out = new PrintWriter(writer);

            solve();
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    public static void main(String[] args) {
        new A().run();

    }

}
",4,0135_A,CODEFORCES,2414,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"
import java.util.*;
import java.math.*;
public class codeforces {
	 public static void main(String[] args)
	{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int[] data=new int[n];
		for(int i=0;i<n;i++)
			data[i]=sc.nextInt();
		Arrays.sort(data);
		if(data[n-1]!=1)
			data[n-1]=1;
		else
			data[n-1]=2;
		Arrays.sort(data);
		for(int i=0;i<n;i++)
		{
			System.out.print(data[i]);
			if(i!=n-1)
				System.out.print("" "");
		}
			
		
		return;
	}

}
",4,0135_A,CODEFORCES,2399,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.regex.*;
import static java.lang.Math.*;
public class A {

    public A() throws Exception {
        int n = in.nextInt();
        int[] arr = new int[n];
        for (int i=0;i<n;i++) 
            arr[i] = in.nextInt();

        if (n==1&&arr[0]==1) {
            System.out.println(2); 
            return;
        } 

        Arrays.sort(arr);
        if (arr[n-1]==1)
            arr[n-2] = 2;
        buf.append(1);
        for (int i=0;i<n-1;i++) 
            buf.append(' ').append(arr[i]);
        buf.append('\n');
        System.out.print(buf);
    }

    Scanner in = new Scanner(System.in);
    StringBuilder buf = new StringBuilder();
    public static void main(String[] args) throws Exception { // {{{
        new A();
    } // }}}
    public static void debug(Object... arr) { // {{{
        System.err.println(Arrays.deepToString(arr));
    } // }}}
}
",4,0135_A,CODEFORCES,2405,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class P_135A {
    static final FS sc = new FS();
    static final PrintWriter pw = new PrintWriter(System.out);

    public static void main(String[] args) {
        int n = sc.nextInt();
        long[] a = sc.nextLongArray(n);
        Arrays.sort(a);
        StringBuilder sb = new StringBuilder();
        if(a[0]>1){
            sb.append(1+"" "");
            for(int i=0; i<n-1; i++){
                sb.append(a[i]+"" "");
            }
            System.out.println(sb.toString());
        }
        else if(a[n-1]==1){
            for(int i=1; i<n; i++){
                sb.append(a[i]+"" "");
            }
            sb.append(2);
            System.out.println(sb.toString());
        }
        else{
            int i = 0;
            while(a[i]==1){
                sb.append(a[i]+"" "");
                i++;
            }
            sb.append(1+"" "");
            while(i<n-1){
                sb.append(a[i]+"" "");
                i++;
            }
            System.out.println(sb.toString());
        }
    }

    static class FS {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer("""");

        String next() {
            while (!st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception ignored) {
                }
            }
            return st.nextToken();
        }

        int[] nextArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextInt();
            }
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",4,0135_A,CODEFORCES,2379,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.lang.*;
import java.math.BigInteger;
import java.io.*;
import java.util.*;

public class Solution implements Runnable{
    public static BufferedReader br;
    public static PrintWriter out;
    public static StringTokenizer stk;
    public static boolean isStream = true;

    public static void main(String[] args) throws IOException {
    	if (isStream) {
            br = new BufferedReader(new InputStreamReader(System.in));
        } else {
            br = new BufferedReader(new FileReader(""in.txt""));
        }
        out = new PrintWriter(System.out);
        new Thread(new Solution()).start();
    }

    public void loadLine() {
        try {
            stk = new StringTokenizer(br.readLine());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String nextLine() {
        try {
            return br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
            return """";
        }
    }

    public String nextWord() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return stk.nextToken();
    }

    public Integer nextInt() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Integer.valueOf(stk.nextToken());
    }

    public Long nextLong() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Long.valueOf(stk.nextToken());
    }

    public Double nextDouble() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Double.valueOf(stk.nextToken());
    }
    
    public Float nextFloat() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Float.valueOf(stk.nextToken());
    }
    
    public void run() {
    	int n = nextInt();
    	int[] arr = new int[n];
    	for (int i = 0; i < n;i++) {
    		arr[i] = nextInt();
    	}
    	Arrays.sort(arr);
    	if (arr[n-1] != 1) arr[n-1] = 1;
    	else arr[n-1] = 2;
    	Arrays.sort(arr);
    	for (int i = 0; i < n; i++) {
    		out.print(arr[i]+"" "");
    	}
    	out.println();
    	out.flush();
    }
}
",4,0135_A,CODEFORCES,2423,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import java.math.*;

//created at 6:06 PM 12/9/11 by Abrackadabra

public class A {
    int IOMode = 0; //0 - consoleIO, 1 - <taskName>.in/out, 2 - input.txt/output.txt, 3 - test case generator
    String taskName = """";

    void solve() throws IOException {
        int n = nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = nextInt();
        Arrays.sort(a);
        int z = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] != 1) z++;
        }
        if (z == 0 && n > 1) a[n - 2] = 2;
        if (n == 1 && a[0] == 1) {
            out.println(2);
            return;
        }
        out.print(""1 "");
        for (int i = 0; i < n - 1; i++)
            out.print(a[i] + "" "");
    }

    public static void main(String[] args) throws IOException {
        if (args.length > 0 && args[0].equals(""Abra"")) debugMode = true;
        new A().run();
    }

    long startTime = System.nanoTime(), tempTime = startTime, finishTime = startTime;
    long startMem = Runtime.getRuntime().totalMemory(), finishMem = startMem;

    void run() throws IOException {
        init();
        if (debugMode) {
            con.println(""Start"");
            con.println(""Console output:"");
        }
        solve();
        finishTime = System.nanoTime();
        finishMem = Runtime.getRuntime().totalMemory();
        out.flush();
        if (debugMode) {
            int maxSymbols = 1000, c = 0;
            BufferedReader tbr = new BufferedReader(new FileReader(""input.txt""));
            char[] a = new char[maxSymbols];
            tbr.read(a);
            if (a[0] != 0) {
                con.println();
                con.println(""File input:"");
                con.print(a);
            }
            boolean left = true;
            for (int i = 0; i < maxSymbols; i++) left = left && a[i] != 0;
            if (left) con.println(""..."");
            else con.println();
            tbr = new BufferedReader(new FileReader(""output.txt""));
            a = new char[maxSymbols];
            tbr.read(a);
            if (a[0] != 0) {
                con.println();
                con.println(""File output:"");
                con.print(a);
            }
            left = true;
            for (int i = 0; i < maxSymbols; i++) left = left && a[i] != 0;
            if (left) con.println(""..."");
            else con.println();
            con.println(""Time passed:  "" + (finishTime - startTime) / 1000000000.0 + "" sec"");
            con.println(""Memory used:  "" + (finishMem - startMem) + "" bytes"");
            con.println(""Total memory: "" + Runtime.getRuntime().totalMemory() + "" bytes"");
        }
    }

    boolean tick(double x) {
        if (System.nanoTime() - tempTime > x) {
            tempTime = System.nanoTime();
            con.println(""Tick at "" + (tempTime - startTime) / 1000000000 + "" sec"");
            con.print(""   "");
            return true;
        }
        return false;
    }

    void printTime() {
        con.println((System.nanoTime() - tempTime) + "" nanos passed"");
        tempTime = System.nanoTime();
    }

    static boolean debugMode = false;
    PrintStream con = System.out;

    void init() throws IOException {
        if (debugMode && IOMode != 3) {
            br = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(new FileWriter(""output.txt""));
        } else
            switch (IOMode) {
                case 0:
                    br = new BufferedReader(new InputStreamReader(System.in));
                    out = new PrintWriter(System.out);
                    break;
                case 1:
                    br = new BufferedReader(new FileReader(taskName + "".in""));
                    out = new PrintWriter(new FileWriter(taskName + "".out""));
                    break;
                case 2:
                    br = new BufferedReader(new FileReader(""input.txt""));
                    out = new PrintWriter(new FileWriter(""output.txt""));
                    break;
                case 3:
                    out = new PrintWriter(new FileWriter(""input.txt""));
                    break;
            }
    }

    BufferedReader br;
    PrintWriter out;
    StringTokenizer in;

    boolean hasMoreTokens() throws IOException {
        while (in == null || !in.hasMoreTokens()) {
            String line = br.readLine();
            if (line == null) return false;
            in = new StringTokenizer(line);
        }
        return true;
    }

    String nextString() throws IOException {
        return hasMoreTokens() ? in.nextToken() : null;
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextString());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextString());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextString());
    }
}
",4,0135_A,CODEFORCES,2384,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

public class A135 {
	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		int n = in.nextInt(), a[] = new int[n], max = 0, imax = 0;

		for (int i = 0; i < n; i++) {
			a[i] = in.nextInt();
			if (a[i] > max) {
				max = a[i];
				imax = i;
			}
		}

		if (a[imax] == 1)
			a[imax] = 2;
		else
			a[imax] = 1;

		Arrays.sort(a);

		for (int i = 0; i < n; i++)
			System.out.print(a[i] + "" "");

	}
}",4,0135_A,CODEFORCES,2380,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"
import java.io.*;
import java.util.*;

public class CodeForce {
    
    private void solve() throws IOException {
        final int N = nextInt();
        int []A = new int[N];
        for(int i = 0; i < N; i++) A[i] = nextInt();
        Arrays.sort(A);
        if(A[N-1] == 1) A[N-1] = 2;
        else            A[N-1] = 1;
        Arrays.sort(A);
        for(int i = 0; i < N; i++)
            System.out.print(A[i] + "" "");
    }
    
    public static void main(String[] args) {
        new CodeForce().run();
    }

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    public void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(new FileOutputStream(new File(""output.txt"")));
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }
    
    String nextLine() throws IOException {
        return reader.readLine();
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }
}
",4,0135_A,CODEFORCES,2395,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(r.readLine());
        
        String[] line = r.readLine().split(""[ ]+"");
        
        int[] a = new int[n];
        for(int i = 0; i < n; i++)
            a[i] = Integer.parseInt(line[i]);
        
        
        Arrays.sort(a);
        
        boolean found = false;
        for(int i = 0; i < n && !found; i++)
            if(a[i] != 1)found = true;
        
        
        if(found){
            System.out.println(1);
            for(int i = 1; i < n; i++)
                System.out.println(a[i-1]);
        }else{
            for(int i = 0; i < n-1; i++)
                System.out.println(1);
            System.out.println(2);
        }
    }
}
",4,0135_A,CODEFORCES,2413,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class A135 {
	public static void main(String[] args) throws Exception {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(r.readLine());

		int[] ar = new int[n];
		StringTokenizer st = new StringTokenizer(r.readLine());
		for (int x = 0; x < n; x++) {
			ar[x] = Integer.parseInt(st.nextToken());
		}
		Arrays.sort(ar);
		if (n == 1) {

			System.out.println(ar[0]==1?""2"":""1"");
			return;
		}
		if (ar[n - 1] == 1) {
			ar[n - 2] = 2;
		}
		System.out.print(""1"");
		for (int x = 0; x < n - 1; x++) {
			System.out.print("" "" + ar[x]);
		}
		System.out.println();
	}
}
",4,0135_A,CODEFORCES,2388,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-9
 * Time: 下午10:48
 * To change this template use File | Settings | File Templates.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class A {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    void solve() throws IOException {
        int n = nextInt();
        int[] a = new int[n];
        for (int i = 0; i < a.length; i++) {
            a[i] = nextInt();
        }
        Arrays.sort(a);
        if (a[a.length - 1] == 1) {
            for (int i = 0; i < a.length - 1; i++) {
                writer.print(1 + "" "");
            }
            writer.println(2 + """");
            return;
        }
        for (int i = 0; i < a.length; i++) {
            if (i == 0)
                writer.print(1 + "" "");
            else
                writer.print(a[i - 1] + "" "");
        }
        writer.println();
    }

    static public void main(String[] args) {
        new A().run();
    }
}
",4,0135_A,CODEFORCES,2389,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.AbstractList;
import java.io.Writer;
import java.util.List;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int size = in.readInt();
		int[] array = IOUtils.readIntArray(in, size);
		Arrays.sort(array);
		if (array[size - 1] == 1)
			array[size - 1] = 2;
		else
			array[size - 1] = 1;
		Arrays.sort(array);
		out.printLine(Array.wrap(array).toArray());
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public static boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(outputStream);
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(Object...objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}

	public void close() {
		writer.close();
	}

	}

class IOUtils {

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readInt();
		return array;
	}

	}

abstract class Array<T> extends AbstractList<T> {

	public static List<Integer> wrap(int...array) {
		return new IntArray(array);
	}

	protected static class IntArray extends Array<Integer> {
		protected final int[] array;

		protected IntArray(int[] array) {
			this.array = array;
		}

		public int size() {
			return array.length;
		}

		public Integer get(int index) {
			return array[index];
		}

		public Integer set(int index, Integer value) {
			int result = array[index];
			array[index] = value;
			return result;
		}
	}

	}

",4,0135_A,CODEFORCES,2406,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import java.util.prefs.NodeChangeEvent;
import java.math.*;

public class Main implements Runnable {
	private BufferedReader in;
	private PrintWriter out;
	private StringTokenizer st;
	private Random rnd;
	
	private void solve() throws IOException {
		int n = nextInt();
		
		int[] a = new int[n];
		int max = 0;
		for(int i = 0; i < n; i++) {
			a[i] = nextInt();
			if(a[i] > a[max]) max = i;
		}
		
		int value = 1;
		
		if(a[max] == 1) value = 2;
		
		a[max] = value;
		
		Arrays.sort(a);
		
		for(int i = 0; i < n; i++) {
			out.print(a[i]);
			out.print(' ');
		}
	}
		
	public static void main(String[] args) {
		new Main().run();
	} 
	
	public void run() {
		try {
			try {
				in = new BufferedReader(new FileReader(""INPUT.TXT""));
				out = new PrintWriter(new FileWriter(""OUTPUT.TXT""));
			} catch(FileNotFoundException e) {
				in = new BufferedReader(new InputStreamReader((System.in)));
				out = new PrintWriter(System.out);
			}
			
			st = null;
			rnd = new Random();
			
			solve();
			
			out.close();
		} catch(IOException e) {
			e.printStackTrace();
		}	
	}
	
	private String nextToken() throws IOException, NullPointerException {
		while(st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		
		return st.nextToken();
	}
	
	private int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
	
	private long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
	
	private double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

}",4,0135_A,CODEFORCES,2398,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.Scanner;

public class Beta97B {

    static Scanner in;
    static StreamTokenizer st;
    static int n;
    static int[] a;
    static int max = 1;

    public static void main(String[] args) throws IOException {
        // in = new Scanner(System.in);
        st = new StreamTokenizer(new InputStreamReader(System.in));
        n = nextInt();
        a = new int[n];
        int ind = 0;
        for (int i = 0; i < n; ++i) {
            a[i] = nextInt();
            if (a[i] > max) {
                max = a[i];
                ind = i;
            }
        }
        if (max == 1) {
            a[0] = 2;
        } else {
            a[ind] = 1;
        }
        Arrays.sort(a);
        for (int i = 0; i < n; ++i)
            System.out.print(a[i] + "" "");
    }

    private static int nextInt() throws IOException {
        st.nextToken();
        return (int) st.nval;
    }
}
",4,0135_A,CODEFORCES,2415,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {

    BufferedReader br;
    PrintWriter out;
    StringTokenizer st;
    boolean eof;

    void solve() throws IOException {
        int n = nextInt();
        int[] a = new int[n];

        boolean onlyOnes = true;

        for (int i = 0; i < n; i++) {
            a[i] = nextInt();
            if (a[i] != 1)
                onlyOnes = false;
        }

        Arrays.sort(a);
        if (onlyOnes) {
            for (int i = 0; i < n - 1; i++)
                out.print(""1 "");
            out.print(2);
        } else {
            out.print(""1 "");
            for (int i = 0; i < n - 1; i++)
                out.print(a[i] + "" "");
        }

    }

    void inp() throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        solve();
        out.close();
    }

    public static void main(String[] args) throws IOException {
        new A().inp();
    }

    String nextToken() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                eof = true;
                return ""0"";
            }
        }
        return st.nextToken();
    }

    String nextString() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                eof = true;
                return ""0"";
            }
        }
        return st.nextToken(""\n"");
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

}
",4,0135_A,CODEFORCES,2429,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Main {
    
    public static void main(String[] args) throws Exception {
        int n = nextInt();
        
        int[] mas = new int[n];
        
        for(int i = 0; i<n; i++) {
            mas[i] = nextInt();
        }
        
        Arrays.sort(mas);
        
        if(mas[n-1] == 1) {
            for(int i = 0; i<n-1; i++) {
                out.print(1 + "" "");
            }
            out.println(2);
            out.flush();
            exit();
        }
        
        out.print(""1 "");
        
        for(int i = 0; i<n-1; i++) {
            out.print(mas[i] + "" "");
        }
        
        out.println();
        out.flush();
    }
    
    /////////////////////////////////////////////////////////////////
    // IO
    /////////////////////////////////////////////////////////////////
    private static StreamTokenizer in;
    private static PrintWriter out;
    private static BufferedReader inB;
    
    private static boolean FILE=false;
    
    private static int nextInt() throws Exception{
        in.nextToken();
        return (int)in.nval;
    }
    
    private static String nextString() throws Exception{
        in.nextToken();
        return in.sval;
    }
    
    static{
        try {
            out = new PrintWriter(FILE ? (new FileOutputStream(""output.txt"")) : System.out);
            inB = new BufferedReader(new InputStreamReader(FILE ? new FileInputStream(""input.txt"") : System.in));
        } catch(Exception e) {e.printStackTrace();}
        in = new StreamTokenizer(inB);
    }
    /////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////
    // pre - written
    /////////////////////////////////////////////////////////////////
    private static void println(Object o) throws Exception {
        out.println(o);
        out.flush();
    }
    private static void exit(Object o) throws Exception {
        println(o);
        exit();
    }
    private static void exit() {
        System.exit(0);
    }
    private static final int  INF = Integer.MAX_VALUE;
    private static final int MINF = Integer.MIN_VALUE;
    //////////////////////////////////////////////////////////////////
}
",4,0135_A,CODEFORCES,2392,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class C {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        String[] S = in.readLine().split("" "");
        int[] A = new int[n];
        boolean allOnes = true;
        for (int i = 0; i < n; i++) {
            A[i] = Integer.parseInt(S[i]);
            allOnes &= A[i] == 1;
        }
        Arrays.sort(A);
        if (A[A.length - 1] > 1)
            A[A.length - 1] = 1;
        else
            A[A.length - 1] = 2;
        Arrays.sort(A);
        for (int i = 0; i < A.length; i++)
            System.out.print(A[i] + "" "");
        System.out.println();
    }
}
",4,0135_A,CODEFORCES,2401,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import static java.lang.Math.*;
 
public class C {
        
        final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"")!=null;
        BufferedReader in;
        PrintWriter out;
        StringTokenizer tok = new StringTokenizer("""");
        
        void init() throws FileNotFoundException{
                if (ONLINE_JUDGE){
                        in = new BufferedReader(new InputStreamReader(System.in));
                        out = new PrintWriter(System.out);
                }else{
                        in = new BufferedReader(new FileReader(""input.txt""));
                        out = new PrintWriter(""output.txt"");
                }
        }
        
        String readString() throws IOException{
                while(!tok.hasMoreTokens()){
                        tok = new StringTokenizer(in.readLine());
                }
                return tok.nextToken();
        }
        
        int readInt() throws IOException{
                return Integer.parseInt(readString());
        }
        
        long readLong() throws IOException{
                return Long.parseLong(readString());
        }
        
        double readDouble() throws IOException{
                return Double.parseDouble(readString());
        }
        
        public static void main(String[] args){
                new C().run();
        }
        
        public void run(){
                try{
                        long t1 = System.currentTimeMillis();
                        init();
                        solve();
                        out.close();
                        long t2 = System.currentTimeMillis();
                        System.err.println(""Time = ""+(t2-t1));
                }catch (Exception e){
                        e.printStackTrace(System.err);
                        System.exit(-1);
                }
        }
        
       
        void solve() throws IOException{
        	int n = readInt();
        	int[] a = new int[n];
        	for(int i = 0; i < n; i++){
        		a[i] = readInt();
        	}
        	boolean c = true;
        	for(int i = 0; i < n; i++){
        		if(a[i] != 1){
        			c = false;
        			break;
        		}
        	}
        	if(c){
        		for(int i = 0; i < n-1; i++){
        			out.print(a[i] + "" "");
        		}
        		out.println(2);
        		return;
        	}
        	Utils.mergeSort(a);
        	out.print(1 + "" "");
        	for(int i = 1; i < n; i++){
        		out.print(a[i-1] + "" "");
        	}
        }
        
        int[] zFunction(char[] s){
        	int[] z = new int[s.length];
        	z[0] = 0;
        	for (int i=1, l=0, r=0; i<s.length; ++i) {
        		if (i <= r)
        			z[i] = min (r-i+1, z[i-l]);
        		while (i+z[i] < s.length && s[z[i]] == s[i+z[i]])
        			++z[i];
        		if (i+z[i]-1 > r){
        			l = i; 
        			r = i+z[i]-1;
        		}
        	}	
        	return z;
        }
        
        int[] prefixFunction(char[] s){
        	int[] pr = new int[s.length];
        	for (int i = 1; i< s.length; ++i) {
        		int j = pr[i-1];
        		while (j > 0 && s[i] != s[j])
        			j = pr[j-1];
        		if (s[i] == s[j])  ++j;
        		pr[i] = j;
        	}
        	return pr;
        }
        
        int ModExp(int a, int n, int mod){
        	int res = 1;
        	while (n!=0)
        		if ((n & 1) != 0) {
        			res = (res*a)%mod;
        			--n;
        		}
        		else {
        			a = (a*a)%mod;
        			n >>= 1;
        		}
        	return res;
        }
        
        
        static class Utils {
 
                private Utils() {}
 
                public static void mergeSort(int[] a) {
                        mergeSort(a, 0, a.length - 1);
                }
 
                private static void mergeSort(int[] a, int leftIndex, int rightIndex) {
                        final int MAGIC_VALUE = 50;
                        if (leftIndex < rightIndex) {
                                if (rightIndex - leftIndex <= MAGIC_VALUE) {
                                        insertionSort(a, leftIndex, rightIndex);
                                } else {
                                        int middleIndex = (leftIndex + rightIndex) / 2;
                                        mergeSort(a, leftIndex, middleIndex);
                                        mergeSort(a, middleIndex + 1, rightIndex);
                                        merge(a, leftIndex, middleIndex, rightIndex);
                                }
                        }
                }
 
                private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {
                        int length1 = middleIndex - leftIndex + 1;
                        int length2 = rightIndex - middleIndex;
                        int[] leftArray = new int[length1];
                        int[] rightArray = new int[length2];
                        System.arraycopy(a, leftIndex, leftArray, 0, length1);
                        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
                        for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
                                if (i == length1) {
                                        a[k] = rightArray[j++];
                                } else if (j == length2) {
                                        a[k] = leftArray[i++];
                                } else {
                                        a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
                                }
                        }
                }
 
                private static void insertionSort(int[] a, int leftIndex, int rightIndex) {
                        for (int i = leftIndex + 1; i <= rightIndex; i++) {
                                int current = a[i];
                                int j = i - 1;
                                while (j >= leftIndex && a[j] > current) {
                                        a[j + 1] = a[j];
                                        j--;
                                }
                                a[j + 1] = current;
                        }
                } 
        }
        
       
        
        boolean isPrime(int a){
        	for(int i = 2; i <= sqrt(a); i++)
        		if(a % i == 0) return false;
        	return true;
        }
        
        static double distance(long x1, long y1, long x2, long y2){
        	return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
        }
        
        static long gcd(long a, long b){
        	if(min(a,b) == 0) return max(a,b);
        	return gcd(max(a, b) % min(a,b), min(a,b));
        }
        
        static long lcm(long a, long b){
        	return a * b /gcd(a, b);
        }
}",4,0135_A,CODEFORCES,2425,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

public class AAA {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = in.nextInt();
        int max = a[0];
        int ind = 0;
        for (int k = 1; k < n; k++) {
            if (a[k] > max) {
                max = a[k];
                ind = k;
            }
        }
        if (max != 1) {
            a[ind] = 1;
            Arrays.sort(a);
            for (int i = 0; i < a.length - 1; i++)
                System.out.print(a[i] + "" "");
            System.out.println(a[a.length - 1]);
        } else {
            a[0] = 2;
            Arrays.sort(a);
            for (int i = 0; i < a.length - 1; i++)
                System.out.print(a[i] + "" "");
            System.out.println(a[a.length - 1]);
        }
    }
}
",4,0135_A,CODEFORCES,2411,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"

import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;

import static java.lang.Math.*;

public class A implements Runnable{
    
    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"")!=null;
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");
    
    void init() throws FileNotFoundException{
        if (ONLINE_JUDGE){
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        }else{
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
    }
    
    String readString() throws IOException{
        while(!tok.hasMoreTokens()){
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }
    
    int readInt() throws IOException{
        return Integer.parseInt(readString());
    }
    
    long readLong() throws IOException{
        return Long.parseLong(readString());
    }
    
    double readDouble() throws IOException{
        return Double.parseDouble(readString());
    }
    
    public static void main(String[] args){
        new Thread(null, new A(), """", 256 * (1L << 20)).start();
    }
    
    public void run(){
        try{
            long t1 = System.currentTimeMillis();
            init();
            solve();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time = ""+(t2-t1));
        }catch (Exception e){
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }
    
    void solve() throws IOException{
        int n = readInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++){
            a[i] = readInt();
        }
        Arrays.sort(a);
        a[n-1] = a[n-1] == 1? 2:1;
        Arrays.sort(a);
        for (int i = 0; i < n; i++){
            out.print(a[i] + "" "");
        }
    }
}

",4,0135_A,CODEFORCES,2390,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        int n = in.nextInt();
        int[] a = new int[n];
        boolean has_more_than_one = false;
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
            if (a[i] > 1)
                has_more_than_one = true;
        }

        Arrays.sort(a);

        if (n == 1) {
            if (a[0] == 1)
                out.print(2);
            else
                out.print(1);
        } else {
            out.print(1 + "" "");
            for (int i = 1; i < n; i++) {
                if (has_more_than_one || i < n - 1)
                    out.print(a[i - 1] + "" "");
                else
                    out.println(2);
            }
        }

        out.close();
    }
}
",4,0135_A,CODEFORCES,2408,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {
	
	// static int INF=1<<28;
	//int x,y;
	static int sum=0;
    //static ArrayList<Integer> lis = new ArrayList<Integer>();
	
	public static void main(String[] args)throws Exception{
	//	Scanner sc =new Scanner(new File(""input.txt""));
		Scanner sc =new Scanner(System.in);
     // File file = new File(""prime2.txt"");
	//	PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file)));
	//	sc.useDelimiter(""(\\s)+|[,]"");
	//	ArrayList<Integer> lis = new ArrayList<Integer>();
	//ArrayList<String> lis = new ArrayList<String>();
	//System.out.println();
    //  for(int i=0;i<;i++)
		
   while(sc.hasNext()){
	 
	 int n=ni(sc),x[]=new int[n+1];
	 for(int i=1;i<=n;i++)x[i]=ni(sc);
	 sort(x);
	 if(x[n]==1){x[n]=2;for(int i=1;i<=n;i++)System.out.print(x[i]+"" "");}
	 else{x[0]=1;
	 for(int i=0;i<n;i++)System.out.print(x[i]+"" "");
	 }
      
   }
	 
	   
	  
	}
	
	
	
	static void db(Object... os){
	         System.err.println(Arrays.deepToString(os));
	}
	

	static int ni(Scanner in){
		return in.nextInt();  
	}
		
}

",4,0135_A,CODEFORCES,2381,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

/*
 * Raudel Ravelo Suarez
 * Problem: 
 */

public class C 
{
	Scanner sc;
	BufferedReader in;
	PrintStream out;
	StringTokenizer tok;
	
	public C() throws NumberFormatException, IOException
	{
		//sc = new Scanner(System.in);
		//sc = new Scanner(new FileReader(""in.txt""));
		in = new BufferedReader(new InputStreamReader(System.in));
		//in = new BufferedReader(new FileReader(""in.txt""));
		out = System.out;
		run();
	}
	void run() throws NumberFormatException, IOException
	{
		//Add your code here
		int[] array;
		int n = nextInt();
		array = new int[n];
		int max = 0;
		int pos = 0;
		for(int i = 0; i <n; i++)
		{
			int l = nextInt();
			if(l > max)
			{
				pos = i;
				max = l;
			}
			array[i] = l;
		}
		if(max == 1)array[pos] = 2;
		else array [pos] = 1;
		Arrays.sort(array);
		out.print(array[0]);
		for(int i = 1; i < n; i++)
			out.print("" "" + array[i]);
		out.println();
	}
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		new C();
	}
	String nextToken() throws IOException
	{
		if(tok ==null || !tok.hasMoreTokens()) tok = new StringTokenizer(in.readLine());
		return tok.nextToken();
	}
	int nextInt() throws NumberFormatException, IOException
	{
		return Integer.parseInt(nextToken());
	}
	long nextLong() throws NumberFormatException, IOException
	{
		return Long.parseLong(nextToken());
	}
	double nextDouble() throws NumberFormatException, IOException
	{
		return Double.parseDouble(nextToken());
	}
}
",4,0135_A,CODEFORCES,2430,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;

import java.awt.geom.Point2D;
import java.text.*;
import java.math.*;
import java.util.*;

public class Main implements Runnable {

	final String filename = """";

	public void solve() throws Exception {
		int n = iread();
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = iread();
		Arrays.sort(a);
		boolean test = true;

		for (int i = 0; i < n; i++) {
			if (a[i] != 1)
				test = false;
			int min = (i == 0) ? 1 : a[i - 1];
			if (test && i == n - 1)
				out.write((min + 1) + """");
			else
				out.write(min + """");
			if (i == n - 1)
				out.write(""\n"");
			else
				out.write("" "");
		}
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new BufferedWriter(new OutputStreamWriter(System.out));
			// in = new BufferedReader(new FileReader(filename+"".in""));
			// out = new BufferedWriter(new FileWriter(filename+"".out""));
			solve();
			out.flush();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public int iread() throws Exception {
		return Integer.parseInt(readword());
	}

	public double dread() throws Exception {
		return Double.parseDouble(readword());
	}

	public long lread() throws Exception {
		return Long.parseLong(readword());
	}

	BufferedReader in;

	BufferedWriter out;

	public String readword() throws IOException {
		StringBuilder b = new StringBuilder();
		int c;
		c = in.read();
		while (c >= 0 && c <= ' ')
			c = in.read();
		if (c < 0)
			return """";
		while (c > ' ') {
			b.append((char) c);
			c = in.read();
		}
		return b.toString();
	}

	public static void main(String[] args) {
		try {
			Locale.setDefault(Locale.US);
		} catch (Exception e) {

		}
		// new Thread(new Main()).start();
		new Thread(null, new Main(), ""1"", 1 << 25).start();
	}
}",4,0135_A,CODEFORCES,2428,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import java.math.*;

public class TaskA {
	void Run() throws IOException {
		int n=ReadInt();
		int[] arr=new int[n];
		for(int i=0;i<n;++i)
			arr[i]=ReadInt();
		Arrays.sort(arr);
		boolean one=true;
		for(int x : arr)
			if(x!=1) {
				one=false;
				break;
			}
		if(one) {
			for(int i=1;i<n;++i)
				output.print(""1 "");
			output.print(""2"");
			return;
		}
		int prev=1;
		for(int x : arr)
			if(x==prev) {
				output.print(prev);
				output.print("" "");
			} else {
				output.print(prev);
				output.print("" "");
				prev=x;
			}
	}

	public static void main(String[] args) throws IOException {
		boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
		Reader reader;
		reader=oj ? new InputStreamReader(System.in) : new FileReader(""input.txt"");
		input=new BufferedReader(reader);
		Writer writer=new OutputStreamWriter(System.out);
		writer=new BufferedWriter(writer);
		output=new PrintWriter(writer);
		new TaskA().Run();
		output.close();
	}
	
	static int ReadInt() throws IOException {
		return Integer.parseInt(ReadString());
	}
	
	static long ReadLong() throws IOException {
		return Long.parseLong(ReadString());
	}
	
	static String ReadString() throws IOException {
		while(tokenizer==null || !tokenizer.hasMoreTokens())
			tokenizer=new StringTokenizer(input.readLine());
		return tokenizer.nextToken();
	}
	
	static StringTokenizer tokenizer;
	static BufferedReader input;
	static PrintWriter output;
}
",4,0135_A,CODEFORCES,2382,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.*;
public class A135 {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextInt();
        }
        Arrays.sort(arr);
        int[] ans = new int[n];
        
        if (arr[n-1] == 1) {
            for (int i = 0 ;i < n; i++) {
                ans[i] = arr[i];
            }
            ans[n-1] = 2;
        } else {
            ans[0] = 1;
            for (int i = 1; i < n; i++) {
                ans[i] = arr[i-1];
            }
        }
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < n; i++) {
            buf.append(ans[i]);
            if (i != n-1) buf.append(' ');
        }
        System.out.print(buf.toString());
    }
}
",4,0135_A,CODEFORCES,2412,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.math.*;
import java.util.*;

public class Main
{
    BufferedReader reader;
    FastScanner sc;
    
    void solve() throws Exception
    {
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
        {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        if (arr[n - 1] == 1)
            arr[n - 1] = 2;
        else
            arr[n - 1] = 1;
        Arrays.sort(arr);
        for (int i = 0; i < n; i++)
        {
            System.out.print(arr[i] + "" "");
        }
        System.out.println();
    }
        
    public static void main(String[] args) throws Exception
    {
        new Main().solve();
    }
    
    Main() throws Exception
    {
        if (System.getProperty(""ONLINE_JUDGE"") == null)
        {
            //System.setIn(new FileInputStream(""input.txt""));
            //System.setOut(new PrintStream(""output.txt""));
        }
        
        reader = new BufferedReader(new InputStreamReader(System.in));
        sc = new FastScanner(reader);
    }
}

class FastScanner
{
    BufferedReader reader;
    StringTokenizer strTok;
    
    public FastScanner(BufferedReader reader)
    {
        this.reader = reader;
    }
    
    public String nextToken() throws IOException
    {
        if (strTok == null || !strTok.hasMoreTokens())
        {
            strTok = new StringTokenizer(reader.readLine());
        }
        return strTok.nextToken();
    }
    
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextToken());
    }
    
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextToken());
    }
    
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextToken());
    }
    
    public BigInteger nextBigInteger() throws IOException
    {
        return new BigInteger(nextToken());
    }
    
    public BigDecimal nextBigDecimal() throws IOException
    {
        return new BigDecimal(nextToken());
    }
}
",4,0135_A,CODEFORCES,2403,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.lang.*;
import java.io.*;
import java.util.*;
import java.math.*;

public class A implements Runnable{
    
    
    public void run() {
        int n = nextInt();
        int[] arr = new int[n];
        boolean allOne = true;
        for (int i = 0; i < n; ++i) {
            arr[i] = nextInt();
            if (arr[i] != 1) {
                allOne = false;
            }
        }
        Arrays.sort(arr);
        if (!allOne) {
            out.print(""1 "");
        }
        for (int i = 0; i < n-1; ++i) {
            out.print(arr[i] + "" "");
        }
        if (allOne) {
            out.print(""2"");
        }
        out.println();
        out.flush();
    }
    
    private static BufferedReader br = null;
    private static PrintWriter out = null;
    private static StringTokenizer stk = null;
    
    public static void main(String[] args) {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        (new Thread(new A())).start();
    }
    
    private void loadLine() {
        try {
            stk = new StringTokenizer(br.readLine());
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    private String nextLine() {
        try {
            return br.readLine();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
    
    private Integer nextInt() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Integer.parseInt(stk.nextToken());
    }
    
    private Long nextLong() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Long.parseLong(stk.nextToken());
    }
    
    private String nextWord() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return (stk.nextToken());
    }
    
    private Double nextDouble() {
        while (stk==null||!stk.hasMoreTokens()) loadLine();
        return Double.parseDouble(stk.nextToken());
    }
    
    
}

",4,0135_A,CODEFORCES,2410,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.*;
public class A {
	static int [] reverse = new int [257];
	public static void main (String [] arg) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int [] A =new int [n];
		for (int i = 0; i<A.length; ++i) A[i] = sc.nextInt();
		Arrays.sort(A);
		if (n == 1) {
			System.out.println( (A[0] == 1) ? ""2"" : ""1"");
			return;
		} else if (A[0] == A[A.length-1] && A[0] == 1) {
			System.out.print(""1"");
			for (int i = 1; i<n-1; ++i) System.out.print("" "" + A[i]);
			System.out.println("" 2"");
			return;
		} else if (A[0] == A[A.length-1]) {
			System.out.print(""1"");
			for (int i = 1; i<n; ++i) System.out.print("" "" + A[i]);
			System.out.println();
			return;
		} 
		
		for (int i = 0; i<A.length; ++i) {
			int prev = (i == 0) ? Integer.MAX_VALUE : A[i-1];
			int next = (i == A.length-1) ? Integer.MAX_VALUE : A[i+1];
			int ans = Math.min(prev, Math.min(next, A[i]));
			if (i == 0) ans = 1;
			
			System.out.print((i == 0) ? """" + ans : "" "" + ans);
		}
		System.out.println();
		
		
	}
	
}",4,0135_A,CODEFORCES,2400,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import javax.sound.sampled.Line;
import java.awt.Point;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.io.*;
import java.math.BigInteger;
import static java.math.BigInteger.*;
import java.util.*;
public class A{


    void solve()throws Exception
    {
      int n=nextInt();
      int[]a=new int[n];
        for(int i=0;i<n;i++)
            a[i]=nextInt();
        Arrays.sort(a);
        int[]res=new int[n];
        for(int i=0;i<n;i++)
        {
            if(i==0)
                res[i]=1;
            else
                res[i]=a[i-1];
        }
        if(a[n-1]==1)
            res[n-1]=2;
        for(int i=0;i<n;i++)
        {
            if(i==n-1)
                writer.println(res[i]);
            else
                writer.print(res[i]+"" "");

        }


    }
     ////////////
    BufferedReader reader;
    PrintWriter writer;
    StringTokenizer stk;
    void run()throws Exception
    {
        reader=new BufferedReader(new InputStreamReader(System.in));
        stk=null;
        writer=new PrintWriter(new PrintWriter(System.out));
        solve();
        reader.close();
        writer.close();
    }
    int nextInt()throws Exception
    {
        return Integer.parseInt(nextToken());
    }

    long nextLong()throws Exception
    {
        return Long.parseLong(nextToken());

    }
    double nextDouble()throws Exception
    {
        return Double.parseDouble(nextToken());


    }

    String nextString()throws Exception
    {
        return nextToken();
    }
    String nextLine()throws Exception
    {
        return reader.readLine();
    }
    String nextToken()throws Exception
    {
        if(stk==null || !stk.hasMoreTokens())
        {
            stk=new StringTokenizer(nextLine());
            return nextToken();

        }
        return stk.nextToken();
    }

    public static void main(String[]args) throws Exception
    {
        new A().run();
    }



}",4,0135_A,CODEFORCES,2383,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

public class C {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        sc.nextLine();
        int[] x = new int[n];
        
        int max=0, pos=-1;
        for(int i=0; i<n; i++) {
            x[i]=sc.nextInt();
            if (max<x[i]) {
                max=x[i];
                pos=i;
            }
        }
        x[pos] = (max==1) ? 2 : 1;
        
        Arrays.sort(x);

        for(int i=0; i<n; i++) 
            System.out.print(x[i]+"" "");
    }
    
}",4,0135_A,CODEFORCES,2396,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"//package round97;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class A {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int n = ni();
		int[] a = new int[n];
		for(int i = 0;i < n;i++){
			a[i] = ni();
		}
		Arrays.sort(a);
		if(a[n-1] > 1){
			a[n-1] = 1;
			Arrays.sort(a);
		}else{
			a[n-1] = 2;
		}
		for(int i = 0;i < n;i++){
			if(i > 0)out.print("" "");
			out.print(a[i]);
		}
		out.println();
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception
	{
		new A().run();
	}
	
	public int ni()
	{
		try {
			int num = 0;
			boolean minus = false;
			while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));
			if(num == '-'){
				num = 0;
				minus = true;
			}else{
				num -= '0';
			}
			
			while(true){
				int b = is.read();
				if(b >= '0' && b <= '9'){
					num = num * 10 + (b - '0');
				}else{
					return minus ? -num : num;
				}
			}
		} catch (IOException e) {
		}
		return -1;
	}
	
	public long nl()
	{
		try {
			long num = 0;
			boolean minus = false;
			while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));
			if(num == '-'){
				num = 0;
				minus = true;
			}else{
				num -= '0';
			}
			
			while(true){
				int b = is.read();
				if(b >= '0' && b <= '9'){
					num = num * 10 + (b - '0');
				}else{
					return minus ? -num : num;
				}
			}
		} catch (IOException e) {
		}
		return -1;
	}
	
	public String ns()
	{
		try{
			int b = 0;
			StringBuilder sb = new StringBuilder();
			while((b = is.read()) != -1 && (b == '\r' || b == '\n' || b == ' '));
			if(b == -1)return """";
			sb.append((char)b);
			while(true){
				b = is.read();
				if(b == -1)return sb.toString();
				if(b == '\r' || b == '\n' || b == ' ')return sb.toString();
				sb.append((char)b);
			}
		} catch (IOException e) {
		}
		return """";
	}
	
	public char[] ns(int n)
	{
		char[] buf = new char[n];
		try{
			int b = 0, p = 0;
			while((b = is.read()) != -1 && (b == ' ' || b == '\r' || b == '\n'));
			if(b == -1)return null;
			buf[p++] = (char)b;
			while(p < n){
				b = is.read();
				if(b == -1 || b == ' ' || b == '\r' || b == '\n')break;
				buf[p++] = (char)b;
			}
			return Arrays.copyOf(buf, p);
		} catch (IOException e) {
		}
		return null;
	}
	
	
	double nd() { return Double.parseDouble(ns()); }
	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",4,0135_A,CODEFORCES,2424,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;
import static java.lang.Math.*;

public class A{
    public static void main(String[] args) throws Exception{
        new A().run();
    }

    void run() throws Exception{
        //Scanner sc = new Scanner(System.in);
        BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(sc.readLine());
        ArrayList<Integer> a = new ArrayList<Integer>();
        //a.add(1);
        StringTokenizer st = new StringTokenizer(sc.readLine(), "" "");
        boolean allOne = true;
        for(int i = 0; i < n; i++){
            int val = Integer.parseInt(st.nextToken());
            if(val!=1)allOne = false;
            a.add(val);
        }
        if(allOne){a.remove(n-1); a.add(2);}
        else a.add(1);
        Collections.sort(a);
        System.out.print(a.get(0));
        for(int i = 1; i < n; i++)
            System.out.print("" "" + a.get(i));
        System.out.println();
    }
}
",4,0135_A,CODEFORCES,2419,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ProblemA {

    private final BufferedReader in;
    private final PrintStream out;
    private StringTokenizer tok = new StringTokenizer("""");
    private String nextLine = null;

    public static void main(String[] args) throws Exception {
        new ProblemA();
    }

    private ProblemA() throws Exception {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = System.out;
        start();
        end();
    }

    private int nextInt() {
        return Integer.parseInt(nextWord());
    }

    private String nextWord() {
        if (tok.hasMoreTokens()) {
            return tok.nextToken();
        } else {
            while (!tok.hasMoreTokens()) {
                try {
                    nextLine = in.readLine();
                    if (nextLine == null) {
                        return null;
                    } else {
                        tok = new StringTokenizer(nextLine);
                    }
                } catch (IOException ex) {
                    Logger.getLogger(ProblemA.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            return tok.nextToken();
        }
    }

    private void start() {
        int n = nextInt();
        int[] a = new int[n];
        boolean allOne = true;
        for (int i = 0; i < n; i++) {
            a[i] = nextInt();
            if (a[i] != 1) {
                allOne = false;
            }
        }
        Arrays.sort(a);
        int[] res = new int[n];
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = a[i - 1];
        }
        if (allOne) {
            for (int i = 0; i < n - 1; i++) {
                out.print(a[i] + "" "");
            }
            out.print(2);
        } else {
            for (int i = 0; i < n; i++) {
                out.print(res[i] + "" "");
            }
        }
    }

    private void end() {
        out.close();
    }
}
",4,0135_A,CODEFORCES,2421,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;


public class A_135 {

    /**
     * @param args
     */
    public static void main(String[] args) {

        Scanner in=new Scanner(System.in);
        
        int n=in.nextInt();
        
        int[] mas=new int[n];
        
        for(int i=0;i<n;i++){
            mas[i]=in.nextInt();
        }
        
        Arrays.sort(mas);
        
        PrintWriter out=new PrintWriter(System.out);
        
        boolean isEd=true;
        for(int i=0;i<n;i++)
            if(mas[i]!=1){
                isEd=false;
                break;
            }
        
        if(!isEd)
            out.print('1');
        
        for(int i=0;i<n-1;i++){
            out.print(' ');
            out.print(mas[i]);
        }
        
        if(isEd)
            out.print("" 2"");
        
        out.flush();
    }

}
",4,0135_A,CODEFORCES,2394,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;


public class ProblemA {

	private void solve() throws IOException {
		Scanner stdin = new Scanner(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        
        int n = Integer.valueOf(stdin.nextInt());
        int[] p = new int[n];
        for (int i = 0; i < n; i++) {
        	p[i] = stdin.nextInt();
        }
        
        Arrays.sort(p);
        if (p[n-1] == 1) {
        	p[n-1] = 2;
        } else {
        	p[n-1] = 1;
        	out.print(p[n-1] + "" "");
        	n--;
        }
        
        for (int i = 0; i < n; i++) {
        	out.print(p[i] + "" "");
        }
        
        
        out.flush();
        out.close();
	}
	
	public static void main(String[] args) throws IOException {
		ProblemA solver = new ProblemA();
        solver.solve();
	}
}
",4,0135_A,CODEFORCES,2418,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class TaskA {
	BufferedReader br;
	PrintWriter out;
	StringTokenizer stok;

	String nextToken() throws IOException {
		while (stok == null || !stok.hasMoreTokens()) {
			String s = br.readLine();
			if (s == null) {
				return ""-1"";
			}
			stok = new StringTokenizer(s);
		}
		return stok.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	char nextChar() throws IOException {
		return (char) (br.read());
	}

	String nextLine() throws IOException {
		return br.readLine();
	}

	void solve() throws IOException {
		int n = nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		Arrays.sort(a);
		a[n - 1] = a[n - 1] == 1 ? 2 : 1;
		Arrays.sort(a);
		for (int i = 0; i < n; i++) {
			out.print(a[i]);
			out.print(' ');
		}
	}

	void run() throws IOException {
		// br = new BufferedReader(new FileReader(""taska.in""));
		// out = new PrintWriter(""taska.out"");
		// br = new BufferedReader(new FileReader(""input.txt""));
		// out = new PrintWriter(""output.txt"");
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		br.close();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		// Locale.setDefault(Locale.US);
		new TaskA().run();
	}
}",4,0135_A,CODEFORCES,2397,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.* ;
import java.util.*;

import static java.lang.Math.* ;
import static java.util.Arrays.* ;

public class A {
	
	public static void main(String[] args) throws IOException {
		
		new A().solveProblem();
		
		out.close();
	}

	static Scanner in = new Scanner(new InputStreamReader(System.in));
	//static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	static PrintStream out = new PrintStream(new BufferedOutputStream(System.out));
	
	
	public void solveProblem() {		

		int n = in.nextInt() ;
		E[] get = new E[n] ;
		for( int i = 0 ; i < n ; i++ ){
			get[i] = new E(i,in.nextInt()) ;
		}
		
		sort(get) ;
		
	
		if( get[n-1].g == 1){
			get[n-1].g = 2 ;
		}else{
			get[n-1].g = 1 ;
			
		}
		sort(get) ;
		for( int i = 0 ; i < n - 1 ; i++ )
			out.print(get[i].g  +"" "" ) ;
		out.println(get[n-1].g) ;
		
	}
	
	class E implements Comparable<E>{
		int g ;
		int index ;
		
		public E( int index, int g){
			this.g = g ;
			this.index = index ;
		}
		
		public int compareTo( E e){
			return g - e.g ;
		}
	}

	static int[] readGet( int n ){
	  	int[] get = new int[n] ;
	  	for( int i = 0 ; i < n ; i++ )
	  		get[i] = in.nextInt();
	  	return get ;
	}
	
       
}",4,0135_A,CODEFORCES,2393,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {

	public A () throws IOException {
		String input = r.readLine();
		int N = Integer.parseInt(input);
		int [] A = new int [N];
		input = r.readLine();
		String [] S = input.split("" "");
		for (int i = 0; i < N; ++i)
			A[i] = Integer.parseInt(S[i]);
		solve(N, A);
	}
	
	public void solve (int N, int [] A) {
		t = millis();
		Arrays.sort(A);
		if (A[N-1] > 1) A[N-1] = 1;
		else A[N-1] = 2;
		Arrays.sort(A);
		System.out.print(A[0]);
		for (int i = 1; i < N; ++i)
			System.out.print("" "" + A[i]);
		System.out.println();
	}

	////////////////////////////////////////////////////////////////////////////////////

	static BufferedReader r;
	static long t;
	
	static void print2 (Object o) {
		System.out.println(o);
	}
	
	static void print (Object o) {
		print2(o);
		//print2((millis() - t) / 1000.0);
		System.exit(0);
	}
	
	static void run () throws IOException {
		r = new BufferedReader(new InputStreamReader(System.in));
		new A();
	}
	
	public static void main(String[] args) throws IOException {
		run();
	}
	
	static long millis() {
		return System.currentTimeMillis();
	}
}
",4,0135_A,CODEFORCES,2386,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;



public class Replacement {
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader r=new BufferedReader(new InputStreamReader(System.in));	
		String s=r.readLine();
		int n=new Integer(s);
		int[]arr=new int[n];
		String[]sp=r.readLine().split(""[ ]+"");
		for (int i = 0; i < sp.length; i++) {
			arr[i]=new Integer(sp[i]);
		}
		Arrays.sort(arr);
		if(arr[arr.length-1]==1){
			arr[arr.length-1]=2;
			Arrays.sort(arr);
			for (int i = 0; i < n; i++) {
				if(i==n-1){
					System.out.println(arr[i]);
				}else
				System.out.print(arr[i]+"" "");
			}
			return;
		}
		arr[arr.length-1]=1;
		Arrays.sort(arr);
		for (int i = 0; i < n; i++) {
			if(i==n-1){
				System.out.println(arr[i]);
			}else
			System.out.print(arr[i]+"" "");
		}
	}
}
",4,0135_A,CODEFORCES,2427,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class c {
	public static void main(String[] args)
			throws IOException {
		BufferedReader r =	
				new BufferedReader(new InputStreamReader(System.in), 1);
		String s = r.readLine();
		int n = Integer.parseInt(s);
		String s2 = r.readLine();
		StringTokenizer st = new StringTokenizer(s2,"" "");
		int a[] = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = Integer.parseInt(st.nextToken());
		Arrays.sort(a);
		if (a[n - 1] == 1) a[n - 1] = 2;
		else {a[n - 1] = 1; Arrays.sort(a);}
		for (int i = 0; i < n; i++)
			System.out.println(a[i]);
	}
}
",4,0135_A,CODEFORCES,2385,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import static java.util.Arrays.deepToString;

import java.io.*;
import java.math.*;
import java.util.*;

public class A {

	static int [] solve(int [] a) {
		int n = a.length;
		Arrays.sort(a);
		a[n - 1] = (a[n - 1] > 1 ? 1 : 2);
		int [] b = Arrays.copyOf(a, n);
		Arrays.sort(b);
		return b;
	}

	public static void main(String[] args) throws Exception {
		reader = new BufferedReader(new InputStreamReader(System.in));
		writer = new PrintWriter(System.out);

		setTime();
		
		int n = nextInt();
		int [] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		int [] b = solve(a);
		for (int v: b) {
			writer.print(v + "" "");
		}
		
		printTime();
		printMemory();

		writer.close();
	}

	static BufferedReader reader;
	static PrintWriter writer;
	static StringTokenizer tok = new StringTokenizer("""");
	static long systemTime;

	static void debug(Object... o) {
		System.err.println(deepToString(o));
	}

	static void setTime() {
		systemTime = System.currentTimeMillis();
	}

	static void printTime() {
		System.err.println(""Time consumed: "" + (System.currentTimeMillis() - systemTime));
	}

	static void printMemory() {
		System.err.println(""Memory consumed: ""
				+ (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1000 + ""kb"");
	}

	static String next() {
		while (!tok.hasMoreTokens()) {
			String w = null;
			try {
				w = reader.readLine();
			} catch (Exception e) {
				e.printStackTrace();
			}
			if (w == null)
				return null;
			tok = new StringTokenizer(w);
		}
		return tok.nextToken();
	}

	static int nextInt() {
		return Integer.parseInt(next());
	}

	static long nextLong() {
		return Long.parseLong(next());
	}

	static double nextDouble() {
		return Double.parseDouble(next());
	}

	static BigInteger nextBigInteger() {
		return new BigInteger(next());
	}
}",4,0135_A,CODEFORCES,2391,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * Created with IntelliJ IDEA.
 * User: Alexey
 * Date: 16.09.12
 * Time: 19:29
 * To change this template use File | Settings | File Templates.
 */
public class stub implements Runnable {
    public static void main(String[] args) {
        new stub().run();
    }

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    PrintWriter out = new PrintWriter(System.out);
    StringTokenizer st;

    public String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine());
        }
        return st.nextToken();
    }

    public int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private void solve() throws IOException {
        int[] cnt = new int[(int) 1e6];
        int n = nextInt();
        int k = nextInt();
        int[] a = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = nextInt();
        }

        int cur = 0;
        int left = 0;
        int i = left;
        while (i < n && cur != k) {
            if (cnt[a[i]] == 0) {
                cur++;
            }
            cnt[a[i]]++;
            i++;
        }
        i--;
        if (cur != k) {
            out.println(""-1 -1"");
            return;
        }
        int right = i;
        while (cnt[a[left]] > 1) {
            cnt[a[left]]--;
            left++;
        }
        out.println((left + 1) + "" "" + (right + 1));
    }

    public void run() {
        try {
            solve();
            out.close();
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
",3,0224_B,CODEFORCES,1666,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a[] = new int[100004];
        int b[] = new int[100004];
        int n, m, ans = 0, dau, cuoi=-1;
        n = sc.nextInt();
        m = sc.nextInt();
        for(int i=0;i<100004;i++) a[i] = 0;
        for(int i=0;i<n;i++){
            b[i] = sc.nextInt();
            if(a[b[i]]==0){
                a[b[i]] = 1;
                ans++;
                if(ans==m){
                    cuoi = i+1;
                    break;
                }
            }
        }
        for(int i=cuoi-1;i>=00;i--){
            if(a[b[i]]==1){
                a[b[i]] = 0;
                ans--;
                if(ans==0){
                    System.out.println((i+1)+"" ""+cuoi);
                    System.exit(0);
                }
            }
        }
        System.out.println(""-1 -1"");
    }

}
",3,0224_B,CODEFORCES,1670,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Scanner;


public class B {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner scr = new Scanner(System.in);
		int n = scr.nextInt();
		int k = scr.nextInt();
		
		int[] a = new int[n+1];		
		int[] d = new int[100001];
		
		int tk = 0;
		int l = 1;
		int r = -1;
		boolean find = false;
		for (int i = 1; i <= n; i++){
			a[i] = scr.nextInt();
			if (d[a[i]] == 0){
				d[a[i]] = 1;
				tk++;
				if ((!find) && (tk == k)){
					find = true;
					r = i;
				} // if 
			} // if
		} // for
		
		
		if (r > 0) {
			int[] cd = new int[100001];
			tk = 0;
			find = false;
			for (int j = r; j >= l; j--){
				if(cd[a[j]] == 0){
					cd[a[j]] = 1;
					tk++;
					if ((!find) && (tk == k)){
						find = true;
						l = j;
						break;
					} // if
				} // if
			} // for
			System.out.println(l + "" "" + r);
		} // if
		else {
			System.out.println(""-1 -1"");
		}			

	}

}
",3,0224_B,CODEFORCES,1647,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class B {

	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
//		Scanner scan = new Scanner(System.in);
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n  = Integer.parseInt(st.nextToken());
		int k  = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		int[] a = new int[n];
		for(int i = 0 ; i  <n;i++)
			a[i] = Integer.parseInt(st.nextToken());
		
		int l = 0, r = 0;
		int[] t = new int[100001];
		int kk = 0;
		int min = 1 << 25 , ll =-1 , rr = -1;
		while(r < n)
		{
			int x = a[r++];
			t[x]++;
			if(t[x] == 1)
				kk++;
			while(r < n && kk < k)
			{
				x = a[r++];
				t[x]++;
				if(t[x] == 1)
					kk++;
			}
			while(kk == k && l < r)
			{
				x = a[l];
				if(t[x] == 1)
					break;
				t[x]--;
				l++;
			}
			if(kk == k)
			{
				int m = r-l+1;
				if(m < min)
				{
					ll = l+1;
					rr = r;
					min = m;
				}
			}
		}
		System.out.println(ll +"" ""+rr);
	}

}
",3,0224_B,CODEFORCES,1684,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class CodeForces {
    static boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;

    void runCase(int caseNum) throws IOException {
        int n = nextInt();
        int k = nextInt();
        int[] nums = new int[n];
        int distinct = 0;
        int L = -1, R = -1;
        int minLen = Integer.MAX_VALUE;
        int maxNum = 0;

        for (int i = 0; i < n; ++i) {
            nums[i] = nextInt();
            maxNum = Math.max(maxNum,  nums[i]);
        }
        int[] count = new int[maxNum + 1];
        int j = 0;

        for (int i = 0; i < n; ++i) {
            ++count[nums[i]];
            if (count[nums[i]] == 1) {
                ++distinct;
                if (distinct >= k) {
                    for (; j <= i; ++j) {
                        --count[nums[j]];
                        if (count[nums[j]] <= 0) {
                            --distinct;
                            if (distinct < k) {
                                if (i - j < minLen) {
                                    minLen = i - j;
                                    L = j + 1;
                                    R = i + 1;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        out.print(L + "" "" + R);
    }


    public static void main(String[] args) throws IOException {
        if (ONLINE_JUDGE){
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        }else{
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
        new CodeForces().runIt();
        out.flush();
        out.close();
        return;
    }

    static BufferedReader in;
    private StringTokenizer st;
    static PrintWriter out;

    String next() throws IOException {
        while (!st.hasMoreTokens()) {
            String line = in.readLine();
            if (line == null) {
                return null;
            }
            st = new StringTokenizer(line, "" "");
        }
        return st.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    long nextLong() throws IOException {
        return Long.parseLong(next());
    }


    void runIt() throws IOException {
        st = new StringTokenizer("""");

//        int N = nextInt();
//        for (int i = 0; i < N; i++) {
//            runCase(i + 1);
//        }
        runCase(0);

        out.flush();
    }

}
",3,0224_B,CODEFORCES,1665,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;


public class B
{
	BufferedReader in;
	PrintStream out;
	StringTokenizer tok;
	public B() throws NumberFormatException, IOException
	{
		in = new BufferedReader(new InputStreamReader(System.in));
		//in = new BufferedReader(new FileReader(""in.txt""));
		out = System.out;
		run();
	}
	void run() throws NumberFormatException, IOException
	{
		int n = nextInt();
		int k = nextInt();
		int[] num = new int[n];
		for(int i = 0; i < n; i++)
			num[i] = nextInt();
		int[] cant = new int[100001];
		int cnt = 0;
		int r = 0;
		for(; r < n; r++)
		{
			if(cant[num[r]]==0)cnt++;
			cant[num[r]]++;
			if(cnt==k) break;
		}
		if(cnt<k)
		{
			out.println(""-1 -1"");
			return;
		}
		int l = 0;
		for(; l < r; l++)
		{
			cant[num[l]]--;
			if(cant[num[l]]==0)cnt--;
			if(cnt<k) break;
		}
		out.println((l+1)+"" ""+(r+1));
	}
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		new B();
	}
	String nextToken() throws IOException
	{
		if(tok ==null || !tok.hasMoreTokens()) tok = new StringTokenizer(in.readLine());
		return tok.nextToken();
	}
	int nextInt() throws NumberFormatException, IOException
	{
		return Integer.parseInt(nextToken());
	}
	long nextLong() throws NumberFormatException, IOException
	{
		return Long.parseLong(nextToken());
	}
	double nextDouble() throws NumberFormatException, IOException
	{
		return Double.parseDouble(nextToken());
	}
}
",3,0224_B,CODEFORCES,1675,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

public class B {

    static BufferedReader in;
    static StringTokenizer st;

    static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static void main(String[] args) throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int n = nextInt();
        int k = nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = nextInt();
        }
        Set<Integer> set_1 = new HashSet<Integer>();
        for (int i = 1; i <= n; i++) {
            set_1.add(a[i]);
            if (set_1.size() == k) {
                Set<Integer> set_2 = new HashSet<Integer>();
                for (int j = i; j >= 1; j--) {
                    set_2.add(a[j]);
                    if (set_2.size() == k) {
                        out.print(j + "" "" + i);
                        out.close();
                        return;
                    }
                }
            }
        }
        out.print(""-1 -1"");
        out.close();

    }
}
",3,0224_B,CODEFORCES,1650,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.*;

public class B {

    private void solve() throws IOException {
        int n = nextInt();
        int k = nextInt();
        
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = nextInt();
        
        int[] f = new int[100000 + 2];
        
        int min = Integer.MAX_VALUE;
        int cur = 0;
        int start = 0;
        int from = -1, to = -1;
        
        for (int i = 0; i < n; i++) {
            f[a[i]]++;
            if (f[a[i]] == 1) cur++;
            if (cur == k) {
                while (f[a[start]] > 1) {
                    f[a[start]]--;
                    start++;
                }
                if (i - start + 1 < min) {
                    min = i - start + 1;
                    from = start;
                    to = i;
                }
            }
        }
        pl(from == -1 ? ""-1 -1"" : ((1 + from) + "" "" + (1 + to)));
    }

    public static void main(String[] args) {
        new B().run();
    }

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    public void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    BigInteger nextBigInteger() throws IOException {
        return new BigInteger(nextToken());
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    void p(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.flush();
            writer.print(objects[i]);
            writer.flush();
        }
    }

    void pl(Object... objects) {
        p(objects);
        writer.flush();
        writer.println();
        writer.flush();
    }

    int cc;

    void pf() {
        writer.printf(""Case #%d: "", ++cc);
        writer.flush();
    }

}",3,0224_B,CODEFORCES,1654,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.FileReader;
import java.io.BufferedWriter;
import java.util.Set;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.File;
import java.io.Writer;
import java.util.StringTokenizer;
import java.util.HashSet;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author jarek
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n = in.nextInt(), k = in.nextInt();
        int[] a = IOUtils.readIntArray(in, n);
        Set<Integer> cnt = new HashSet<Integer>();
        int i = 0;
        while (i < n && cnt.size() < k) {
            cnt.add(a[i]);
            if (cnt.size() < k)
                ++i;
        }
        if (cnt.size() < k)
            out.print(""-1 -1"");
        else {
            int r = i;
            cnt = new HashSet<Integer>();
            while (i >= 0 && cnt.size() < k) {
                cnt.add(a[i]);
                if (cnt.size() < k) --i;
            }
            out.print(i + 1, r + 1);
        }
    }
}

class InputReader {
    BufferedReader br;
    StringTokenizer st;

    public InputReader(File f) {
        try {
            br = new BufferedReader(new FileReader(f));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    public InputReader(InputStream f) {
        br = new BufferedReader(new InputStreamReader(f));
    }

    public String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    }

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void close() {
        writer.close();
    }
}

class IOUtils {

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.nextInt();
        return array;
    }

    }

",3,0224_B,CODEFORCES,1657,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Map;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.io.BufferedWriter;
import java.util.Locale;
import java.util.InputMismatchException;
import java.util.HashMap;
import java.util.Set;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Jacob Jiang
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
	public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n = in.nextInt();
        int k = in.nextInt();
        int[] a = in.nextIntArray(n);
        if (k == 1) {
            out.println(""1 1"");
            return;
        }
        int left = -1, right = -1;
        Counter<Integer> counter = new Counter<Integer>();
        while (true) {
            right++;
            if (right == n) {
                out.println(""-1 -1"");
                return;
            }
            counter.add(a[right]);
            if (counter.size() >= k)
                break;
        }
        while (true) {
            left++;
            if (counter.get(a[left]) == 1)
                break;
            counter.add(a[left], -1);
        }
        out.printLine(left + 1, right + 1);
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1 << 16];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int nextInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c & 15;
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public static boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int[] nextIntArray(int count) {
        int[] result = new int[count];
        for (int i = 0; i < count; i++) {
            result[i] = nextInt();
        }
        return result;
    }

    }

class OutputWriter {
    private PrintWriter writer;

    public OutputWriter(OutputStream stream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(Object obj) {
        writer.print(obj);
    }

    public void println() {
        writer.println();
    }

    public void println(String x) {
        writer.println(x);
    }

    public void print(char c) {
        writer.print(c);
    }

    public void close() {
        writer.close();
    }

    public void printItems(Object... items) {
        for (int i = 0; i < items.length; i++) {
            if (i != 0) {
                print(' ');
            }
            print(items[i]);
        }
    }

    public void printLine(Object... items) {
        printItems(items);
        println();
    }

}

class Counter<T> extends HashMap<T, Long> {
    public void add(T obj, long count) {
        put(obj, get(obj) + count);
    }

    public void add(T obj) {
        put(obj, get(obj) + 1L);
    }

    public Long get(Object key) {
        return containsKey(key) ? super.get(key) : 0L;
    }
}

",3,0224_B,CODEFORCES,1662,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;


public class CF224B {
    
    public static void main(String[] args) throws Exception {
        new CF224B().solve();
    }

    private void solve() throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        final int MAX_A = 100000;
        int[] freq = new int[MAX_A+1];
        int numDistinct = 0;
        int r = -1;
        for (int i = 0; i < n; i++) {
            int t = a[i];
            freq[t]++;
            if (freq[t] == 1) {
                numDistinct++;
            }
            if (numDistinct == k) {
                r = i;
                break;
            }
        }
        if (r == -1) {
            System.out.println(""-1 -1"");
            return;
        }
        int l;
        for (l = 0; l < r; l++) {
            int t = a[l];
            freq[t]--;
            if (freq[t] == 0) {
                break;
            }
        }
        System.out.println((l+1) + "" "" + (r+1));
    }

}
",3,0224_B,CODEFORCES,1672,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.StringTokenizer;

public class Array {

    void run() {
        try {
            BufferedReader bfd = new BufferedReader(new InputStreamReader(
                    System.in));
            StringTokenizer tk = new StringTokenizer(bfd.readLine());
            int n = Integer.parseInt(tk.nextToken());
            int k = Integer.parseInt(tk.nextToken()), i;
            int arr[] = new int[n];
            tk = new StringTokenizer(bfd.readLine());
            for(i=0;i<n;++i)
                arr[i] = Integer.parseInt(tk.nextToken());
            int dist=0,l=0,r=0;
            HashSet<Integer> hs = new HashSet<Integer>();
            for(i=0; i<n; ++i) {
                if(!hs.contains(arr[i])){
                    hs.add(arr[i]);
                    dist++;
                }
                if(dist==k) break;
                r++;
            }
            int freq[] = new int[100010];
            if(hs.size()<k) System.out.println(""-1 -1"");
            else {
                while(l<arr.length-1 && l<r && arr[l]==arr[l+1])
                    ++l;
                while(r>=1 && r>l && arr[r]==arr[r-1])
                    --r;
                for(i=l;i<=r;++i)
                    freq[arr[i]]++;
                while(freq[arr[l]]>1){
                    freq[arr[l]]--;
                    l++;
                }
                while(freq[arr[r]]>1){
                    freq[arr[r]]--;
                    r--;
                }
                System.out.println((l+1)+"" "" +(r+1));
            }
        } catch (Exception e) {

        }
    }
    public static void main(String[] args) {
        new Array().run();
    }

}
",3,0224_B,CODEFORCES,1643,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class B implements Runnable {

	void Solution() throws IOException {
		int n = nextInt(), k = nextInt();
		int[] mas = new int[n];
		for (int i = 0; i < n; i++)
			mas[i] = nextInt();
		int l = 0, r = 0;
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		map.put(mas[l], 1);
		int cur = 1;
		while (true) {
			if (cur == k) {
				print(l + 1, r + 1);
				return;
			}
			r++;
			if (r >= n)
				break;
			int kol = map.containsKey(mas[r]) ? map.remove(mas[r]) : 0;
			if (kol == 0) {
				cur++;
				map.put(mas[r], 1);
			} else
				map.put(mas[r], kol + 1);
			while (true) {
				kol = map.remove(mas[l]);
				if (kol == 1) {
					map.put(mas[l], 1);
					break;
				} else
					map.put(mas[l++], kol - 1);
			}
		}
		print(-1, -1);
	}

	public static void main(String[] args) {
		new B().run();
	}

	BufferedReader in;
	PrintWriter out;
	StringTokenizer tokenizer;

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			Solution();
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(0);
		}
	}

	void print(Object... obj) {
		for (int i = 0; i < obj.length; i++) {
			if (i != 0)
				out.print("" "");
			out.print(obj[i]);
		}
	}

	void println(Object... obj) {
		print(obj);
		out.println();
	}

	void halt() {
		out.close();
		System.exit(0);
	}

	String nextLine() throws IOException {
		return in.readLine();
	}

	String next() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(nextLine());
		return tokenizer.nextToken();
	}

	int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(next());
	}

	long nextLong() throws NumberFormatException, IOException {
		return Long.parseLong(next());
	}

	double nextDouble() throws NumberFormatException, IOException {
		return Double.parseDouble(next());
	}
}
",3,0224_B,CODEFORCES,1644,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

public class Solver {

    StringTokenizer st;
    BufferedReader in;
    PrintWriter out;

    public static void main(String[] args) throws NumberFormatException,
            IOException {
        Solver solver = new Solver();
        solver.open();
        long time = System.currentTimeMillis();
        solver.solve();
        if (!""true"".equals(System.getProperty(""ONLINE_JUDGE""))) {
            System.out.println(""Spent time: ""
                    + (System.currentTimeMillis() - time));
        }
        solver.close();
    }

    public void open() throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
    }

    public String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    public int nextInt() throws NumberFormatException, IOException {
        return Integer.parseInt(nextToken());
    }

    public long nextLong() throws NumberFormatException, IOException {
        return Long.parseLong(nextToken());
    }

    public double nextDouble() throws NumberFormatException, IOException {
        return Double.parseDouble(nextToken());
    }

    public void solve() throws NumberFormatException, IOException {
        int n = nextInt();
        int k = nextInt();
        
        int[] ar = new int[n];
        int[] ex = new int[100005];
        int dif = 0;
        
        for(int i=0;i<n;i++){
            int tmp = nextInt();
            ar[i] = tmp;
            if (ex[tmp]++==0){
                dif++;          
            }           
        }
        
        if (dif<k){
            out.println(""-1 -1"");
            return;
        }
        
        Arrays.fill(ex, 0);
        dif = 0;
        int right = 0;
        while(dif<k){
            int tmp = ar[right];
            if(ex[tmp]++==0){       
                dif++;
            }
            right++;
        }
        
        int left = 0;
        while (ex[ar[left]]-- > 1) left++;
        
        out.println((left+1)+"" ""+right);
    }

    public void close() {
        out.flush();
        out.close();
    }

}",3,0224_B,CODEFORCES,1659,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    static StringTokenizer st;
    static PrintWriter out = new PrintWriter(System.out,true);
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

    public static int nextInt() throws Exception {
        if(st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());
        return Integer.parseInt(st.nextToken());
    }

    public static long nextLong() throws Exception {
        if(st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());
        return Long.parseLong(st.nextToken());
    }

    public static void main(String[] args) throws Exception {
        HashSet<Integer> set = new HashSet<>();
        int n = nextInt();
        int k = nextInt();
        int[] m = new int[n];
        int[] d = new int[n];
        for(int i = 0;i < n;i++) m[i] = nextInt();
        int l = -1;
        int r = -1;
        for(int i = 0;i < n;i++) {
            set.add(m[i]);
            d[i] = set.size();
            if(d[i] == k) {
                r = i;
                break;
            }
        }
        if(r == -1) {
            out.println(""-1 -1"");
            return;
        }

        for(int i = r;i >= 0;i--) {
            set.remove(m[i]);
            if(set.size() == 0) {
                l = i;
                break;
            }
        }
        out.println((l+1)+"" ""+(r+1));
    }
}",3,0224_B,CODEFORCES,1652,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class PrB {

	public static long time;
	
	public static void main(String[] args) throws Exception {
		time = System.currentTimeMillis();
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		n = Integer.parseInt(st.nextToken());
		k = Integer.parseInt(st.nextToken());
		a = new int[n];
		st = new StringTokenizer(br.readLine());
		for(int i = 0; i < n; i++) 
			a[i] = Integer.parseInt(st.nextToken());
		int end = end();
		if(end < 0) System.out.println(""-1 -1"");
		else System.out.println((start(end) + 1) + "" "" + (end + 1));
		br.close();
		System.exit(0);
	}
	
	static int n, k;
	static int[] a;

	public static int end() throws Exception {
		boolean[] reached = new boolean[100002];
		int rem = k;
		for(int i = 0; i < n; i++) {
			if(!reached[a[i]]) {
				rem--;
				if(rem == 0) return i;
			}
			reached[a[i]] = true;
		}
		return -1;
	}
	
	public static int start(int end) throws Exception {
		boolean[] reached = new boolean[100002];
		int rem = k;
		for(int i = end; i >= 0; i--) {
			if(!reached[a[i]]) {
				rem--;
				if(rem == 0) return i;
			}
			reached[a[i]] = true;
		}
		return 0;
	}

	public static void checkTime() {
		System.out.println(System.currentTimeMillis() - time);
		time = System.currentTimeMillis();
	}
}",3,0224_B,CODEFORCES,1649,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Arrays;
import java.util.Scanner;

public class Array {
		
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int k = in.nextInt();
		/*
		if ( k == 1 ){ 
			System.out.println(""1 1""); return;
		}
		*/
		int last[] = new int[100001];
		int distinct = 0;
		for ( int i = 0 ; i < n ; ++i ) {
			int t = in.nextInt();
			if ( last[t] == 0 ) ++distinct;
			last[t] = i+1;
			if ( distinct == k ) {
				int min = i+1;
				for ( int j = 0 ; j < last.length ; ++j ) {
					if ( last[j] != 0 ) min = min>last[j]?last[j]:min;
				}
				System.out.println(min+"" ""+(i+1)); return;
			}
		}
		System.out.println(""-1 -1""); 
	}
	
}
",3,0224_B,CODEFORCES,1641,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;


public class C_138B {
	private static BufferedReader in;
	private static StringTokenizer st;
	private static PrintWriter out;
	
	
	static String nextToken() throws IOException {
		while (!st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		return st.nextToken();
	}
	
	static int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(nextToken());
	}
	public static void main(String[] args) throws NumberFormatException, IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		st = new StringTokenizer("""");
		out = new PrintWriter(new OutputStreamWriter(System.out));
		int n = nextInt();
		int k = nextInt();
		int [] a = new int [n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		Set<Integer> set = new HashSet<Integer>();
		for (int i = 0; i < a.length; i++) {
			set.add(a[i]);
			if(set.size()==k){
				Set<Integer> set2 = new HashSet<Integer>();
				for (int j = i; j >= 0; j--) {
					set2.add(a[j]);
					if(set2.size()==k){
						out.print((j+1)+"" ""+(i+1));
						out.close();
						return;
					}
				}
			}
		}
		out.print(""-1 -1"");		
		out.close();
	}
}
",3,0224_B,CODEFORCES,1642,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;


public class B {
    public static void main(String[] args) throws Exception {
        new B().solve();
    }
    
    void solve() throws IOException {
        BufferedReader in = new BufferedReader(new
                InputStreamReader(System.in));
        // Scanner sc = new Scanner(System.in);
        
        String[] sp = in.readLine().split("" "");
        
        int n = Integer.parseInt(sp[0]);
        int k = Integer.parseInt(sp[1]);
        int[] a = new int[n];
        sp = in.readLine().split("" "");
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(sp[i]);
        }
        
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int r = 0;
        map.put(a[r], 1);
        while (map.size() < k) {
            r++;
            if (r == n) {
                // ng
                System.out.println(""-1 -1"");
                return;
            }
            if (map.containsKey(a[r])) {
                map.put(a[r], map.get(a[r]) + 1);
            } else {
                map.put(a[r], 1);
            }
        }
        int l = 0;
        while (map.get(a[l]) > 1) {
            map.put(a[l], map.get(a[l]) - 1);
            l++;
        }
        System.out.println((l + 1) + "" "" + (r + 1));
    }
}




//
",3,0224_B,CODEFORCES,1651,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

public class B {

    static BufferedReader in;
    static StringTokenizer st;

    static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static void main(String[] args) throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int n = nextInt();
        int k = nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = nextInt();
        }
        Set<Integer> set_1 = new HashSet<Integer>();
        for (int i = 1; i <= n; i++) {
            set_1.add(a[i]);
            if (set_1.size() == k) {
                Set<Integer> set_2 = new HashSet<Integer>();
                for (int j = i; j >= 1; j--) {
                    set_2.add(a[j]);
                    if (set_2.size() == k) {
                        out.print(j + "" "" + i);
                        out.close();
                        return;
                    }
                }
            }
        }
        out.print(""-1 -1"");
        out.close();

    }
}
",3,0224_B,CODEFORCES,1653,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class Array224B {
	public static void main(String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(f.readLine());
		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		int[] array = new int[n];
		int[] visited = new int[100002];
		st = new StringTokenizer(f.readLine());
		for(int i=0;i<n;i++){
			array[i] = Integer.parseInt(st.nextToken());
		}
		int count = 0;
		int begin = array[0];
		while(count<n && array[count] == begin){
			count++;
		}
		count--;
		int kcount = 1;
		visited[array[count]]++;
		int bindex = count;
		boolean good=true;
		count++;
		while(kcount<k){
			if(count==n){
				System.out.println(""-1 -1"");
				good=false;
				break;
			}
			if(visited[array[count]]==0){
				kcount++;
			}
			visited[array[count]]++;
			count++;
		}
		if(good&&k!=1){
		for(int i=bindex;i<count;i++){
			if(visited[array[i]]==1){
				break;
			}
			bindex++;
			visited[array[i]]--;
		}
		for(int i=count-1;i>bindex;i--){
			if(visited[array[i]]==1){
				break;
			}
			count--;
			visited[array[i]]--;
		}
		}
		if(k==1){
			System.out.println(""1 1"");
		}
		else if(good){
			System.out.println(bindex+1+"" ""+count);
		}
	}
}",3,0224_B,CODEFORCES,1688,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

public class Code implements Runnable {

    public static void main(String[] args) throws IOException {
        new Thread(new Code()).start();
    }

    private void solve() throws IOException {
        taskB();
    }

    private void taskB() throws IOException {
        int n = nextInt(), k = nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; ++i)  arr[i] = nextInt();

        int i = 0;
        while(i < n - 1 && arr[i] == arr[i + 1])    ++i;

        if(k == 1)
            writer.println(1 + "" "" + 1);
        else if(k == 2 && i == n - 2)
            writer.println(n - 1 + "" "" + n);
        else {
            if(i == n - 1)
                writer.println(-1 + "" "" + -1);
            else {
                int l = i;
                Map<Integer, Integer> set = new HashMap<Integer, Integer>(n);
                while(i < n && set.size() < k) {
                    if(set.containsKey(arr[i])) set.put(arr[i], set.get(arr[i]) + 1);
                    else    set.put(arr[i], 1);
                    i += 1;
                }
                if(set.size() < k)  writer.println(-1 + "" "" + -1);
                else {
                    while(l < i && i - l > k && set.get(arr[l]) > 1) {
                        set.put(arr[l], set.get(arr[l]) - 1);
                        l += 1;
                    }
                    writer.println((l + 1) + "" "" + i);
                }
            }
        }
    }

    private class Pair<E extends Comparable, V extends Comparable> implements Comparable<Pair<E, V>> {
        public Pair(E first, V second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(Pair<E, V> obj) {
            if(first.equals(obj.first))  return second.compareTo(obj.second);
            return first.compareTo(obj.first);
        }

        @Override
        public boolean equals(Object obj) {
            Pair other = (Pair)obj;
            return first.equals(other.first) && second.equals(other.second);
        }

        public E first;
        public V second;
    }

    @Override
    public void run() {
        try {
            if(in.equals(""""))   reader = new BufferedReader(new InputStreamReader(System.in));
            else    reader = new BufferedReader(new FileReader(in));

            if(out.equals(""""))  writer = new PrintWriter(new OutputStreamWriter(System.out));
            else    writer = new PrintWriter(new FileWriter(out));
            solve();
        } catch(IOException e) {
            e.printStackTrace();
        } finally {
            try {
                reader.close();
                writer.close();
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    private double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private float nextFloat() throws IOException {
        return Float.parseFloat(nextToken());
    }

    private String nextToken() throws IOException {
        while(st == null || !st.hasMoreTokens())    st = new StringTokenizer(reader.readLine());
        return st.nextToken();
    }

    private String in = """", out = """";
    private BufferedReader reader;
    private PrintWriter writer;
    private StringTokenizer st;
}",3,0224_B,CODEFORCES,1674,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
import java.io.*;

public class A2OJ
{
	public static class FastIO
	{
		BufferedReader br;
		BufferedWriter bw, be;
		StringTokenizer st;

		public FastIO()
		{
			br = new BufferedReader(new InputStreamReader(System.in));
			bw = new BufferedWriter(new OutputStreamWriter(System.out));
			be = new BufferedWriter(new OutputStreamWriter(System.err));
			st = new StringTokenizer("""");
		}

		private void read() throws IOException
		{
			st = new StringTokenizer(br.readLine());
		}

		public String ns() throws IOException
		{
			while(!st.hasMoreTokens())
				read();
			return st.nextToken();
		}

		public int ni() throws IOException
		{
			return Integer.parseInt(ns());
		}

		public long nl() throws IOException
		{
			return Long.parseLong(ns());
		}

		public float nf() throws IOException
		{
			return Float.parseFloat(ns());
		}

		public double nd() throws IOException
		{
			return Double.parseDouble(ns());
		}

		public char nc() throws IOException
		{
			return ns().charAt(0);
		}

		public int[] nia(int n) throws IOException
		{
			int[] a = new int[n];
			for(int i = 0; i < n; i++)
				a[i] = ni();

			return a;
		}

		public long[] nla(int n) throws IOException
		{
			long[] a = new long[n];
			for(int i = 0; i < n; i++)
				a[i] = nl();

			return a;
		}

		public void out(String s) throws IOException
		{
			bw.write(s);
		}

		public void flush() throws IOException
		{
			bw.flush();
			be.flush();
		}

		public void err(String s) throws IOException
		{
			be.write(s);
		}
	}

	static FastIO f;

	public static void main(String args[]) throws IOException
	{
		f = new FastIO();

		int n = f.ni(), k = f.ni(), a[] = f.nia(n), l, i;
		HashSet<Integer> h = new HashSet<>();

		for(i = 0; i < n; i++)
		{
			h.add(a[i]);
			if(h.size() == k)
				break;
		}

		for(l = i, h.clear(); l >= 0 && l < n; l--)
		{
			h.add(a[l]);
			if(h.size() == k)
				break;
		}

		if(i == n)
			f.out(""-1 -1\n"");
		else
			f.out((l+1) + "" "" + (i+1) + ""\n"");

		f.flush();
	}
}",3,0224_B,CODEFORCES,1638,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class C138B
{

    private static StringTokenizer st;
    
    public static void nextLine(BufferedReader br) throws IOException
    {
        st = new StringTokenizer(br.readLine());
    }
    
    public static int nextInt()
    {
        return Integer.parseInt(st.nextToken());
    }
    
    public static String next()
    {
        return st.nextToken();
    }
    
    public static long nextLong()
    {
        return Long.parseLong(st.nextToken());
    }
    /**
     * @param args
     */
    public static void main(String[] args) throws IOException
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        nextLine(br);
        int n = nextInt();
        int k = nextInt();
        int[] a = new int[n];
        nextLine(br);
        for (int i = 0; i < n; i++) a[i] = nextInt();
        
        int bp = 0, fp = 0, count = 0;
        boolean good = false;
        int[] mark = new int[100001];
        for (fp = 0; fp < n; fp++)
        {
            if (mark[a[fp]] == 0)
            {
                count++;
            }
            mark[a[fp]]++;
            if (count == k)
            {
                good = true;
                break;
            }
        }
        if (!good)
        {
            System.out.println(""-1 -1"");
            return;
        }
        for (bp = 0; bp < fp; bp++)
        {
            if (mark[a[bp]] > 1)
            {
                mark[a[bp]]--;
            }
            else break;
        }
        System.out.println((bp+1) + "" "" + (fp+1));
    }
    
}
",3,0224_B,CODEFORCES,1676,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;

public class Array implements Runnable {

    void solve() throws IOException {
        int n = readInt();
        int k = readInt();
        int a[] = new int[n];
        int startIdx = 0;
        int endIdx = -1;
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i = 0; i < n; i ++) {
            a[i] = readInt();
            if(map.containsKey(a[i]))
                map.put(a[i], map.get(a[i]) + 1);
            else
                map.put(a[i], 1);
            if(map.size() == k && endIdx == -1) {
                endIdx = i;
                break;
            }
        }

        if(endIdx != -1) {
            while(startIdx < n && map.get(a[startIdx])>1) {
                map.put(a[startIdx], map.get(a[startIdx]) - 1);
                startIdx ++;
            }
            startIdx ++;
            endIdx   ++;
        } else
            startIdx = -1;

        out.println((startIdx)+"" ""+(endIdx));


    }



    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");

    public static void main(String[] args) {
        new Array().run();
    }

    public void run() {
        try {
            long t1 = System.currentTimeMillis();
            if (System.getProperty(""ONLINE_JUDGE"") != null) {
                in = new BufferedReader(new InputStreamReader(System.in));
                out = new PrintWriter(System.out);
            } else {
                in = new BufferedReader(new FileReader(""/Users/shenchen/input.txt""));
                out = new PrintWriter(""/Users/shenchen/output.txt"");
            }
            Locale.setDefault(Locale.US);
            solve();
            in.close();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time = "" + (t2 - t1));
        } catch (Throwable t) {
            t.printStackTrace(System.err);
            System.exit(-1);
        }
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }


}",3,0224_B,CODEFORCES,1689,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
import java.math.*;

public class Main {
    static final long MOD = 1000000007L;
    
    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int k = scan.nextInt();
        int res = -1;
        int[] arr = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scan.nextInt();
        }
        BitSet bits = new BitSet();
        int count = 0;
        int end = -1;
        for (int i = 0; i < arr.length; i++) {
            if (!bits.get(arr[i])) {
                bits.set(arr[i]);
                count++;
                if (count == k) {
                    end = i;
                    break;
                }
            }
        }
        if (end == -1) {
            System.out.print(""-1 -1"");
            return;
        }
        bits = new BitSet();
        count = 0;
        int start = end;
        while (start >= 0) {
            if (!bits.get(arr[start])) {
                bits.set(arr[start]);
                count++;
                if (count == k) {
                    break;
                }
            }
            start--;
        }
        System.out.println((start + 1) + "" "" + (end + 1));
    }
}",3,0224_B,CODEFORCES,1660,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"        import java.io.*;
        import java.math.BigInteger;
        import java.util.*;
        
        public class Main {
         
            static final double eps = 1e-8;
            
            public static void main(String[] args) throws IOException {
                try {
                    
                       int n = nextInt();
                       int k = nextInt();
                       int[] a = new int[n];
                       int[] d = new int[n];
                       int[] dr = new int[n];
                       boolean used[] = new boolean[100001];
                       a[0] = nextInt();
                       used[ a[0] ] = true;
                       d[0] = 1;
                       for(int i = 1; i < n; i++)
                       {
                           a[i] = nextInt();
                           if(!used[ a[i] ])
                           {
                               used[ a[i] ] = true;
                               d[i] = d[i - 1] + 1;
                           }
                           else
                           {
                               d[i] = d[i - 1];
                           }
                       }
                       Arrays.fill(used, false);

                       
                       int r = Arrays.binarySearch(d, k);
                       
                       if(r < 0)
                       {
                           pw.println(""-1 -1"");
                           return;
                       }
        
                       while( r > 0 && d[r] == d[r - 1] )
                           r--;
                       
                       used[ a[r] ] = true;
                       dr[r] = 1;
                       for(int i = r - 1; i >= 0; i--)
                       {
                           if(!used[ a[i] ])
                           {
                               used[ a[i] ] = true;
                               dr[i] = dr[i + 1] + 1;
                           }
                           else
                           {
                               dr[i] = dr[i + 1];
                           }
                       }
        
                       
                       
                       int l = 0;
        
                       while(l < n - 1 && dr[l] == dr[l + 1] && r - l >= k)
                           l++;
                       
                       
                       pw.println(l + 1 + "" "" + (r + 1));
                }
                finally {
                    pw.close();
                }
            }
        
        
            static Scanner sc = new Scanner(System.in);
            static PrintWriter pw = new PrintWriter(System.out);
            static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
            static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
            static StringTokenizer st ;
            static int nextInt() throws IOException {
                in.nextToken();
                return (int) in.nval;
            }
            static long nextLong() throws IOException {
                in.nextToken();
                return (long) in.nval;
            }
            static double nextDouble() throws IOException {
                in.nextToken();
                return in.nval;
            }
            static String next() throws IOException {
                in.nextToken();
                return in.sval;
            }
            static void outArray(int[] O) {
                for(int i = 0; i < O.length - 1; i++)
                    pw.print(O[i] + "" "");
                pw.println(O[O.length - 1]);
            }
        }",3,0224_B,CODEFORCES,1656,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

public class B {
	static Vector<Integer> primes;

	public static void main(String[] args) throws IOException {
		InputReader myScanner = new InputReader();
		int n = myScanner.nextInt(), k = myScanner.nextInt();
		myScanner.hasNext();
		int all[] = new int[n];
		boolean numbers[] = new boolean[100100];
		int diff[] = new int[n];
		all[0] = myScanner.nextInt();
		diff[0] = 1;
		numbers[all[0]] = true;
		int r = -1;
		if (k == 1)
			r = 1;
		for (int i = 1; i < all.length; i++) {
			all[i] = myScanner.nextInt();
			diff[i] = diff[i - 1];
			if (!numbers[all[i]]) {
				if (r == -1 && diff[i] + 1 == k)
					r = i + 1;
				numbers[all[i]] = true;
				diff[i]++;
			}
		}
		if (r == -1)
			System.out.println(-1 + "" "" + -1);
		else {
			numbers = new boolean[100010];
			int l = 0, cnt = 1;
			numbers[all[r - 1]] = true;
			if (k == 1)
				System.out.println(1 + "" "" + 1);
			else {
				for (int i = r - 2; i >= 0; i--) {
					if (!numbers[all[i]]) {
						numbers[all[i]] = true;
						cnt++;
					}
					if (cnt == k) {
						l = i + 1;
						break;
					}
				}

				System.out.println(l + "" "" + r);
			}
		}
	}

	static class InputReader {
		BufferedReader buff;
		StringTokenizer tok;
		String cur;

		public InputReader() throws IOException {
			buff = new BufferedReader(new InputStreamReader(System.in));
			tok = new StringTokenizer(cur = buff.readLine());
		}

		public boolean hasNext() throws IOException {
			if (!tok.hasMoreElements()) {
				cur = buff.readLine();
				if (cur == null)
					return false;
				tok = new StringTokenizer(cur);
			}
			return true;
		}

		public String next() throws IOException {
			while (!tok.hasMoreElements())
				tok = new StringTokenizer(cur = buff.readLine());

			return tok.nextToken();
		}

		public int nextInt() throws NumberFormatException, IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws NumberFormatException, IOException {
			while (!tok.hasMoreElements())
				tok = new StringTokenizer(cur = buff.readLine());

			return Long.parseLong(next());
		}
	}

}
",3,0224_B,CODEFORCES,1681,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author George Marcus
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		StreamInputReader in = new StreamInputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
	public void solve(int testNumber, StreamInputReader in, PrintWriter out) {
        int N = in.readInt();
        int K = in.readInt();
        int[] A = new int[N];
        for(int i = 0; i < N; i++)
            A[i] = in.readInt();

        int num = 0;
        int left = 0;
        int right = 0;
        int[] seen = new int[100005];
        while(right < N && num < K) {
            if(seen[A[right]] == 0)
                num++;
            seen[A[right]]++;
            right++;
        }
        right--;

        if(num == K) {
            while(seen[A[left]] > 1) {
                seen[A[left]]--;
                left++;
            }

            out.print((left + 1) + "" "" + (right + 1));
            return;
        }
        out.print(""-1 -1"");
	}
}

class StreamInputReader extends InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar, numChars;

    public StreamInputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    }

abstract class InputReader {

    public abstract int read();

    public int readInt() {
        return Integer.parseInt(readString());
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuffer res = new StringBuffer();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    private boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    }

",3,0224_B,CODEFORCES,1671,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;



public class Main{

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Parser p = new Parser(System.in);
		PrintWriter pw= new PrintWriter(System.out);

		int n = p.nextInt();
		int k = p.nextInt();

		int[] a = p.nextIntArray(n);
		int [] pos = new int[100001];
		Arrays.fill(pos,-1);
		int cnt = 0;
		for(int i=0; i<n; ++i){
			int e = a[i];
			if( pos[e] == -1 ){
				++cnt;
			}
			pos[e] = i;
			if( cnt == k){
				break;
			}
		}
		if( cnt < k){
			pw.println(""-1 -1"");
			pw.close();
			return;
		}
		int min = 1000000;
		int max = -1;
		for(int i=0; i<100001; ++i){
			if(pos[i] != -1 && pos[i] < min ){
				min = pos[i];
			}
			if( pos[i] > max){
				max = pos[i];
			}
		}
		++min;
		++max;

		pw.println(min+"" ""+max);
		pw.close();
	}
	
	





	static class Parser{
		
		StringTokenizer st;
		BufferedReader br;

		public Parser(InputStream is){
			this.br = new BufferedReader( new InputStreamReader(is));
			
		}
		
		public int nextInt(){
			return Integer.parseInt(nextToken());
		}
		
		public double nextDouble(){
			return Double.parseDouble(nextToken());
		}
		
		public String nextString(){
			return nextToken();
		}
		
		public int[] nextIntArray(int s){
			int[] a = new int[s];
			for(int i=0; i<s; ++i){
				a[i] = nextInt();
			}
			return a;
		}
		
		public int[][] nextIntTable(int r, int c){
			int[][] a = new int[r][c];
			for(int i=0; i<r; ++i){
				a[i] = nextIntArray(c);
			}
			return a;
		}
	
		private String nextToken() {
			if( st == null || ! st.hasMoreTokens() ){
				try{
					st = new StringTokenizer( br.readLine());
				}catch( Exception e){
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
		
	}
}



",3,0224_B,CODEFORCES,1667,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class B {
    public static void main(String[] args) throws IOException {
        InputReader in = new InputReader();
        int n = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = in.nextInt();
        if (k > n) {
            System.out.println(-1 + "" "" + -1);
            return;
        }
        int[] v = new int[100010];
        int cnt = 0;
        for (int i = 0; i < k; i++) {
            if (v[a[i]] == 0) {
                cnt++;
            }
            v[a[i]]++;

        }
        int i = k;
        while (cnt < k && i < n) {
            if (v[a[i]] == 0) {
                cnt++;
            }
            v[a[i]]++;
            i++;
        }
        if (cnt != k) {
            System.out.println(-1 + "" "" + -1);
        } else {
            int st = 0;
            while (st < n && st < i && v[a[st]] > 1) {
                v[a[st]]--;
                st++;
            }
            System.out.println((st+1) + "" "" + (i));
        }
    }

    static class InputReader {
        BufferedReader in;
        StringTokenizer st;

        public InputReader() throws IOException {
            in = new BufferedReader(new InputStreamReader(System.in));
            st = new StringTokenizer(in.readLine());
        }

        public String next() throws IOException {
            while (!st.hasMoreElements())
                st = new StringTokenizer(in.readLine());
            return st.nextToken();
        }

        public int nextInt() throws NumberFormatException, IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws NumberFormatException, IOException {
            return Long.parseLong(next());
        }
    }

}",3,0224_B,CODEFORCES,1677,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class Main {
	boolean eof;

	public String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return ""-1"";
			}
		}
		return st.nextToken();
	}

	public int nextInt() {
		return Integer.parseInt(nextToken());
	}

	int NOD(int a, int b) {
		while (a * b > 0) {
			if (a > b) {
				a %= b;
			} else {
				b %= a;
			}
		}
		return a + b;
	}

	void solve() {
		int n = nextInt(), k= nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; ++i){
			a[i] = nextInt() - 1;
		}
		int[] b = new int[100000];
		int p = 0;
		for (int i = 0; i < n; ++i){
			++b[a[i]];
			if (b[a[i]] == 1){
				++p;
			}
			if (k == p){
				int j;
				for (j = 0; j <= i; ++j){
					if (b[a[j]] > 1){
						--b[a[j]];
					} else {
						break;
					}
				}
				out.print((j + 1) + "" "" + (i + 1));
				return;
			}
		}
		out.print(""-1 -1"");
	}

	BufferedReader br;
	StringTokenizer st;
	PrintWriter out;

	void run() {
		try {
			br = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(new OutputStreamWriter(System.out));

			// br = new BufferedReader(new FileReader(""input.txt""));
			// out = new PrintWriter(new FileWriter(""output.txt""));
			solve();
			br.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}
}
",3,0224_B,CODEFORCES,1661,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
public class B138 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a[] = new int[100004];
        int b[] = new int[100004];
        int n, m, ans = 0, dau, cuoi=-1;
        n = sc.nextInt();
        m = sc.nextInt();
        for(int i=0;i<100004;i++) a[i] = 0;
        for(int i=0;i<n;i++){
            b[i] = sc.nextInt();
            if(a[b[i]]==0){
                a[b[i]] = 1;
                ans++;
                if(ans==m){
                    cuoi = i+1;
                    break;
                }
            }
        }
        for(int i=cuoi-1;i>=00;i--){
            if(a[b[i]]==1){
                a[b[i]] = 0;
                ans--;
                if(ans==0){
                    System.out.println((i+1)+"" ""+cuoi);
                    System.exit(0);
                }
            }
        }
        System.out.println(""-1 -1"");
    }

}
",3,0224_B,CODEFORCES,1655,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;


public class B {
	
	// -- DEBUG switch --
	static final boolean DBG = false;
	static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
	static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

	static int[] e = new int[100001];
	
	public static void main(String[] args) throws IOException {
		int n = i(), k = i(), cnt = 0;
		int[] a = new int[n+1];
		for (int i=1; i<=n; i++){
			a[i] = i();
			if (e[a[i]] == 0)
				cnt++;
			e[a[i]]++;
		}
		if (k > cnt){
			pw.println(""-1 -1"");
			pw.close();
			return;
		}
		if (cnt == n){
			pw.print(""1 "" + k);
			pw.close();
			return;
		}
		if (k == 1){
			pw.println(""1 1"");
			pw.close();
			return;
		}
		Arrays.fill(e, 0);
		int i = 1, j = 0, unik = 0, start = 0, end = 0, len = n, m = 0;


		if (e[a[i]] == 0){
			unik++;
		}
		e[a[i]]++;
		while (i+1<=n && a[i+1] == a[i]){
			i = i+1;
		}		
		
		j = i+1;
		
		while (j <= n){
			if (e[a[j]] == 0){
				unik++;
				if (unik == k){
					while (e[a[i]] > 1){
						e[a[i]]--;
						i++;
						while (i+1<=n && a[i+1] == a[i]){
							i = i+1;
						}	
					}
					m = j - i + 1;
					if (m < len){
						start = i; end = j; len = m;
						if (m == k)
							break;
					}
					
					while (i <=n && unik == k){
						e[a[i]]--;
						if (e[a[i]] == 0)
							unik--;
						i++;
						
						while (i+1<=n && a[i+1] == a[i]){
							i = i+1;
						}					
					}

				}
			}
			e[a[j]]++;
			while (j+1<=n && a[j+1] == a[j]){
				j++;
			}			
			j++;

		}
		pw.println(start + "" "" + end);	
		pw.close();
	}
	
	static int i() throws IOException{
		st.nextToken();
		return (int)st.nval;
	}
	
	static long l() throws IOException {
		st.nextToken();
		return (long)st.nval;
	}

	static double d() throws IOException {
		st.nextToken();
		return st.nval;
	}
	static String s() throws IOException{
		st.nextToken();
		return st.sval;
	}
}
",3,0224_B,CODEFORCES,1640,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;
public class B {
	static int i(String s) { return Integer.parseInt(s); }
	public static void main(String[] args) throws Exception {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		String[] arr = in.readLine().split("" "");
		int n = i(arr[0]);
		int k = i(arr[1]);
		int[] A = new int[n];
		arr = in.readLine().split("" "");
		for(int i=0; i<n; i++)
			A[i] = i(arr[i]);
		
		int st = 0;
		int cnt = 0;
		int[] cnts = new int[100*100*10+1];
		for(int i=0; i<n; i++) {
			cnts[A[i]]++;
			if(cnts[A[i]] == 1) cnt++;
			else while(cnts[A[st]] > 1) {
				cnts[A[st]]--;
				st++;
			}
			if(cnt == k) {
				System.out.println((st+1)+"" ""+(i+1));
				return;
			}
		}
		System.out.println(-1+"" ""+-1);
	}
}
",3,0224_B,CODEFORCES,1645,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
import java.io.*;

public class Main{

	static int mod=(int)1e9+7;
	
	public static void main(String[] args) throws IOException {
		PrintWriter out=new PrintWriter(System.out);
		Reader in=new Reader(System.in);	
		int ts=1;
//		ts=in.nextInt();
		outer: while(ts-->0) {
			
			int n=in.nextInt();
			int k=in.nextInt();
			
			int a[]=in.readArray(n);
			Set<Integer> st=new HashSet<>();
			
			for(int i=0; i<n; ++i) {
				st.add(a[i]);
				if(st.size()==k) {
					Set<Integer> stmp=new HashSet<>();
					for(int j=i; j>=0; --j) {
						stmp.add(a[j]);
						if(stmp.size()==k) {
							out.println((j+1)+"" ""+(i+1));
							continue outer;
						}
					}
				}
			}
			out.println(""-1 -1"");
			
		}
		out.close();	
	}
	
	static void sort(int [] a) {
		List<Integer> l=new ArrayList<>();
		for(int i: a) l.add(i);
		Collections.sort(l);
		for(int i=0; i<a.length; i++) a[i]=l.get(i);
	}
	
	static class Reader{
		BufferedReader br;
		StringTokenizer to;
		Reader(InputStream stream){
			br=new BufferedReader(new InputStreamReader(stream));
			to=new StringTokenizer("""");
		}
		String next() {
			while(!to.hasMoreTokens()) {
				try {
					to=new StringTokenizer(br.readLine());	
				}catch(IOException e) {}
				
			}
			return to.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		
		int [] readArray(int n) {
			int a[]=new int[n];
			for(int i=0; i<n; i++) a[i]=nextInt();
			return a;
		}
	}	
	
}",3,0224_B,CODEFORCES,1639,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;

public class TaskB {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        
        int n = s.nextInt();
        int k = s.nextInt();
        int[] nums = new int[100000 + 10];
        
        int first = -1, last = -1;
        Set<Integer> dif = new TreeSet<Integer>();
        
        s.nextLine();
        for (int i = 0; i < n; i++) {
            nums[i] = s.nextInt();
            dif.add(nums[i]);
            if (dif.size() == k) {
                last = i;
                break;
            }
        }

        dif.clear();

        for (int i = last; i >= 0; i--) {
            dif.add(nums[i]);
            if (dif.size() == k) {
                first = i;
                break;
            }
        }
        
        if (last == -1)
            System.out.print(""-1 -1"");
        else
            System.out.print(Integer.toString(first + 1) + "" ""  + Integer.toString(last + 1));
    }
}
",3,0224_B,CODEFORCES,1683,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.HashSet;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Lokesh Khandelwal aka (codeKNIGHT | phantom11)
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n=in.nextInt(),k=in.nextInt();
        int a[]=new int[n];
        int i;
        for(i=0;i<n;i++)
            a[i]=in.nextInt();
        HashSet<Integer> hs=new HashSet<Integer>();
        boolean status=false;
        int index=-1;
        for(i=0;i<n;i++)
        {
            
            hs.add(a[i]);
            if(hs.size()==k)
            {
                index=i;
                status=true;
                break;
            }
        }
        if(!status)
        {
            out.println(-1+"" ""+ -1);
            return;
        }
        HashSet<Integer> hash=new HashSet<Integer>();
        for(i=index;i>=0;i--)
        {

            hash.add(a[i]);
            if(hash.size()==k)
            {
                break;
            }
        }
        out.println((i+1)+"" ""+(index+1));
    }
}

class InputReader
{
    BufferedReader in;
    StringTokenizer tokenizer=null;

    public InputReader(InputStream inputStream)
    {
        in=new BufferedReader(new InputStreamReader(inputStream));
    }
    public String next()
    {
        try{
            while (tokenizer==null||!tokenizer.hasMoreTokens())
            {
                tokenizer=new StringTokenizer(in.readLine());
            }
            return tokenizer.nextToken();
        }
        catch (IOException e)
        {
            return null;
        }
    }
    public int nextInt()
    {
        return Integer.parseInt(next());
    }

}

",3,0224_B,CODEFORCES,1658,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Sunits789
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n=in.nextInt();
        int k=in.nextInt();
        int arr[]=new int[n];
        in.getArray(arr);
        int ansl=-1;
        int ansr=n;
        int occ[]=new int[100100];
        boolean f[]=new boolean[n];
        Arrays.fill(occ,0);
        Arrays.fill(f,true);
        int pk=0;
        for (int l=0,r=0;r<n&&l<n;){
            int num=arr[r];
            if(f[r]){
                f[r]=false;
                occ[num]++;
                if(occ[num]==1){
                    pk++;
                }
            }
            //System.out.println(l+"" ""+r+"" ""+pk+"" ""+k);
            if(pk<k){
                r++;
            }
            else if (pk==k){
                if((r-l)<=(ansr-ansl)){
                    ansl=l+1;
                    ansr=r+1;
                }
                num=arr[l];
                occ[num]--;
                if(occ[num]==0){
                    pk--;
                }
                l++;
            }
            else {
                num=arr[l];
                occ[num]--;
                if(occ[num]==0){
                    pk--;
                }
                l++;
            }
        }
        if(ansl==-1){
            ansr=-1;
        }
        out.println(ansl+"" ""+ansr);
    }
}

class InputReader{
    private BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream){
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }
    public String next(){
        while (tokenizer == null||!tokenizer.hasMoreTokens()){
            try{
                tokenizer = new StringTokenizer(reader.readLine());
            }
            catch (IOException e){
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt(){
        return Integer.parseInt(next());
    }

    public void getArray(int arr[]){
        for(int i=0;i<arr.length;i++){
            arr[i]=nextInt();
        }
    }

    }

",3,0224_B,CODEFORCES,1669,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Scanner;
import java.util.TreeMap;

public class B {

    static Scanner in;

    static void put(TreeMap<Integer, Integer> m, int key) {
        if (m.containsKey(key)) {
            m.put(key, m.get(key) + 1);
        } else {
            m.put(key, 1);
        }
    }

    static void remove(TreeMap<Integer, Integer> m, int key) {
        if (!m.containsKey(key))
            return;
        m.put(key, m.get(key) - 1);
        if (m.get(key) == 0) {
            m.remove(key);
        }
    }

    public static void main(String[] args) {
        in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int i = 0;
        while (i + 1 < n && a[i + 1] == a[0]) {
            i++;
        }
        int left = i;
        TreeMap<Integer, Integer> used = new TreeMap<Integer, Integer>();
        for (; i < n; i++) {
            put(used, a[i]);
            if (used.size() == k) {
                while (used.get(a[left]) > 1) {
                    remove(used, a[left]);
                    left++;
                }
                System.out.println(left + 1 + "" "" + (i + 1));
                return;
            }
        }
        System.out.println(""-1 -1"");
    }

}
",3,0224_B,CODEFORCES,1673,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

public class B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int distinct = sc.nextInt();
        HashMap<Integer, Integer> set = new HashMap<Integer, Integer>();
        int[] ar = new int[n];
        for (int i = 0; i < n; i++) {
            ar[i] = sc.nextInt();
            if (set.containsKey(ar[i])) {
                set.put(ar[i], set.get(ar[i])+1);
            } else {
                set.put(ar[i], 1);
            }
            if (set.size() == distinct) {
                int st = 0;
                for (int j = 0; j < i; j++) {
                    st=j;
                    if (set.get(ar[j]) > 1) {
                        set.put(ar[j], set.get(ar[j]) - 1);
                    } else {
                        break;
                    }
                }
                System.out.println((st + 1) + "" "" + (i + 1));
                return;
            }
        }
        System.out.println(""-1 -1"");
    }
}
",3,0224_B,CODEFORCES,1646,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Arrays;
import java.util.Scanner;

public class B {

    void run(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), k = sc.nextInt();
        int[] a = new int[n+1];
        for(int i=1;i<=n;i++)a[i]=sc.nextInt();
        int[] c = new int[100001];
        int num = 0;
        int ri = -1, rj = -1;
        int s = 1, t = 0;
        while(t<n){
            t++;
            if(c[a[t]]==0){
                num++;
            }
            c[a[t]]++;
            for(;k<=num;s++){
                if(ri==-1 || rj-ri+1>t-s+1){
                    ri = s; rj = t;
                }
                c[a[s]]--;
                if(c[a[s]]==0){
                    num--;
                }
            }
        }
        System.out.println(ri+"" ""+rj);
    }
    
    void debug(Object...o){
        System.out.println(Arrays.deepToString(o));
    }
    
    public static void main(String[] args) {
        new B().run();
    }
}",3,0224_B,CODEFORCES,1668,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;

public class BT {

    static BufferedReader in = new BufferedReader(new InputStreamReader(
            System.in));
    static StringTokenizer str;
    static String SK;

    static String next() throws IOException {
        while ((str == null) || (!str.hasMoreTokens())) {
            SK = in.readLine();
            if (SK == null)
                return null;
            str = new StringTokenizer(SK);
        }
        return str.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static void main(String[] args) throws IOException {
        int n, k;
        n = nextInt();
        k = nextInt();
        HashSet<Integer> hs = new HashSet<Integer>();
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();

        int[] ar = new int[n];
        int ii = 0, jj = -1;
        for (int i = 0; i < n; i++) {
            ar[i] = nextInt();

            Integer iii = hm.get(ar[i]);
            if(iii!=null)
            hm.put(ar[i], ++iii); else hm.put(ar[i], 1);
            hs.add(ar[i]);
            if (hs.size() == k) {
                jj = i;
                break;
            }
        }
        if (jj == -1) {
            System.out.println(-1 + "" "" + (-1));
            System.exit(0);
        }
        for (int i = 0; i < ar.length; i++) {
            Integer iii = hm.get(ar[i]);
            if (iii != null && iii - 1 > 0) {
                hm.put(ar[i], --iii);
                ii++;
            } else {
                break;
            }
        }
        System.out.println((ii+1) + "" "" + (jj+1));

    }

}",3,0224_B,CODEFORCES,1680,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class  test{
	
	// ArrayList<Integer> lis = new ArrayList<Integer>();
	// ArrayList<String> lis = new ArrayList<String>();
	//
    //	static long sum=0;
	// int a,b,c;
	// 1000000007 (10^9+7)
	//static int mod = 1000000007;
    //static int dx[]={1,-1,0,0};
	//static int dy[]={0,0,1,-1};
    //static long H,L;
	
public  static void main(String[] args)   throws Exception, IOException{
   //String line=""""; throws Exception, IOException
   //(line=br.readLine())!=null
	//Scanner sc =new Scanner(System.in);
	Reader sc = new Reader(System.in);
  // while( ){
	   int  n=sc.nextInt(),m=sc.nextInt(),a[]=new int[n];
	   int b[]=new int[100000+1], r=n+1;
	for(int i=0;i<n;i++)a[i]=sc.nextInt(); 
		// db(a);
		int s=0,t=-1, sum=0;
		int as=0,at=0;
	for(;;){
		while(t<n-1 && sum<m){
			t++;
			if( b[ a[t] ]<1 ){sum++; }
			 b[a[t]]++;
	}
		db(s,t,sum);
		if( sum<m )break;
		as=s;at=t;
		r=min(r,t-s+1);
		if( b[ a[s] ]==1 ){sum--; }
	//	if(t==n-1)break;
		 b[a[s]]--;
		 s++;
	}
	
	if( n<r )System.out.println(""-1 -1"");
	else System.out.println(as+1+"" ""+(at+1));
}

static void db(Object... os){
    System.err.println(Arrays.deepToString(os));

}

}


/*
class P implements Comparable<P>{
//	implements Comparable<P>
    
	int x;
	boolean b;
	P(int x,boolean b){
		this.x=x;
		this.b=b;
	} 

	   public int compareTo(P y){
         
		  return  x-y.x;
		   
		   }	
	
}
//*/
class Reader
{
	private BufferedReader x;
	private StringTokenizer st;
	
	public Reader(InputStream in)
	{
		x = new BufferedReader(new InputStreamReader(in));
		st = null;
	}
	public String nextString() throws IOException
	{
		while( st==null || !st.hasMoreTokens() )
			st = new StringTokenizer(x.readLine());
		return st.nextToken();
	}
	public int nextInt() throws IOException
	{
		return Integer.parseInt(nextString());
	}
	public long nextLong() throws IOException
	{
		return Long.parseLong(nextString());
	}
	public double nextDouble() throws IOException
	{
		return Double.parseDouble(nextString());
	}
}
",3,0224_B,CODEFORCES,1687,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.HashMap;


public class B {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception {
//		System.setIn(new FileInputStream(""b.in""));
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		
		String[] parts = bf.readLine().trim().split(""[ ]+"");
		int N = Integer.parseInt(parts[0]);
		int K = Integer.parseInt(parts[1]);
		
		int[] nums = new int[N];
		int idx = 0;
		
		String line = bf.readLine();
		for(int i = 0; i < line.length(); i++) {
			char c = line.charAt(i);
			if(c == ' ') idx++;
			else {
				int d = c - '0';
				nums[idx] = 10 * nums[idx] + d;
			}
		}
		
		int from = -1, to = -1;
		HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();
		for(int i = 0; i < N; i++) {
			Integer q = count.get(nums[i]);
			
			if(q == null) count.put(nums[i], 1);
			else count.put(nums[i], q + 1);
			
			if(count.size() == K) {
				to = i;
				break;
			}
		}
		
		if(count.size() < K) {
			System.out.println(""-1 -1"");
			return;
		}
		
		for(from = 0; from <= to; from++) {
			Integer q = count.get(nums[from]);
			
			if(q == 1) count.remove(nums[from]);
			else count.put(nums[from], q - 1);
			
			if(count.size() < K) break;
		}
		
		System.out.println((from + 1) + "" "" + (to + 1));

	}

}
",3,0224_B,CODEFORCES,1679,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;


public class B {
	
	static class Scanner
	{
		BufferedReader rd;
		StringTokenizer tk;
		public Scanner() throws IOException
		{
			rd=new BufferedReader(new InputStreamReader(System.in));
			tk=new StringTokenizer(rd.readLine());
		}
		public String next() throws IOException
		{
			while(!tk.hasMoreTokens())
				tk=new StringTokenizer(rd.readLine());
			return tk.nextToken();
		}
		public int nextInt() throws NumberFormatException, IOException
		{
			return Integer.valueOf(this.next());
		}
	}
	
	static int N,K;
	static int[] array=new int[100010];
	
	public static void main(String args[]) throws IOException{
		Scanner sc=new Scanner();
		N=sc.nextInt();
		K=sc.nextInt();
		for(int i=0;i<N;i++)
			array[i]=sc.nextInt();
		TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();
		boolean flag=false;
		for(int i=0;i<N;i++){
			if (!map.containsKey(array[i])){
				map.put(array[i], i);
				if (map.size()==K){
					flag=true;
					break;
				}
			}
			else
				map.put(array[i], i);
		}
		if (!flag)
			System.out.println(""-1 -1"");
		else{
			Set<Integer> s=map.keySet();
			int l=Integer.MAX_VALUE;
			int r=Integer.MIN_VALUE;
			for(int k: s){
				int tmp=map.get(k);
				l=Math.min(l, tmp);
				r=Math.max(r, tmp);
			}
			System.out.println((l+1)+"" ""+(r+1));
		}
	}

}",3,0224_B,CODEFORCES,1664,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Tibor
 */
public class test{

//   static java.io.InputStreamReader converter = new java.io.InputStreamReader(System.in);
//    static java.io.BufferedReader in = new java.io.BufferedReader(converter);
//
//    public static String readLine() {
//        String s = """";
//        try {
//
//            s = in.readLine();
//        } catch (Exception e) {
//            System.out.println(""Error! Exception: "" + e);
//        }
//        return s;
//    }
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(
            new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(System.out);

//    static {
//        in.ordinaryChars('-', '-');
//        in.ordinaryChars('+', '+');
//        in.wordChars('-', '-');
//        in.wordChars('+', '+');
//    }
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException ex) {
            Logger.getLogger(test.class.getName()).log(Level.SEVERE, null, ex);
        }
        return (int) in.nval;
    }

    static String nextString() {
        try {
            in.nextToken();
        } catch (IOException ex) {
            Logger.getLogger(test.class.getName()).log(Level.SEVERE, null, ex);
        }
        return in.sval;
    }

    public static void main(String args[]) throws Exception {
        int n = nextInt();
        long k = nextInt();
        long a[] = new long[n + 1];
        Map<Long, Long> drb = new HashMap<Long, Long>();
        int elso = 1;
        long sk = 0;
        long sm = 0;
        long minjo = Long.MAX_VALUE;
        long minjoh = Long.MAX_VALUE;
        Vector<long[]> ret = new Vector<long[]>();
        for (int i = 1; i <= n; i++) {
            a[i] = nextInt();
            if (/*a[i - 1] <= a[i]*/true) {
                sm += a[i];
                if (drb.containsKey(a[i])) {
                    drb.put(a[i], drb.get(a[i]) + 1);
                } else {
                    drb.put(a[i], (long) 1);
                    sk++;
                }
                while (sk > k || drb.get(a[elso]) > 1) {
                    long s = drb.get(a[elso]);
                    if (s == 1) {
                        drb.remove(a[elso]);
                        sk--;
                    } else {
                        drb.put(a[elso], s - 1);
                    }
                    sm -= a[elso];
                    elso++;
                }
                if (sk == k) {
                    if (minjo > sm) {
                        minjo = sm;
                        ret.clear();
                        minjoh = i - elso;
                    }
                    if (minjo == sm) {
                        if (minjoh > i - elso) {
                            ret.clear();
                            minjoh = i - elso;
                        }
                        ret.add(new long[]{elso, i});
                    }
                }
            } else {
                elso = i;
                drb.clear();
                drb.put(a[i], (long) 1);
                sk = 1;
                sm = a[i];
                if (k == 1) {
                    if (minjo > sm) {
                        minjo = sm;
                        ret.clear();
                    }
                    if (minjo == sm) {
                        ret.add(new long[]{elso, i});
                    }
                }
            }
        }

        for (long[] r : ret) {
            System.out.print(r[0] + "" "");
            System.out.print(r[1] + "" "");
            break;
        }
        if (ret.size() == 0) {
            System.out.print(-1 + "" "");
            System.out.print(-1 + "" "");
        }
    }
}
",3,0224_B,CODEFORCES,1686,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
import java.io.*;
public class B {
	public void solve() throws IOException {
		int n = nextInt();
		int k = nextInt();
		int[] a = new int[n];
		for(int i = 0; i < n; i++){
			a[i] = nextInt();
		}
		int[] num = new int[n];
		Set<Integer> set = new HashSet<Integer>();
		int s = -1;
		int l = -1;
		for(int i = 0; i < n; i++){
			set.add(a[i]);
			num[i] = set.size();
			if( num[i] == k ){
				l = i+1;
				set = new HashSet<Integer>();
				for(int j = i; j >= 0; j--){
					set.add(a[j]);
					if( set.size() == k ){
						s = j+1;
						break;
					}
				}
				break;
			}
		}
		writer.println(s + "" "" + l);
 	}

	public static void main(String[] args) throws IOException {
		new B().run();
	}

	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;

	public void run() throws IOException {
		try {
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	public double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			tokenizer = new StringTokenizer(reader.readLine());
		}
		return tokenizer.nextToken();
	}

}
",3,0224_B,CODEFORCES,1648,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"

import java.io.DataInputStream;
import java.io.InputStream;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;

public class B {

    
    public static void main(String[] args) throws Exception {
        Parserdoubt2333 s = new Parserdoubt2333(System.in);
        
        int n = s.nextInt();
        int k = s.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < a.length; i++) {
            a[i] = s.nextInt();
            
        }
        
        TreeMap<Integer, Integer> tree = new TreeMap<Integer,Integer>();
        
        int left = 0;
        int right = 0;
        
        for (right = 0; right < a.length; right++) {
            if(tree.containsKey(a[right]))
                tree.put(a[right], tree.get(a[right]) + 1);
            else 
                tree.put(a[right],1);
            if(tree.size() == k)
                break;
        }
        
        if(tree.size() < k){
            System.out.println(""-1 -1"");
            return ;
        }
//      System.out.println(right);
        for (left = 0; left < a.length; left++) {
            int val = tree.get(a[left]);
            val--;
            if(val > 0)
                tree.put(a[left],val);
            if(val == 0)
                break;
            
        }
        left++;
        right++;
        System.out.println(left + "" ""+right);
    }

}



class Parserdoubt2333
{
   final private int BUFFER_SIZE = 1 << 18;
 
   private DataInputStream din;
   private byte[] buffer;
   private int bufferPointer, bytesRead;
 
   public Parserdoubt2333(InputStream in)
   {
      din = new DataInputStream(in);
      buffer = new byte[BUFFER_SIZE];
      bufferPointer = bytesRead = 0;
   }
   public String nextString() throws Exception
   {
       StringBuffer sb=new StringBuffer("""");
       byte c = read();
       while (c <= ' ') c = read();
       do
       {
           sb.append((char)c);
           c=read();
       }while(c>' ');
       return sb.toString();
   }
   public char nextChar() throws Exception
   {
       byte c=read();
       while(c<=' ') c= read();
       return (char)c;
   }
   public int nextInt() throws Exception
   {
      int ret = 0;
      byte c = read();
      while (c <= ' ') c = read();
      boolean neg = c == '-';
      if (neg) c = read();
      do
      {
          ret = ret * 10 + c - '0';
         c = read();
      } while (c > ' ');
      if (neg) return -ret;
      return ret;
   }
   public long nextLong() throws Exception
   {
      long ret = 0;
      byte c = read();
      while (c <= ' ') c = read();
      boolean neg = c == '-';
      if (neg) c = read();
      do
      {
          ret = ret * 10 + c - '0';
         c = read();
      } while (c > ' ');
      if (neg) return -ret;
      return ret;
   }
   private void fillBuffer() throws Exception
   {
      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
      if (bytesRead == -1) buffer[0] = -1;
   }
 
   private byte read() throws Exception
   {
      if (bufferPointer == bytesRead) fillBuffer();
      return buffer[bufferPointer++];
   }
} ",3,0224_B,CODEFORCES,1682,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;



public class Main {
	static class MyReader{
	    private BufferedReader reader = null;
	    private StringTokenizer tokenizer = null;
	    MyReader(Reader r) throws IOException{
	        reader = new BufferedReader(r);
	    }
	    public int nextInt() throws IOException {
	        return Integer.parseInt(nextToken());
	    }
	    public String nextToken() throws IOException {
	        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
	            tokenizer = new StringTokenizer(reader.readLine());
	        }
	        return tokenizer.nextToken();
	    }
	}
	public static void main(String []args) throws IOException{
		PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));
		MyReader reader = new MyReader(new InputStreamReader(System.in));
		int n = reader.nextInt();
		int k = reader.nextInt();
		int []a = new int[n];
		for (int i = 0; i < n; ++i)
			a[i] = reader.nextInt();
		int j = 0;
		HashMap<Integer,Integer> map = new HashMap<>();
		for (int i = 0; i < n; ++i){
			if (map.containsKey(a[i]))
				map.put(a[i], map.get(a[i])+1);
			else{
				map.put(a[i], 1);
				if (map.size()==k) { j = i+1; break; }
			}
		}
		if (map.size()<k){
			System.out.println(""-1 -1"");
			return;
		}
		for (int i = 0; i < n; ++i){
			if (map.get(a[i])==1){
				System.out.println(i+1 + "" "" + j);
				return;
			}
			map.put(a[i], map.get(a[i])-1);
		}
	}
	
}",3,0224_B,CODEFORCES,1663,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.Scanner;


public class BB {
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int k=sc.nextInt();
    int a[]=new int[n+1];
    boolean used[]=new boolean[100009];
    for (int i = 1; i <=n; i++) {
        a[i]=sc.nextInt();
    }
    int cnt=0;
    int id=0;
    for (int i = 1; i <=n; i++) {
        if(!used[a[i]]){
            cnt++;
        used[a[i]]=true;
        }
        if(cnt==k){
            id=i;
            break;
        }
    }
    boolean x[]=new boolean[100005];
    int y=0;
    int id1=0;
    if(id==0){
        System.out.println(-1+"" ""+-1);
            return;
    }
    for (int i =id; i >=1; i--) {
        if(!x[a[i]]){
            y++;
            x[a[i]]=true;
        }
        if(y==k){
            id1=i;
            break;
        }
    }
    System.out.println(id1+"" ""+id);
}
}
",3,0224_B,CODEFORCES,1678,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.util.*;
public class b {
public static void main(String[] args)
{
    Scanner input = new Scanner(System.in);
    int n = input.nextInt(), k = input.nextInt();
    int[] data = new int[n];
    for(int i = 0; i<n; i++)
        data[i] = input.nextInt();
    int[] freq = new int[100001];
    int count = 0;
    for(int i = 0; i<n; i++)
    {
        if(freq[data[i]] == 0)
            count++;
        freq[data[i]]++;
    }
    if(count<k)
        System.out.println(""-1 -1"");
    
    else
    {
        int start = 0;
        for(int i = 0; i<n; i++)
        {
            //System.out.println(i + "" "" + count + "" "" + freq[data[i]]);
            if(count > k)
            {
                freq[data[i]]--;
                if(freq[data[i]] == 0)
                    count--;
            }
            else
            {
                if(freq[data[i]] > 1)
                {
                    freq[data[i]]--;
                }
                else
                {
                    start = i;
                    break;
                }
            }
        }
        int end = n-1;
        for(int i = n-1; i>=0; i--)
        {
            if(freq[data[i]] == 1)
            {
                end = i;
                break;
            }
            else
                freq[data[i]]--;

        }
        start++;
        end++;
        if(start<= end)
        System.out.println(start + "" "" + end);
        else
            System.out.println(-1 + "" "" + -1);
    }
}
}
",3,0224_B,CODEFORCES,1685,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class A {

	BufferedReader in;
	StringTokenizer st;
	PrintWriter out;

	String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	int nextInt() throws Exception {
		return Integer.parseInt(next());
	}

	long nextLong() throws Exception {
		return Long.parseLong(next());
	}

	double nextDouble() throws Exception {
		return Double.parseDouble(next());
	}

	void solve() throws Exception {
		int n = nextInt(), k = nextInt(), s = nextInt();
		int a[] = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = -nextInt();
		
		Arrays.sort(a);
		for(int i=0;i<n;i++)
		{
			if (s>=k)
			{
				out.println(i);
				return;
			}
			
			s += -a[i];
			s--;
		}
		if (s<k)
			out.println(-1);
		else
			out.println(n);
	}

	void run() {
		try {
			Locale.setDefault(Locale.US);
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(new OutputStreamWriter(System.out));
			solve();
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public static void main(String[] args) {
		new A().run();
	}


}
",4,0257_A,CODEFORCES,2647,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {

    void run() throws IOException {
        int n = ni();
        int m = ni();
        int k = ni();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni() - 1;
        Arrays.sort(a);
        int ans = 0;
        if (m > k) {
            m -= k - 1;
            for (int i = n - 1; i >= 0; i--) {
                ans++;
                m -= a[i];          
                if (m < 2)
                    break;

            }
            if (m > 1)
                ans = -1;
        }
        pw.print(ans);
    }

    String next() throws IOException {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    int ni() throws IOException {
        return Integer.parseInt(next());
    }

    String nl() throws IOException {
        return br.readLine();
    }

    PrintWriter pw;
    BufferedReader br;
    StringTokenizer st;

    public static void main(String[] args) throws IOException {
        long timeout = System.currentTimeMillis();
        boolean CF = System.getProperty(""ONLINE_JUDGE"") != null;
        PrintWriter _pw = new PrintWriter(System.out);
        BufferedReader _br = new BufferedReader(CF ? new InputStreamReader(System.in) : new FileReader(new File(""in.txt"")));
        new A(_br, _pw).run();
        if (!CF) {
            _pw.println();
            _pw.println(System.currentTimeMillis() - timeout);
        }
        _br.close();
        _pw.close();
    }

    public A(BufferedReader _br, PrintWriter _pw) {
        br = _br;
        pw = _pw;
    }
}
",4,0257_A,CODEFORCES,2677,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import static java.lang.Math.*;

public class A {

	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
	BufferedReader in;
	PrintWriter out;
	StringTokenizer tok = new StringTokenizer("""");

	void solve() throws IOException {
		int n = readInt();
		int m = readInt();
		int k = readInt();
		int[] a = readArr(n);
		Arrays.sort(a);
		for(int i = 0; i <= n; i++){
			int curR = k;
			for(int j = n-1; j >= n-i; j--){
				curR += a[j];
			}
			curR -= i;
			if(curR >= m){
				out.println(i);
				return;
			}
		}
		out.println(-1);
	}

	void init() throws FileNotFoundException {
		if (ONLINE_JUDGE) {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
		} else {
			in = new BufferedReader(new FileReader(""input.txt""));
			out = new PrintWriter(""output.txt"");
		}
	}

	String readString() throws IOException {
		while (!tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	int readInt() throws IOException {
		return Integer.parseInt(readString());
	}

	long readLong() throws IOException {
		return Long.parseLong(readString());
	}

	double readDouble() throws IOException {
		return Double.parseDouble(readString());
	}

	int[] readArr(int n) throws IOException {
		int[] res = new int[n];
		for (int i = 0; i < n; i++) {
			res[i] = readInt();
		}
		return res;
	}

	long[] readArrL(int n) throws IOException {
		long[] res = new long[n];
		for (int i = 0; i < n; i++) {
			res[i] = readLong();
		}
		return res;
	}

	public static void main(String[] args) {
		new A().run();
	}

	public void run() {
		try {
			long t1 = System.currentTimeMillis();
			init();
			solve();
			out.close();
			long t2 = System.currentTimeMillis();
			System.err.println(""Time = "" + (t2 - t1));
		} catch (Exception e) {
			e.printStackTrace(System.err);
			System.exit(-1);
		}
	}
}",4,0257_A,CODEFORCES,2662,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"//package round159;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class A {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int n = ni(), m = ni(), K = ni();
		int[] a = na(n);
		a = radixSort(a);
		
		if(K >= m){
			out.println(0);
			return;
		}
		int p = 1;
		for(int i = n-1;i >= 0;i--){
			K += a[i]-1;
			if(K >= m){
				out.println(p);
				return;
			}
			p++;
		}
		out.println(-1);
	}
	
	public static int[] radixSort(int[] f)
	{
		int[] to = new int[f.length];
		{
			int[] b = new int[65537];
			for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
			for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
			for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
			int[] d = f; f = to;to = d;
		}
		{
			int[] b = new int[65537];
			for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
			for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
			for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
			int[] d = f; f = to;to = d;
		}
		return f;
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new A().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",4,0257_A,CODEFORCES,2653,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class round159A {
    static BufferedReader br = new BufferedReader(new InputStreamReader(
            System.in));
    static StringTokenizer st = new StringTokenizer("""");

    static int nextInt() throws Exception {
        return Integer.parseInt(next());
    }

    static String next() throws Exception {
        while (true) {
            if (st.hasMoreTokens()) {
                return st.nextToken();
            }
            String s = br.readLine();
            if (s == null) {
                return null;
            }
            st = new StringTokenizer(s);
        }
    }

    public static void main(String[] args) throws Exception {
        int n = nextInt();
        int m = nextInt();
        int k = nextInt();
        int[] supply = new int[n];
        for (int i = 0; i < n; ++i)
            supply[i] = nextInt();
        if (m <= k) {
            System.out.println(0);
        } else {
            int have = k;
            Arrays.sort(supply);
            for(int i = n - 1 ; i >= 0 ; --i){
                have--;
                have += supply[i];
                if(have >= m){
                    System.out.println(n - i);
                    return;
                }
            }
            System.out.println(-1);
        }
    }
}
",4,0257_A,CODEFORCES,2673,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
import java.util.Arrays;
import java.util.Scanner;

public class A {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int[] A = new int[n];
        for (int i = 0; i < n; i++)
            A[i] = in.nextInt();
        Arrays.sort(A);
        int cnt = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (k >= m) {
                System.out.println(cnt);
                return;
            }
            cnt++;
            k += A[i] - 1;
        }
        if (k >= m)
            System.out.println(cnt);
        else
            System.out.println(-1);
    }
}
",4,0257_A,CODEFORCES,2686,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;


public class A {
    
    static StringTokenizer st;
    static BufferedReader in;
    public static void main(String[] args) throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int n = nextInt();
        int m = nextInt();
        int k = nextInt();
        int[]a = new int[n+1];
        for (int i = 1; i <= n; i++) {
            a[i] = nextInt();
        }
        if (k >= m) {
            System.out.println(0);
            return;
        }
        Arrays.sort(a, 1, n+1);
        int ans = 0;
        for (int i = n; i >= 1; i--) {
            ans++;
            k--;
            k += a[i];
            if (k >= m) {
                System.out.println(ans);
                return;
            }
        }
        System.out.println(-1);
        pw.close();
    }
    private static int nextInt() throws IOException{
        return Integer.parseInt(next());
    }
    
    private static long nextLong() throws IOException{
        return Long.parseLong(next());
    }
    
    private static double nextDouble() throws IOException{
        return Double.parseDouble(next());
    }
    
    private static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }
}
",4,0257_A,CODEFORCES,2643,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import static java.util.Arrays.*;
import static java.util.Collections.*;

import java.io.*;
import java.lang.reflect.*;

public class A {

	final int MOD = (int)1e9 + 7;
	final double eps = 1e-12;
	final int INF = (int)1e9;
	
	public A () {
		int N = sc.nextInt();
		int M = sc.nextInt();
		int K = sc.nextInt();
		
		Integer [] S = sc.nextInts();
		sort(S, reverseOrder()); 
		
		int cnt = K, res;
		for (res = 0; res < N && cnt < M; ++res)
			cnt += S[res] - 1;
		
		exit(cnt < M ? -1 : res);
	}

	////////////////////////////////////////////////////////////////////////////////////
	
	static MyScanner sc;
	
	static class MyScanner {
		public String next() {
			newLine();
			return line[index++];
		}
		
		public char nextChar() {
			return next().charAt(0);
		}
				
		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
			return Long.parseLong(next());
		}
		
		public double nextDouble() {
			return Double.parseDouble(next());
		}
		
		public String nextLine() {
			line = null;
			return readLine();
		}
		
		public String [] nextStrings() {
			line = null;
			return readLine().split("" "");
		}
		
		public char [] nextChars() {
			return next().toCharArray();
		}

		public Integer [] nextInts() {
			String [] L = nextStrings();
			Integer [] res = new Integer [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Integer.parseInt(L[i]);
			return res;
		}	
		
		public Long [] nextLongs() {
			String [] L = nextStrings();
			Long [] res = new Long [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Long.parseLong(L[i]);
			return res;
		}

		public Double [] nextDoubles() {
			String [] L = nextStrings();
			Double [] res = new Double [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Double.parseDouble(L[i]);
			return res;
		}

		//////////////////////////////////////////////
		
		private boolean eol() {
			return index == line.length;
		}

		private String readLine() {
			try {
				return r.readLine();
			} catch (Exception e) {
				throw new Error(e);
			}
		}
		private final BufferedReader r;

		MyScanner () {
			this(new BufferedReader(new InputStreamReader(System.in)));
		}
		
		MyScanner(BufferedReader r) {
			try {
				this.r = r;
				while (!r.ready())
					Thread.sleep(1);
				start();
			} catch (Exception e) {
				throw new Error(e);
			}
		}
		
		private String [] line;
		private int index;

		private void newLine() {
			if (line == null || eol()) {
				line = readLine().split("" "");
				index = 0;
			}
		}		
	}
	
	static void print (Object o, Object... a) {
		pw.println(build(o, a));
	}

	static void exit (Object o, Object... a) {
		print(o, a);
		exit();
	}

	static void exit () {
		pw.close();
		System.out.flush();
		System.err.println(""------------------"");
		System.err.println(""Time: "" + ((millis() - t) / 1000.0));
		System.exit(0);
	}
	
	void NO() {
		throw new Error(""NO!"");
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	static String build(Object... a) {
		StringBuilder b = new StringBuilder();
		for (Object o : a)
			append(b, o);
		return b.toString().trim();		
	}
	
	static void append(StringBuilder b, Object o) {
		if (o.getClass().isArray()) {
			int L = Array.getLength(o);
			for (int i = 0; i < L; ++i)
				append(b, Array.get(o, i));
		} else if (o instanceof Iterable<?>) {
			for (Object p : (Iterable<?>)o)
				append(b, p);
		} else
			b.append("" "").append(o);		
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	public static void main(String[] args) {
		sc = new MyScanner ();
		new A();
		exit();
	}

	static void start() {
		t = millis();
	}

	static PrintWriter pw = new PrintWriter(System.out);
	
	static long t;
	
	static long millis() {
		return System.currentTimeMillis();
	}	
}
",4,0257_A,CODEFORCES,2664,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;


public class CodeforcesRound159 {

    /**
     * @param args
     */
    public static void main(String[] args) 
    {
	Scanner kde = new Scanner(System.in);
	int n =kde.nextInt();  //���������� ������� ��������
	int m =kde.nextInt();  //���������� ���������
	int k =kde.nextInt(); //���������� �������
	ArrayList<Integer> count = new ArrayList<Integer>();
	for (int i=0; i<n; i++  )
	{
	    count.add(kde.nextInt()) ; 
	}
	
	Collections.sort(count);
	Collections.reverse(count);
	if(m<=k)
	{
	    System.out.println(""0""); 
	    return;
	}
	
	m=m-k+1;
	
	
	
	
	   int  res=0;
	for(int i=0; i<n; i++ ) 
	{
	    if(i!=0)
	    {
	    res+=count.get(i)-1;
	    }
	    else 
	    {
	    res+=count.get(i);
	    }
	  
	    if(res>=m)
	    {
		   System.out.println(i+1);
		   return;
	    }
	    
	}
	
	    
	
	  
	
	
	System.out.println(""-1"");
	

    }

}
",4,0257_A,CODEFORCES,2685,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.PrintStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author coderbd
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int m, n, k;
        n = in.readInt();
        m = in.readInt();
        k = in.readInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = in.readInt() - 1;
        Arrays.sort(a);
        int ans = -1;
        if (k >= m)
            ans = 0;
        else for (int i = 0; i < n; i++) {
            k += a[n-i-1];
            if (k >= m) {
                ans = i + 1;
                break;
            }
        }
        System.out.println(ans);
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            }
            catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            }
            catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0L;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuffer res = new StringBuffer();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public static boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuffer buf = new StringBuffer();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        }
        catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m *= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(Object...objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void printLine(Object...objects) {
        print(objects);
        writer.println();
    }

    public void printLine(char[] array) {
        writer.print(array);
    }

    public void printFormat(String format, Object...objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }
}

",4,0257_A,CODEFORCES,2649,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class CFTest6 {

	static BufferedReader br;

	public static void main(String[] args) {
		br = new BufferedReader(new InputStreamReader(System.in));

		try {

			int[] a1 = readIntArr();
			int[] a2 = readIntArr();
			br.close();
			int f = a1[0];
			int d = a1[1];
			int s = a1[2];
			Arrays.sort(a2);

			if (d <= s)
				System.out.println(0);

			else {
				int cur = d - s + 1;

				
				int num=0;
				for(int i=0;i<f;i++){
					num++;
					cur-=a2[f-i-1];
					if(cur<=0)break;
					cur++;
				}
				if (cur > 0)
					System.out.println(-1);
				else{
					
				
					System.out.println(num);
				}
			}

		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	static public String readLine() throws IOException {
		return br.readLine();

	}

	static public String readString() throws IOException {
		return br.readLine();

	}

	static public long readlong() throws IOException {
		return Long.parseLong(br.readLine());
	}

	static public int readInt() throws IOException {
		return Integer.parseInt(br.readLine());
	}

	static public int[] readIntArr() throws IOException {
		String[] str = br.readLine().split("" "");
		int arr[] = new int[str.length];
		for (int i = 0; i < arr.length; i++)
			arr[i] = Integer.parseInt(str[i]);
		return arr;
	}

	static public double[] readDoubleArr() throws IOException {
		String[] str = br.readLine().split("" "");
		double arr[] = new double[str.length];
		for (int i = 0; i < arr.length; i++)
			arr[i] = Double.parseDouble(str[i]);
		return arr;
	}

	static public long[] readLongArr() throws IOException {
		String[] str = br.readLine().split("" "");
		long arr[] = new long[str.length];
		for (int i = 0; i < arr.length; i++)
			arr[i] = Long.parseLong(str[i]);
		return arr;
	}

	static public double readDouble() throws IOException {
		return Double.parseDouble(br.readLine());
	}
}
",4,0257_A,CODEFORCES,2658,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Scanner;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
	public void solve(int testNumber, Scanner in, PrintWriter out) {
		int n = in.nextInt();
		int m = in.nextInt();
		int k = in.nextInt();
		int[] fs = IOUtils.readIntArray(in, n);
		Arrays.sort(fs);
		int ptr = fs.length - 1;
		int res = 0;
		while (ptr >= 0 && k < m) {
			k += fs[ptr--] - 1;
			res++;
		}
		if (k < m) out.println(-1);
		else out.println(res);
	}
}

class IOUtils {
    public static int[] readIntArray(Scanner in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.nextInt();
        return array;
    }

    }

",4,0257_A,CODEFORCES,2669,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.awt.Point;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;



import static java.lang.Math.*;

public class Start {

    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");

    void init() throws FileNotFoundException {
        if (ONLINE_JUDGE) {
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        } else {
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }

    public static void main(String[] args) {
        new Start().run();
        // Sworn to fight and die
    }

    public static void mergeSort(int[] a) {
        mergeSort(a, 0, a.length - 1);
    }

    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {
        final int MAGIC_VALUE = 50;
        if (levtIndex < rightIndex) {
            if (rightIndex - levtIndex <= MAGIC_VALUE) {
                insertionSort(a, levtIndex, rightIndex);
            } else {
                int middleIndex = (levtIndex + rightIndex) / 2;
                mergeSort(a, levtIndex, middleIndex);
                mergeSort(a, middleIndex + 1, rightIndex);
                merge(a, levtIndex, middleIndex, rightIndex);
            }
        }
    }

    private static void merge(int[] a, int levtIndex, int middleIndex,
            int rightIndex) {
        int length1 = middleIndex - levtIndex + 1;
        int length2 = rightIndex - middleIndex;
        int[] levtArray = new int[length1];
        int[] rightArray = new int[length2];
        System.arraycopy(a, levtIndex, levtArray, 0, length1);
        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {
            if (i == length1) {
                a[k] = rightArray[j++];
            } else if (j == length2) {
                a[k] = levtArray[i++];
            } else {
                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]
                        : rightArray[j++];
            }
        }
    }

    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {
        for (int i = levtIndex + 1; i <= rightIndex; i++) {
            int current = a[i];
            int j = i - 1;
            while (j >= levtIndex && a[j] > current) {
                a[j + 1] = a[j];
                j--;
            }
            a[j + 1] = current;
        }
    }

    public void run() {
        try {
            long t1 = System.currentTimeMillis();
            init();
            solve();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time = "" + (t2 - t1));
        } catch (Exception e) {
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }

    class LOL implements Comparable<LOL> {
        int x;
        int y;
        int num;

        public LOL(int x, int y,int num) {
            this.x = x;
            this.y = y;
            this.num = num;
        }

        @Override
        public int compareTo(LOL o) {
            return x - o.x; // ---->
            // return o.x - x; // <----
            // return o.y-y;
        }

    }
    
    
    
    public void solve() throws IOException {
    
        int n = readInt();
        int m = readInt();
        int k = readInt();
        
        int [] a = new int [n];
        for (int i = 0; i < n; i++){
            a[i] = readInt();
        }
        mergeSort(a);
        
        if (k>=m){
            out.print(0);
             return;
        }
        
        int ans = 0;
        k--;
        for (int i = n-1; i >=0; i--){
            ans += a[i];
            if (ans +  k >= m){
                out.print(n-i);
                return;
            }
            else {
                k--;
            }

        }
        out.print(-1);
        
        
    }
    
    
}

























",4,0257_A,CODEFORCES,2650,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;

public class Sockets {

    BufferedReader in;
    PrintWriter out;
    StringTokenizer st;
    
    String nextToken() throws Exception {
        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());
        return st.nextToken();
    }
    
    int nextInt() throws Exception {
        return Integer.parseInt(nextToken());
    }
    
    void solve() throws Exception {
        int n = nextInt();
        int m = nextInt();
        int k = nextInt();
        List<Integer> fs = new ArrayList<Integer>();
        for (int i = 0; i < n; i++)
            fs.add(nextInt());
        Collections.sort(fs);
        Collections.reverse(fs);
        int c = k;
        for (int i = 0; i < fs.size(); i++) {
            if (c >= m) {
                out.println(i);
                return;
            }
            c += (fs.get(i)-1);
        }
        if (c>=m)
            out.println(fs.size());
        else
            out.println(-1);
    }
    
    void run() {
        try {
            in = new BufferedReader(new InputStreamReader(System.in));
//            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(System.out);
            solve();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        } finally {
            out.close();
        }
    }
    
    public static void main(String[] args) {
        new Sockets().run();
    }

}

",4,0257_A,CODEFORCES,2644,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;

public class Main {
    
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = in.nextInt();
        Arrays.sort(a);
        int ans = 0, r = k, p = n-1;
        while (r < m && p >= 0) {
            r = r - 1 + a[p];
            p--;
            ans++;
        }
        if (r < m) out.println(""-1"");
        else out.println(ans);
        
        out.flush();
    }
    
}",4,0257_A,CODEFORCES,2651,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"//package A;

import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

public class Solution {
    public static void main(String args[]) throws IOException {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; ++i)
            a[i] = in.nextInt();
        Arrays.sort(a);
        
        int res = 0, p = n - 1;
        while (k < m && p >= 0) {
            ++res;
            k += a[p] - 1;
            --p;
        }
        if (k >= m)
            System.out.println(res);
        else
            System.out.println(""-1"");
    }
}
",4,0257_A,CODEFORCES,2654,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"//package codeforces.contests.cf159;

import java.io.*;
import java.util.Arrays;

public class ProblemA {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));

    int[] readInts() throws IOException {
        String[] strings = reader.readLine().split("" "");
        int[] ints = new int[strings.length];
        for(int i = 0; i < ints.length; i++) {
            ints[i] = Integer.parseInt(strings[i]);
        }
        return ints;
    }

    void solve() throws IOException {
        int[] tt = readInts();
        int n = tt[0];
        int m = tt[1];
        int k = tt[2];
        int[] a = readInts();
        Arrays.sort(a);
        for(int i = 0, j = a.length - 1; i < j; i++, j--) {
            int t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
        int ix = 0;
        while(k < m && ix < n) {
            k += a[ix++] - 1;
        }
        if(k < m) {
            writer.println(-1);
        }
        else {
            writer.println(ix);
        }
        writer.flush();
    }

    public static void main(String[] args) throws IOException {
        new ProblemA().solve();
    }
}
",4,0257_A,CODEFORCES,2663,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;


public class TaskA {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		new TaskA().solve(in, out);
		in.close();
		out.close();
	}
	
	private void solve(Scanner in, PrintWriter out) {
		int n = in.nextInt();
		int m = in.nextInt();
		int k = in.nextInt();
		int answer = 0;
		int counter = k;
		int[] a = new int[n];
		for (int i = 0; i < n; ++i)
			a[i] = in.nextInt();
		Arrays.sort(a);
		int[] b = Arrays.copyOf(a, a.length);
		for (int i = 0; i < n; ++i) 
			a[i] = b[n - i - 1];
		for (int i = 0; i < n; ++i) {
			if (counter < m) {
				counter += a[i] - 1;
				++answer;
			} else
				break;
		}
		if (counter < m)
			out.println(""-1"");
		else
			out.println(answer);
	}

}
",4,0257_A,CODEFORCES,2672,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author AndresFelipe
 */
public class A {
    
    public static void main(String Args[]) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        st = new StringTokenizer(br.readLine());
        int n=Integer.valueOf(st.nextToken());
        int m=Integer.valueOf(st.nextToken());
        int k=Integer.valueOf(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int sock[] = new int[n];
        
        for (int i=0;i<n;i++){
            sock[i]= Integer.valueOf(st.nextToken());
        }
        Arrays.sort(sock);
        m-=k;
        int count=0;
        int index=sock.length-1;
        while(m>0){
            if(index<0){
                System.out.println(""-1"");
                return;
            }
            m++;
            m-=sock[index];
            index--;
            count++;
        }
        System.out.println(count);
    }
    
}
",4,0257_A,CODEFORCES,2688,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;

public class File {
	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;
		
		public FastScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				}
				catch (IOException e) {
					e.printStackTrace();
				}
			}
			
			return st.nextToken();
		}
		
		int nextInt() {
			return Integer.parseInt(next());
		}
		
		long nextLong() {
			return Long.parseLong(next());
		}
	}
	
	public static void main(String[] args) {
		FastScanner sc = new FastScanner();
		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
		
		
		
		int n = sc.nextInt(); // Number of supply-line filters
		int m = sc.nextInt(); // Number of devices
		int k = sc.nextInt(); // Number of sockets available to plug to directly
		
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
		}
		
		// Need >= m free sockets to charge all devices.
		// Find minimum supply-line filters needed to do this.
		
		// Always best to use supply-line filter with more sockets in it.
		Arrays.sort(a);
		
		// Keep adding a filter until total sockets >= m
		int sockets = k;
		int filtersNeeded = 0;
		int index = n-1;
		
		while (sockets < m && index >= 0) {
		    // Each filter we add can increase number of sockets by a[i] - 1.
			sockets += (a[index] - 1);
			filtersNeeded++;
			index--;
		}
		
		if (sockets >= m) {
			out.println(filtersNeeded);
		}
		else {
			out.println(-1);
		}
		
		out.close();
	}
}






















",4,0257_A,CODEFORCES,2638,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"//package Round_159;

import java.util.*;
import java.io.*;

import static java.lang.Math.*;

public class a {

	void solve() throws Exception {
		int n = in.nextInt();
		int m = in.nextInt();
		int k = in.nextInt();
		int a[] = new int[n];
		for (int i = 0; i<n; i++){
			a[i] = in.nextInt();
		}
		Arrays.sort(a);
		int sum = 0;
		if (k >= m){
			out.println(0);
			return;
		}
		sum = a[n-1] + k - 1;
		int j = 1;
		for (int i = n-2; i >=0 && sum < m; i--, j++){
			sum += a[i] - 1;
		}
		if (sum < m){
			out.println(-1);
		}else{
			out.println(j);
		}
	}

	FastScanner in;
	PrintWriter out;

	String input = """";
	String output = """";

	void run() {
		try {
			if (input.length() > 0) {
				in = new FastScanner(new BufferedReader(new FileReader(input)));
			} else
				in = new FastScanner(new BufferedReader(new InputStreamReader(
						System.in)));
			if (output.length() > 0)
				out = new PrintWriter(new FileWriter(output));
			else
				out = new PrintWriter(System.out);

			solve();

			out.flush();
			out.close();
		} catch (Exception ex) {
			ex.printStackTrace();
			out.flush();
			out.close();
		} finally {
			out.close();
		}
	}

	public static void main(String[] args) {
		new a().run();
	}

	class FastScanner {
		BufferedReader bf;
		StringTokenizer st;

		public FastScanner(BufferedReader bf) {
			this.bf = bf;
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(bf.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public String nextLine() throws IOException {
			return bf.readLine();
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

	}

}
",4,0257_A,CODEFORCES,2648,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

public class Main2 {
	
    public static void main(String args[]){
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int m = input.nextInt();
        int k = input.nextInt();
        int[] num = new int[n];
        for(int i = 0 ; i < n ; i++){
        	num[i] = input.nextInt();
        }
        
        System.out.println(str(n,m,k,num));
    }

	static int str(int n,int m,int k,int[] num){
		Arrays.sort(num);
		int total = k;
		int count = 0;
		while(k < m){
			if(count == num.length)return -1;
			k += num[num.length-count-1]-1;
			count++;
		}
		return count;
	}
	
}",4,0257_A,CODEFORCES,2655,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class A {
	int n, m, k;
	int[] a;
	
	void run()throws IOException{
//		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		Scanner sc = new Scanner(new InputStreamReader(System.in));
		n = sc.nextInt();
		m = sc.nextInt();
		k = sc.nextInt();
		a = new int[n];
		for(int i=0;i<n; i++) a[i] = sc.nextInt();
		Arrays.sort(a);
		
		if(m<=k){
			System.out.println(0);
			return;
		}
		
		int cnt = k;
		int ind = a.length-1;
		int ret = 0;
		while(cnt<m && ind>=0){
			cnt += a[ind]-1;
			--ind;
			ret++;
			
		}
		
		if(cnt>=m) System.out.println(ret);
		else System.out.println(-1);
	}

	public static void main(String[] args)throws IOException {
		new A().run();
	}
}
",4,0257_A,CODEFORCES,2678,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] in = br.readLine().split("" "");
		
		int n=Integer.parseInt(in[0]),m=Integer.parseInt(in[1]),k=Integer.parseInt(in[2]);
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] caps = new int[n];
		for (int i = 0; i < caps.length; i++) {
			caps[i] = Integer.parseInt(st.nextToken());
		}
		Arrays.sort(caps);
		
		int curSockets=k, neededLines=0;
		int i = n-1;
		while(curSockets<m && i>=0){
			curSockets+=caps[i]-1;
			neededLines++;
			i--;
		}
		if(curSockets>=m)
			System.out.println(neededLines);
		else
			System.out.println(-1);
	}
}
",4,0257_A,CODEFORCES,2656,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class A
{
	String line;
	StringTokenizer inputParser;
	BufferedReader is;
	FileInputStream fstream;
	DataInputStream in;
	String FInput="""";
	
	void openInput(String file)
	{

		if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin
		else
		{
			try{
		
				
			fstream = new FileInputStream(file);
			in = new DataInputStream(fstream);
			is = new BufferedReader(new InputStreamReader(in));
			}catch(Exception e)
			{
				System.err.println(e);
			}
		}

	}
	
	void readNextLine()
	{
		try {
			line = is.readLine();
			inputParser = new StringTokenizer(line, "" "");
			//System.err.println(""Input: "" + line);
		} catch (IOException e) {
			System.err.println(""Unexpected IO ERROR: "" + e);
		}	
		catch (NullPointerException e)
		{
			line=null;
			
		}
		
	}
	
	int NextInt()
	{
		String n = inputParser.nextToken();
		int val = Integer.parseInt(n);
		
		//System.out.println(""I read this number: "" + val);
		return val;
	}
	
	long NextLong()
	{
		String n = inputParser.nextToken();
		long val = Long.parseLong(n);
		
		//System.out.println(""I read this number: "" + val);
		return val;
	}
	
	String NextString()
	{
		String n = inputParser.nextToken();
		return n;
	}
	
	void closeInput()
	{
		try {
			is.close();
		} catch (IOException e) {
			System.err.println(""Unexpected IO ERROR: "" + e);
		}
			
	}
	
	
	public static void main(String [] argv)
	{
		//String filePath=""input.txt"";
		//String filePath=""D:\\_d\\learn\\coursera\\algorithms and design II\\data\\knapsack2.txt"";
        String filePath=null;
		if(argv.length>0)filePath=argv[0];
		new A(filePath);
	}
	
	public void readFInput()
	{
		for(;;)
		{
			try
			{
				readNextLine();
				FInput+=line+"" "";
			}
			catch(Exception e)
			{
				break;
			}
		}
		inputParser = new StringTokenizer(FInput, "" "");
	}
	 
	public A(String inputFile)
	{
		openInput(inputFile);
		readNextLine();
		int N=NextInt(), M=NextInt(), K=NextInt();
		int [] v = new int[N];
		readNextLine();
		for(int i=0; i<N; i++)
		{
			
			v[i]=NextInt();
			
		}
		Arrays.sort(v);
		M-=(K-1);
		int id=N-1;
		int ret=0;
		while(M>1&&id>=0)
		{
			M++;
			M-=v[id--];
			ret++;
		}
		if(id<0&&M>1)ret=-1;
		System.out.println(ret);
		closeInput();			
	}
	

	public static void out(Object s)
	{
		try
		{
		    FileWriter fstream = new FileWriter(""output.txt"");
			BufferedWriter out = new BufferedWriter(fstream);
			out.write(s.toString());
			out.close();
		}catch (Exception e){
			System.err.println(""Error: "" + e.getMessage());
		}
	}
	

}
",4,0257_A,CODEFORCES,2642,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class A {

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		// BufferedReader rd = new BufferedReader(new
		// InputStreamReader(System.in));
		// StringTokenizer t = new StringTokenizer(rd.readLine(), "" "");
		int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();
		int pl[] = new int[n];
		if (k >= m) {
			System.out.println(0);
			System.exit(0);
		}
		m -= k;
		for (int i = 0; i < n; i++) {
			pl[i] = sc.nextInt() - 1;
		}
		Arrays.sort(pl);
		int out = 0;
		for (int i = n - 1; i >= 0; i--) {
			m -= pl[i];
			out++;
			if (m <= 0)
				break;
		}
		if (m <= 0)
			System.out.println(out);
		else
			System.out.println(-1);
	}

}
",4,0257_A,CODEFORCES,2683,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author BSRK Aditya (bsrkaditya@gmail.com)
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n = in.readInt();
        int m = in.readInt();
        int k = in.readInt();


        int [] filters = new int[n];
        for(int i = 0; i < n; ++i) filters[i] = in.readInt();

        Arrays.sort(filters);

        int nS = 0, tN = k;

        while(tN < m && nS < n) {
            tN += filters[n-1-nS] - 1;
            nS++;
        }

        if(tN >= m) out.printLine(nS);
        else out.printLine(-1);
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }


    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(Object...objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void printLine(Object...objects) {
        print(objects);
        writer.println();
    }

    public void close() {
        writer.close();
    }

}

",4,0257_A,CODEFORCES,2689,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;


public class Round159ProblemA {

	public static void main(String[] args) {
		Reader r = new Reader();
		int filters = r.nextInt();
		int devices = r.nextInt();
		int sockets = r.nextInt();
		
		List<Integer> filtery = new ArrayList<>();
		for (int i = 0; i < filters; i++) {
			filtery.add(r.nextInt()-1);
		}
		
		//System.out.println(filtery);
		
		if(devices <= sockets){
			System.out.println(0);
			return;
		}else{
			Collections.shuffle(filtery);
			Collections.sort(filtery);
			devices -= sockets;
			int act = filtery.size()-1;
			int result = 0;
			while(devices > 0){
				//System.out.println(devices + "" "" + act);
				if(act < 0){
					System.out.println(-1);
					return;
				}
				devices -= filtery.get(act);
				act--;
				result++;
			}
			System.out.println(result);
		}
	}

	static class Reader {
		StreamTokenizer in;

		public Reader() {
			in = new StreamTokenizer(new BufferedReader(new InputStreamReader(
					System.in)));
		}

		public int nextInt() {
			try {
				in.nextToken();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return (int) in.nval;
		}

		public long nextLong() {
			try {
				in.nextToken();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return (long) in.nval;
		}

		public String next() {
			try {
				in.nextToken();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return in.sval;
		}
	}
}
",4,0257_A,CODEFORCES,2665,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class Main {
	public static void main (String[] args) throws IOException {
		BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));
		String[] splitted = reader.readLine().split("" "");
		int n = Integer.parseInt(splitted[0]);
		int m = Integer.parseInt(splitted[1]);
		int k = Integer.parseInt(splitted[2]);
		PriorityQueue<Integer> queue = new PriorityQueue<Integer> (1000, Collections.reverseOrder());
		splitted = reader.readLine().split("" "");
		for (int ii = 0; ii < splitted.length; ii++) {
			queue.add(Integer.parseInt(splitted[ii]));
		}
		
		int counter = 0;
		int spot = k;
		while (spot < m && !queue.isEmpty()) {
			spot = spot + queue.poll() - 1;
			counter++;
		}
		if (spot < m) {
			System.out.println(""-1"");
		} else {
			System.out.println(counter);
		}
	}
}",4,0257_A,CODEFORCES,2680,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class Sockets {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        int n = in.nextInt(), m = in.nextInt(), socket = in.nextInt();
        int[] filters = new int[n];

        for (int i = 0; i < n; i++ ) {
            filters[i] = in.nextInt();
        }
        Arrays.sort(filters);

        int result = 0, index = n - 1;
        while ( m > socket && index >= 0) {
            socket += filters[index] - 1;
            result += 1;
            index -= 1;
        }

        out.println(m > socket ? -1 : result);
        out.close();
    }
}
",4,0257_A,CODEFORCES,2640,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.*;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */
public class Main {
    public static void main(String[] args) {
        InputReader in = new StreamInputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        run(in, out);
    }

    public static void run(InputReader in, PrintWriter out) {
        Solver solver = new TaskB();
        solver.solve(1, in, out);
        Exit.exit(in, out);
    }
}

abstract class InputReader {
    private boolean finished = false;

    public abstract int read();

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuffer res = new StringBuffer();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    private boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public void setFinished(boolean finished) {
        this.finished = finished;
    }

    public abstract void close();
}

class StreamInputReader extends InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar, numChars;

    public StreamInputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public void close() {
        try {
            stream.close();
        } catch (IOException ignored) {
        }
    }
}

class Exit {
    private Exit() {
    }

    public static void exit(InputReader in, PrintWriter out) {
        in.setFinished(true);
        in.close();
        out.close();
    }
}

interface Solver {
    public void solve(int testNumber, InputReader in, PrintWriter out);
}

class TaskB implements Solver 
{
    public void solve(int testNumber, InputReader in, PrintWriter out) 
    {
        int n = in.readInt();
        int m = in.readInt();
        int k = in.readInt();
        int[] a = new int[n];
        for(int i=0;i<n;i++) a[i] = in.readInt();
        Arrays.sort(a);
        if(k>=m)
        {
            out.println(0);
        }
        else
        {
            for(int i=n-1;i>=0;i--)
            {
                k += (a[i]-1);
                if(k>=m) 
                {
                    out.println(n-i);
                    return;
                }
            }
            if(k<m) out.println(-1);
        }
    }
}
",4,0257_A,CODEFORCES,2646,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.*;
public class a {
public static void main(String[] args)
{
    Scanner input = new Scanner(System.in);
    int n = input.nextInt(), m = input.nextInt(), k = input.nextInt();
    int[] data = new int[n];
    for(int i = 0; i<n; i++)
        data[i] = input.nextInt();
    Arrays.sort(data);
    m -= k;
    int at = n-1;
    int count = 0;
    while(at>=0 && m>0)
    {
        count++;
        m++;
        m -= data[at];
        at--;
    }
    if(m>0)
        System.out.println(-1);
    else
        System.out.println(count);
}
}
",4,0257_A,CODEFORCES,2671,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.Collections;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n=in.nextInt();
        int m=in.nextInt();
        int k=in.nextInt();
        Integer []cap=new Integer[n];
        for(int i=0;i<n;i++) {
            cap[i]=in.nextInt();
        }
        Arrays.sort(cap, Collections.reverseOrder());
        int count=0;

        while(k<m && count<cap.length) {
            k+=(cap[count]-1);
            ++count;
        }
        if(k>=m) {
            out.println(count);
        } else {
            out.println(-1);
        }
    }
}

class InputReader {
    StringTokenizer st;
    BufferedReader in;
    public InputReader(InputStream ins)
    {
        in = new BufferedReader(new InputStreamReader(ins));
    }

    public String nextToken()
    {
        while(st==null || !st.hasMoreTokens())
        {
            try {
                st=new StringTokenizer(in.readLine());
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
        return st.nextToken();
    }
    public int nextInt()
    {

        return Integer.parseInt(nextToken());
    }

    }

",4,0257_A,CODEFORCES,2659,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;

/**
 *
 * @author oleksiys
 */
public class A {
    public static void main(String [] args){
        try(Scanner s = new Scanner(System.in)){
            final int n = s.nextInt();
            final int m = s.nextInt();
            final int k = s.nextInt();
            final int [] a = new int [n];
            for (int i = 0; i < a.length; ++i){
                a[i] = s.nextInt();
            }
            Arrays.sort(a);
            int i = a.length - 1;
            int available = k;
            int filters = 0;
            while (available < m && i >= 0){
                available -= 1;
                available += a[i];
                filters++;
                i--;
            }
            if (available < m){
                System.out.println(-1);
            }else{
                System.out.println(filters);
            }
        }
    }
}
",4,0257_A,CODEFORCES,2661,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


public class A {
	
	static class Scanner{
		BufferedReader br=null;
		StringTokenizer tk=null;
		public Scanner(){
			br=new BufferedReader(new InputStreamReader(System.in));
		}
		public String next() throws IOException{
			while(tk==null || !tk.hasMoreTokens())
				tk=new StringTokenizer(br.readLine());
			return tk.nextToken();
		}
		public int nextInt() throws NumberFormatException, IOException{
			return Integer.valueOf(next());
		}
		public double nextDouble() throws NumberFormatException, IOException{
			return Double.valueOf(next());
		}
	}
	
	public static void main(String args[]) throws NumberFormatException, IOException{
		Scanner sc=new Scanner();
		int N=sc.nextInt();
		int M=sc.nextInt();
		int K=sc.nextInt();
		int[] array=new int[N];
		for(int i=0;i<N;i++)
			array[i]=sc.nextInt();
		Arrays.sort(array);
		int val=K;
		int index=N - 1;
		while(index>=0 && val<M){
			val--;
			val+=array[index];
			index--;
		}
		if (val<M)
			System.out.println(""-1"");
		else
			System.out.println((N - 1) - index);
	}

}
",4,0257_A,CODEFORCES,2668,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = in.nextInt();
        Arrays.sort(a);
        if (k >= m) {
            out.println(0);
            return;
        }
        for (int i = 1; i <= n; i++) {
            int sockets = k - 1;
            for (int j = 0; j < i; j++)
                sockets += a[n - j - 1];
            sockets -= i - 1;
            if (sockets >= m) {
                out.println(i);
                return;
            }
        }
        out.println(-1);
    }
}

class InputReader {
    private BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }
}
",4,0257_A,CODEFORCES,2684,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.*;
import java.lang.*;

public class Main
{
    public static void main (String[] args) throws java.lang.Exception
    {
        Scanner sc = new Scanner(System.in);
        int numSupply = sc.nextInt();
        int dev = sc.nextInt();
        int socket = sc.nextInt();
        int[] sockInSu = new int[numSupply];
        for (int i = 0; i< sockInSu.length; i++) {
            sockInSu[i] = sc.nextInt();
        }
        
        Arrays.sort(sockInSu);
        
        if (socket >= dev) {
            System.out.println(0);
        }else {
            int count = 0;
            for (int i = sockInSu.length-1; i >= 0; i--) {
                socket+= sockInSu[i]-1;
                count++;
                if (socket >= dev) {
                    System.out.println(count);
                    break;
                }
            }
            if (socket < dev)
                System.out.println(-1);
        }
    }
}",4,0257_A,CODEFORCES,2666,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;


public class A {
    
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int so[]= new int[n];
        for(int i=0;i<n;i++) so[i]=in.nextInt();
        Arrays.sort(so);
        if(m<=k) {
            System.out.println(""0"");
            return;
        }
        int sum=0;
        int socUsed=0;
        int cont=0;
        for(int i=n-1;i>=0;i--){
            cont++;
            sum+=so[i]; 
            if(sum>=m || sum+(k-1)>=m){
                System.out.println(cont);
                return;
            }   
            sum--;  
        }   
        System.out.println(""-1"");
    }
}
",4,0257_A,CODEFORCES,2676,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Arrays;
import java.util.Scanner;


public class Main {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        
        int n = s.nextInt();
        int m = s.nextInt();
        int k = s.nextInt();
        
        int a[] = new int [n];
        for (int i = 0; i < a.length; i++) {
            a[i] = s.nextInt();
        }
        int ans = 0;
        
        while(k < m){
            k--;
            int max = -1;
            int ix = -1;
            for (int i = 0; i < a.length; i++) {
                if(a[i] > max){
                    max = a[i];
                    ix = i;
                }
            }
            if(ix == -1){
                System.out.println(""-1"");
                return ;
            }
            k += a[ix];
            a[ix] = -1;
            ans++;
        }
        System.out.println(ans);
    }

}
",4,0257_A,CODEFORCES,2652,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

// device can plug the supply-line filter
// plugged to electricity if it is either plugged to one of k electrical sockets

public class A {
    private static final int[] TYPES_OF_APARTMENTS = new int[]{3, 5, 7};

    public static void main(String[] args) {
        try {
            FastScanner in = new FastScanner(System.in);
            PrintWriter out = new PrintWriter(System.out);
            int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();
            // # supply-line filters, # devices, # sockets
            int[] array = new int[n];
            for (int i = 0; i < n; i++)
                array[i] = in.nextInt();

            out.println(solve(array, m, k));

            out.close();

        } catch(Exception exc) {
            throw new RuntimeException(exc);
        }
    }

    private static int solve(int[] supplies, int device, int socket) {
        Arrays.sort(supplies);
        int cnt = 0;
        for (int i = supplies.length - 1; i >= 0; i--) {
            if (device <= socket) return cnt;
            if (socket > 0) {
                socket += supplies[i];
            }
            socket--;
            cnt++;
        }
        return device <= socket ? cnt : -1;
    }

    private static String print(int[] values) {
        if (values == null) return ""-1"";
        StringBuilder sb = new StringBuilder();
        sb.append(values[0]).append("" "").append(values[1]).append("" "").append(values[2]);
        return sb.toString();
    }

    //@
    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream i) {
            br = new BufferedReader(new InputStreamReader(i));
            st = new StringTokenizer("""");
        }

        public String next() throws IOException {
            if (st.hasMoreTokens())
                return st.nextToken();
            else
                st = new StringTokenizer(br.readLine());
            return next();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        //#
        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
    //$
}
",4,0257_A,CODEFORCES,2639,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Lokesh Khandelwal
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n=in.nextInt(),m=in.nextInt(),k=in.nextInt();
        int ans=-1;
        int i;
        int a[]=new int[n];
        for(i=0;i<n;i++)
            a[i]=in.nextInt();
        Arrays.sort(a);
        int p=k,c=0;
        for(i=n-1;i>=0;i--)
        {
            if(p>=m)
                break;
            p+=a[i]-1;
            c++;
        }
        if(p>=m)
            out.printLine(c);
        else out.printLine(-1);
    }
}

class InputReader
{
    BufferedReader in;
    StringTokenizer tokenizer=null;

    public InputReader(InputStream inputStream)
    {
        in=new BufferedReader(new InputStreamReader(inputStream));
    }
    public String next()
    {
        try{
            while (tokenizer==null||!tokenizer.hasMoreTokens())
            {
                tokenizer=new StringTokenizer(in.readLine());
            }
            return tokenizer.nextToken();
        }
        catch (IOException e)
        {
            return null;
        }
    }
    public int nextInt()
    {
        return Integer.parseInt(next());
    }
    }

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(Object...objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}

	public void close() {
		writer.close();
	}
}

",4,0257_A,CODEFORCES,2682,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class Main
{
   public static void main(String[] args) throws IOException
   {
      new Main().run();
   }

   StreamTokenizer in;
   PrintWriter out;

   int nextInt() throws IOException
   {
      in.nextToken();
      return (int)in.nval;
   }
   long nextLong() throws IOException
   {
      in.nextToken();
      return (long)in.nval;
   }
   void run() throws IOException
   {
     // in = new StreamTokenizer(new BufferedReader(new FileReader(""input.txt"")));
     // out = new PrintWriter(new FileWriter(""output.txt""));
      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    out = new PrintWriter(new OutputStreamWriter(System.out));
      solve();
      out.flush();
   }

   void solve() throws IOException
   {
      int N=nextInt();
      int m=nextInt();
      int k=nextInt();
     //  System.out.println(""k ""+k);
      ArrayList<Integer> ts= new ArrayList<Integer>();
       for (int i = 0; i < N; i++) {
           ts.add(nextInt());
       }
       int count=0,pos=0;
       Collections.sort(ts);
       int jj=ts.size()-1;
      while(m>k){
         
      if((jj<0)||(k==0))
      {pos=1;break;}
      else{
        //  System.out.println(k);
      k+=ts.get(jj) -1;
      jj--;
      count++;
      }
      
      }
      if(pos==0)
           out.println(count);
      else
           out.println(""-1"");
      
   }
}",4,0257_A,CODEFORCES,2667,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class A implements Runnable {

	final boolean LOCAL = System.getProperty(""ONLINE_JUDGE"") == null;
	
	BufferedReader in;
	PrintWriter out;
	StringTokenizer tok;
	
	public static void main(String[] args) {
		new Thread(null, new A(), """", 256*1024*1024).start();
	}

	public void run() {
		try {
			long t1 = 0, t2 = 0, m1 = 0, m2 = 0;
			if (LOCAL) {
				t1 = System.currentTimeMillis();
				m1 = Runtime.getRuntime().freeMemory();
			}
			Locale.setDefault(Locale.US);
			if (LOCAL) {
				in = new BufferedReader(new FileReader(""input.txt""));
				out = new PrintWriter(""output.txt"");
			} else {
				in = new BufferedReader(new InputStreamReader(System.in));
				out = new PrintWriter(System.out);
			}
			tok = new StringTokenizer("""");
			solve();
			in.close();
			out.close();
			if (LOCAL) {
				t2 = System.currentTimeMillis();
				m2 = Runtime.getRuntime().freeMemory();
				System.err.println(""Time = "" + (t2 - t1) + "" ms."");
				System.err.println(""Memory = "" + ((m1 - m2) / 1024) + "" KB."");
			}
		} catch (Throwable e) {
			e.printStackTrace(System.err);
			throw new RuntimeException();
		}
	}

	String readString() throws IOException {
		while (!tok.hasMoreTokens()) {
			String line = in.readLine();
			if (line == null) return null;
			tok = new StringTokenizer(line);
		}
		return tok.nextToken();
	}
	
	int readInt() throws IOException {
		return Integer.parseInt(readString());
	}
	
	long readLong() throws IOException {
		return Long.parseLong(readString());
	}
	
	double readDouble() throws IOException {
		return Double.parseDouble(readString());
	}
	
	static class Mergesort {

		private Mergesort() {}

		public static void sort(int[] a) {
			mergesort(a, 0, a.length - 1);
		}

		public static void sort(long[] a) {
			mergesort(a, 0, a.length - 1);
		}

		public static void sort(double[] a) {
			mergesort(a, 0, a.length - 1);
		}

		private static final int MAGIC_VALUE = 42;

		private static void mergesort(int[] a, int leftIndex, int rightIndex) {
			if (leftIndex < rightIndex) {
				if (rightIndex - leftIndex <= MAGIC_VALUE) {
					insertionSort(a, leftIndex, rightIndex);
				} else {
					int middleIndex = (leftIndex + rightIndex) / 2;
					mergesort(a, leftIndex, middleIndex);
					mergesort(a, middleIndex + 1, rightIndex);
					merge(a, leftIndex, middleIndex, rightIndex);
				}
			}
		}

		private static void mergesort(long[] a, int leftIndex, int rightIndex) {
			if (leftIndex < rightIndex) {
				if (rightIndex - leftIndex <= MAGIC_VALUE) {
					insertionSort(a, leftIndex, rightIndex);
				} else {
					int middleIndex = (leftIndex + rightIndex) / 2;
					mergesort(a, leftIndex, middleIndex);
					mergesort(a, middleIndex + 1, rightIndex);
					merge(a, leftIndex, middleIndex, rightIndex);
				}
			}
		}

		private static void mergesort(double[] a, int leftIndex, int rightIndex) {
			if (leftIndex < rightIndex) {
				if (rightIndex - leftIndex <= MAGIC_VALUE) {
					insertionSort(a, leftIndex, rightIndex);
				} else {
					int middleIndex = (leftIndex + rightIndex) / 2;
					mergesort(a, leftIndex, middleIndex);
					mergesort(a, middleIndex + 1, rightIndex);
					merge(a, leftIndex, middleIndex, rightIndex);
				}
			}
		}

		private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {
			int length1 = middleIndex - leftIndex + 1;
			int length2 = rightIndex - middleIndex;
			int[] leftArray = new int[length1];
			int[] rightArray = new int[length2];
			System.arraycopy(a, leftIndex, leftArray, 0, length1);
			System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
			for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
				if (i == length1) {
					a[k] = rightArray[j++];
				} else if (j == length2) {
					a[k] = leftArray[i++];
				} else {
					a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
				}
			}
		}

		private static void merge(long[] a, int leftIndex, int middleIndex, int rightIndex) {
			int length1 = middleIndex - leftIndex + 1;
			int length2 = rightIndex - middleIndex;
			long[] leftArray = new long[length1];
			long[] rightArray = new long[length2];
			System.arraycopy(a, leftIndex, leftArray, 0, length1);
			System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
			for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
				if (i == length1) {
					a[k] = rightArray[j++];
				} else if (j == length2) {
					a[k] = leftArray[i++];
				} else {
					a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
				}
			}
		}

		private static void merge(double[] a, int leftIndex, int middleIndex, int rightIndex) {
			int length1 = middleIndex - leftIndex + 1;
			int length2 = rightIndex - middleIndex;
			double[] leftArray = new double[length1];
			double[] rightArray = new double[length2];
			System.arraycopy(a, leftIndex, leftArray, 0, length1);
			System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
			for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
				if (i == length1) {
					a[k] = rightArray[j++];
				} else if (j == length2) {
					a[k] = leftArray[i++];
				} else {
					a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
				}
			}
		}

		private static void insertionSort(int[] a, int leftIndex, int rightIndex) {
			for (int i = leftIndex + 1; i <= rightIndex; i++) {
				int current = a[i];
				int j = i - 1;
				while (j >= leftIndex && a[j] > current) {
					a[j + 1] = a[j];
					j--;
				}
				a[j + 1] = current;
			}
		}

		private static void insertionSort(long[] a, int leftIndex, int rightIndex) {
			for (int i = leftIndex + 1; i <= rightIndex; i++) {
				long current = a[i];
				int j = i - 1;
				while (j >= leftIndex && a[j] > current) {
					a[j + 1] = a[j];
					j--;
				}
				a[j + 1] = current;
			}
		}

		private static void insertionSort(double[] a, int leftIndex, int rightIndex) {
			for (int i = leftIndex + 1; i <= rightIndex; i++) {
				double current = a[i];
				int j = i - 1;
				while (j >= leftIndex && a[j] > current) {
					a[j + 1] = a[j];
					j--;
				}
				a[j + 1] = current;
			}
		}

	}
	
	void debug(Object... o) {
		if (LOCAL) {
			System.err.println(Arrays.deepToString(o));
		}
	}
	
//------------------------------------------------------------------------------
	
	void solve() throws IOException {
		int n = readInt();
		int m = readInt();
		int k = readInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = readInt();
		}
		Mergesort.sort(a);
		for (int need = 0; need <= n; need++) {
			int cnt = k;
			for (int i = 0; i < need; i++) {
				cnt += a[n - i - 1] - 1;
			}
			if (cnt >= m) {
				out.println(need);
				return;
			}
		}
		out.println(-1);
	}
	
}
",4,0257_A,CODEFORCES,2641,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
import java.util.Arrays;
import java.util.Scanner;

/**
 *
 * @author Natasha
 */
public class Main{

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int produzeni = in.nextInt();
        int devices = in.nextInt();
        int stekovi = in.nextInt();
        int [] filter = new int[produzeni];
        for(int i = 0; i<produzeni; i++){
            filter[i] = in.nextInt();
        }
        Arrays.sort(filter);
        int filt_no = filter.length-1;
        if(devices<=stekovi) {
            System.out.println(""0"");
            return;
        }
        int used = 0;
        while(devices>stekovi){
            try{
            stekovi+=filter[filt_no--]-1;
            }
            catch(Exception e){
                System.out.println(""-1"");
                return;
            }
        }
        
        System.out.println(filter.length - filt_no-1);
        
        
        
    }
}
",4,0257_A,CODEFORCES,2670,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import java.lang.*;

public class Main {

  public static void main(String[] args) {
    Scanner cin=new Scanner(new BufferedInputStream(System.in));
    
    int n=cin.nextInt(),
        m=cin.nextInt(),
        k=cin.nextInt();
    int[] a=new int[51];
    
    for (int i=0;i<n;i++) {
      a[i]=-cin.nextInt();
    }
    Arrays.sort(a);
    
    if (m<=k) {
        System.out.println(0);
        return;
    }
    for (int i=0;i<Math.min(k,n);i++) {
      m+=a[i];
      if (m-(k-1-i)<=0) {
        System.out.println(i+1);
        return;
      }
    }
    for (int i=k;i<n;i++) {
      m+=a[i]+1;
      if (m<=0) {
        System.out.println(i+1);
        return;
      }
    }
    System.out.println(-1);
    
    cin.close();
  }

}",4,0257_A,CODEFORCES,2657,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class CF159DIV2 {
	FastScanner in;
	PrintWriter out;

	void solve() {
		int n = in.nextInt();
		int m = in.nextInt();
		int k = in.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = in.nextInt();
		Arrays.sort(a);
		for (int i = 0; i < a.length / 2; i++) {
			int tmp = a[i];
			a[i] = a[n - i - 1];
			a[n - i - 1] = tmp;
		}
		int need = m;
		int have = k;
		int ans = 0;
		int it = 0;
		while (have < need) {
			have += a[it++] - 1;
			ans++;
			if (it >= n) break;
		}
		if (have >= need) {
			out.println(ans);
		} else {
			out.println(-1);
		}
	}

	void run() {
		try {
			in = new FastScanner(new File(""object.in""));
			out = new PrintWriter(new File(""object.out""));

			solve();

			out.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	void runIO() {

		in = new FastScanner(System.in);
		out = new PrintWriter(System.out);

		solve();

		out.close();
	}

	class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(File f) {
			try {
				br = new BufferedReader(new FileReader(f));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public FastScanner(InputStream f) {
			br = new BufferedReader(new InputStreamReader(f));
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				String s = null;
				try {
					s = br.readLine();
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (s == null)
					return null;
				st = new StringTokenizer(s);
			}
			return st.nextToken();
		}

		boolean hasMoreTokens() {
			while (st == null || !st.hasMoreTokens()) {
				String s = null;
				try {
					s = br.readLine();
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (s == null)
					return false;
				st = new StringTokenizer(s);
			}
			return true;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}
		
		double nextDouble() {
			return Double.parseDouble(next());
		}
	}

	public static void main(String[] args) {
		new CF159DIV2().runIO();
	}
}",4,0257_A,CODEFORCES,2679,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
public class a{
    static int a;
    static Scanner sc = new Scanner(System.in);
    public static void main(String[] args) throws IOException{
        int n = sc.nextInt();
        int p = n;
        int m = sc.nextInt();
        int k = sc.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
        {
            a[i] = sc.nextInt() - 1;
        }
        Arrays.sort(a);
        int j =0;
        for(int i=0; i<n; i++){
            if(m > k){
                k = k + a[n-i-1];
                j++;
            }
        }
        if(m > k)
            System.out.println(-1);
        else
            System.out.println(j);
    }
    
}",4,0257_A,CODEFORCES,2687,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;

public class ProblemA {
    InputReader in; PrintWriter out;
    void solve() {
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = in.nextInt();
        Arrays.sort(a);
        int d = k;
        int cur = n - 1;
        int ans = 0;
        while (d < m && cur >= 0) {
            d += a[cur] - 1;
            cur--;
            ans++;
        }
        if (d >= m)
            out.println(ans);
        else
            out.println(""-1"");
    }
    
    ProblemA(){
        boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
        try {
            if (oj) {
                in = new InputReader(System.in);
                out = new PrintWriter(System.out);
            }
            else {
                Writer w = new FileWriter(""output.txt"");
                in = new InputReader(new FileReader(""input.txt""));
                out = new PrintWriter(w);
            }
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
        solve();
        out.close();
    }
    public static void main(String[] args){
        new ProblemA();
    }
}

class InputReader {
    private BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }
    
    public InputReader(FileReader fr) {
        reader = new BufferedReader(fr);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }
    public int nextInt() {
        return Integer.parseInt(next());
    }
    public long nextLong() {
        return Long.parseLong(next());
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }

}",4,0257_A,CODEFORCES,2674,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author c0der
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int[] a = new int[ n ];
        for (int i=0; i<n; i++) a[i] = in.nextInt();

        if ( m <= k ) out.println( 0 );
        else
        {
            m -= k - 1;
            Arrays.sort( a );
            int ans = 0;
            for (int i=n-1; i>=0; i--)
            {
                ans++;
                //out.println(m+"" ""+a[i]);
                m -= a[ i ];
                if ( m <= 0 ) break;
                m++;
            }
            if ( m > 0 ) out.println( -1 );
            else out.println( ans );
        }
    }
}

class InputReader {
    BufferedReader br;
    StringTokenizer st;

    public InputReader(InputStream in)
    {
        br = new BufferedReader(new InputStreamReader(in));
        st = null;
    }

    public String next()
    {
        while (st==null || !st.hasMoreTokens())
        {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }

    public int nextInt()
    {
        return Integer.parseInt(next());
    }
}
",4,0257_A,CODEFORCES,2645,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
import java.util.Arrays;
import java.util.StringTokenizer;

public class Solution {
    //<editor-fold desc=""input parse"" defaultstate=""collapsed"">

    private static StringTokenizer st;
    private static java.io.BufferedReader reader;
    private static java.io.BufferedWriter writer;

    private static long nextLong() {
        return Long.parseLong(st.nextToken());
    }

    private static int nextInt() {
        return Integer.parseInt(st.nextToken());
    }

    private static double nextDouble() {
        return Double.parseDouble(st.nextToken());
    }

    private static short nextShort() {
        return Short.parseShort(st.nextToken());
    }

    private static byte nextByte() {
        return Byte.parseByte(st.nextToken());
    }

    private static void initTokenizer() throws Exception {
        st = new StringTokenizer(reader.readLine());
    }

    //</editor-fold>
    

    public static void main(String[] args) throws Exception {
	reader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in), 1 << 20);
	writer = new java.io.BufferedWriter(new java.io.OutputStreamWriter(System.out));
	//reader = new java.io.BufferedReader(new java.io.FileReader(""input.txt""), 1 << 20);
	//writer = new java.io.BufferedWriter(new java.io.FileWriter(""output.txt""));
	
	initTokenizer();
	int n = nextInt();
	int m = nextInt();
	int k = nextInt();
	
	initTokenizer();
	int[] a = new int[n];
	
	for (int i = 0; i < n; i++) {
	    a[i] = nextInt();
	}
	
	Arrays.sort(a);
	
	int total = k;
	int cnt = 0;
	
	while (total < m && cnt < a.length) {
	    total += a[a.length - 1 - cnt] - 1;
	    cnt++;
	}
	
	if (total >= m) System.out.println(cnt);
	else System.out.println(-1);
    }
}",4,0257_A,CODEFORCES,2681,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
import java.util.*;
import java.io.*;
import java.math.*;
import java.util.regex.*;

public class Main {
       
    static InputReader in;
    
    public static void main(String[] args) throws IOException{        
        
        File file = new File(""input.txt"");
        if(file.exists())in = new InputReader( new FileInputStream(file) );
        else in = new InputReader( System.in );
        
        int n=in.nextInt(), m=in.nextInt(), k=in.nextInt();
        int a[]=new int[n];
        for( int i=0; i<n; i++ ) a[i]=in.nextInt();
        Arrays.sort( a );
        int i=n-1, ans=0;
        while( k<m && i>=0 ) {
            k+=a[i]-1;
            i--;
            ans++;
        }
        if( m<=k ) System.out.println( ans );
        else System.out.println(""-1"");
    } 
    
    // IO utilities:
    
    static void out(Object ...o){ 
        System.out.println(Arrays.deepToString(o)); 
    } 
    
    static class InputReader {
        
        private BufferedInputStream inp;
	private int offset;
	private final int size=5120000;
        private byte buff[];
 
        InputReader( InputStream in ) throws IOException {
		inp = new BufferedInputStream( in );
                buff=new byte[size];
                offset=0;
		inp.read( buff, 0, size );
	}
 
	int nextInt() throws IOException {
            
            int parsedInt=0;
            int i=offset;
            if( buff[i]==0 ) throw new IOException(); //EOF
            // skip any non digits
            while ( i<size && ( buff[i]<'0' || buff[i]>'9' ) ) i++;
            // read digits and parse number
            while( i<size && buff[i]>='0' && buff[i]<='9') {
                parsedInt*=10;
                parsedInt+=buff[i]-'0';
                i++;
            }
            // check if we reached end of buffer
            if ( i==size ) {
                // copy leftovers to buffer start
		int j = 0;
		for ( ; offset<buff.length; j++, offset++ ) 
                        buff[j] = buff[offset];
		// and now fill the buffer
		inp.read( buff, j, size - j );
		// and attempt to parse int again
		offset = 0;
		parsedInt = nextInt();
            } else offset=i;
            return parsedInt;
	}
        
        long nextLong() throws IOException{
            
            long parsedLong=0;
            int i=offset;
            if( buff[i]==0 ) throw new IOException(); //EOF
            // skip any non digits
            while( i<size && ( buff[i]<'0' || buff[i]>'9' ) ) i++;
            // read digits and parse number
            while( i<size && buff[i]>='0' && buff[i]<='9') {
                parsedLong*=10L;
                parsedLong+=buff[i]-'0';
                i++;
            }
            // check if we reached end of buffer
            if ( i==size ) {
                // copy leftovers to buffer start
		int j = 0;
		for ( ; offset<buff.length; j++, offset++ ) 
                        buff[j] = buff[offset];
		// and now fill the buffer
		inp.read( buff, j, size - j );
		// and attempt to parse int again
		offset = 0;
		parsedLong = nextLong();
            } else offset=i;
            return parsedLong;
        }
        
        String next() throws IOException {
            
            StringBuilder token=new StringBuilder();
            int i=offset;
            if( buff[i]==0 ) throw new IOException(); //EOF
            // skip any non chars
            while( i<size && ( buff[i]=='\n' || buff[i]==' ' || buff[i]=='\r' ||
                    buff[i]=='\t' ) ) i++;
            // read chars
            while( i<size && buff[i]!='\n' && buff[i]!=' ' && buff[i]!='\r' &&
                    buff[i]!='\t' && buff[i]!=0 ) {
                token.append( (char)buff[i] );
                i++;
            }
            // check if we reached end of buffer
            if ( i==size ) {
                // copy leftovers to buffer start
		int j = 0;
		for ( ; offset<buff.length; j++, offset++ ) 
                        buff[j] = buff[offset];
		// and now fill the buffer
		inp.read( buff, j, size - j );
		// and attempt to parse int again
		offset = 0;
		return next();
            } else offset=i;
            return token.toString();
        }
        
        String nextLine() throws IOException {
            
            StringBuilder line=new StringBuilder();
            int i=offset;
            if( buff[i]==0 ) throw new IOException(); //EOF
            // read chars
            while( i<size && buff[i]!='\n' && buff[i]!=0 ) {
                line.append( (char)buff[i] );
                i++;
            }
            if( i<size && buff[i]=='\n' ) i++;
            // check if we reached end of buffer
            if ( i==size ) {
                // copy leftovers to buffer start
		int j = 0;
		for ( ; offset<buff.length; j++, offset++ ) 
                        buff[j] = buff[offset];
		// and now fill the buffer
		inp.read( buff, j, size - j );
		// and attempt to parse int again
		offset = 0;
		return nextLine();
            } else offset=i;
            line.deleteCharAt( line.length()-1 );
            return line.toString();
        }
        
    }
}",4,0257_A,CODEFORCES,2660,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.io.*;
import java.util.*;
import java.math.*;
import java.awt.geom.*;

import static java.lang.Math.*;

public class Solution implements Runnable {
	
	void solve() throws Exception {
		int n = sc.nextInt();
		int m = sc.nextInt();
		int k = sc.nextInt();
		int a [] = new int [n];
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
		}
		Arrays.sort(a);
		if (k >= m) {
			out.println(0);
			return;
		}
		int sum = k;
		for (int j = n - 1; j >= 0; j--) {
			sum--;
			sum += a[j];
			if (sum >= m) {
				out.println((n - j));
				return;
			}
		}
		out.println(-1);
	}

	BufferedReader in;
	PrintWriter out;
	FastScanner sc;

	static Throwable uncaught;

	@Override
	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			sc = new FastScanner(in);
			solve();
		} catch (Throwable t) {
			Solution.uncaught = t;
		} finally {
			out.close();
		}
	}

	public static void main(String[] args) throws Throwable {
		Thread t = new Thread(null, new Solution(), """", (1 << 26));
		t.start();
		t.join();
		if (uncaught != null) {
			throw uncaught;
		}
	}

}

class FastScanner {

	BufferedReader reader;
	StringTokenizer strTok;

	public FastScanner(BufferedReader reader) {
		this.reader = reader;
	}

	public String nextToken() throws IOException {
		while (strTok == null || !strTok.hasMoreTokens()) {
			strTok = new StringTokenizer(reader.readLine());
		}
		return strTok.nextToken();
	}

	public int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	public long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	public double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

}",4,0257_A,CODEFORCES,2675,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"import java.util.Scanner;


public class Composite {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		if (n == 12)
			System.out.println(""4 8"");
		
		else if (n % 2 == 1)
			System.out.println((n - 9) + "" 9"");
		
		else
			System.out.println((n - 6) + "" 6"");
	}
}
",1,0472_A,CODEFORCES,416,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class ProblemA {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(new InputStreamReader(System.in));
        int n = sc.nextInt();
        if (n % 2 == 0) {
            System.out.println((n - 4) + "" "" + 4);
        } else {
            System.out.println((n - 9) + "" "" + 9);
        }
    }
}
",1,0472_A,CODEFORCES,426,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class Solution {

  public static void main(String[] args) throws Exception {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    if (n % 2 == 0)
      System.out.println(""4 "" + (n - 4));
    else
      System.out.println(""9 "" + (n - 9));
  }
}
",1,0472_A,CODEFORCES,414,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.*;

public class Main {
    private static PrintWriter out;
    private static FastReader in;

    private static class FastReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public FastReader(InputStream inputStream) {
            reader = new BufferedReader(
                    new InputStreamReader(inputStream), 1 << 16);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException ex) {
                    throw new RuntimeException(ex);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }

    public static void main(String[] args) throws FileNotFoundException, InterruptedException {
        in = new FastReader(System.in);
        out = new PrintWriter(System.out);

        int n = in.nextInt();
        int a = ((n & 1) == 0) ? a = 6 : 9;
        int b = n - a;
        out.println(a + "" "" + b);

        out.flush();
    }
}",1,0472_A,CODEFORCES,429,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;

public class LearnMath {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		scan.close();
		
		if ((N%2) == 0) {
			System.out.println(4 + "" "" + (N-4));
		}
		else {
			if (N > 18) {
				System.out.println(9 + "" "" + (N-9));
			}
			else {
				System.out.println((N-9) + "" "" + 9);
			}
		}

	}

}
",1,0472_A,CODEFORCES,415,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Anirudh Rayabharam (anirudhrb@yandex.com)
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        if (n % 2 == 0) {
            out.println(""4 "" + (n - 4));
        } else {
            out.println(""9 "" + (n - 9));
        }
    }
}

class InputReader {
    public BufferedReader reader;
    private int tokenCount, nextTokenIndex;
    private String[] tokens;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenCount = nextTokenIndex = 0;
    }

    public String next() {
        String nextLine;
        if (nextTokenIndex == tokenCount) {
            try {
                nextLine = reader.readLine();
                nextTokenIndex = 0;
                tokens = nextLine.split(""\\s"");
                tokenCount = tokens.length;
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokens[nextTokenIndex++];
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}

",1,0472_A,CODEFORCES,443,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

/**
 * Created by misanand on 9/20/14.
 */
public class Recovery {
    public static void main(String [] args) {
        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        if( N%2 == 0) {
            System.out.println( (4)+"" ""+(N-4));
        }
        else System.out.println( (9)+"" ""+(N-9));
        scan .close();
    }
}",1,0472_A,CODEFORCES,438,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"
import java.util.Scanner;


public class composite {

  
    public static void main(String[] args) {
        int b;
        Scanner s3=new Scanner(System.in);
         b=s3.nextInt();
      
          if(b%2==0)
          {
              b=b-4;
              System.out.println(4+"" ""+b);
          }
          else
          {
              b=b-9;
              System.out.println(9+"" ""+b);
          }
      
    
}
}",1,0472_A,CODEFORCES,450,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;
public class A
{
	public static void main(String[] args)
	{
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		
		if(n % 2 == 1)
		{
			System.out.println(9 + "" "" + (n - 9));
		}
		else
		{
			System.out.println(4 + "" "" + (n - 4));
		}
	}
}
",1,0472_A,CODEFORCES,457,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;


public class A {

    public static void main(String[] args) {
         
        Scanner x=new Scanner(System.in);
        
        int n=x.nextInt();
                
                if(n%2==0){
                    
                    System.out.println((n-4)+"" ""+""4"");
                }
                else{
                    
                    System.out.println((n-9)+"" ""+""9"");
                    
                }
        
        
        
        
    }

}
",1,0472_A,CODEFORCES,422,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

/**
 * Created by ZeRoGerc on 25.02.15.
 */
public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        int n = scan.nextInt();

        if (n % 2 == 0) {
            System.out.println(4 + "" "" + (n - 4));
        }
        else {
            System.out.println(9 + "" "" + (n - 9));
        }
    }
}
",1,0472_A,CODEFORCES,410,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;
public class Test {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		if (n % 2 == 0) {
			System.out.println(4 + "" "" + (n - 4));
		} else {
			System.out.println(9 + "" "" + (n - 9));
		}
	}
}",1,0472_A,CODEFORCES,432,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
    public static void main (String[] args) throws java.lang.Exception
    {
     int n,a,b;
     Scanner obj=new Scanner(System.in);
    
     n=obj.nextInt();
    
     if(n%4==0){a=n/2;b=n/2;System.out.println(a+"" ""+b);}
     else if(n%2==0 && n%4!=0)
     {a=n/2-1;b=n/2+1;System.out.println(a+"" ""+b);}
     
     else if(n%2!=0)
     {  a=4;b=0;
       while(b!=1)
       { b=n-a;
         if(b%3==0){ System.out.println(a+"" ""+b);break; }
         else{a=a+2;}
       }
     }
    }
}",1,0472_A,CODEFORCES,461,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;
import java.io.*;
public class Cf270a {
    public static void main(String[] args) throws IOException {
        InputStreamReader fin = new InputStreamReader(System.in);
        Scanner scr = new Scanner(fin);
        int n = scr.nextInt();
        int x = 0;
        int y = 0;
        if (n%2 == 0) {
            x = 4;
            y = n - x;
        } else {
            x = 9;
            y = n - x;
        }
        PrintWriter fout = new PrintWriter(System.out);
        fout.print(x+"" ""+y);
        fout.flush();
        fout.close();
    }
}",1,0472_A,CODEFORCES,445,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.*;

public class Main {
  // main
  public static void main(String [] args) throws IOException {
    // makes the reader and writer
    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
    
    // read in N
    int N = Integer.parseInt(f.readLine());
    
    // write to out
    if (N%2==0) out.println(""4 ""+(N-4));
    if (N%2==1) out.println(""9 ""+(N-9));
    
    // cleanup
    out.close();
    System.exit(0);
  }
}",1,0472_A,CODEFORCES,452,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class code0 {

public static void main(String[] args){
	Scanner scr= new Scanner(System.in);
int c=0,e=0,d=0;
int a=scr.nextInt();
d=a/2;
if(a>=11 && a%2==1){
c=9;
e=a-9;
}
else{
c=a-4;e=4;
}

System.out.print(c+"" ""+e);
}

}
",1,0472_A,CODEFORCES,433,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.*;

public class a
{
	public static void main(String[] args)
	{
		
		Scanner sc=new Scanner(System.in);
		
		int N=sc.nextInt();
		
		solve(N);
		
		
	}
	
	static void solve(int a)
	{
		if((a-8)%3==0)
		{
			System.out.println(8+"" ""+(a-8));
			return ;
		}
		if((a-4)%3==0)
		{
			System.out.println(4+"" ""+(a-4));
			return ;
		}
		if((a-6)%3==0)
		{
			System.out.println(6+"" ""+(a-6));
			return ;
		}
	}
		
}",1,0472_A,CODEFORCES,436,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.*;

public class Main {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        int n = in.nextInt();
        if (n%2==0) {
            System.out.println(4+"" ""+(n-4));
        } else {
            System.out.println(9+"" ""+(n-9));
        }

        in.close();
        out.close();
    }
}
",1,0472_A,CODEFORCES,413,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        if (n % 2 == 0) {
            System.out.println((n - 4) + "" "" + (n - (n - 4)));
        } else {
            System.out.println((n - 9) + "" "" + (n - (n - 9)));
        }
    }

}
",1,0472_A,CODEFORCES,442,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class Code1 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = Integer.valueOf(sc.nextLine());
        if (n % 2 == 0)
            System.out.println(4 + "" "" + (n - 4));
        else {
            System.out.println(9 + "" "" + (n - 9));
        }

    }
}
",1,0472_A,CODEFORCES,420,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;


public class main1 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		
		int a = n / 2;
		int b = n - a;
		
		if (n % 2 == 0) {
			if (a % 2 == 1) {
				a++;
				b--;
			}
			
			System.out.println(a + "" "" + b);
		} else {
			if (a % 2 == 1) {
				int x = a;
				a = b;
				b= x;
			}
			
			if (b % 3 == 0) {
				
			} else if (b % 3 == 1) {
				a-=2;
				b+=2;
			} else {
				a+=2;
				b-=2;
			}
			
			System.out.println(a + "" "" + b);
		}
	}
}
",1,0472_A,CODEFORCES,439,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        if (n % 2 == 0) {
            out.println(4 + "" "" + (n - 4));
        } else {
            out.println(9 + "" "" + (n - 9));
        }
    }
}

class InputReader {
    private final BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }

    public String nextLine() {
        try {
            return reader.readLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(nextLine());
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}

",1,0472_A,CODEFORCES,418,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class A {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = in.nextInt();
        
        int a = n/2;
        int b = (n/2) + (n%2);
        
        if ((a%2!=0 && a%3!=0) || (b%2!=0 && b%3!=0)) {
            a--;
            b++;
        }
        
        if ((a%2!=0 && a%3!=0) || (b%2!=0 && b%3!=0)) {
            a--;
            b++;
        }

        System.out.println(a + "" "" + b);
    }
}",1,0472_A,CODEFORCES,449,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner inputReader = new Scanner(System.in);
        int n;
        n = inputReader.nextInt();

        boolean[] mark = new boolean[n + 1];
        for (int i = 2; i * i <= n; i++)
            if (!mark[i])
                for (int j = i * 2; j <= n; j += i)
                    mark[j] = true;

        for (int i = 2; i <= n / 2; i++)
            if (mark[i] && mark[n - i]) {
                System.out.println("""" + i + "" "" + (n - i));
                break;
            }
    }
}",1,0472_A,CODEFORCES,411,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.Scanner;


public class T
{
    public static void main(String[] args) throws IOException
    {
        T t = new T();
        t.run();
        t.close();
    }

    private void close()
    {
        sc.close();
        pw.close();
    }

    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    Scanner sc = new Scanner(reader);
    PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    void yesno(boolean b)
    {
        pw.println(b ? ""YES"" : ""NO"");
    }


    void run() throws IOException
    {
        int n = sc.nextInt();

        if (n % 2 == 0)
        {
            pw.print(4 + "" "" + (n - 4));
        }
        else
        {
            pw.print(9 + "" "" + (n - 9));
        }

    }
}
",1,0472_A,CODEFORCES,430,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class ProblemA {

	public static void main(String [] args) throws NumberFormatException, IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		int num1,num2;
		if(n % 2 == 0){
			num1 = n / 2;
			if(num1 % 2 == 0){
				num2 = num1;
			}
			else{
				num1--;
				num2 = num1 + 2;
			}
		}
		else{
			num1 = 9;
			num2 = n - num1;
		}
		
		System.out.println(num1+"" ""+num2);
	}
}
",1,0472_A,CODEFORCES,437,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;
import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, Scanner in, PrintWriter out) {
        int N = in.nextInt();
        if (N % 2 == 0){
            out.println(""4 "" + (N - 4));
        }
        else {
            out.println(""9 "" + (N - 9));
        }
    }
}

",1,0472_A,CODEFORCES,423,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class TA {

	public void solve(long n) {
		long a = 0, b = 0;
		if (n % 2 == 0) {
			if (n % 4 == 0) {
				a = n / 2;
				b = n/ 2;
			} else {
				a = n / 2 - 1;
				b = n / 2 + 1;
			}
		} else {
			a = 4;
			b = n - a;
			while (b > 0 && (b % 3 != 0)) {
				a += 2;
				b = n - a;
			}
			
		}
		System.out.println(a + "" "" + b);
	}
	public static void main(String[] args) {
		FastScanner in = new FastScanner();
		
		new TA().solve(in.nextLong());
	}
	static class FastScanner {

		BufferedReader br;
		StringTokenizer st;

		public FastScanner(String s) {
			try {
				br = new BufferedReader(new FileReader(s));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public FastScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String nextToken() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(nextToken());
		}

		long nextLong() {
			return Long.parseLong(nextToken());
		}

		double nextDouble() {
			return Double.parseDouble(nextToken());
		}

	}

}
",1,0472_A,CODEFORCES,446,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Scanner;

/**
 *
 * @author RezaM
 */
public class A {

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);

        int n = scan.nextInt();

        if (n % 2 == 0) {
            System.out.println(4 + "" "" + (n - 4));
        } else {
            System.out.println(9 + "" "" + (n - 9));
        }

    }

}
",1,0472_A,CODEFORCES,434,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int a,b;
		if (n%2==0) {
			a = 4;
		}else{
			a = 9;
		}
		b = n - a;
		System.out.println(a + "" "" + b);
	}

}
",1,0472_A,CODEFORCES,448,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
    
    public static boolean isPrime(long num){
        int divisor = 2;
        boolean bandera = true;
        while(bandera && divisor<num) //ponemos el while con su condicion en este caso si bandera 
        { 
        if (num%divisor==0) {
            bandera=false;
            break;
        }else{
            divisor++; //igual si el divisor llego al numero q se capturo este sera primo 
        }
        }
        return bandera;
    }
    
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        
        int uno = 4;
        int dos = n-4;

        while(isPrime(dos) || isPrime(uno)){
            dos--;
            uno++;
        }

        System.out.println(uno+"" ""+dos);
        
    }
    
}
",1,0472_A,CODEFORCES,460,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;
	
public class A {
	public static void main(String[] args)
	{
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		s.close();
		
		if (n % 2 == 0)
			System.out.print(""4 "" + (n-4));
		else 
			System.out.print(""9 "" + (n-9));
	}
}
",1,0472_A,CODEFORCES,435,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Solution {
	private BufferedReader cin;
	private PrintWriter cout;
	private StringTokenizer strtok;

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		Solution sol = new Solution();
		final boolean CONTEST = true;
		if (CONTEST) {
			sol.cin = new BufferedReader(new InputStreamReader(System.in));
			sol.cout = new PrintWriter(System.out);

		} else {
			sol.cin = new BufferedReader(new FileReader(""input.txt""));
			sol.cout = new PrintWriter(""output.txt"");
		}
		sol.solve();
		sol.cin.close();
		sol.cout.close();
	}

	private int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(nextToken());
	}

	private String nextToken() throws IOException {
		while (strtok == null || !strtok.hasMoreTokens()) {
			strtok = new StringTokenizer(cin.readLine());
		}
		return strtok.nextToken();
	}

	private void solve() throws IOException {
		int n = nextInt();
		if (n % 2 == 0) {
			cout.println(n - 4 + "" "" + 4);
		} else {
			cout.println(n - 9 + "" "" + 9);
		}
	}

}
",1,0472_A,CODEFORCES,424,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class A {

	public static void main(String[] args) throws IOException {
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
			String input;

			while ((input = reader.readLine()) != null && input.length() > 0) {
				int n = Integer.parseInt(input);
				int start = 4;
				int end = n - start;

				while (start <= end) {
					if ((start % 2 == 0 || start % 3 == 0) && (end % 2 == 0 || end % 3 == 0)) {
						System.out.println(start + "" "" + end);
						break;
					}
					++start;
					--end;
				}
			}
		}
	}
}",1,0472_A,CODEFORCES,421,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.*;
import java.math.*;

public class p472a {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n % 2 == 0) {
            System.out.println(""8 "" + (n - 8));
        } else {
            System.out.println(""9 "" + (n - 9));
        }
    }
}",1,0472_A,CODEFORCES,456,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.PrintStream;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Nipuna Samarasekara
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		FastPrinter out = new FastPrinter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    /////////////////////////////////////////////////////////////

    public void solve(int testNumber, FastScanner in, FastPrinter out) {
    int n=in.nextInt();
        if (n%2==0){
            if (n%4==0)
                out.println(n/2+"" ""+n/2);
            else out.println(6+"" ""+(n-6));

        }
        else{
            out.println(9+"" ""+(n-9));
        }

    }
}

class FastScanner extends BufferedReader {

    public FastScanner(InputStream is) {
        super(new InputStreamReader(is));
    }

    public int read() {
        try {
            int ret = super.read();
//            if (isEOF && ret < 0) {
//                throw new InputMismatchException();
//            }
//            isEOF = ret == -1;
            return ret;
        } catch (IOException e) {
            throw new InputMismatchException();
        }
    }

    static boolean isWhiteSpace(int c) {
        return c >= 0 && c <= 32;
    }

    public int nextInt() {
        int c = read();
        while (isWhiteSpace(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int ret = 0;
        while (c >= 0 && !isWhiteSpace(c)) {
            if (c < '0' || c > '9') {
                throw new NumberFormatException(""digit expected "" + (char) c
                        + "" found"");
            }
            ret = ret * 10 + c - '0';
            c = read();
        }
        return ret * sgn;
    }

    public String readLine() {
        try {
            return super.readLine();
        } catch (IOException e) {
            return null;
        }
    }

}

class FastPrinter extends PrintWriter {

    public FastPrinter(OutputStream out) {
        super(out);
    }

    public FastPrinter(Writer out) {
        super(out);
    }


}

",1,0472_A,CODEFORCES,440,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class Test {
public static void main(String[] args) throws IOException{
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	//StringTokenizer st=new StringTokenizer(bf.readLine());
	int n=Integer.parseInt(bf.readLine());
	
	if(n%2==0) System.out.println(4+"" ""+(n-4));
	else System.out.println(9+"" ""+(n-9));
	
}
}
",1,0472_A,CODEFORCES,459,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.IOException;
import java.util.Scanner;

/**
 * TODO: describe
 *
 * @author keks
 */
public class A {
    public static void main(String[] args) throws IOException {
        final Scanner sc = new Scanner(System.in);
        final int n = sc.nextInt();
        if (n % 2 == 0) {
            System.out.println(4 + "" "" + (n - 4));
        } else {
            System.out.println(9 + "" "" + (n - 9));
        }
    }
}
",1,0472_A,CODEFORCES,444,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;

public class Problem1 {

    public static void main(String[] args) throws IOException {
        // TODO Auto-generated method stub
        
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        long n=Long.parseLong(br.readLine());
        if(n%2==0){
            System.out.println(4+"" ""+(n-4));
        }
        else{
            System.out.println(9+"" ""+(n-9));
        }
        
    }

}
",1,0472_A,CODEFORCES,458,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"
import java.util.Scanner;


public class composite {

  
    public static void main(String[] args) {
        
        Scanner s=new Scanner(System.in);
        int a=s.nextInt();
      
          if(a%2==0)
          {
              a=a-4;
              System.out.println(4+"" ""+a);
          }
          else
          {
              a=a-9;
              System.out.println(9+"" ""+a);
          }
      
    
}
}",1,0472_A,CODEFORCES,427,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class J472A {
	private static Scanner scan = new Scanner(System.in);
	public static void main(String[] args) {
		int a = scan.nextInt();
		if(a % 2 == 0) {
			System.out.println(4 + "" "" + (a - 4));//ż���4
		} else {
			System.out.println(9 + "" "" + (a - 9));//������
		}
	}
}
",1,0472_A,CODEFORCES,447,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
    public static void main (String[] args) throws java.lang.Exception
    {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n%2==0){
            System.out.println(4 + "" "" + (n-4));
        }
        else{
            int a = Math.min(9,n-9);
            int b = Math.max(9,n-9);
            System.out.println(a + "" "" + b);
        }
    }
}",1,0472_A,CODEFORCES,425,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;


public class A470 {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
	Scanner sc = new Scanner(System.in);
	
	int n=sc.nextInt();
	
	int start=4;
	
	
	while(true){
		
		if((start%2==0||start%3==0)&&((n-start)%2==0||(n-start)%3==0))
		{
			System.out.println(start+"" ""+(n-start));
			return;
		}
		else 
		start++;
		
		
		
	}
	
	
		
		
	}
}
",1,0472_A,CODEFORCES,453,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.*;
public class a {
public static void main(String[] args)
{
    Scanner input = new Scanner(System.in);
    int n = input.nextInt();
    if(n%2 == 0) System.out.println(4+"" ""+(n-4));
    else System.out.println(9+"" "" +(n-9));
}
}
",1,0472_A,CODEFORCES,431,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.StringTokenizer;


public class A {
	
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tb;
		int n = Integer.parseInt(br.readLine());
		int x = 0,y=0;
		if(n%2==0){
			x = n-4;
			y = 4;
		}else{
			x = n-9;
			y = 9;
		}
		System.out.println(x+"" ""+y);
	}
}
",1,0472_A,CODEFORCES,454,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class Main 
{   
    public static void main(String[] args) 
    {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        int one, two;
        if(n%2 == 0)
        {
            one = two = n/2;
            if(one%2 != 0 && two%2 != 0)
            {
                one--;
                two++;
            }
        }
        else
        {
            one = n - 9;
            two = 9;
        }
        
        System.out.println(one+"" ""+two);
        
    }
}
",1,0472_A,CODEFORCES,441,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.util.*;

public class A {

	BufferedReader in;
	StringTokenizer st;
	PrintWriter out;

	String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	int nextInt() throws Exception {
		return Integer.parseInt(next());
	}

	long nextLong() throws Exception {
		return Long.parseLong(next());
	}

	double nextDouble() throws Exception {
		return Double.parseDouble(next());
	}

	void solve() throws Exception {
		int n = nextInt();
		if(n%2==0)
			out.println(""4 ""+(n-4));
		else
			out.println(""9 ""+(n-9));
	}

	void run() {
		try {
			Locale.setDefault(Locale.US);
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(new OutputStreamWriter(System.out));
			solve();
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public static void main(String[] args) {
		new A().run();
	}

}
",1,0472_A,CODEFORCES,451,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main
{

	private static BufferedReader in;
	private static BufferedWriter out;

	public static void main(String[] args) throws NumberFormatException, IOException
	{
		// streams
		boolean file = false;
		if (file)
			in = new BufferedReader(new FileReader(""input.txt""));
		else
			in = new BufferedReader(new InputStreamReader(System.in));
		// out = new BufferedWriter(new OutputStreamWriter(System.out));
		out = new BufferedWriter(new FileWriter(""output.txt""));
		StringTokenizer tok;

		int n = Integer.parseInt(in.readLine());
		if (n % 2 == 0)
			System.out.println(4 + "" "" + (n-4));
		else
			System.out.println(9 + "" "" + (n-9));
	}

}",1,0472_A,CODEFORCES,428,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
    public class Main
    {
        public static void main(String[] args)
        {
        Scanner sc =new Scanner(System.in);    
        long a=sc.nextLong();
        if(a%4==0){System.out.println(a/2 + "" "" + a/2);}
        if(a%4==1){System.out.println(9 + "" "" + (a-9));}
        if(a%4==2){System.out.println(6 + "" "" + (a-6));}
        if(a%4==3 && a>15){System.out.println(15 + "" "" + (a-15));}
        if(a==15){System.out.println(""6 9"");}
        
        }
    }
",1,0472_A,CODEFORCES,419,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author bdepwgjqet
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		A solver = new A();
		solver.solve(1, in, out);
		out.close();
	}
}

class A {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int number = in.nextInt();
        if((number & 1) == 0) {
            out.println(4+"" ""+(number-4));
        } else {
            out.println(9+"" ""+(number-9));
        }
    }
}

class InputReader {

    private final BufferedReader bufferedReader;
    private StringTokenizer stringTokenizer;

    public InputReader(InputStream in) {
        bufferedReader = new BufferedReader(new InputStreamReader(in));
        stringTokenizer = null;
    }

    public String nextLine() {
        try {
            return bufferedReader.readLine();
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String nextBlock() {
        while(stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {
            stringTokenizer = new StringTokenizer(nextLine());
        }
        return stringTokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(nextBlock());
    }

    public double nextDouble() {
        return Double.parseDouble(nextBlock());
    }

    public long nextLong() {
        return Long.parseLong(nextBlock());
    }
}

",1,0472_A,CODEFORCES,455,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.util.Scanner;

public class A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n % 2 == 0) {
            System.out.printf(""%d %d"", 4, n - 4);
        } else {
            System.out.printf(""%d %d"", 9, n - 9);
        }
    }
}
",1,0472_A,CODEFORCES,412,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Scanner;
import java.util.StringTokenizer;
import static java.lang.Integer.*;

public class A {

    public static void main(String[] args) throws IOException {
        //BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
        Scanner sc=new Scanner (System.in);
    //  StringTokenizer st=new StringTokenizer(buf.readLine());
        int n=sc.nextInt();
        System.out.println(n%2==0?4+"" ""+(n-4):9+"" ""+(n-9));

    }

}
",1,0472_A,CODEFORCES,417,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory"
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Ahmed
 */




public class Watermelon {

   static class Passengers {
  
     public int floor ;
     public int time;
     
     
     public Passengers( int floor  , int time){
         this.floor =floor;
         this.time =time;
     }
     
}

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        
        Scanner in = new Scanner(System.in);
        
        int x = in.nextInt() , y = in.nextInt();
        
        ArrayList<Passengers> list = new ArrayList<>();
        
        for(int i = 1 ; i <= x ; ++i){
            list.add(new Passengers(in.nextInt(), in.nextInt()));
        }
        
        int sum = 0 ;
       for(int i = list.size() - 1 ; i >= 0 ; --i)
       {
          int s = y -  list.get(i).floor;
          sum = sum + s ; 
          
          if(sum < list.get(i).time)
          {
              sum = sum + ( list.get(i).time - sum);
          }
          
          y = list.get(i).floor;
       } 
        
        
       if( list.get(list.size() - 1).floor != 0){
           sum = sum  + (list.get(0).floor);
       }
        System.out.println(sum);
    }
    
}
",3,0608_A,CODEFORCES,1751,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        int l;
        int r;
        public card(int ch,int i)
        {
            this.l=ch;
            this.r=i;
        }
    }
    static class sort implements Comparator<card>
    {
        public int compare(card o1,card o2)
        {
            if(o1.l!=o2.l)
                return (int)(o1.l-o2.l);
            else
                return (int)(o1.r-o2.r);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }
    static int ans1=Integer.MAX_VALUE,ans2=Integer.MAX_VALUE,ans3=Integer.MAX_VALUE,ans4=Integer.MAX_VALUE;
    static boolean v[]=new boolean[101];
    static void dfs(Integer so,Set<Integer> s[]){
    if(!v[so.intValue()])
    {
    v[so]=true;
    for(Integer h:s[so.intValue()])
    {
    if(!v[h.intValue()])
    dfs(h,s);
    }
    }
    }
    static class Print{
    public PrintWriter out;
    Print(OutputStream o)
    {
    out=new PrintWriter(o);
    }
    }
    static int CeilIndex(int A[], int l, int r, int key) 
    { 
    while (r - l > 1) { 
    int m = l + (r - l) / 2; 
    if (A[m] >= key) 
    r = m; 
    else
    l = m; 
    } 

    return r; 
    } 

    static int LongestIncreasingSubsequenceLength(int A[], int size) 
    { 
    // Add boundary case, when array size is one 
    int[] tailTable = new int[size]; 
    int len; // always points empty slot 
    tailTable[0] = A[0]; 
    len = 1; 
    for (int i = 1; i < size; i++) { 
    if (A[i] < tailTable[0]) 
    // new smallest value 
    tailTable[0] = A[i]; 

    else if (A[i] > tailTable[len - 1]) 
    // A[i] wants to extend largest subsequence 
    tailTable[len++] = A[i]; 

    else
    // A[i] wants to be current end candidate of an existing 
    // subsequence. It will replace ceil value in tailTable 
    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; 
    } 
    return len; 
    }*/
    /*static int binary(int n)
    {
    int s=1;
    while(n>0)
    {
    s=s<<1;
    n--;
    }
    return s-1;
    }
    static StringBuilder bin(int i,int n)
    {
    StringBuilder s=new StringBuilder();
    while(i>0)
    {
    s.append(i%2);
    i=i/2;
    }
    while(s.length()!=n)
    {
    s.append(0);
    }
    return s.reverse();
    }*/
    static boolean valid(int i,int j,int n,int m)
    {
        if(i<n && i>=0 && j<m && j>=0)
            return true;
        else
            return false;
    }

    public static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        int n=sc.nextInt();
        int s=sc.nextInt();
        card c[]=new card[n];
        for(int i=0;i<n;i++)
        {
            int x=sc.nextInt();
            int y=sc.nextInt();
            c[i]=new card(x,y);
        }
        Arrays.sort(c,new sort());
        int time=0;
        for(int i=n-1;i>=0;i--)
        {
            time+=s-c[i].l;
            if((c[i].r-time)>0)
            time+=c[i].r-time;
            s=c[i].l;
        }
        if(c[0].l!=0)
        time+=c[0].l;
        System.out.println(time);
    }
}",4,0608_A,CODEFORCES,2754,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

	public static void main(String[] args) {
		FastReader reader = new FastReader();
		int n = reader.nextInt();
		int s = reader.nextInt();
		int[][] mat = new int[n][2];
		for (int i = 0; i < n; ++i) {
			int j = 0;
			for (String st : reader.nextLine().split(""\\s+""))
				mat[i][j++] = Integer.parseInt(st);
		}
		reader.close();
		int time = s - mat[n - 1][0];
		if (time < mat[n - 1][1])
			time += mat[n - 1][1] - time;
		for (int i = n - 2; i >= 0; --i) {
			time += mat[i + 1][0] - mat[i][0];
			if (time < mat[i][1])
				time += mat[i][1] - time;
		}
		System.out.println(time + mat[0][0]);
	}

	static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine().trim());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine().trim();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

		int[] readArray(int size) {
			int[] ar = new int[size];
			int i = 0;
			try {
				for (String s : br.readLine().trim().split(""\\s+""))
					ar[i++] = Integer.parseInt(s);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return ar;
		}

		void close() {
			try {
				br.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}",3,0608_A,CODEFORCES,1749,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import java.util.Scanner;

public class Main {
    private static final Scanner scanner = new Scanner(System.in);
    private static int OO = (int) 9e6 + 9;
    private static int[] dx = {0, 1, -1, 1};
    private static int[] dy = {1, 0, -1, 1};

    public static void main(String[] args) {
        int n = scanner.nextInt(), s = scanner.nextInt(), r;
        int[][] arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i][0] = scanner.nextInt();
            arr[i][1] = scanner.nextInt();
        }
        r = s - arr[n - 1][0];
        if (r < arr[n - 1][1]) {
            r += (arr[n - 1][1] - r);
        }
        for (int i = n - 2; i >= 0; i--) {
            r += arr[i + 1][0] - arr[i][0];
            if ((arr[i][1]) > r) {
                r += (arr[i][1] - r);
            }
        }
        System.out.println(r + arr[0][0]);
    }

}
",3,0608_A,CODEFORCES,1750,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.StringTokenizer;

public class ChainReaction implements Closeable {

  private InputReader in = new InputReader(System.in);
  private PrintWriter out = new PrintWriter(System.out);
  
  private class Beacon implements Comparable<Beacon> {
    private int position, range, score;

    private Beacon(int position, int range) {
      this.position = position;
      this.range = range;
    }

    public void setScore(int score) {
      this.score = score;
    }

    @Override
    public int compareTo(Beacon o) {
      return Integer.compare(this.position, o.position);
    }
  }

  public void solve() {
    int n = in.ni();
    if (n == 1) {
      out.println(0);
      return;
    }
    beacons = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      beacons.add(new Beacon(in.ni(), in.ni()));
    }
    beacons.sort(Comparator.naturalOrder());
    for (int i = 1; i < n; i++) {
      int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;
      int leftmost = i;
      while (left <= right) {
        int mid = left + (right - left) / 2;
        if (position - range <= beacons.get(mid).position) {
          leftmost = Math.min(leftmost, mid);
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      beacons.get(i).setScore(i - leftmost);
    }
    dp = new Integer[n];
    int ans = Integer.MAX_VALUE;
    for (int i = n - 1; i >= 0; i--) {
      ans = Math.min(n - 1 - i + recurse(i), ans);
    }
    out.println(ans);
  }
  
  private List<Beacon> beacons;
  private Integer[] dp;
  
  private int recurse(int idx) {
    if (idx <= 0) return 0;
    
    if (dp[idx] != null) return dp[idx];
    
    int destroyed = beacons.get(idx).score;
    int ans = destroyed + recurse(idx - destroyed - 1);
    return dp[idx] = ans;
  }
  
  @Override
  public void close() throws IOException {
    in.close();
    out.close();
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int ni() {
      return Integer.parseInt(next());
    }

    public long nl() {
      return Long.parseLong(next());
    }

    public void close() throws IOException {
      reader.close();
    }
  }

  public static void main(String[] args) throws IOException {
    try (ChainReaction instance = new ChainReaction()) {
      instance.solve();
    }
  }
}
",4,0608_C,CODEFORCES,2755,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.util.Scanner;

public class ChainReaction {
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        int num = scan.nextInt();
        int m = 1000001;
        int[] b = new int[m];
        for (int i = 0; i < num; i++){
            int p = scan.nextInt();
            b[p] = scan.nextInt();
        }
        int [] dp = new int[m];
        if (b[0] > 0){
            dp[0] = 1;
        }
        int max = 0;
        for (int i = 1; i < m; i++){
            if (b[i] == 0){
                dp[i] = dp[i-1];
            }
            else if (b[i] >= i){
                dp[i] = 1;
            }
            else {
                dp[i] = dp[i - b[i] - 1] + 1;
            }

            if (dp[i] > max){
                max = dp[i];
            }
        }

        System.out.println(num - max);
        scan.close();
    }
}
",3,0608_C,CODEFORCES,1760,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.util.Scanner;

public class ChainReaction {
	
	public static void main(String [] args) {
		Scanner kb = new Scanner(System.in);
		int num = kb.nextInt();
		
		int[] beacons = new int[1000002];
		for (int i=0; i<num; i++) {
			beacons[kb.nextInt()] = kb.nextInt();
		}
		
		int [] dp = new int[1000002];
		int max = 0;
		if (beacons[0] != 0)
			dp[0] = 1;
		
		for (int i=1; i<dp.length; i++) {
			if (beacons[i] == 0) {
				dp[i] = dp[i-1];
			} else {
				int index = i-1-beacons[i];
				if (index<0)
					dp[i] = 1;
				else
					dp[i] = 1 + dp[index];
			}
			max = Math.max(max, dp[i]);
			//if (i<11)
				//System.out.println(i +"" is ""+dp[i]);
		}
		
		System.out.println(num-max);
	}

}
",3,0608_C,CODEFORCES,1764,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.util.Scanner;

public class codef8 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int beacon[] = new int[1000001];
		int pos[] = new int[num];
		for (int i = 0; i < num; i++) {
			int position = sc.nextInt();
			beacon[position] = sc.nextInt();
			pos[i] = position;
		}
		int dp[] = new int[1000001];
		int max = 1;
		if (beacon[0] != 0)
			dp[0] = 1;
		
		for (int i = 1; i <= 1000000; i++) {
			if (beacon[i] == 0) {
				dp[i] = dp[i-1];
			} 
			else {
				int j = i - beacon[i] - 1;
				if (j < 0) {
					dp[i] = 1;
				}
				else {
					dp[i] = dp[j] + 1;
				}
			}
			max = Math.max(max, dp[i]);
		}		
		System.out.println(num-max);
	}

}
",3,0608_C,CODEFORCES,1763,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.util.Scanner;

public class codef8 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int beacon[] = new int[1000001];
		int pos[] = new int[num];
		for (int i = 0; i < num; i++) {
			int position = sc.nextInt();
			beacon[position] = sc.nextInt();
			pos[i] = position;
		}
		int dp[] = new int[1000001];
		int max = 0;
		if (beacon[0] != 0)
			dp[0] = 1;
		
		for (int i = 1; i <= 1000000; i++) {
			if (beacon[i] == 0) {
				dp[i] = dp[i-1];
			} 
			else {
				int j = i - beacon[i] - 1;
				if (j < 0) {
					dp[i] = 1;
				}
				else {
					dp[i] = dp[j] + 1;
				}
			}
			max = Math.max(max, dp[i]);
		}		
		System.out.println(num-max);
	}

}
",3,0608_C,CODEFORCES,1762,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"// Don't place your source in a package
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;






// Please name your class Main
public class Main {
    static Scanner in = new Scanner(System.in);
    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(System.out);

        int T=1;
        for(int t=0;t<T;t++){
            int n=Int();
            int A[][]=new int[n][2];


            for(int i=0;i<n;i++){
                A[i][0]=Int();
                A[i][1]=Int();
            }

            Solution sol=new Solution();
            sol.solution(out,A);

        }
        out.flush();

    }

    public static long Long(){
        return in.nextLong();
    }
    public static int Int(){
        return in.nextInt();
    }
    public static String Str(){
        return in.next();
    }
}


class Solution{
    int dp[];
    TreeMap<Integer,Integer>tree=new TreeMap<>();
    public void solution(PrintWriter out,int A[][]){
        int res=Integer.MIN_VALUE;
        int n=A.length;
        Arrays.sort(A,(a,b)->{
            return a[0]-b[0];
        });
        dp=new int[n];
        Arrays.fill(dp,-1);

        for(int i=0;i<A.length;i++){
            tree.put(A[i][0],i);
        }


        for(int i=0;i<A.length;i++){
            res=Math.max(res,1+dfs(A,i));
        }
        System.out.println((n+1)-res);
    }

    public int dfs(int A[][],int i){
        if(dp[i]!=-1){
            return dp[i];
        }

        int pos=A[i][0];
        int pow=A[i][1];



        Integer floor=tree.floorKey(pos-pow-1);
        int res=1;
        if(floor==null){

        }
        else{
            res+=dfs(A,tree.get(floor));
        }
        dp[i]=res;
        return res;
    }

}

",3,0608_C,CODEFORCES,1759,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
public class BOOL {
    static char [][]ch;
    static int n,m;
private static FastReader in =new FastReader();
    public static void main(String[] args) {
    int n=in.nextInt();
    int a[]=new int[1000002];
    int dp[]=new int[1000002],ans=0;
    for(int i=0;i<n;i++){a[in.nextInt()]=in.nextInt();}
    dp[0]=a[0]==0?0:1;
    for(int i=1;i<1000002;i++){
    if(a[i]==0){dp[i]=dp[i-1];}
    else{
    if(a[i]>=i){dp[i]=1;}
    else{
    dp[i]=dp[i-a[i]-1]+1;
    }}
    if(dp[i]>=ans)ans=dp[i];
    }
        System.out.println(n-ans);
    }}
class FastReader
    {
        BufferedReader br;
        StringTokenizer st;
 
        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }
 
        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int nextInt()
        {
            return Integer.parseInt(next());
        }
 
        long nextLong()
        {
            return Long.parseLong(next());
        }
 
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
 
        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
}
",3,0608_C,CODEFORCES,1761,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import javafx.util.Pair;

import java.io.*;
import java.util.*;

public class Beacon8 {
    public static void main(String[] args) throws IOException {
//        int[] arr = {1, 3, 7, 18};
//        int bIndex = Arrays.binarySearch(arr, 4);
//        System.out.println(bIndex);


        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        Map<Integer, Integer> beacons = new TreeMap<>();

        for (int i = 0; i < n; i++) {
            int index = scan.nextInt();
            int power = scan.nextInt();
            beacons.put(index, power);
        }
        int[] indicesArr = new int[n];
        int arrInd = 0;
        for (int index : beacons.keySet()) {
            indicesArr[arrInd] = index;
            arrInd++;
        }
       // Integer[] indicesArr = ((Integer[])beacons.keySet().toArray());
        int[] nDestroys = new int[n];
        for (int i = 0; i < n; i++) {
            int bIndex = Arrays.binarySearch(indicesArr, indicesArr[i] - beacons.get(indicesArr[i]));
            if (bIndex < 0)
                bIndex = -(bIndex + 1);
            nDestroys[i] = i - bIndex;
        }
        int[] totalBeacons = new int[n];
        int maxBeacons = 1;
        totalBeacons[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nDestroys[i] == 0)
                totalBeacons[i] = totalBeacons[i - 1] + 1;
            else {
                if ((i - nDestroys[i] - 1) >= 0)
                    totalBeacons[i] = totalBeacons[i - nDestroys[i] - 1] + 1;
                else
                    totalBeacons[i] = 1;
            }
               // totalBeacons[i] = totalBeacons[i - nDestroys[i]] + 1;
            //totalBeacons[i] = i - nDestroys[i] + totalBeacons[i - nDestroys[i]] + 1;
            if(totalBeacons[i] > maxBeacons)
                maxBeacons = totalBeacons[i];
        }
//        System.out.println(""\ntotalBeacons array"");
//        for (int i = 0; i < n; i++) {
//            System.out.print(totalBeacons[i] + "" "");
//        }
//        if (maxBeacons == -1)
//            System.out.println(n);
        System.out.println(n - maxBeacons);
    }

}
",4,0608_C,CODEFORCES,2756,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp
"import java.util.Scanner;

import java.io.*;

import java.util.*;

import java.math.*;

import java.lang.*;

import static java.lang.Math.*;



public class main implements Runnable{



    static ArrayList <Integer> adj[];

    static int co=0,f=0;



    static void Check2(int n){

        adj=new ArrayList[n+1];

        for(int i=0;i<=n;i++){

            adj[i]=new ArrayList<>();

        }



    }

    static void add(int i,int j){



        adj[i].add(j);

        adj[j].add(i);

    }

    public static void main(String[] args)  {

        new Thread(null, new main(), ""Check2"", 1<<26).start();// to increse stack size in java

    }

    static long mod=(long)(1e9+7);

    public void run() {

        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */

        //Scanner in=new Scanner(System.in);



        InputReader in = new InputReader(System.in);

        PrintWriter w = new PrintWriter(System.out);







       long n=in.nextLong();

        long s=in.nextLong();

        

        long l=1;

        long r=(long)(n);

       long ans=-1;

        while(l<=r){

            

            long mid=(l+r)/2;

            if(ch(mid,s)){

                ans=mid;

                r=mid-1;

            }

            else

            {

                l=mid+1;

            }

            

        }

        if(ans==-1)w.println(0);

        else

            w.println(n-ans+1);

        w.close();

    }

        public boolean ch(long a,long s){

            

            long p=0;

            long val=a;

            while(val>0){

                p=p+val%10;

                val=val/10;

            }

            if(a-p>=s)return true;

            return false;

            

        }

    public boolean rec(int a,int b,int x,int y,int c,int d,int co){



        if(a>x|b>y)return false;



        if(a<-100000||b<-100000||co>100000)return false;



        if(a==x&&b==y)return true;







        return (rec(a+c,b+d,x,y,c,d,co+1)||rec(a+c,b-d,x,y,c,d,co+1)||rec(a-c,b+d,x,y,c,d,co+1)||rec(a-c,b-d,x,y,c,d,co+1));







    }







    static  int gcd(int a,int b){



        if(b==0)return a;

        return gcd(b,a%b);

    }

    static  void dfs(int i,int v[],int val,int b[]){





        if(v[i]==1)return ;



        v[i]=1;

        b[i]=val;



        Iterator <Integer> it=adj[i].iterator();

        while(it.hasNext()){

            int q=it.next();

            dfs(q,v,val,b);

        }











    }



    static  void sev(int a[],int n){



        for(int i=2;i<=n;i++)a[i]=i;

        for(int i=2;i<=n;i++){



            if(a[i]!=0){

                for(int j=2*i;j<=n;){



                    a[j]=0;

                    j=j+i;

                }

            }



        }



    }



    static class pair implements Comparable<pair> {



        int x,y;

        pair(int c,int d){

            x=c;

            y=d;

        }



        public int compareTo(pair o){



            return (this.x-o.x);   //sort in incrementing order w.r.t to c

        }







    }



    static class node{



        int y;

        int val;



        node(int a,int b){



            y=a;

            val=b;



        }





    }

    static  void rec(String s,int a,int b,int n){



        if(b==n){

            System.out.println(s);

            return ;

        }

        String p=s;

        if(a>b){

            s=p+"")"" ;

            rec(s,a,b+1,n);

        }

        if(a<n){

            s=p+""("";

            rec(s,a+1,b,n);

        }









    }



    static class InputReader

    {

        private InputStream stream;

        private byte[] buf = new byte[1024];

        private int curChar;

        private int numChars;

        private SpaceCharFilter filter;



        public InputReader(InputStream stream)

        {

            this.stream = stream;

        }



        public int read()

        {

            if (numChars==-1)

                throw new InputMismatchException();



            if (curChar >= numChars)

            {

                curChar = 0;

                try

                {

                    numChars = stream.read(buf);

                }

                catch (IOException e)

                {

                    throw new InputMismatchException();

                }



                if(numChars <= 0)

                    return -1;

            }

            return buf[curChar++];

        }



        public String nextLine()

        {

            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));

            String str = """";

            try

            {

                str = br.readLine();

            }

            catch (IOException e)

            {

                e.printStackTrace();

            }

            return str;

        }

        public int nextInt()

        {

            int c = read();



            while(isSpaceChar(c))

                c = read();



            int sgn = 1;



            if (c == '-')

            {

                sgn = -1;

                c = read();

            }



            int res = 0;

            do

            {

                if(c<'0'||c>'9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));



            return res * sgn;

        }



        public long nextLong()

        {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-')

            {

                sgn = -1;

                c = read();

            }

            long res = 0;



            do

            {

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));

            return res * sgn;

        }



        public double nextDouble()

        {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-')

            {

                sgn = -1;

                c = read();

            }

            double res = 0;

            while (!isSpaceChar(c) && c != '.')

            {

                if (c == 'e' || c == 'E')

                    return res * Math.pow(10, nextInt());

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            if (c == '.')

            {

                c = read();

                double m = 1;

                while (!isSpaceChar(c))

                {

                    if (c == 'e' || c == 'E')

                        return res * Math.pow(10, nextInt());

                    if (c < '0' || c > '9')

                        throw new InputMismatchException();

                    m /= 10;

                    res += (c - '0') * m;

                    c = read();

                }

            }

            return res * sgn;

        }



        public String readString()

        {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            StringBuilder res = new StringBuilder();

            do

            {

                res.appendCodePoint(c);

                c = read();

            }

            while (!isSpaceChar(c));



            return res.toString();

        }



        public boolean isSpaceChar(int c)

        {

            if (filter != null)

                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }



        public String next()

        {

            return readString();

        }



        public interface SpaceCharFilter

        {

            public boolean isSpaceChar(int ch);

        }

    }















}",2,0817_C,CODEFORCES,1073,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.IOException;

import java.io.InputStream;

import java.util.InputMismatchException;



public class ques3 {

	static class InputReader {

        private InputStream stream;

        private byte[] buf = new byte[1024];

        private int curChar;

        private int numChars;

        private SpaceCharFilter filter;

 

        public InputReader(InputStream stream) {

            this.stream = stream;

        }

 

        public static boolean isWhitespace(int c) {

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }

 

        public int read() {

            if (numChars == -1) {

                throw new InputMismatchException();

            }

            if (curChar >= numChars) {

                curChar = 0;

                try {

                        numChars = stream.read(buf);

                } catch (IOException e) {

                        throw new InputMismatchException();

                }

                if (numChars <= 0) {

                        return -1;

                }

            }

            return buf[curChar++];

        }

 

        public boolean isSpaceChar(int c) {

            if (filter != null) {

                return filter.isSpaceChar(c);

            }

            return isWhitespace(c);

        }

 

        public interface SpaceCharFilter {

 

            public boolean isSpaceChar(int ch);

        }

 

        public String next() {

            return nextString();

        }

        

        public char nextChar(){

        	int c=read();

        	while (isSpaceChar(c)) {

                c = read();

            }

        	return (char)c;

        }

 

        public String nextString() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            StringBuilder res = new StringBuilder();

            do {

                res.appendCodePoint(c);

                c = read();

            } while (!isSpaceChar(c));

            return res.toString();

        }

 

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            int res = 0;

            do {

                if (c < '0' || c > '9') {

                    throw new InputMismatchException();

                }

                res *= 10;

                res += c - '0';

                c = read();

            } while (!isSpaceChar(c));

            return res * sgn;

        }

 

        public Long nextLong() {

            return Long.parseLong(nextString());

        }

 

        public Double nextDouble() {

            return Double.parseDouble(nextString());

        }

    }



	public static void main(String[] args) {

		InputReader sc=new InputReader(System.in);

		long n=sc.nextLong();

		long s=sc.nextLong();

		

		long start=0,end=n;

		while(start<end)

		{

			long mid=(start+end)/2;

			if(func(mid)>=s)

				end=mid;

			else 

				start=mid+1;

		}

		if(func(start)>=s)

			System.out.println(n-start+1);

		else

			System.out.println(0);

	}

	

	public static long func(long n)

	{

		long temp=n;

		int sum=0;

		while(temp>0)

		{

			sum+=temp%10;

			temp/=10;

		}

		return n-sum;

	}

}",2,0817_C,CODEFORCES,1075,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

// import java.io.FileInputStream;

// import java.io.FileOutputStream;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.ArrayList;

import java.util.Collections;

import java.util.Random;

import java.util.StringTokenizer;



import static java.lang.Math.*;

import static java.util.Arrays.copyOf;

import static java.util.Arrays.fill;

import static java.util.Arrays.sort;

import static java.util.Collections.reverseOrder;

import static java.util.Collections.sort;



public class Main {

    private FastScanner in;

    private PrintWriter out;



    private void solve() throws IOException {

        solveC();

    }



    private void solveA() throws IOException {

        int x1 = in.nextInt(), y1 = in.nextInt();

        int x2 = in.nextInt(), y2 = in.nextInt();

        int dx = abs(x1 - x2), dy = abs(y1 - y2);

        int x = in.nextInt(), y = in.nextInt();

        out.print((dx % (2 * x) == 0 && dy % (2 * y) == 0) ||

                (dx % (2 * x) == x && dy % (2 * y) == y) ? ""YES"" : ""NO"");

    }



    private void solveB() throws IOException {

        int n = in.nextInt();

        int[] a = new int[n];

        for (int i = 0; i < n; i++) {

            a[i] = in.nextInt();

        }



        shuffle(a);

        sort(a);



        int have = 0;

        for (int i = 0; i < n; i++) {

            if (a[i] == a[2]) {

                have++;

            }

        }



        long ans = 1;

        for (int i = 0; i < (a[1] == a[2] ? a[0] == a[2] ? 3 : 2 : 1); i++) {

            ans = ans * (have - i) / (i + 1);

        }

        out.print(ans);

    }



    private void shuffle(int[] a) {

        int b;

        Random r = new Random();

        for (int i = a.length - 1, j; i > 0; i--) {

            j = r.nextInt(i + 1);

            b = a[j];

            a[j] = a[i];

            a[i] = b;

        }

    }



    private void solveC() throws IOException {

        long n = in.nextLong(), s = in.nextLong();

        long l = 0, mid, r = Long.MAX_VALUE / 2;

        while (l + 1 < r) {

            mid = (l + r) / 2;

            if (mid - sum(mid) >= s)

                r = mid;

            else

                l = mid;

        }

        out.print(max(0, n - r + 1));

    }



    private long sum(long n) {

        long sum = 0;

        for (char c : Long.toString(n).toCharArray())

            sum += c - '0';

        return sum;

    }



    private void solveD() throws IOException {



    }



    private void solveE() throws IOException {



    }



    private void solveF() throws IOException {



    }



    class FastScanner {

        StringTokenizer st;

        BufferedReader br;



        FastScanner(InputStream s) {

            br = new BufferedReader(new InputStreamReader(s));

        }



        String next() throws IOException {

            while (st == null || !st.hasMoreTokens())

                st = new StringTokenizer(br.readLine());

            return st.nextToken();

        }



        boolean hasNext() throws IOException {

            return br.ready() || (st != null && st.hasMoreTokens());

        }



        int nextInt() throws IOException {

            return Integer.parseInt(next());

        }



        long nextLong() throws IOException {

            return Long.parseLong(next());

        }



        double nextDouble() throws IOException {

            return Double.parseDouble(next().replace(',', '.'));

        }



        String nextLine() throws IOException {

            return br.readLine();

        }



        boolean hasNextLine() throws IOException {

            return br.ready();

        }

    }



    private void run() throws IOException {

        in = new FastScanner(System.in); // new FastScanner(new FileInputStream("".in""));

        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream("".out""));



        solve();



        out.flush();

        out.close();

    }



    public static void main(String[] args) throws IOException {

        new Main().run();

    }

}

",2,0817_C,CODEFORCES,1117,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class ProblemC {

    public static int sumDigits(long number) {

        int count = 0;



        while (number > 0) {

            count += number % 10;

            number /= 10;

        }



        return count;

    }



    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        long n = scanner.nextLong();

        long s = scanner.nextLong();

        long lowerBorder = 1;

        long upperBorder = n;

        long x = (lowerBorder + upperBorder) / 2;



        while (lowerBorder <= upperBorder) {

            long sumDigits = sumDigits(x);



            if ((x - sumDigits) >= s) {

                upperBorder = x - 1;

            } else {

                lowerBorder = x + 1;

            }



            x = (lowerBorder + upperBorder) / 2;

        }



        System.out.println(n - x);

    }

}",2,0817_C,CODEFORCES,1115,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class CF817C {
    public static void main(String[] args) throws IOException {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(countBigNums(sc.nextLong(), sc.nextLong()));
        pw.flush();
    }

    static long countBigNums(long n, long s) {
        long lo = 1, hi = (long) 1e18;
        while (lo <= hi) {
            long mid = (lo + hi) / 2;
            long v = mid - sumDigits(mid);
            if (v >= s)
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return Math.max(0, n - lo + 1);
    }

    static int sumDigits(long v) {
        return String.valueOf(v).chars().map(Character::getNumericValue).sum();
    }

    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;

        public FastScanner() {
            this.in = new BufferedReader(new InputStreamReader(System.in));
        }

        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public long nextLong() {
            return Long.parseLong(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        public void close() throws IOException {
            in.close();
        }
    }
}
",2,0817_C,CODEFORCES,1056,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;

import java.io.*;

import java.util.*;

public class ReallyBigNumbers817c {

     static long sd(String s) {

        long c = 0;

        for (int i = 0; i < s.length(); i++) {

            c += s.charAt(i);

        }

        return c - s.length() * 0x30;

    }

     

    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

        long n = in.nextLong();

        long s = in.nextLong(); // number

         // level -- > (n + 8) / 9 * 9; --- > s

        long i = (s/10+1)*10 ;

        if (n<10||n-sd(n+"""")<s) {

            System.out.println(0);

            return;

        }

        while(!(i-sd(i+"""")>=s)){

        i+=10;

        

        }

        System.out.println(n-i+1);

       

    }

    

	}



",2,0817_C,CODEFORCES,1094,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class CF817C {
    public static void main(String[] args) throws IOException {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(countBigNums(sc.nextLong(), sc.nextLong()));
        pw.flush();
    }

    static long countBigNums(long n, long s) {
        long lo = 1, hi = n;
        while (lo <= hi) {
            long mid = (lo + hi) / 2;
            long v = mid - sumDigits(mid);
            if (v >= s)
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return n - lo + 1;
    }

    static int sumDigits(long v) {
        return String.valueOf(v).chars().map(Character::getNumericValue).sum();
    }

    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;

        public FastScanner() {
            this.in = new BufferedReader(new InputStreamReader(System.in));
        }

        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public long nextLong() {
            return Long.parseLong(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        public void close() throws IOException {
            in.close();
        }
    }
}
",2,0817_C,CODEFORCES,1057,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.*;

public class ed817Q3 {
	public static void main(String[] args){
		InputReader in = new InputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		int t = 1;
		for(int zxz=0;zxz<t;zxz++){
			// my code starts here
			long n = in.nextLong();
			long s = in.nextLong();
			long start=s,end=n;
			long ans=n+1;
			while(start<=end){
				long mid = start+(end-start)/2;
				if(mid-digitSum(mid)>=s){
					ans = mid;
					end = mid-1;
				}
				else{
					start=mid+1;
				}
			}
			System.out.println(n-ans+1);
			// my code ends here
		}
	}
	static int digitSum(long n){
		int sum=0;
		while(n>0){
			sum+=n%10;
			n=n/10;
		}
		return sum;
	}
	static class InputReader {
		 
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;
 
        public InputReader(InputStream stream) {
            this.stream = stream;
        }
 
        public int snext() {
            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar >= snumChars) {
                curChar = 0;
                try {
                    snumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }
 
        public int nextInt() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public long nextLong() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public int[] nextIntArray(int n) {
            int a[] = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }
 
        public String readString() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = snext();
            } while (!isSpaceChar(c));
            return res.toString();
        }
 
        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
 
        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}
",2,0817_C,CODEFORCES,1084,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jenish
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        CReallyBigNumbers solver = new CReallyBigNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class CReallyBigNumbers {
        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            long n = in.scanLong();
            long sum = in.scanLong();
            long low = 1;
            long high = n;
            long index = -1;
            while (low <= high) {
                long mid = (low + high) / 2;
                if (mid - getsum(mid) >= sum) {
                    index = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            if (index == -1) {
                out.println(0);
            } else {
                out.println(n - index + 1);
            }
        }

        long getsum(long n) {
            long s = 0;
            while (n > 0) {
                s += n % 10;
                n /= 10;
            }
            return s;
        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int INDEX;
        private BufferedInputStream in;
        private int TOTAL;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (INDEX >= TOTAL) {
                INDEX = 0;
                try {
                    TOTAL = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (TOTAL <= 0) return -1;
            }
            return buf[INDEX++];
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

        public long scanLong() {
            long I = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    I *= 10;
                    I += n - '0';
                    n = scan();
                }
            }
            return neg * I;
        }

    }
}

",2,0817_C,CODEFORCES,1129,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.Stack;




public class Main{
	public static class FastReader {
		BufferedReader br;
		StringTokenizer root;
		
 
		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
 
		String next() {
			while (root == null || !root.hasMoreTokens()) {
				try {
					root = new StringTokenizer(br.readLine());
				} catch (Exception r) {
					r.printStackTrace();
				}
			}
			return root.nextToken();
		}
 
		int nextInt() {
			return Integer.parseInt(next());
		}
 
		double nextDouble() {
			return Double.parseDouble(next());
		}
 
		long nextLong() {
			return Long.parseLong(next());
		}
 
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (Exception r) {
				r.printStackTrace();
			}
			return str;
		}
	}
	
	public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));
	static int mod = (int) (1e9+7);
	static long cf = 998244353;
    static final long MAX = (long) 1e9;
    public static List<Integer>[] edges;
    public static int[][] parent;
    public static int col = 32;
    public static int[] Bit;
    public static long[] dp;
    public static long[] fac,inv;
	public static void main(String[] args) {
	
	FastReader sc = new FastReader();
	
	long n = sc.nextLong();
	long s = sc.nextLong();
	int d = 9 * 18;
	long ans;
	if (n >= s + d) {
		ans = n - s - d;
		for (long x = s; x <= s + d; x++)
			if (check(x, s))
				ans++;
	} else {
		ans = 0;
		for (long x = s; x <= n; x++)
			if (check(x, s))
				ans++;
	}
	out.println(ans);
	out.close();

	}
	private static boolean check(long x, long s) {
		long n = x;
		long sum = 0;
		while(n>0) {
			sum+=n%10;
			n/=10;
		}
		return x-sum>=s;
	}
	
	
}
		 	   				     	    	 			 				",2,0817_C,CODEFORCES,1135,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;

public class Really_Big_Numbers {
	static long sum(long x) {
		String s=""""+x;
		long r=0;
		for(int i=0;i<s.length();i++) {
			r+=Integer.parseInt(""""+s.charAt(i));
		}
		return r;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		long n=sc.nextLong();
		long  s=sc.nextLong();
		long r=0;
//		10<=x<=n     x-sum>=s
		long st=Math.max(10, s);
		for(long i=st;i<=n;i++) {
			if(i-sum(i)>=s) {
				r+=n-i+1;
//				System.out.println(i);
				break;	
			}
			else {
				i=((i/10)+1)*10-1;
			}
		}
		System.out.println(r);
	}
}
",2,0817_C,CODEFORCES,1126,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.util.Scanner;
import java.io.*;
import javax.lang.model.util.ElementScanner6; 
import static java.lang.System.out;
import java.util.Stack;
import java.util.Queue;
import java.util.LinkedList;

public class C817
{

   static int mod=(int)(1e9+7);
   static long MOD=(long)(1e9+7);
   static FastReader in=new FastReader();
   static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
    public static void main(String args[])
    {  

        int tc=1;
     
        //tc=in.nextInt();
        tcloop: while(tc-->0)
        {
            
        	long n=in.nextLong();
        	long s=in.nextLong();
        	
        	long start=s+1;
        	int f=0;
        	while(start<=n)
        	{
				long sum=0;
				long t=start;
				while(t>0)
				{
					sum+=t%10;
					t/=10;
					
				}
				//pr.println(sum);
				if(start-sum>=s)
				{
					f=1;
					break;
				}
				start++;
				
			}

			if(f==1)
			pr.println(n-start+1);
			
			else pr.println(0);

        }
        pr.flush();
    }


    

    static void sort(long[] a) {
		ArrayList<Long> l = new ArrayList<>();
		for (long i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
	}
    
    
	static void sort(int[] a) {
		ArrayList<Integer> l = new ArrayList<>();
		for (int i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
    }

    
    static class FastReader
    { 
        BufferedReader br; 
        StringTokenizer st; 

        public FastReader() 
        { 
            br = new BufferedReader(new InputStreamReader(System.in)); 
        } 

        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 

        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 

        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 

        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
        
        int[] readIntArray(int n)
        {
		int a[]=new int[n];
		for(int i=0;i<n;i++)a[i]=nextInt();
		return a;
	}
		
	long[] readLongArray(int n)
	{
		long a[]=new long[n];
		for(int i=0;i<n;i++)a[i]=nextLong();
		return a;
	}
	
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
}


",2,0817_C,CODEFORCES,1049,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
public class main {
	public static void main(String[] args) {
		Scanner kb=new Scanner(System.in);
		while(kb.hasNext()){
			long a=kb.nextLong();
			long b=kb.nextLong();
			if(a<b){
				System.out.println(0);
			}else{
				int n=0;
				long i=0;
				for (i = b; i <= a; i++) {
					int sum=0;
					long aa=i;
					while(aa!=0){
						sum=(int) (sum+aa%10);
						aa=aa/10;
					}
					
					if(i-sum>=b){
						if(i%10==9){
							break;
						}
						n++;
					}
				}
				System.out.println(n+a-i+1);
			}
		}
	}
}

 		 					    		 		  	 			 				",2,0817_C,CODEFORCES,1108,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

import java.lang.*;

import java.io.*;



public class Main

{

	static class InputReader{

		private InputStream stream;

		private byte[] buf = new byte[1024];

		private int curChar;

		private int numChars;

		private SpaceCharFilter filter;

 

		public InputReader(InputStream stream) {

			this.stream = stream;

		}

 

		public int read() {

			if (numChars == -1)

				throw new InputMismatchException();

			if (curChar >= numChars) {

				curChar = 0;

				try {

					numChars = stream.read(buf);

				} catch (IOException e) {

					throw new InputMismatchException();

				}

				if (numChars <= 0)

					return -1;

			}

			return buf[curChar++];

		}

 

		public int readInt() {

			int c = read();

			while (isSpaceChar(c))

				c = read();

			int sgn = 1;

			if (c == '-') {

				sgn = -1;

				c = read();

			}

			int res = 0;

			do {

				if (c < '0' || c > '9')

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = read();

			} while (!isSpaceChar(c));

			return res * sgn;

		}

 

		public String readString() {

			int c = read();

			while (isSpaceChar(c))

				c = read();

			StringBuilder res = new StringBuilder();

			do {

				res.appendCodePoint(c);

				c = read();

			} while (!isSpaceChar(c));

			return res.toString();

		}

 

		public boolean isSpaceChar(int c) {

			if (filter != null)

				return filter.isSpaceChar(c);

			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

		}

 

		public String next() {

			return readString();

		}

 

		public interface SpaceCharFilter {

			public boolean isSpaceChar(int ch);

		}

	}

	

 

static class OutputWriter {

		private final PrintWriter writer;

 

		public OutputWriter(OutputStream outputStream) {

			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));

		}

 

		public OutputWriter(Writer writer) {

			this.writer = new PrintWriter(writer);

		}

 

		public void print(Object...objects) {

			for (int i = 0; i < objects.length; i++) {

				if (i != 0)

					writer.print(' ');

				writer.print(objects[i]);

			}

		}

 

		public void printLine(Object...objects) {

			print(objects);

			writer.println();

		}

 

		public void close() {

			writer.close();

		}

 

		public void flush() {

			writer.flush();

		}

 

		}

 

    static class IOUtils {

 

		public static int[] readIntArray(InputReader in, int size) {

			int[] array = new int[size];

			for (int i = 0; i < size; i++)

				array[i] = in.readInt();

			return array;

		}

    }

    static long n, k;

    static OutputWriter out;

    static InputReader in;

    static int[] a;

    public static void main (String[] args) throws java.lang.Exception

	{

	    out = new OutputWriter(System.out);

		in = new InputReader(System.in);

        n = Long.parseLong(in.readString());

        k = Long.parseLong(in.readString());

        long low = 1; long high = n+1;

        long sum = get(n);

        if(sum<k)out.printLine(0); 

        else {

            while(low < high){

            long mid = (low+high)/2;

            long sum1 = get(mid); long sum2 = get(mid-1); long sum3 = get(mid+1);

            if(sum1>=k && (sum2<k||mid==1)){out.print(n-mid+1); break;}

            else if(sum1<k && sum3>=k){out.print(n-mid); break;}

            else if(sum1>=k)high = mid;

            else if(sum1<k)low = mid+1;

            }

        }

        out.flush();

        out.close();

	}

	

	public static long get(long mid){

	    long x = mid;

	    long t = 0;

	    while(x>0){t+=x%10; x/=10;}

	    return mid-t;

	}

	public static long count(int j){

	    long sum = 0; int i = j;

	    while(i<n && a[i++]==a[j])sum++;

	    return sum;

	}

	

	public static int function(){

	    int min = Integer.MAX_VALUE;

	    int sum = 0;

	    int index = 0;

	    for(int i=0; i<n; i++){if(min>a[i]){min=a[i]; index = i; sum=0;} else if(min==a[i])sum++;}

	    a[index] = Integer.MAX_VALUE;

	    if(sum>=3)return (sum*(sum-1)*(sum-2))/3;

	    return sum;

	}

	

	public static void add(int index, int value, int[] b){

	    while(index < b.length){

	        b[index] += value;

	        index = index + (index & (-index));

	    }

	}

	

	public static int getSum(int index, int [] b){

	    int sum = 0;

	    while(index > 0){

	        sum += b[index];

	        index = index - (index&(-index));

	    }

	    return sum;

	}

	

	public static void printArray(int[] a){

	    for(int i=1; i<a.length; i++)out.print(a[i]+"" "");

	    out.printLine(""---------"");

	}

	

	static class Pair implements Comparable<Pair>{

	    int s;

	    //int d;

	    int len;

	    public Pair(int a, int c){

	        s = a; len = c;

	    }

	    public int compareTo(Pair p){

	        if(this.len > p.len)return 1;

	        else if(this.len < p.len)return -1;

	        return 0;

	    }

	}

}",2,0817_C,CODEFORCES,1101,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class CodeforcesC {



	public static void main(String[] args) {

		Scanner ob = new Scanner(System.in);

		long n = ob.nextLong();

		long s = ob.nextLong();

		long l = 1;

		long r = n;

		while(l<=r){

			long mid = (l + r)/2;

			if(reallybignumber(mid,s)){

				r = mid-1;

			}else{

				l = mid +1;

			}

		}

		/******long l1 = l;

		***while(l1<=n) {

			System.out.print(l1 + "" "");

			l1++;

		}*/////////

		System.out.println(n-l+1);



	}



	private static boolean reallybignumber(long n,long s) {

		long m = n;

		long sum=0;

		int d=1;

		while(m>0){

			long rem = m % 10;

			sum =   rem * d + sum;

			m = m / 10;

		}

		if(n-sum >= s) return true;

		else return false;

	}



}",2,0817_C,CODEFORCES,1090,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.InputStreamReader;
import java.io.BufferedOutputStream;
import java.util.StringTokenizer;
import java.io.Closeable;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.Flushable;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	static class TaskAdapter implements Runnable {
		@Override
		public void run() {
			InputStream inputStream = System.in;
			OutputStream outputStream = System.out;
			Input in = new Input(inputStream);
			Output out = new Output(outputStream);
			CReallyBigNumbers solver = new CReallyBigNumbers();
			solver.solve(1, in, out);
			out.close();
		}
	}

	public static void main(String[] args) throws Exception {
		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<29);
		thread.start();
		thread.join();
	}
	static class CReallyBigNumbers {
		long s;

		public CReallyBigNumbers() {
		}

		public boolean valid(long l) {
			long sum = 0;
			String str = String.valueOf(l);
			for(int i = 0; i<str.length(); i++) {
				sum += str.charAt(i)-'0';
			}
			return l-sum >= s;
		}

		public void solve(int kase, Input in, Output pw) {
			long n = in.nextLong();
			s = in.nextLong();
			long l = 0, h = n+1;
			while(l<h) {
				long mid = l+h >> 1;
				if(valid(mid)) {
					h = mid;
				}else {
					l = mid+1;
				}
			}
			pw.println(n-l+1);
		}

	}

	static class Output implements Closeable, Flushable {
		public StringBuilder sb;
		public OutputStream os;
		public int BUFFER_SIZE;
		public boolean autoFlush;
		public String LineSeparator;

		public Output(OutputStream os) {
			this(os, 1<<16);
		}

		public Output(OutputStream os, int bs) {
			BUFFER_SIZE = bs;
			sb = new StringBuilder(BUFFER_SIZE);
			this.os = new BufferedOutputStream(os, 1<<17);
			autoFlush = false;
			LineSeparator = System.lineSeparator();
		}

		public void println(long l) {
			println(String.valueOf(l));
		}

		public void println(String s) {
			sb.append(s);
			println();
			if(autoFlush) {
				flush();
			}else if(sb.length()>BUFFER_SIZE >> 1) {
				flushToBuffer();
			}
		}

		public void println() {
			sb.append(LineSeparator);
		}

		private void flushToBuffer() {
			try {
				os.write(sb.toString().getBytes());
			}catch(IOException e) {
				e.printStackTrace();
			}
			sb = new StringBuilder(BUFFER_SIZE);
		}

		public void flush() {
			try {
				flushToBuffer();
				os.flush();
			}catch(IOException e) {
				e.printStackTrace();
			}
		}

		public void close() {
			flush();
			try {
				os.close();
			}catch(IOException e) {
				e.printStackTrace();
			}
		}

	}

	static class Input {
		BufferedReader br;
		StringTokenizer st;

		public Input(InputStream is) {
			this(is, 1<<20);
		}

		public Input(InputStream is, int bs) {
			br = new BufferedReader(new InputStreamReader(is), bs);
			st = null;
		}

		public boolean hasNext() {
			try {
				while(st==null||!st.hasMoreTokens()) {
					String s = br.readLine();
					if(s==null) {
						return false;
					}
					st = new StringTokenizer(s);
				}
				return true;
			}catch(Exception e) {
				return false;
			}
		}

		public String next() {
			if(!hasNext()) {
				throw new InputMismatchException();
			}
			return st.nextToken();
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

	}
}

",2,0817_C,CODEFORCES,1144,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;

import java.io.*;

import java.util.*;

import java.math.*;

import java.lang.*;

import static java.lang.Math.*;

 

public class TestClass implements Runnable

{

	/*int x,y;

	public TestClass(int x,int y)

	{

		this.x=x;

		this.y=y;

	}*/

	public static void main(String args[])

	{

		new Thread(null, new TestClass(),""TESTCLASS"",1<<18).start();

	}

	public void run()

	{

		//Scanner scan=new Scanner(System.in);

		InputReader hb=new InputReader(System.in);

		PrintWriter w=new PrintWriter(System.out);

		

		long n=hb.nextLong();

		long s=hb.nextLong();

		

		long start=0;

		long end=n;

		long ans=0;

		while(start<=end)

		{

			long mid=(start+end)/2;

			if(mid-get(mid)>=s)

			{

				end=mid-1;

				ans=mid;

			}

			else

			{

				start=mid+1;

			}

		}

		if(ans<1)

			w.print(0);

		else

			w.print(n-ans+1);

		w.close();

	}

	

	public long get(long a)

	{

		String str = Long.toString(a);

		int ans = 0;

		for(char ch : str.toCharArray())

			ans += (ch-'0');

		return ans;

	}

	

	

	private void shuffle(int[] arr)

	{

		Random ran = new Random();

		for (int i = 0; i < arr.length; i++) {

			int i1 = ran.nextInt(arr.length);

			int i2 = ran.nextInt(arr.length);



			int temp = arr[i1];

			arr[i1] = arr[i2];

			arr[i2] = temp;

		}

	}

	

	static class DSU

	{

		int parent[];

		int sizeParent[];

		DSU(int n)

		{

			parent=new int[n];

			sizeParent=new int[n];

			Arrays.fill(sizeParent,1);

			for(int i=0;i<n;i++)

				parent[i]=i;

		}

		

		int find(int x)

		{

			if(x!=parent[x])

				parent[x]=find(parent[x]);

			return parent[x];

		}

		

		void union(int x,int y)

		{

			x=find(x);

			y=find(y);

			if(sizeParent[x]>=sizeParent[y])

			{

				if(x!=y)

					sizeParent[x]+=sizeParent[y];

				parent[y]=x;

			}

			else

			{

				if(x!=y)

					sizeParent[y]+=sizeParent[x];

				parent[x]=y;

			}

		}

	}

	

	static class InputReader

	{

		private InputStream stream;

		private byte[] buf = new byte[1024];

		private int curChar;

		private int numChars;

		private SpaceCharFilter filter;

		

		public InputReader(InputStream stream)

		{

			this.stream = stream;

		}

		

		public int read()

		{

			if (numChars==-1) 

				throw new InputMismatchException();

			

			if (curChar >= numChars)

			{

				curChar = 0;

				try 

				{

					numChars = stream.read(buf);

				}

				catch (IOException e)

				{

					throw new InputMismatchException();

				}

				

				if(numChars <= 0)				

					return -1;

			}

			return buf[curChar++];

		}

	 

		public String nextLine()

		{

			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));

			String str = """";

			try

			{

				str = br.readLine();

			}

			catch (IOException e)

			{

				e.printStackTrace();

			}

			return str;

		}

		public int nextInt()

		{

			int c = read();

			

			while(isSpaceChar(c)) 

				c = read();

			

			int sgn = 1;

			

			if (c == '-') 

			{

				sgn = -1;

				c = read();

			}

			

			int res = 0;

			do 

			{

				if(c<'0'||c>'9') 

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = read();

			}

			while (!isSpaceChar(c)); 

			

			return res * sgn;

		}

		

		public long nextLong() 

		{

			int c = read();

			while (isSpaceChar(c))

				c = read();

			int sgn = 1;

			if (c == '-') 

			{

				sgn = -1;

				c = read();

			}

			long res = 0;

			

			do 

			{

				if (c < '0' || c > '9')

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = read();

			}

			while (!isSpaceChar(c));

				return res * sgn;

		}

		

		public double nextDouble() 

		{

			int c = read();

			while (isSpaceChar(c))

				c = read();

			int sgn = 1;

			if (c == '-') 

			{

				sgn = -1;

				c = read();

			}

			double res = 0;

			while (!isSpaceChar(c) && c != '.') 

			{

				if (c == 'e' || c == 'E')

					return res * Math.pow(10, nextInt());

				if (c < '0' || c > '9')

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = read();

			}

			if (c == '.') 

			{

				c = read();

				double m = 1;

				while (!isSpaceChar(c)) 

				{

					if (c == 'e' || c == 'E')

						return res * Math.pow(10, nextInt());

					if (c < '0' || c > '9')

						throw new InputMismatchException();

					m /= 10;

					res += (c - '0') * m;

					c = read();

				}

			}

			return res * sgn;

		}

		

		public String readString() 

		{

			int c = read();

			while (isSpaceChar(c))

				c = read();

			StringBuilder res = new StringBuilder();

			do 

			{

				res.appendCodePoint(c);

				c = read();

			} 

			while (!isSpaceChar(c));

			

			return res.toString();

		}

	 

		public boolean isSpaceChar(int c) 

		{

			if (filter != null)

				return filter.isSpaceChar(c);

			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

		}

	 

		public String next() 

		{

			return readString();

		}

		

		public interface SpaceCharFilter 

		{

			public boolean isSpaceChar(int ch);

		}

	}

 

	static class Pair implements Comparable<Pair>

	{

		int a;

		int b;

		String str;

		public Pair(int a,int b)

		{

			this.a=a;

			this.b=b;

			str=min(a,b)+"" ""+max(a,b);

		}

 

		public int compareTo(Pair pair)

		{

			if(Integer.compare(a,pair.a)==0)

				return Integer.compare(b,pair.b);

 

			return Integer.compare(a,pair.a);

		}

	}

 

	

}",2,0817_C,CODEFORCES,1074,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;
import java.util.*;

public class CF817C {
	static long count(long x) {
		return x < 10 ? x : count(x / 10) + x % 10;
	}
	static boolean check(long x, long s) {
		return x - count(x) >= s;
	}
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		long n = Long.parseLong(st.nextToken());
		long s = Long.parseLong(st.nextToken());
		int d = 9 * 18;
		long cnt;
		if (n >= s + d) {
			cnt = n - s - d;
			for (long x = s; x <= s + d; x++)
				if (check(x, s))
					cnt++;
		} else {
			cnt = 0;
			for (long x = s; x <= n; x++)
				if (check(x, s))
					cnt++;
		}
		System.out.println(cnt);
	}
}
",2,0817_C,CODEFORCES,1061,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class _817C {
	public static long value(long temp) {
		long sum = 0;
		long temp2 = temp;
		while(temp2!=0) {
			sum+=temp2%10;
			temp2/=10;
		}
		
		return temp-sum;
	}
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		long num = sc.nextLong();
		long limiter = sc.nextLong();
		long counter = 0;
		long lower = 1; long higher = num;long middle = 0;
		while(lower<=higher) {
			middle = (higher+lower)/2;
			if(value(middle)<limiter) {
				lower = middle+1;
			}
			else {
				higher = middle-1;
				counter = num - middle +1;
			}
		}
		System.out.println(counter);
	}

}
",2,0817_C,CODEFORCES,1128,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.util.*;
  
public class c726b
{
    //By shwetank_verma
	public static void main(String[] args)
    {
        FastReader sc=new FastReader();
        try{
           
                int t=1;
               // t=sc.nextInt();
                while(t-->0){
                long n=sc.nextLong();
                long k=sc.nextLong();
                long l=0,r=n+1;
                while(l+1<r) {
                	long m=l+(r-l)/2;
                	long temp=m;
                	long s=0;
                	while(temp!=0) {
                		s+=temp%10;
                		temp=temp/10;
                	}
                	if(m-s>=k)
                		r=m;
                	else
                		l=m;
                	
                }
                System.out.println(n-r+1);
                }
           
            
        }catch(Exception e){
            return;
        }
    }

static void ruffleSort(long[] a) {
		int n=a.length;
		Random r=new Random();
		for (int i=0; i<a.length; i++) {
			long oi=r.nextInt(n), temp=a[i];
			a[i]=a[(int)oi];
			a[(int)oi]=temp;
		}
		Arrays.sort(a);
	}
static void ruffleSort(int[] a) {
		int n=a.length;
		Random r=new Random();
		for (int i=0; i<a.length; i++) {
			int oi=r.nextInt(n), temp=a[i];
			a[i]=a[oi];
			a[oi]=temp;
		}
		Arrays.sort(a);
	}

    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;
  
        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }
  
        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
  
        int nextInt()
        {
            return Integer.parseInt(next());
        }
  
        long nextLong()
        {
            return Long.parseLong(next());
        }
  
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
  
        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
    static int mod=1000000007;
    static boolean primes[]=new boolean[1000007];
    static ArrayList<Integer> b=new ArrayList<>();
    static boolean seive(int n){
        Arrays.fill(primes,true);
        primes[0]=primes[1]=false;
        for(int i=2;i*i<=n;i++){
            if(primes[i]==true){
                for(int p=i*i;p<=n;p+=i){
                    primes[p]=false;
                }
            }
        }
        if(n<1000007){
        	for(int i=2;i<=n;i++) {
        		if(primes[i])
        			b.add(i);
        	}
            return primes[n];
        }
        return false;
        
    }
    static int gcd(int a,int b){
        if(b==0)
        return a;
        return gcd(b,a%b);
    }
    static long GCD(long a,long b){
        if(b==0)
        return a;
        return GCD(b,a%b);
    }
    static ArrayList<Integer> segseive(int l,int r){
    	
    	ArrayList<Integer> isprime=new ArrayList<Integer>();
    	boolean p[]=new boolean[r-l+1];
    	Arrays.fill(p, true);
        
    	for(int i=0;b.get(i)*b.get(i)<=r;i++) {
    		int currprime=b.get(i);
    		int base=(l/currprime)*currprime;
    		if(base<l) {
    			base+=currprime;
    		}
    		for(int j=base;j<=r;j+=currprime) {
    			p[j-l]=false;
    		}
    		
    		
    		if(base==currprime) {
    			p[base-l]=true;
    		}
    		
    	}
    	for(int i=0;i<=r-l;i++) {
    		if(p[i])
    			isprime.add(i+l);
    	}
    	return isprime;
    }
      static int LowerBound(int a[], int x) { // x is the target value or key
  int l=-1,r=a.length;
  while(l+1<r) {
    int m=(l+r)>>>1;
    if(a[m]>=x) r=m;
    else l=m;
  }
  return r;
}
static int UpperBound(int a[], int x) {// x is the key or target value
    int l=-1,r=a.length;
    while(l+1<r) {
       int m=(l+r)>>>1;
       if(a[m]<=x) l=m;
       else r=m;
    }
    return l+1;
 }

  
     
}
",2,0817_C,CODEFORCES,1055,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"//Codeforces
// package codeNcode.binarySearch;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

//    public static int n, s;

    public static Long F(long x){
        return x-sumOfDigits(x);
    }

    private static long sumOfDigits(long x) {
        long sum = 0;
        while(x!=0){
            long rem = x%10;
            sum+=rem;
            x/=10;
        }
        return sum;
    }

    public static long bSearch(long x,long s){
        long l=10,h=x;
        long ans = -1;
        while(l<=h){
            long mid=(l+h)/2;
            long a = F(mid);
            long b = F(mid-1);
            if(a>=s && b<s){
                ans = mid;
                break;
            }
            else if (a<s)
                l = mid+1;
            else
                h = mid - 1;
        }
        return ans;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] in = br.readLine().split("" "");
        long n = Long.parseLong(in[0]);
        long s = Long.parseLong(in[1]);
        if(n<10)
            System.out.println(0);
        else
        {
            if(F(n)<s){
                System.out.println(0);
            }
            else {
                long y = bSearch(n,s);
                System.out.println(n-y+1);
            }
        }
    }
}
",2,0817_C,CODEFORCES,1052,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class C {

	public static void main(String[] args) {



		Scanner scan = new Scanner(System.in);



		long n = scan.nextLong();

		long s = scan.nextLong();

		long low = 0;

		long high = n + 1;

		while (high-low>1) {

			long sum = 0;

			long mid = (high + low) / 2;

			long value = findSum(mid, sum);

			if (mid - value >= s)

				high = mid;

			else

				low = mid;

		}

		

		System.out.println(n - high + 1);



		scan.close();

	}



	public static long findSum(long n, long sum) {

		if (n == 0)

			return sum;

		return findSum(n / 10, sum + n % 10);

	}



}",2,0817_C,CODEFORCES,1095,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class Ivan{



  public static boolean check(long s,long n){

    long big = 0;

    long u = s;

    while (s != 0){

      long amari = s % 10;

      big = big + s % 10;

      s = (s - amari) / 10;

    }

    if (u - big >= n){

      return true;

    }else return false;

  }

  public static void main(String args[]){

      Scanner scan = new Scanner(System.in);

      long s = scan.nextLong();

      long n = scan.nextLong();

      long r =0;

        if ( s > n){

          for (long i = n;i<s+1;i++){

          if (check(i,n)){

            r=i;

            break;

          }else r = s+1;

          }

        System.out.print(s-r+1);

      }else System.out.print(""0"");

  }

}

",2,0817_C,CODEFORCES,1103,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.StringTokenizer;



public class ReallyBigNumbers {



	public static void main(String[] args) throws IOException {

		Scanner sc = new Scanner(System.in);

		PrintWriter out = new PrintWriter(System.out);

		

		long n = sc.nextLong(), s = sc.nextLong();

		long low = 0, high = n, ans = -1;

		while(low <= high) {

			long mid = low + (high - low) / 2;

			if (mid - sum(mid) >= s) {

				ans = mid;

				high = mid-1;

			}

			else

				low = mid+1;

		}

		

		out.println(ans == -1 ? 0 : n - ans + 1);

		

		out.flush();

		out.close();

	}

	

	static int sum(long n) {

		int sum = 0;

		while(n > 0) {

			sum += n % 10;

			n /= 10;

		}

		

		return sum;

	}

	

	static class Scanner {

		BufferedReader br;

		StringTokenizer st;

		

		public Scanner(FileReader f) {

			br = new BufferedReader(f);

		}



		public Scanner(InputStream in) {

			br = new BufferedReader(new InputStreamReader(in));

		}



		public String next() throws IOException {

			while (st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public String nextLine() throws IOException {

			return br.readLine();

		}



		public int nextInt() throws IOException {

			return Integer.parseInt(next());

		}



		public long nextLong() throws IOException {

			return Long.parseLong(next());

		}



		public double nextDouble() throws IOException {

			return Double.parseDouble(next());

		}



		public boolean Ready() throws IOException {

			return br.ready();

		}



		public void waitForInput(long time) {

			long ct = System.currentTimeMillis();

			while(System.currentTimeMillis() - ct < time) {};

		}



	}



}

",2,0817_C,CODEFORCES,1116,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

import java.util.Scanner;



public class Main {

    private static class Node<V extends Comparable<V>> {

        public Node parent;

        private final V data;



        public Node(V data) {

            this.data = data;

            this.parent = null;

        }



    }



    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong(), s = sc.nextLong();

        long first = -1l;

        for (long i = s; i < s + 1000l; i = i + 1l) {

            if (i - summa(i) >= s) {

                first = i;

                break;

            }

        }

        long res = n - first + 1l;

        if(res<0) res = 0;

        System.out.println(res);



    }



    static long summa(long n) {

        long sum = 0l;

        if (n % 10l == n) return n;

        sum += n % 10l + summa(n / 10l);

        return sum;

    }

}

",2,0817_C,CODEFORCES,1113,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Edu_23C {

	public static void main(String[] args) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer inputData = new StringTokenizer(reader.readLine());
		long bound = Long.parseLong(inputData.nextToken());
		long s = Long.parseLong(inputData.nextToken());
		if(bound < s){
			System.out.println(0);
			return;
		}

		long cur = s;
		while (cur <= bound && s + digitSum(cur) > cur) {
			cur++;
		}
		System.out.println(bound - cur + 1);
	}

	static int digitSum(long inp) {
		int sum = 0;
		while (inp != 0) {
			sum += inp % 10;
			inp /= 10;
		}
		return sum;
	}

}
",2,0817_C,CODEFORCES,1102,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.InputMismatchException;

import java.io.IOException;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 */

public class Main {

    public static void main(String[] args) {

        InputStream inputStream = System.in;

        OutputStream outputStream = System.out;

        InputReader in = new InputReader(inputStream);

        PrintWriter out = new PrintWriter(outputStream);

        atskb solver = new atskb();

        solver.solve(1, in, out);

        out.close();

    }



    static class atskb {

        long s;



        public void solve(int testNumber, InputReader in, PrintWriter out) {

            long n = in.nextLong();

            s = in.nextLong();

            long ans = binarysearch(0, (long) Math.pow(10, 18) + 20 * 9);

            if (ans > n) {

                out.print(0);

            } else {

                out.print(n - ans + 1);

            }



        }



        public long binarysearch(long l, long r) {

            if (l == r) {

                if (check(l))

                    return l;

                return -1;



            }

            if (l - r == -1) {

                if (check(l))

                    return l;

                if (check(r)) {

                    return r;

                }



                //return -1;

            }

            long mid = l + (r - l) / 2;

            if (check(mid))

                return binarysearch(l, mid);

            return binarysearch(mid + 1, r);

        }



        public boolean check(long m) {

            String str = m + """";

            long sum = 0;

            for (int i = 0; i < str.length(); i++) {

                sum += str.charAt(i) - '0';

            }

            if (sum + s <= m)

                return true;

            return false;

        }



    }



    static class InputReader {

        private final InputStream stream;

        private final byte[] buf = new byte[8192];

        private int curChar;

        private int snumChars;



        public InputReader(InputStream st) {

            this.stream = st;

        }



        public int read() {

            if (snumChars == -1)

                throw new InputMismatchException();

            if (curChar >= snumChars) {

                curChar = 0;

                try {

                    snumChars = stream.read(buf);

                } catch (IOException e) {

                    throw new InputMismatchException();

                }

                if (snumChars <= 0)

                    return -1;

            }

            return buf[curChar++];

        }



        public long nextLong() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            long res = 0;

            do {

                res *= 10;

                res += c - '0';

                c = read();

            } while (!isSpaceChar(c));

            return res * sgn;

        }



        public boolean isSpaceChar(int c) {

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }



    }

}



",2,0817_C,CODEFORCES,1068,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.io.*;
 
 public class Solution {
 
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        long n = scan.nextLong();
        long s = scan.nextLong();
        
        long l=1; long r=n; //System.out.println(sumfxn(43));
        long ans=-1;
         while(l<=r)
         {
             long mid=r+(l-r)/2;
            
             if(mid-sumfxn(mid)>=s)
             {  long t=n-mid+1;
                 if(ans<t)
                   ans=n-mid+1;
                 r=mid-1;
                
             }else{
                 l=mid+1;
             }
             }
        
         if(ans==-1)
        System.out.println(""0"");
        else
         System.out.println(ans);
 
 
    }
    
    public  static  long sumfxn(long n)
    {
        long sum=0;
        
        while(n!=0)
        {
           long d=n%10;
           sum+=d;
           n=n/10;
        }
        return sum;
    }
}",2,0817_C,CODEFORCES,1051,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.lang.*;
import java.io.*;
public class Codechef{
    static PrintWriter out = new PrintWriter(System.out);
    
    static boolean check(long x, long k){
        long dup = x;
        long sm = 0L;
        while(dup>0){
            sm += dup%10;
            dup /= 10;
        }
        return(x-sm>=k);
    }
    
	public static void main (String[] args) throws java.lang.Exception {
	    InputReader sc = new InputReader(System.in);
	    long n = sc.nextLong(), k = sc.nextLong();
	    long lo=1, hi=n+1;
	    while(lo<hi){
	        long mid = lo + (hi-lo)/2;
	        if(check(mid,k)) hi = mid;
	        else lo = mid+1;
	    }
	    out.println(n-lo+1);
	    out.close();
	}
	
	public static class InputReader {
        private static final int BUFFER_LENGTH = 1 << 12;
        private InputStream stream;
        private byte[] buf = new byte[BUFFER_LENGTH];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int next() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public char nextChar() {
            return (char) skipWhileSpace();
        }

        public String nextToken() {
            int c = skipWhileSpace();
            StringBuilder res = new StringBuilder();
            do {
                res.append((char) c);
                c = next();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public int nextInt() {
            return (int) nextLong();
        }

        public long nextLong() {
            int c = skipWhileSpace();
            long sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = next();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            return Double.valueOf(nextToken());
        }

        int skipWhileSpace() {
            int c = next();
            while (isSpaceChar(c)) {
                c = next();
            }
            return c;
        }

        boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    }
}",2,0817_C,CODEFORCES,1123,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.math.*;

import java.security.KeyStore.Entry;

import java.util.*;



public class CODEFORCES {

	private InputStream is;

	private PrintWriter out;



	boolean check(long num, long s) {

		long sum = 0;

		long nm = num;

		while (nm != 0) {

			sum += nm % 10;

			nm /= 10;

		}

		if (num - sum >= s)

			return true;

		return false;

	}



	void solve() {

		long n = nl();

		long s = nl();

		if (n < s) {

			out.println(""0"");

			return;

		}

		long sn = 0;

		for (long i = s; i <= Math.min(s + 180, n); i++) {

			if (check(i, s))

				sn++;

		}

		if (s + 180 < n)

			sn += n - s - 180;

		out.println(sn);

	}



	void soln() {

		is = System.in;

		out = new PrintWriter(System.out);

		long s = System.currentTimeMillis();

		solve();

		out.flush();

		tr(System.currentTimeMillis() - s + ""ms"");

	}



	public static void main(String[] args) throws Exception {

		new CODEFORCES().soln();

	}



	// To Get Input

	// Some Buffer Methods

	private byte[] inbuf = new byte[1024];

	public int lenbuf = 0, ptrbuf = 0;



	private int readByte() {

		if (lenbuf == -1)

			throw new InputMismatchException();

		if (ptrbuf >= lenbuf) {

			ptrbuf = 0;

			try {

				lenbuf = is.read(inbuf);

			} catch (IOException e) {

				throw new InputMismatchException();

			}

			if (lenbuf <= 0)

				return -1;

		}

		return inbuf[ptrbuf++];

	}



	private boolean isSpaceChar(int c) {

		return !(c >= 33 && c <= 126);

	}



	private int skip() {

		int b;

		while ((b = readByte()) != -1 && isSpaceChar(b))

			;

		return b;

	}



	private double nd() {

		return Double.parseDouble(ns());

	}



	private char nc() {

		return (char) skip();

	}



	private String ns() {

		int b = skip();

		StringBuilder sb = new StringBuilder();

		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '

									// ')

			sb.appendCodePoint(b);

			b = readByte();

		}

		return sb.toString();

	}



	private char[] ns(int n) {

		char[] buf = new char[n];

		int b = skip(), p = 0;

		while (p < n && !(isSpaceChar(b))) {

			buf[p++] = (char) b;

			b = readByte();

		}

		return n == p ? buf : Arrays.copyOf(buf, p);

	}



	private char[][] nm(int n, int m) {

		char[][] map = new char[n][];

		for (int i = 0; i < n; i++)

			map[i] = ns(m);

		return map;

	}



	private int[] na(int n) {

		int[] a = new int[n];

		for (int i = 0; i < n; i++)

			a[i] = ni();

		return a;

	}



	private int ni() {

		int num = 0, b;

		boolean minus = false;

		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))

			;

		if (b == '-') {

			minus = true;

			b = readByte();

		}



		while (true) {

			if (b >= '0' && b <= '9') {

				num = num * 10 + (b - '0');

			} else {

				return minus ? -num : num;

			}

			b = readByte();

		}

	}



	private long nl() {

		long num = 0;

		int b;

		boolean minus = false;

		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))

			;

		if (b == '-') {

			minus = true;

			b = readByte();

		}



		while (true) {

			if (b >= '0' && b <= '9') {

				num = num * 10 + (b - '0');

			} else {

				return minus ? -num : num;

			}

			b = readByte();

		}

	}



	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;



	private void tr(Object... o) {

		if (!oj)

			System.out.println(Arrays.deepToString(o));

	}

}",2,0817_C,CODEFORCES,1106,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"//package Chapter3;



import java.io.IOException;

import java.util.Scanner;



public class ReallyBigNumbers {

	static long count(long mid) {

		long count = 0;

		while(mid>0) {

			count+=(mid%10);

			mid/=10;

		}

		return count;

	}

	static long findBs(long n, long s) {

		long low = 10l;

		long high = n;

		long ans = -1;

		while(low<=high) {

			long mid = (low+high)/2;

			long count = count(mid);

			if(mid-count>=s) {

				ans = mid;

				high = mid-1;

			}else

				low = mid+1;

		}

		return ans;

	}

public static void main(String[] args) throws IOException{

	Scanner sc = new Scanner(System.in);

	long n = sc.nextLong();

	long s= sc.nextLong();

	long ans = findBs(n,s);

	if(ans==-1)

		System.out.println(0);

	else

	System.out.println(n-ans+1);

}

}

",2,0817_C,CODEFORCES,1119,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class C {

	

	public static void main(String[] args) {

		new C();

	}



	C() {

		

		Scanner in = new Scanner(System.in);

		

		long n = in.nextLong(), s = in.nextLong();

		long lo = 1, hi = 1000000000000000000L;

		

		while(lo<hi){

			//System.out.println(lo+"" ""+hi);

			//STUPID STUPID DUMB

			long mid = (lo+hi)/2;

			if(reallyBig(mid,s))

				hi = mid;

			else

				lo = mid+1;

		}

		

		//System.out.println(lo+"" ""+hi);

		if(!reallyBig(lo,s))

			System.out.println(0);

		else

			System.out.println(Math.max(n-lo+1,0));

			

		//System.out.println(reallyBig(100000000000000009L,100000000000000000L));



		in.close();



	}

	

	boolean reallyBig(long n, long s){

		int sum = 0;

		long temp = n;

		while(temp>0){

			sum += temp%10;

			temp/=10;

		}

		return n-sum>=s;

	}

	

}



/*



12 1



25 20



10 9



1000000000000000000 1000000000000000000



1000000000000000000 100000000000000000



 */



















",2,0817_C,CODEFORCES,1097,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.io.*;
import java.math.*;

public class Main{

  public static boolean check(BigInteger a, BigInteger b){
    long  n = 0;
    String aStr = a.toString();
    for (int i=0; i < aStr.length() ;i++ ) {
      n += Long.valueOf(aStr.charAt(i)-'0');
    }
    return a.subtract(BigInteger.valueOf(n)).compareTo(b) >= 0;
  }

  public static void main(String[] args) {
    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in))){
      String[] str = in.readLine().split("" "");
      BigInteger n = new BigInteger(str[0]);
      BigInteger s = new BigInteger(str[1]);

      BigInteger left = BigInteger.ONE;
      BigInteger right = new BigInteger(n.toString()).add(BigInteger.TEN);

      BigInteger TWO = BigInteger.ONE.add(BigInteger.ONE);

      BigInteger t;

      while(right.subtract(left).compareTo(BigInteger.ONE)>0){
        t = left.add(right.subtract(left).divide(TWO));
        if(check(t, s)){
          right = t;
        }else{
          left = t;
        }
      }
      BigInteger result = n.subtract(right).add(BigInteger.ONE);
      if (result.compareTo(BigInteger.ZERO)<=0) {
        System.out.println(0);
      }else{
        System.out.println(result);
      }

    }catch (IOException e) {
      e.printStackTrace();
    }
  }
}
",2,0817_C,CODEFORCES,1071,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"//package codeforces;

import java.util.Scanner;

/**
 * Created by nitin.s on 03/08/17.
 */
public class ReallyBigNumbers {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        long n = in.nextLong();
        long s = in.nextLong();
        long limit = s + 200;
        long answer = 0;
        for(long i = s; i <= Math.min(n, limit); ++i) {
            int sum = findsum(i);
            if(i - sum >= s) ++answer;
        }

        answer += Math.max(0, n - limit);
        System.out.println(answer);
    }

    private static int findsum(long number) {
        int sum = 0;
        while(number > 0) {
            sum += (number % 10);
            number /= 10;
        }
        return sum;
    }
}
",2,0817_C,CODEFORCES,1114,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;
import java.util.*;

public class Main implements Runnable {
	FastReader scn;
	PrintWriter out;
	String INPUT = """";

	void solve() {
		long n = scn.nextLong(), k = scn.nextLong();
		long l = 0, r = (long) n, ans = n + 1;
		
		while(l <= r) {
			long m = (l + r) >> 1;
			if(m - sum(m) >= k) {
				ans = m;
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		
		out.println(n - ans + 1);
	}
	
	int sum(long x) {
		String s = Long.toString(x);
		int rv = 0;
		for(int i = 0; i < s.length(); i++) {
			rv += s.charAt(i) - '0';
		}
		return rv;
	}

	public void run() {
		long time = System.currentTimeMillis();
		boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
		out = new PrintWriter(System.out);
		scn = new FastReader(oj);
		solve();
		out.flush();
		if (!oj) {
			System.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + "" ms"" }));
		}
	}

	public static void main(String[] args) {
		new Thread(null, new Main(), ""Main"", 1 << 26).start();
	}

	class FastReader {
		InputStream is;

		public FastReader(boolean onlineJudge) {
			is = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		}

		byte[] inbuf = new byte[1024];
		public int lenbuf = 0, ptrbuf = 0;

		int readByte() {
			if (lenbuf == -1)
				throw new InputMismatchException();
			if (ptrbuf >= lenbuf) {
				ptrbuf = 0;
				try {
					lenbuf = is.read(inbuf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return -1;
			}
			return inbuf[ptrbuf++];
		}

		boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		int skip() {
			int b;
			while ((b = readByte()) != -1 && isSpaceChar(b))
				;
			return b;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		char nextChar() {
			return (char) skip();
		}

		String next() {
			int b = skip();
			StringBuilder sb = new StringBuilder();
			while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		String nextLine() {
			int b = skip();
			StringBuilder sb = new StringBuilder();
			while ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		char[] next(int n) {
			char[] buf = new char[n];
			int b = skip(), p = 0;
			while (p < n && !(isSpaceChar(b))) {
				buf[p++] = (char) b;
				b = readByte();
			}
			return n == p ? buf : Arrays.copyOf(buf, p);
		}

		int nextInt() {
			int num = 0, b;
			boolean minus = false;
			while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
				;
			if (b == '-') {
				minus = true;
				b = readByte();
			}

			while (true) {
				if (b >= '0' && b <= '9') {
					num = num * 10 + (b - '0');
				} else {
					return minus ? -num : num;
				}
				b = readByte();
			}
		}

		long nextLong() {
			long num = 0;
			int b;
			boolean minus = false;
			while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
				;
			if (b == '-') {
				minus = true;
				b = readByte();
			}

			while (true) {
				if (b >= '0' && b <= '9') {
					num = num * 10 + (b - '0');
				} else {
					return minus ? -num : num;
				}
				b = readByte();
			}
		}

		char[][] nextMatrix(int n, int m) {
			char[][] map = new char[n][];
			for (int i = 0; i < n; i++)
				map[i] = next(m);
			return map;
		}

		int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		int[][] next2DInt(int n, int m) {
			int[][] arr = new int[n][];
			for (int i = 0; i < n; i++) {
				arr[i] = nextIntArray(m);
			}
			return arr;
		}

		long[][] next2DLong(int n, int m) {
			long[][] arr = new long[n][];
			for (int i = 0; i < n; i++) {
				arr[i] = nextLongArray(m);
			}
			return arr;
		}

		int[] shuffle(int[] arr) {
			Random r = new Random();
			for (int i = 1, j; i < arr.length; i++) {
				j = r.nextInt(i);
				arr[i] = arr[i] ^ arr[j];
				arr[j] = arr[i] ^ arr[j];
				arr[i] = arr[i] ^ arr[j];
			}
			return arr;
		}

		int[] uniq(int[] arr) {
			Arrays.sort(arr);
			int[] rv = new int[arr.length];
			int pos = 0;
			rv[pos++] = arr[0];
			for (int i = 1; i < arr.length; i++) {
				if (arr[i] != arr[i - 1]) {
					rv[pos++] = arr[i];
				}
			}
			return Arrays.copyOf(rv, pos);
		}
	}
}",2,0817_C,CODEFORCES,1130,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.IOException;
import java.util.Scanner;

public class Main
{

	static Scanner in = new Scanner(System.in);

	public static void main(String[] args) throws IOException
	{

		long n = in.nextLong();
		long s = in.nextLong();
		long minNum = getMin(s);
		//System.out.println(""minNum=="" + minNum);
		if (n < minNum)
			System.out.println(0);
		else
		{
			System.out.println(n - minNum + 1);
		}

	}

	static long getMin(long s)
	{
		long ans = (s / 9) * 9;
		if (ans != s)
			ans += 9;

		ans = ans - ans % 10 + 10;
		while (true)
		{
			if (ans - getStringSum(ans) >= s)
			{
				break;
			}
			ans += 10;
		}
		return ans;
	}

	static int getStringSum(long s)
	{
		int sum = 0;
		while (s != 0)
		{
			sum += s % 10;
			s = s / 10;
		}
		return sum;
	}

}",2,0817_C,CODEFORCES,1104,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.util.*;



/**

 * Road to 1600 raiting

 */

public class Main {

    static class Task {

        PrintWriter out;



        int[] num = new int[3];



        public void solve(MyScanner in, PrintWriter out) {

            this.out = out;



            long n = in.nextLong();

            long s = in.nextLong();



            long l = 1;



            long r = n;



            while (r - l > 5) {

                long x = (l + r) / 2;



                long ans = ans(x);



                if (ans >= s) {

                    r = x;

                } else {

                    l = x;

                }

            }



            for (long i = l; i <= r; i++) {

                if (ans(i) >= s) {

                    out.println((n - i + 1));

                    return;

                }

            }



            out.println(0);



        }



        long ans(long n) {

            long res = n;



            while (n > 9) {

                res -= n % 10;

                n /= 10;

            }



            res -= n;



            return res;

        }



    }



    public static void main(String[] args) {

        MyScanner in = new MyScanner();

        PrintWriter out = new PrintWriter(System.out);

        Task solver = new Task();

        solver.solve(in, out);

        out.close();

    }



    public static class MyScanner {

        BufferedReader br;

        StringTokenizer st;



        public MyScanner() {

            br = new BufferedReader(new InputStreamReader(System.in));

        }



        String next() {

            while (st == null || !st.hasMoreElements()) {

                try {

                    st = new StringTokenizer(br.readLine());

                } catch (IOException e) {

                    e.printStackTrace();

                }

            }

            return st.nextToken();

        }



        int nextInt() {

            return Integer.parseInt(next());

        }



        long nextLong() {

            return Long.parseLong(next());

        }



        double nextDouble() {

            return Double.parseDouble(next());

        }



        String nextLine() {

            String str = """";

            try {

                str = br.readLine();

            } catch (IOException e) {

                e.printStackTrace();

            }

            return str;

        }

    }

}



",2,0817_C,CODEFORCES,1064,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner reader=new Scanner(System.in);
		long a=reader.nextLong();
		long b=reader.nextLong();
		long sum=0;
		long num=0;
		for(long n=b+1;n<=a;n++){
			String s=String.valueOf(n);
			long x=0;
			for(int m=0;m<s.length();m++){
				x+=Integer.valueOf(s.substring(m, m+1));
			}
			if(n-x>=b){
				num=n;
				sum++;
				if(n%10==9){
					break;
				}
			}
		}
		if(num==0&&sum==0){
			System.out.println(0);
		}
		else{
			System.out.println(a-num+sum);	
		}
		
		//System.out.println(num);
		
		
	}	
}
  	  	 			  	    		 	     		  	",2,0817_C,CODEFORCES,1110,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"

import java.util.Scanner;





public class ReallyBigNumbers1 

{

    

    public static void main(String[] args) 

    {

        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong();

        long s = sc.nextLong();

        

        int r = 0 ;

        

        long l = 0L ;

        long u = n ;

        

        if(  (l-sumDigits(l)< s )  && (u-sumDigits(u)< s ) )

        {

            System.out.println(0);

            return ;

        }

        

        long specified = 0L ;

        while( true )

        {

            long m = (l + u) / 2L ;

            

            if( ( m - sumDigits(m) ) >= s && ( (m-1) - sumDigits(m-1) ) < s  )

            {

                specified = m ;

                break ;

            }

            

            if( l > u  )

                break ;

            

            else

            {

                if( ( m - sumDigits(m) ) >= s )

                    u = m-1 ;

                else

                    l = m+1 ;

            }

        }

        

        System.out.println( n-specified+1 );

        

        

    }

    

    public static int sumDigits(long n)

    {

        char [] a = (n+"""").toCharArray();

        int sum = 0 ;

        for(int k = 0 ; k < a.length ; k++)

        {

            sum += Integer.parseInt(a[k]+"""") ;

        }

        return sum ;

    }

    

}

",2,0817_C,CODEFORCES,1088,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;
import java.util.*;
public class Solution
{
    public static void main(String ag[])
    {
        Scanner sc=new Scanner(System.in);
        int i,j,k;
        long N=sc.nextLong();
        long S=sc.nextLong();
        long ans=(long)1e18+5;
        
        long l=0;
        long r=(long)1e18+5;
        while(l<=r)
        {
            long mid=(l+r)/2;
            if(find(mid,S))
            {
                ans=mid;
                r=mid-1;
            }
            else 
            {
                l=mid+1;
            }
        }
        if(ans>N)
        System.out.println(0);
        else 
        System.out.println(N-ans+1);
    }
    public static boolean find(long num,long S)
    {
        long sum=0;
        long N=num;
        while(num>0)
        {
            sum+=num%10;
            num/=10;
        }
        if(N-sum>=S)
        return true;
        return false;
    }
}",2,0817_C,CODEFORCES,1143,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.math.BigInteger;

import java.util.ArrayList;

import java.util.Collections;

import java.util.HashMap;

import java.util.Map;

import java.util.Scanner;



/**

 *

 * @author Fuad

 */

public class Codeforces {



    private static boolean greater(long mid, long s) {



        int sum = 0;

        long num = mid;



        while (num != 0) {

            sum += (num % 10);

            num /= 10;



        }



        return mid - sum >= s;

    }



    static class pair {



        int first;

        int second;



        pair(int f, int s) {

            first = f;

            second = s;

        }



        pair() {



        }



    }



    public static void main(String[] args) throws Exception {

        // TODO code application logic here

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));



        long n, s;



        String arr[] = br.readLine().split("" "");



        n = Long.parseLong(arr[0]);

        s = Long.parseLong(arr[1]);



        long l = 1;

        long h = n;



        while (l < h) {

            long mid = (l + h) / 2;

            if (greater(mid, s)) {

                h = mid;

            } else {

                l = mid + 1;

            }

        }



        System.out.println(greater(h, s) ? n - h + 1 : 0);



    }



}

",2,0817_C,CODEFORCES,1096,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

public class bignumbers {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		long n = in.nextLong();
		long s = in.nextLong();
		in.close();

		long max = (long) Math.ceil((double) s/9) * 10;
		long min = Math.min(s, max);
		long x = 0, sum = 0, temp = 0;
		
		while(min + 1 < max)
		{
			x = (min + max)/2; 
			sum = 0;
			temp = x;
			while(temp>0)
			{
				sum += temp%10;
				temp /= 10;
			}
			
			if(x-sum >= s)
				max = x;
			else
				min = x;
			
		}
		
		if(max == 0)
			System.out.println(n);
		else if(n-max < 0)
			System.out.println(0);
		else
			System.out.println(n-max+1);

	}

}
",2,0817_C,CODEFORCES,1138,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"

import java.io.BufferedReader;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.Scanner;

import java.util.StringTokenizer;





public class ReallyBigNumbers1 

{

    

    public static void main(String[] args) throws IOException 

    {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        PrintWriter out = new PrintWriter(System.out);

        long n = Long.parseLong(st.nextToken());

        long s = Long.parseLong(st.nextToken());

        

        int r = 0 ;

        

        long l = 0L ;

        long u = n ;

        

        if(  (l-sumDigits(l)< s )  && (u-sumDigits(u)< s ) )

        {

            out.println(0);

            out.flush();

            out.close();

            return ;

        }

        

        long specified = 0L ;

        while( true )

        {

            long m = (l + u) / 2L ;

            

            if( ( m - sumDigits(m) ) >= s && ( (m-1) - sumDigits(m-1) ) < s  )

            {

                specified = m ;

                break ;

            }

            

            if( l > u  )

                break ;

            

            else

            {

                if( ( m - sumDigits(m) ) >= s )

                    u = m-1 ;

                else

                    l = m+1 ;

            }

        }

        

        out.println( n-specified+1 );

        out.flush();

        out.close();

        

    }

    

    public static int sumDigits(long n)

    {

        char [] a = (n+"""").toCharArray();

        int sum = 0 ;

        for(int k = 0 ; k < a.length ; k++)

        {

            sum += Integer.parseInt(a[k]+"""") ;

        }

        return sum ;

    }

    

}

",2,0817_C,CODEFORCES,1089,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class ReallyBigNumbers {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		long n = Long.parseLong(st.nextToken());
		long s = Long.parseLong(st.nextToken());
		long t = s;
		while(t - addDigits(t) < s && t <= n) {
			t++;
		}
		System.out.println(Math.max(n-t+1, 0));

	}
	public static long addDigits(long n) {
		long sum = 0; 
        
        while (n != 0) 
        { 
            sum = sum + n % 10; 
            n = n/10; 
        } 
      
        return sum; 
	}

}
",2,0817_C,CODEFORCES,1127,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.StringTokenizer;



public class A {



	static int[] UPPER = new int[64], LOWER = new int[64];

	static long[][][] memo;

	

	static long dp(int bit, int lims, int digs)

	{

		if(bit == -1)

			return digs == 0 ? 1 : 0;

		if(memo[lims][bit][digs] != -1)

			return memo[lims][bit][digs];

		long ret = 0;

		for(int d = 0, end = digs < 10 ? digs + 1 : 10; d < end; ++d)

			if(((lims & 1) == 1 || d >= LOWER[bit]) && ((lims & 2) == 2 || d <= UPPER[bit]))

				ret += dp(bit - 1, lims | (d > LOWER[bit] ? 1 : 0) | (d < UPPER[bit] ? 2 : 0), digs - d);

		return memo[lims][bit][digs] = ret;

	}

	

	static void create(int[] x, long n)

	{

		for(int i = 0; i < 64; ++i)

		{

			x[i] = (int) (n % 10);

			n /= 10;

		}

	}

	

	static void prepMemo(int sod)

	{

		memo = new long[4][64][sod + 1];

		for(long[][] x: memo)

			for(long[] y: x)

				Arrays.fill(y, -1);

	}



	public static void main(String[] args) throws IOException {



		Scanner sc = new Scanner(System.in);

		PrintWriter out = new PrintWriter(System.out);



		long n = sc.nextLong(), s = sc.nextLong();

		create(UPPER, n);

		long ans = 0;

		for(int sod = 1; sod <= 162; ++sod)

		{

			create(LOWER, s + sod);

			prepMemo(sod);

			ans += dp(63, 0, sod);

		}

		

		

		out.println(ans);

		out.close();

	}

	

	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}



		public Scanner(String s) throws FileNotFoundException{	br = new BufferedReader(new FileReader(s));}



		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {return Integer.parseInt(next());}



		public long nextLong() throws IOException {return Long.parseLong(next());}



		public String nextLine() throws IOException {return br.readLine();}



		public double nextDouble() throws IOException { return Double.parseDouble(next()); }



		public boolean ready() throws IOException {return br.ready();} 

	}

}",2,0817_C,CODEFORCES,1091,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.util.*;

import java.math.*;



public class utkarsh {



    InputStream is;

    PrintWriter out;

    

    long maxl = 4L * (long)1e18, mod = (long)1e9 + 7L;

    int p[], maxi = 2 * (int)1e9, sz, np = 15485900, modi = (int)1e9 + 7;

    boolean b[];    // = isPrime();

    

    void solve(){

        //Enter code here utkarsh

        //sz=sieve(); //sz = 1000001;

        //out.println(sz);

        long i, j, k, n, s, ans;

        n = nl();

        s = nl();

        ans = 0;

        if(n < s){

            out.println(0);

            return;

        }

        if(n > s + 500){

            ans = n - (s+500);

            n = s+500;

        }

        for(i = s; i <= n; i++){

            k = 0;

            j = i;

            while(j > 0){

                k += j%10;

                j /= 10;

            }

            if(i - k >= s){

                ans++;

            }

        }

        out.println(ans);

    }

    

    int sieve(){ int i, j, n = np; b = new boolean[n]; for(i = 3; i < n; i += 2){ b[i] = true; } b[2] = true; for(i = 3; i * i <= n; i += 2){ if(b[i]){ for(j = 2 * i; j < n; j += i){ b[j] = false; } } } p = new int[n]; p[0] = 2; j = 1; for(i = 3; i < n; i += 2){ if(b[i]){ p[j++] = i; } } p=Arrays.copyOf(p,j); return j;

    }

    long modpow(long base, long exp, long modulus) { base %= modulus; long result = 1L; while (exp > 0) { if ((exp & 1)==1) result = (result * base) % modulus; base = (base * base) % modulus; exp >>= 1; } return result;

    }

    

    public static void main(String[] args) { new utkarsh().run();

    }

    void run(){ is = System.in; out = new PrintWriter(System.out); solve(); out.flush();

    }

    

    byte input[] = new byte[1024];

    int len = 0, ptr = 0;

    

    int readByte(){ if(ptr >= len){ ptr = 0; try{ len = is.read(input); }catch(IOException e){ throw new InputMismatchException(); } if(len <= 0){ return -1; } } return input[ptr++];

    }

    boolean isSpaceChar(int c){ return !( c >= 33 && c <= 126 ); 

    }

    int skip(){ int b = readByte(); while(b != -1 && isSpaceChar(b)){ b = readByte(); } return b;

    }

    

    char nc(){ return (char)skip();

    }

    String ns(){ int b = skip(); StringBuilder sb = new StringBuilder(); while(!isSpaceChar(b)){ sb.appendCodePoint(b); b=readByte(); } return sb.toString();

    }

    int ni(){ int n = 0,b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } if(b == -1){ return -1; } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;

    }

    long nl(){ long n = 0L; int b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;

    }

    double nd(){ return Double.parseDouble(ns());

    }

    float nf(){ return Float.parseFloat(ns());

    }

    int[] na(int n){ int a[] = new int[n]; for(int i = 0; i < n; i++){ a[i] = ni(); } return a;

    }

    char[] ns(int n){ char c[] = new char[n]; int i,b = skip(); for(i = 0; i < n; i++){ if(isSpaceChar(b)){ break; } c[i] = (char)b; b = readByte(); } return i == n ? c : Arrays.copyOf(c,i);

    }

}",2,0817_C,CODEFORCES,1105,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

import java.io.*;

import java.lang.Math.*;



public class Main{

	static long s;

	static boolean check(long n){

		int sum = 0;

		long storen=n;

		while(n>0){

			int k = (int)(n%10);

			n /=10;

			sum+=k;

		}

		return storen-(long)sum >= s;

	}

	public static void main(String args[]){

		PrintWriter pw=new PrintWriter(System.out);

		InputReader ip=new InputReader(System.in);

		

		long n;

		n=ip.nextLong();

		s=ip.nextLong();



		if(s>n){

			pw.println(""0"");

		}

		else{

			long l=0,r=n;

			boolean possible=false;

			long mid=0;

			int it=100;

			while(it-->0){

				mid = (l+r)/2;

				if(check(mid)){

					r=mid;

					possible = true;

				}

				else{

					l=mid+1;

				}

		//		pw.println(mid);

		//		pw.println(l+"" ""+r);

			}

			if(possible){

				pw.println(n-l+1);

			}	

			else{

				pw.println(""0"");

			}

		}

		

		pw.close();

	}

	static class InputReader {

        private InputStream stream;

        private byte[] buf = new byte[1024];

        private int curChar;

        private int numChars;

        private SpaceCharFilter filter;



        public InputReader(InputStream stream) {

            this.stream = stream;

        }



        public int read() {

            if (numChars == -1)

                throw new InputMismatchException();



            if (curChar >= numChars) {

                curChar = 0;

                try {

                    numChars = stream.read(buf);

                } catch (IOException e) {

                    throw new InputMismatchException();

                }



                if (numChars <= 0)

                    return -1;

            }

            return buf[curChar++];

        }



        public String nextLine() {

            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

            String str = """";

            try {

                str = br.readLine();

            } catch (IOException e) {

                e.printStackTrace();

            }

            return str;

        }



        public int nextInt() {

            int c = read();



            while (isSpaceChar(c))

                c = read();



            int sgn = 1;



            if (c == '-') {

                sgn = -1;

                c = read();

            }



            int res = 0;

            do {

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));



            return res * sgn;

        }



        public long nextLong() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            long res = 0;



            do {

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));

            return res * sgn;

        }



        public double nextDouble() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            double res = 0;

            while (!isSpaceChar(c) && c != '.') {

                if (c == 'e' || c == 'E')

                    return res * Math.pow(10, nextInt());

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            if (c == '.') {

                c = read();

                double m = 1;

                while (!isSpaceChar(c)) {

                    if (c == 'e' || c == 'E')

                        return res * Math.pow(10, nextInt());

                    if (c < '0' || c > '9')

                        throw new InputMismatchException();

                    m /= 10;

                    res += (c - '0') * m;

                    c = read();

                }

            }

            return res * sgn;

        }



        public String readString() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            StringBuilder res = new StringBuilder();

            do {

                res.appendCodePoint(c);

                c = read();

            }

            while (!isSpaceChar(c));



            return res.toString();

        }



        public boolean isSpaceChar(int c) {

            if (filter != null)

                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }



        public String next() {

            return readString();

        }



        public interface SpaceCharFilter {

            public boolean isSpaceChar(int ch);

        }

    }

}",2,0817_C,CODEFORCES,1070,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner reader=new Scanner(System.in);
		long a=reader.nextLong();
		long b=reader.nextLong();
		long sum=0;
		long num=0;
		for(long n=b+1;n<=a;n++){
			String s=String.valueOf(n);
			long x=0;
			for(int m=0;m<s.length();m++){
				x+=Integer.valueOf(s.substring(m, m+1));
			}
			if(n-x>=b){
				num=n;
				sum++;
				if(n%10==9){
					break;
				}
			}
		}
		if(num==0&&sum==0){
			System.out.println(0);
		}
		else{
			System.out.println(a-num+sum);	
		}
		
		//System.out.println(num);
		
		
	}	
}
    		   		    			 		 	   			 	",2,0817_C,CODEFORCES,1140,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

import java.io.*;

import java.math.*;

public class q817c {

	public static void main(String argsp[]){

		//long startTime = System.currentTimeMillis();

		long input;

		

		String someinp;

		long count = 0;

		long s;

		Scanner sc = new Scanner(System.in);

		input = sc.nextLong();

		s = sc.nextLong();

		//System.out.println(Long.toString(input));

		//System.out.println(Long.toString(s));

		//input = 12345678910l;

		long newi;

		while(input / s >= 100){

			

			newi = input / 10;

			count += input - newi;

			input = newi;

		}

		//System.out.println((double)input/(double)s);

		//while((double)input/(double)s >1.05 && input >10000){

		while(input - s > 1000){

			if(input == 1000 + s){break;}

			newi = input;

			input = 1000 + s;

			if(newi >= input){

			count += newi - input;}

		}

		

		

		while(input > s){

			int sum = 0;

			someinp = Long.toString(input);

			for(char a : someinp.toCharArray()){

				sum += a - '0';

			}

			if(input - sum >= s){count++;}

			input--;

		}

		System.out.println(Long.toString(count));

		//long endTime = System.currentTimeMillis();

		//long finishTime = endTime - startTime;

		//System.out.println(Long.toString(finishTime));

	}

}

",2,0817_C,CODEFORCES,1099,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		FastReader sc=new FastReader();
		long n=sc.L();
		long s=sc.L();
		
		    long m=binarysearch(1,n,s);
		    if(rbn(m,s))
		    System.out.println(n-m+1);
		    else
		    System.out.println(n-m);
		
	//	System.out.println(n+1-binarysearch(1,n,s));
        
	 }
	 static boolean rbn(long n,long s)
	 {
	     long a=n,sum=0;
	     while(a>0)
		{
		    sum+=a%10;
		    a/=10;
		}
		if(n-sum>=s)
		return true;
		else
		return false;
	 }
	 static long binarysearch(long s,long e,long m)
	 {
	     while(s!=e)
	     {
	         if(rbn((s+e)/2,m))
	         e=(s+e)/2-1;
	         else{
	         s=(s+e)/2+1;
	         if(rbn(s,m))
	         return s;
	         }
	     }
	     return s;
	 }
	  static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int I() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long L() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double D() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
    static int gcd(int a,int b)
		{
		    if(a%b==0)
		    return b;
		    return gcd(b,a%b);
		}
	static float power(float x, int y) 
    { 
        float temp; 
        if( y == 0) 
            return 1; 
        temp = power(x, y/2);  
          
        if (y%2 == 0) 
            return temp*temp; 
        else
        { 
            if(y > 0) 
                return x * temp * temp; 
            else
                return (temp * temp) / x; 
        } 
    } 
    static long pow(int a,int b)
    {
        long result=1;
        if(b==0)
        return 1;
        long x=a;
        while(b>0)
        {
            if(b%2!=0)
            result*=x;
            
            x=x*x;
            b=b/2;
        }
        return result;
    }
    
    static ArrayList<Integer> sieveOfEratosthenes(int n) 
    { 
        ArrayList<Integer> arr=new ArrayList<Integer>();
        boolean prime[] = new boolean[n+1]; 
        for(int i=2;i<n;i++) 
            prime[i] = true; 
          
        for(int p = 2; p*p <=n; p++) 
        { 
            if(prime[p] == true) 
            { 
                arr.add(p);
                for(int i = p*p; i <= n; i += p) 
                    prime[i] = false; 
            } 
        } 
        return arr;
    } 
}",2,0817_C,CODEFORCES,1132,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.IOException;

import java.io.InputStreamReader;



public class Main {



	public static void main(String[] args) throws IOException {



		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String[] in = br.readLine().split("" "");

		long n = Long.parseLong(in[0]), s = Long.parseLong(in[1]);

		Solver solver = new Solver(n, s);

		System.out.println(solver.solve());



	}



}



class Solver {



	private long n, s;



	Solver(long n, long s) {

		this.n = n;

		this.s = s;

	}



	public long solve() {

		long low = 1, high = n;

		for (int i = 0; i < 72; ++i) {

			long x = low + (high - low) / 2;

			if (check(x))

				high = x - 1;

			else

				low = x + 1;

		}

		return n - high;

	}



	private boolean check(long x) {



		long tmp = x;

		int sum = 0;

		while (tmp > 0) {

			sum += tmp % 10;

			tmp /= 10;

		}

		return x - sum >= s;

	}

}

",2,0817_C,CODEFORCES,1078,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Arrays;

import java.util.Scanner;



public class P817C

{

	public static void main(String[] args)

	{

		Scanner scan = new Scanner(System.in);

		long n = scan.nextLong();

		long s = scan.nextLong();

		long ans = 0;

		if (s > n)

		{

			System.out.println(0);

			return;

		}

		if (n > s+200)

		{

			ans += n-(s+200);

			n = s+200;

		}

		for (long i = s; i <= n; i++)

		{

			char[] num = (""""+i).toCharArray();

			int sum = 0;

			for (int j = 0; j < num.length; j++)

				sum += num[j] - '0';

			if (i - sum >= s)

				ans++;

		}

		System.out.println(ans);

	}

}",2,0817_C,CODEFORCES,1080,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"//package code;
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.text.*;
import java.math.*;
import java.util.regex.*;
import java.awt.Point;
/**
 *
 * @author prabhat // use stringbuilder,TreeSet, priorityQueue, x+y=(x&y + x|y);
 */
   public class  a
   {
   public static int a[],n,max1=100005,k;
   public static long mod=(long)1e9+7;
   public static boolean[] isPrime;
   public static  ArrayList<Integer> divisor[],prime,adj[];
   public  static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
   static PrintWriter pw;
   public  static void main(String[] args) throws Exception
   {
   	     InputReader in = new InputReader(System.in);
		 pw=new PrintWriter(System.out);
		 long n=in.il();
		 long s=in.il();
		 long st=0;
		 long e=n;
		 while(st<e)
		 { 
			long mid=(st+e)>>1;
			if(mid-sum(mid)<s)st=mid+1;
			else e=mid;
		 }
		 pw.println(st-sum(st)>=s?n-st+1:0);
 	   pw.close();
}
static int sum(long a)
{
	String s=a+"""";
	int sum=0;
	for(int i=0;i<s.length();i++)sum+=s.charAt(i)-'0';
	return sum;
}
static int gcd(int a,int b)
{
	while(a!=0)
	{
		int temp=a;
		a=b%a;
		b=temp;
	}
	return b;
}
static void Seive()
{
	isPrime=new boolean[max1];
	Arrays.fill(isPrime,true);
	prime=new ArrayList<>();
	divisor=new ArrayList[max1];
	for(int i=1;i<max1;i++)divisor[i]=new ArrayList<Integer>();
    isPrime[0]=isPrime[1]=false;
	for(int i=2;i<(max1);i++)
	{
         if(isPrime[i]){
			 divisor[i].add(i);
			 prime.add(i);
			for(int j=2*i;j<max1;j+=i)
			{
				isPrime[j]=false;
				divisor[j].add(i);
			}
		}
	}
}
public static long pow(long n,long p,long m)
{
	 long  result = 1;
	  if(p==0)
	    return 1;

	while(p!=0)
	{
	    if(p%2==1)
	        result *= n;
	    if(result>=m)
	    result%=m;
	    p >>=1;
	    n*=n;
	    if(n>=m)
	    n%=m;
	}
	return result;
}


static  class InputReader
{
   private InputStream stream;
   private byte[] buf = new byte[1024];

   private SpaceCharFilter filter;
    byte inbuffer[] = new byte[1024];
   int lenbuffer = 0, ptrbuffer = 0;
    final int M = (int) 1e9 + 7;
   int md=(int)(1e7+1);
    int[] SMP=new int[md];
   final double eps = 1e-6;
   final double pi = Math.PI;

	PrintWriter out;
   String check = """";
 InputStream   obj = check.isEmpty() ? System.in : new ByteArrayInputStream(check.getBytes());
   public InputReader(InputStream stream)
   {
       this.stream = stream;
   }

    int readByte() {
	        if (lenbuffer == -1) throw new InputMismatchException();
	        if (ptrbuffer >= lenbuffer) {
	            ptrbuffer = 0;
	            try {
	                lenbuffer = obj.read(inbuffer);
	            } catch (IOException e) {
	                throw new InputMismatchException();
	            }
	        }
	        if (lenbuffer <= 0) return -1;
	        return inbuffer[ptrbuffer++];
   }

   public  int read()
   {
       int c = read();
       while (isSpaceChar(c))
           c = read();
       int sgn = 1;
       if (c == '-')
       {
           sgn = -1;
           c = read();
       }
       int res = 0;
       do
       {
           if (c < '0' || c > '9')
               throw new InputMismatchException();
           res *= 10;
           res += c - '0';
           c = read();
       } while (!isSpaceChar(c));
       return res * sgn;
   }

   String is() {
	        int b = skip();
	        StringBuilder sb = new StringBuilder();
	        while (!(isSpaceChar(b))) // when nextLine, (isSpaceChar(b) && b!=' ')
	        {
	            sb.appendCodePoint(b);
	            b = readByte();
	        }
	        return sb.toString();
   }
   public   int ii() {
	        int num = 0, b;
	        boolean minus = false;
	        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
	        if (b == '-') {
	            minus = true;
	            b = readByte();
	        }
	        while (true) {
	            if (b >= '0' && b <= '9') {
	                num = num * 10 + (b - '0');
	            } else {
	                return minus ? -num : num;
	            }
	            b = readByte();
	        }
   }
 public   long il() {
	        long num = 0;
	        int b;
	        boolean minus = false;
	        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
	        if (b == '-') {
	            minus = true;
	            b = readByte();
	        }
	        while (true) {
	            if (b >= '0' && b <= '9') {
	                num = num * 10 + (b - '0');
	            } else {
	                return minus ? -num : num;
	            }
	            b = readByte();
	        }
   }

	    boolean isSpaceChar(int c) {
	        return (!(c >= 33 && c <= 126));
	       }

	      int skip()
	        {
	        int b;
	        while ((b = readByte()) != -1 && isSpaceChar(b)) ;
	        return b;
	        }

	    float nf() {
	        return Float.parseFloat(is());
	    }

	    double id() {
	        return Double.parseDouble(is());
	    }

	    char ic() {
	        return (char) skip();
	    }

	    int[] iia(int n) {
	        int a[] = new int[n];
	        for (int i = 0; i<n; i++) a[i] = ii();
	        return a;
	    }

	    long[] ila(int n) {
	        long a[] = new long[n];
	        for (int i = 0; i <n; i++) a[i] = il();
	        return a;
	    }

	    String[] isa(int n) {
	        String a[] = new String[n];
	        for (int i = 0; i < n; i++) a[i] = is();
	        return a;
	    }


		 long mul(long a, long b) { return a * b % M; }

			long div(long a, long b)
				 {
					return mul(a, pow(b, M - 2,M));

		           }



	    double[][] idm(int n, int m) {
	        double a[][] = new double[n][m];
	        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) a[i][j] = id();
	        return a;
	        }

	    int[][] iim(int n, int m) {
	        int a[][] = new int[n][m];
	        for (int i = 0; i < n; i++) for (int j = 0; j <m; j++) a[i][j] = ii();
	        return a;
          }


   public String readLine() {
       int c = read();
       while (isSpaceChar(c))
           c = read();
       StringBuilder res = new StringBuilder();
       do {
           res.appendCodePoint(c);
           c = read();
       } while (!isEndOfLine(c));
       return res.toString();
   }

   public interface SpaceCharFilter
   {
       public boolean isSpaceChar(int ch);
   }
   public boolean isEndOfLine(int c) {
       return c == '\n' || c == '\r' || c == -1;
   }
}

}
",2,0817_C,CODEFORCES,1124,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"
import java.util.*;


public class Main {

    public static void main(String[] args) {

          Scanner sc=new Scanner(System.in);
        long x=sc.nextLong();
       
        long y=sc.nextLong();
       
     
        
      
   
      int count=0;
  
    if(x<y){System.out.println(""0"");}
      else{
         for(long i =y;i<=x;i++){
        
     int sub_temp=0;
     long tempi=i;
   while(tempi>0){
        sub_temp+=tempi%10;
        tempi/=10;
        }
     if((i-sub_temp)<y){count++;}
     else{break;}
         
     }
        System.out.println(x-(count+y)+1);
    }
            
	}
    public static long main(long sub_temp,long tempi) {
        int count=0;
    while(tempi>0){
        sub_temp+=tempi%10;
        tempi/=10;
        }
    return count;
    }
}
",2,0817_C,CODEFORCES,1134,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Comparator;
import java.util.StringTokenizer;
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.abs;

public class A
{
    static long N, S;
    static int[] arr, num;
    static char[] s;
    static long[][][] dp;
    public static void main(String[] args) throws IOException
    {
        f = new Flash();
        out = new PrintWriter(System.out);
        
        int T = 1;//ni();
        for(int tc = 1; tc <= T; tc++){
            N = nl(); S = nl(); sop(fn()); 
        }
        
        out.flush(); out.close();
    }
    
    //XXXX
    static long fn()
    {
    	//The sum of digits for any number could be at max 18*9 = 162
    	//We are fixing the sumOfDigits and counting every possible number with this sumOfDigits.
    	//The number-sumOfDigits >= S
        long ans = 0L;
        for(int sumOfDigits = 1; sumOfDigits <= 162; sumOfDigits++) {
        	if(S+sumOfDigits > N) break;
        	long a = N, b = S+sumOfDigits;
        	ans += solve(a, sumOfDigits) - solve(b-1, sumOfDigits);
        }
        
        return ans;
    }
    
    static long solve(long n, int sumOfDigits) {
    	int len = Long.toString(n).length();
    	num = new int[len];
    	for(int idx = len-1; idx >= 0; idx--) {
    		num[idx] = (int)(n%10);
    		n /= 10;
    	}
    	
    	dp = new long[len][2][163];
    	for(int i = 0; i < len; i++) {
    		for(int j = 0; j < 2; j++) {
				for(int k = 0; k < 163; k++) {
					dp[i][j][k] = -1;
				}
			}
    	}
    	
    	return recurse(0, 0, 0, sumOfDigits);
    }
    
    static long recurse(int pos, int f, int sum, int sumOfDigits) {
    	if(pos == num.length) {
    		if(sum == sumOfDigits) return 1;
    		else return 0;
    	}
    	
    	if(dp[pos][f][sum] != -1) return dp[pos][f][sum];
    	int lim;
    	if(f == 0) lim = num[pos];
    	else lim = 9;
    	long ans = 0;
    	for(int d = 0; d <= lim; d++) {
    		int nf = f;
    		if(f == 0 && d < num[pos]) nf = 1;
    		ans += recurse(pos+1, nf, sum+d, sumOfDigits);
    	}
    	
    	return dp[pos][f][sum] = ans;
    }
    
    static Flash f;
    static PrintWriter out;
    static final long mod = (long)1e9+7;
    static final long inf = Long.MAX_VALUE;
    static final int _inf = Integer.MAX_VALUE;
    static final int maxN = (int)5e5+5;
    static long[] fact, inv;
    
    static void sort(int[] a){
        List<Integer> A = new ArrayList<>();
        for(int i : a) A.add(i);
        Collections.sort(A);
        for(int i = 0; i < A.size(); i++) a[i] = A.get(i);
    }
    
    static void sort(long[] a){
        List<Long> A = new ArrayList<>();
        for(long i : a) A.add(i);
        Collections.sort(A);
        for(int i = 0; i < A.size(); i++) a[i] = A.get(i);
    }
    
    static void print(int[] a){
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < a.length; i++) sb.append(a[i] + "" "");
        sop(sb);
    }
    
    static void print(long[] a){
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < a.length; i++) sb.append(a[i] + "" "");
        sop(sb);
    }
    
    static int swap(int itself, int dummy){return itself;}
    static long swap(long itself, long dummy){return itself;}
    static void sop(Object o){out.println(o);}
    static int ni(){return f.ni();}
    static long nl(){return f.nl();}
    static double nd(){return f.nd();}
    static String next(){return f.next();}
    static String ns(){return f.ns();}
    static char[] nc(){return f.nc();}
    static int[] arr(int len){return f.arr(len);}
    static int gcd(int a, int b){if(b == 0) return a; return gcd(b, a%b);}
    static long gcd(long a, long b){if(b == 0) return a; return gcd(b, a%b);}
    static int lcm(int a, int b){return (a*b)/gcd(a, b);}
    static long lcm(long a, long b){return (a*b)/gcd(a, b);}
    
    static class Flash
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer("""");
        
        String next(){
            while(!st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch(IOException e){
                    e.printStackTrace();
                }
            }
            
            return st.nextToken();
        }
        
        String ns(){
            String s = new String();
            try{
                s = br.readLine().trim();
            }catch(IOException e){
                e.printStackTrace();
            }
            
            return s;
        }
        
        int[] arr(int n){
            int[] a = new int[n];
            for(int i = 0; i < n; i++) a[i] = ni();
            return a;
        }
        
        char[] nc(){return ns().toCharArray();}
        int ni(){return Integer.parseInt(next());}
        long nl(){return Long.parseLong(next());}
        double nd(){return Double.parseDouble(next());}
    }
}",2,0817_C,CODEFORCES,1053,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.math.BigInteger;

import java.util.*;

	

public 	class a {

		public static void main(String args[])throws IOException{

		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));

		OutputStream out=new BufferedOutputStream(System.out);

		String s[]=br.readLine().trim().split(""\\ "");

		BigInteger a1=new BigInteger(s[0]);

		BigInteger a=new BigInteger(s[0]);

		String q=a.toString();

		String q1=q.substring(q.length()-1, q.length());

		a=a.subtract(new BigInteger(q1));

		//System.out.println(a.toString());

		BigInteger c=new BigInteger(""1"");

		BigInteger b=new BigInteger(s[1]);

		int z=check(a,a.toString(),b);

		if(z==1)

		{

			out.write(""0"".getBytes());

			out.flush();

			//System.out.println(""jwefcyuwe"");

			return;

		}

		while(a.compareTo(c)>0)

		{

			BigInteger d=a;

			if(d.subtract(c).compareTo(new BigInteger(""9""))==-1)

			{

				break;

			}

			else

			{

				BigInteger mid=a;

				mid=mid.add(c);

				mid=mid.divide(new BigInteger(""2""));

				//System.out.println(mid.toString());

				if(check(mid,mid.toString(),b)==1)

				{

					c=mid;

					c=c.add(new BigInteger(""1""));

				}

				else

				{

					a=mid;

					

					//System.out.println(a.toString());

				}

					

			}

			

		}

		 q=a.toString();

		 q1=q.substring(q.length()-1, q.length());

		a=a.subtract(new BigInteger(q1));

		BigInteger ans=a1.subtract(a);

		ans=ans.add(new BigInteger(""1""));

		out.write(ans.toString().getBytes());

		//System.out.print(""sfvlksfv"");

		

		

		out.flush();

	}

		

		static int check(BigInteger a,String s,BigInteger b)

		{

			int l=s.length();

			long z=0;

			for(int i=0;i<l;i++)

			{

				z+=Long.parseLong(s.substring(i,i+1));

			}

			BigInteger c=a.subtract(new BigInteger(Long.toString(z)));

			//System.out.println(c.toString());

			return -1*c.compareTo(b);

		}

	}",2,0817_C,CODEFORCES,1067,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Arrays;

import java.util.Scanner;



public class P817C

{

	public static void main(String[] args)

	{

		Scanner scan = new Scanner(System.in);

		long n = scan.nextLong();

		long s = scan.nextLong();

		long ans = 0;

		if (s > n)

		{

			System.out.println(0);

			return;

		}

		if (n > s+200)

		{

			ans += n-(s+200);

			n = s+200;

		}

		for (long i = s; i <= n; i++)

		{

			char[] num = (""""+i).toCharArray();

			int sum = 0;

			for (int j = 0; j < num.length; j++)

				sum += num[j] - '0';

			if (i - sum >= s)

				ans++;

		}

		System.out.println(ans);

	}

}

",2,0817_C,CODEFORCES,1079,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Vaibhav Pulastya
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        CReallyBigNumbers solver = new CReallyBigNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class CReallyBigNumbers {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            long n = in.nextLong();
            long s = in.nextLong();
            int count = 0;
            long last = s;
            for (long i = s; i <= s + 9 * 20 && i <= n; i++) {
                long num = i;
                int digsum = 0;
                while (num != 0) {
                    digsum += num % 10;
                    num /= 10;
                }

                if (i - s >= digsum) {
                    count++;
                }
                last = i;
            }
            out.println(count + Math.max(n - last, 0));
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",2,0817_C,CODEFORCES,1133,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

import java.io.*;



public class CFEdu23C 

{

	static long sum(long n)

	{

		long ans=0;

		while(n>0)

		{

			ans+=(n%10);

			n/=10;

		}

		return ans;

	}

	static long BS(long l,long h,long s)

	{

		if(l<=h)

		{

			long m=(l+h)/2l;

			if(m-sum(m)>=s && (m==1 || (m-1)-sum(m-1)<s))

				return m;

			else if(m-sum(m)>=s)

				return BS(l, m-1, s);

			else

				return BS(m+1, h, s);

		}

		return (h+1);

	}

	public static void main(String args[]) {

		InputReader in = new InputReader(System.in);

		OutputStream outputStream = System.out;

		PrintWriter out = new PrintWriter(outputStream);

		/*------------------------------My Code starts here------------------------------*/

		long n=in.nextLong(),s=in.nextLong();

		long x=BS(0,n,s);

		out.print(n-x+1);

		out.close();

		/*------------------------------The End------------------------------------------*/

	}



	public static final long l = (int) (1e9 + 7);



	private static int[] nextIntArray(InputReader in, int n) {

		int[] a = new int[n];

		for (int i = 0; i < n; i++)

			a[i] = in.nextInt();

		return a;

	}



	private static long[] nextLongArray(InputReader in, int n) {

		long[] a = new long[n];

		for (int i = 0; i < n; i++)

			a[i] = in.nextLong();

		return a;

	}



	private static int[][] nextIntMatrix(InputReader in, int n, int m) {

		int[][] a = new int[n][m];

		for (int i = 0; i < n; i++) {

			for (int j = 0; j < m; j++)

				a[i][j] = in.nextInt();

		}

		return a;

	}



	private static void show(int[] a) {

		for (int i = 0; i < a.length; i++)

			System.out.print(a[i] + "" "");

		System.out.println();

	}



	private static void show2DArray(char[][] a) {

		for (int i = 0; i < a.length; i++) {

			for (int j = 0; j < a[0].length; j++)

				System.out.print(a[i][j]);

			System.out.println();

		}

	}



	static class Pair {

		private int first;

		private int second;



		public Pair(int i, int j) {

			this.first = i;

			this.second = j;

		}



		public int getFirst() {

			return first;

		}



		public int getSecond() {

			return second;

		}



		public void setFirst(int k) {

			this.first = k;

		}



		public void setSecond(int k) {

			this.second = k;

		}

	}



	static int modPow(int a, int b, int p) {

		int result = 1;

		a %= p;

		while (b > 0) {

			if ((b & 1) != 0)

				result = (result * a) % p;

			b = b >> 1;

			a = (a * a) % p;

		}

		return result;

	}



	public static void SieveOfEratosthenes(int n) {

		boolean[] prime = new boolean[n + 1];

		Arrays.fill(prime, true);

		prime[1] = false;

		int i, j;

		for (i = 2; i * i <= n; i++) {

			if (prime[i]) {

				for (j = i; j <= n; j += i) {

					if (j != i)

						prime[j] = false;

				}

			}

		}

	}



	static class InputReader {

		public BufferedReader reader;

		public StringTokenizer tokenizer;



		public InputReader(InputStream inputstream) {

			reader = new BufferedReader(new InputStreamReader(inputstream));

			tokenizer = null;

		}



		public String nextLine() {

			String fullLine = null;

			while (tokenizer == null || !tokenizer.hasMoreTokens()) {

				try {

					fullLine = reader.readLine();

				} catch (IOException e) {

					throw new RuntimeException(e);

				}

				return fullLine;

			}

			return fullLine;

		}



		public String next() {

			while (tokenizer == null || !tokenizer.hasMoreTokens()) {

				try {

					tokenizer = new StringTokenizer(reader.readLine());

				} catch (IOException e) {

					throw new RuntimeException(e);

				}

			}

			return tokenizer.nextToken();

		}



		public long nextLong() {

			return Long.parseLong(next());

		}



		public int nextInt() {

			return Integer.parseInt(next());

		}

	}



}

",2,0817_C,CODEFORCES,1093,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.SortedMap;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

  public class Test
 {
    static PrintWriter pw = new PrintWriter(System.out);
    static long sum(long x)
    {
        long res = 0;
        while(x>0)
        {
            res += x%10;
            x = x/10;
        }
        return res;
    }
    public static void main(String[] args)throws Exception
    {
        Reader.init(System.in);
        long n = Reader.nextLong();
        long s = Reader.nextLong();
        long x = 0;
        
        for(long i = s+1 ; ; i++)
            if(i - sum(i) >= s)
            {
                x = i;
                break;
            }
        
        long res = n - x +1;
        if(res <=0)
            pw.print(0);
        else
        pw.print(res);
        pw.close();
            
    }
    
  }


class Reader {

    static BufferedReader reader;
    static StringTokenizer tokenizer;

    public static int pars(String x) {
        int num = 0;
        int i = 0;
        if (x.charAt(0) == '-') {
            i = 1;
        }
        for (; i < x.length(); i++) {
            num = num * 10 + (x.charAt(i) - '0');
        }

        if (x.charAt(0) == '-') {
            return -num;
        }

        return num;
    }

    static void init(InputStream input) {
        reader = new BufferedReader(
                new InputStreamReader(input));
        tokenizer = new StringTokenizer("""");
    }

    static void init(FileReader input) {
        reader = new BufferedReader(input);
        tokenizer = new StringTokenizer("""");
    }

    static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(
                    reader.readLine());
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return pars(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
}",2,0817_C,CODEFORCES,1125,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

public class C817 {



	public static boolean isBig(long m, long s){

		long temp=m;

		long sum=0;

		while(m>0){

			sum+=m%10;

			m/=10;

		}

		if(temp-sum>=s)

			return true;

		return false;

	}

	public static void main(String[] args) {

		// TODO Auto-generated method stub

		Scanner sc = new Scanner(System.in);

		long n = sc.nextLong();

		long s = sc.nextLong();

		long l=1;

		long h = n+1;

		while(l<h){

			long m = l+(h-l)/2;

			if(isBig(m,s))

				h=m;

			else

				l=m+1;

		}

		System.out.println(n-l+1);

	}



}

",2,0817_C,CODEFORCES,1100,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"//package educational.round23;

import java.io.ByteArrayInputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.InputMismatchException;



public class C {

	InputStream is;

	PrintWriter out;

	String INPUT = """";

	

	void solve()

	{

		long n = nl();

		long S = nl();

		long d = 1000000000000000000L;

		out.println(dfs(d, n, S));

	}

	

	long dfs(long d, long n, long S)

	{

		if(d == 0)return 0L;

		long ret = 0;

		for(int i = 0;i <= n/d;i++){

			if(S <= 0){

				ret += Math.min(n-i*d+1, d);

			}else if(S < d){

				ret += dfs(d/10, i == n/d ? n%d : d-1, S);

			}

			S -= d-1;

		}

		return ret;

	}

	

	void run() throws Exception

	{

		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());

		out = new PrintWriter(System.out);

		

		long s = System.currentTimeMillis();

		solve();

		out.flush();

		tr(System.currentTimeMillis()-s+""ms"");

	}

	

	public static void main(String[] args) throws Exception { new C().run(); }

	

	private byte[] inbuf = new byte[1024];

	public int lenbuf = 0, ptrbuf = 0;

	

	private int readByte()

	{

		if(lenbuf == -1)throw new InputMismatchException();

		if(ptrbuf >= lenbuf){

			ptrbuf = 0;

			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }

			if(lenbuf <= 0)return -1;

		}

		return inbuf[ptrbuf++];

	}

	

	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }

	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

	

	private double nd() { return Double.parseDouble(ns()); }

	private char nc() { return (char)skip(); }

	

	private String ns()

	{

		int b = skip();

		StringBuilder sb = new StringBuilder();

		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')

			sb.appendCodePoint(b);

			b = readByte();

		}

		return sb.toString();

	}

	

	private char[] ns(int n)

	{

		char[] buf = new char[n];

		int b = skip(), p = 0;

		while(p < n && !(isSpaceChar(b))){

			buf[p++] = (char)b;

			b = readByte();

		}

		return n == p ? buf : Arrays.copyOf(buf, p);

	}

	

	private char[][] nm(int n, int m)

	{

		char[][] map = new char[n][];

		for(int i = 0;i < n;i++)map[i] = ns(m);

		return map;

	}

	

	private int[] na(int n)

	{

		int[] a = new int[n];

		for(int i = 0;i < n;i++)a[i] = ni();

		return a;

	}

	

	private int ni()

	{

		int num = 0, b;

		boolean minus = false;

		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));

		if(b == '-'){

			minus = true;

			b = readByte();

		}

		

		while(true){

			if(b >= '0' && b <= '9'){

				num = num * 10 + (b - '0');

			}else{

				return minus ? -num : num;

			}

			b = readByte();

		}

	}

	

	private long nl()

	{

		long num = 0;

		int b;

		boolean minus = false;

		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));

		if(b == '-'){

			minus = true;

			b = readByte();

		}

		

		while(true){

			if(b >= '0' && b <= '9'){

				num = num * 10 + (b - '0');

			}else{

				return minus ? -num : num;

			}

			b = readByte();

		}

	}

	

	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;

	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }

}

",2,0817_C,CODEFORCES,1072,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.util.*;



public class Main {

	

	static InputReader in = new InputReader(System.in);

	static PrintWriter out = new PrintWriter(System.out);

	

	

	public static void main(String[] args) {



		long n = in.nextLong();

		long s = in.nextLong();

		

		if(diff(n) < s) {

			System.out.println(0);

			out.close();

			return;

		}

		

		long lo = 1;

		long hi = n;

		while(lo < hi) {

			long mid = lo + (hi - lo) / 2;

			if(diff(mid) >= s)

				hi = mid;

			else

				lo = mid + 1;

		}

		System.out.println(n - lo + 1);

		

		out.close();

	}



	static long diff(long n) {

		char[] ca = (n + """").toCharArray();

		int sum = 0;

		for(char c : ca)

			sum += (c - '0');

		return n - sum;

	}

}





class InputReader {



	private final InputStream stream;

	private final byte[] buf = new byte[8192];

	private int curChar, snumChars;



	public InputReader(InputStream st) {

		this.stream = st;

	}



	public int read() {

		if (snumChars == -1)

			throw new InputMismatchException();

		if (curChar >= snumChars) {

			curChar = 0;

			try {

				snumChars = stream.read(buf);

			} catch (IOException e) {

				throw new InputMismatchException();

			}

			if (snumChars <= 0)

				return -1;

		}

		return buf[curChar++];

	}



	public int nextInt() {

		int c = read();

		while (isSpaceChar(c)) {

			c = read();

		}

		int sgn = 1;

		if (c == '-') {

			sgn = -1;

			c = read();

		}

		int res = 0;

		do {

			res *= 10;

			res += c - '0';

			c = read();

		} while (!isSpaceChar(c));

		return res * sgn;

	}



	public long nextLong() {

		int c = read();

		while (isSpaceChar(c)) {

			c = read();

		}

		int sgn = 1;

		if (c == '-') {

			sgn = -1;

			c = read();

		}

		long res = 0;

		do {

			res *= 10;

			res += c - '0';

			c = read();

		} while (!isSpaceChar(c));

		return res * sgn;

	}



	public int[] nextIntArray(int n) {

		int a[] = new int[n];

		for (int i = 0; i < n; i++) {

			a[i] = nextInt();

		}

		return a;

	}



	public String readString() {

		int c = read();

		while (isSpaceChar(c)) {

			c = read();

		}

		StringBuilder res = new StringBuilder();

		do {

			res.appendCodePoint(c);

			c = read();

		} while (!isSpaceChar(c));

		return res.toString();

	}



	public String nextLine() {

		int c = read();

		while (isSpaceChar(c))

			c = read();

		StringBuilder res = new StringBuilder();

		do {

			res.appendCodePoint(c);

			c = read();

		} while (!isEndOfLine(c));

		return res.toString();

	}



	public boolean isSpaceChar(int c) {

		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

	}



	private boolean isEndOfLine(int c) {

		return c == '\n' || c == '\r' || c == -1;

	}



}",2,0817_C,CODEFORCES,1092,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;
import java.util.*;
import java.lang.*;
public class Codechef {
	PrintWriter out;
    StringTokenizer st;
    BufferedReader br;
 	
 	class Pair implements Comparable<Pair>
	{
	    int f;
	    int s;
 
	    Pair(int t, int r) {
	       f = t;
	       s = r;
	    }
	    public int compareTo(Pair p)
	    {
	    	if(this.f!=p.f)
	    		return this.f-p.f;
 
	    	return this.s-p.s;
	    }
 	}
 // 	class Sort implements Comparator<String> 
	// { 
	//     public int compare(String a, String b) 
	//     { 
	//     	return (a+b).compareTo(b+a);
	//     } 
	// }
 
	String ns() {
        while (st == null || !st.hasMoreElements()) {
 
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
 
    String nextLine() throws Exception {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            throw new Exception(e.toString());
        }
        return str;
    }
 
    int nextInt() {
        return Integer.parseInt(ns());
    }
 
    long nextLong() {
        return Long.parseLong(ns());
    }
 
    double nextDouble() {
        return Double.parseDouble(ns());
    }
	
	int upperBound(ArrayList<Integer> a,int key)
	{
		int l=0,r=a.size()-1;
		int i=-1;
 
		while(l<=r)
		{
			int mid=(l+r)/2;
 
			if(a.get(mid)<=key)	
				l=mid+1;
			
 
			else{
				i=mid;
				r=mid-1;
			}
		}
		if(i!=-1)
			return a.get(i);
		return i;
	}
 
	long power(long x,long y)
	{
	    long ans=1;
	    
	    while(y!=0)
	    {
	        if(y%2==1) ans=(ans*x)%mod;
	        x=(x*x)%mod;
	        y/=2;
	    }
	    return ans%mod;
	}
	
 
	long mod= 1000000007;
	long gcd(long x ,long y)
	{
		if(y==0)
			return x;
		return gcd(y,x%y);
	}
 
	// ArrayList a[];
	// int vis[];
	// ArrayList<Integer> list;
	// int dfs(int ver)
	// {
	// 	ArrayList<Integer> l=a[ver];
	// 	int cnt=0;
	// 	for(int v:l)
	// 	{
	// 		if(vis[v]==0){
	// 			vis[v]=vis[ver]+1;
	// 			cnt+=dfs(v)+1;
	// 		}
	// 	}
	// 	list.add(vis[ver]-cnt-1);
	// 	return cnt;
	// }
 
 	long digitSum(long n)
 	{
 		long sum=0;
 		while(n!=0)
 		{
 			sum+=n%10;
 			n/=10;
 		}
 		return sum;
 	}
	void solve() throws IOException{
		long n=nextLong();
		long sum=nextLong();

		long l=0,r=n,ans=n+1;
		while(l<=r)
		{
			long mid=(l+r)/2;
			long d=digitSum(mid);
			if(mid-d<sum)
				l=mid+1;
			else
			{
				ans=mid;
				r=mid-1;
			}
		}
		out.println(n-ans+1);
	}
	
    void run() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
		solve();
		out.flush();
 
		out.close();
	}
 
	public static void main(String args[]) throws IOException {
		new Codechef().run();
	}
  
}",2,0817_C,CODEFORCES,1142,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class CF817C {
    public static void main(String[] args) throws IOException {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(countBigNums(sc.nextLong(), sc.nextLong()));
        pw.flush();
    }

    static long countBigNums(long n, long s) {
        long lo = 1, hi = n;
        while (lo <= hi) {
            long mid = (lo + hi) / 2;
            long v = mid - sumDigits(mid);
            if (v >= s)
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return n - lo + 1;
    }

    static int sumDigits(long v) {
        int sum = 0;
        while (v > 0) {
            sum += v % 10;
            v /= 10;
        }
        return sum;
    }

    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;

        public FastScanner() {
            this.in = new BufferedReader(new InputStreamReader(System.in));
        }

        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public long nextLong() {
            return Long.parseLong(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        public void close() throws IOException {
            in.close();
        }
    }
}
",2,0817_C,CODEFORCES,1058,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

public class Main{

	public static void main(String args[]){

		Scanner reader=new Scanner(System.in);

		long a=reader.nextLong();

		long b=reader.nextLong();

		long sum=0;

		long num=0;

		for(long n=b+1;n<=a;n++){

			String s=String.valueOf(n);

			long x=0;

			for(int m=0;m<s.length();m++){

				x+=Integer.valueOf(s.substring(m, m+1));

			}

			if(n-x>=b){

				num=n;

				sum++;

				if(n%10==9){

					break;

				}

			}

		}

		if(num==0&&sum==0){

			System.out.println(0);

		}

		else{

			System.out.println(a-num+sum);	

		}

		

		//System.out.println(num);

		

		

	}	

}",2,0817_C,CODEFORCES,1109,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.InputMismatchException;



public class C817{



	void solve()

	{

		long n = nl(), s = nl();

		long l = 0, r = n;

		while(l < r)

		{

			long mid = (l + r)/2;

			if(mid - digSum(mid) < s)

				l = mid + 1;

			else

				r = mid;

		}

		out.println(l - digSum(l) >= s ? (n - l + 1) : 0);

	}

	

	int digSum(long k)

	{

		int sum = 0;

		while(k != 0)

		{

			sum += k % 10;

			k /= 10;

		}

		return sum;

	}

	

	public static void main(String[] args){new C817().run();}

	

	private byte[] bufferArray = new byte[1024];

	private int bufLength = 0;

	private int bufCurrent = 0;

	InputStream inputStream;

	PrintWriter out;

	

	public void run()

	{

		inputStream = System.in;

		out = new PrintWriter(System.out);

		solve();

		out.flush();

	}

	

	int nextByte()

	{

		if(bufLength==-1)

			throw new InputMismatchException();

		if(bufCurrent>=bufLength)

		{

			bufCurrent = 0;

			try

			{bufLength = inputStream.read(bufferArray);}

			catch(IOException e)

			{ throw new InputMismatchException();}

			if(bufLength<=0)

				return -1;

		}

		return bufferArray[bufCurrent++];

	}

	

	boolean isSpaceChar(int x)

	{return (x<33 || x>126);}

	

	boolean isDigit(int x)

	{return (x>='0' && x<='9');}

	

	int nextNonSpace()

	{

		int x;

		while((x=nextByte())!=-1 && isSpaceChar(x));

		return x;

	}

	

	int ni()

	{

		long ans = nl();

		if ( Integer.MIN_VALUE <= ans && ans <= Integer.MAX_VALUE )

			return (int)ans;

		throw new InputMismatchException();

	}

	

	long nl()

	{

		long ans = 0;

		boolean neg = false;

		int x = nextNonSpace();

		if(x=='-') 

		{

			neg = true;

			x = nextByte();

		}

		while(!isSpaceChar(x))

		{

			if(isDigit(x))

			{

				ans = ans*10 + x -'0';

				x = nextByte();

			}

			else

				throw new InputMismatchException();

		}

		return neg ? -ans:ans;

	}

	

	String ns()

	{

		StringBuilder sb = new StringBuilder();

		int x = nextNonSpace();

		while(!isSpaceChar(x))

		{

			sb.append((char)x);

			x = nextByte();

		}

		return sb.toString();

	}

	

	char nc()

	{ return (char)nextNonSpace();}

	

	double nd()

	{ return (double)Double.parseDouble(ns()); }

	

	char[] ca()

	{ return ns().toCharArray();}

	

	char[] ca(int n)

	{

		char[] ans = new char[n];

		int p =0;

		int x = nextNonSpace();

		while(p<n)

		{

			ans[p++] = (char)x;

			x = nextByte();

		}

		return ans;

	}

	

	int[] ia(int n)

	{

		int[] ans = new int[n];

		for(int i=0;i<n;i++)

			ans[i]=ni();

		return ans;

	}

	

}

",2,0817_C,CODEFORCES,1087,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BinarySearchAdv {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		String s[];
		s = br.readLine().split("" "");
		long n = Long.parseLong(s[0]);
	long b = Long.parseLong(s[1]);
	
	long ans = binarySearch(1,n,b);
	System.out.println(ans<0?0:(n-ans)+1);
	}

	private static long binarySearch(long start,long end,long comp) {
		long index=-1;
		while(start<=end) {
		long mid = (start+end)/2;	

			if(countDiff(mid,comp))
			{
				index=mid;
				end=mid-1;
			}
			else {
				start=mid+1;
			}
		}
		return index;
		
	}

	private static boolean countDiff(long mid,long comp) {
		long sum=0;
		long n=mid;
		while(n>0) {
			sum +=n%10;
			n/=10;
		}
		if(mid-sum>=comp)
			return true;
		else
			return false;
	}
	
	
// 1 4 5 6 10	
}",2,0817_C,CODEFORCES,1050,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.*;

public class ed817Q3 {
	public static void main(String[] args){
		InputReader in = new InputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		int t = 1;
		for(int zxz=0;zxz<t;zxz++){
			// my code starts here
			long n = in.nextLong();
			long s = in.nextLong();
			long start=0,end=n;
			long ans=n+1;
			while(start<=end){
				long mid = start+(end-start)/2;
				if(mid-digitSum(mid)>=s){
					ans = mid;
					end = mid-1;
				}
				else{
					start=mid+1;
				}
			}
			System.out.println(n-ans+1);
			// my code ends here
		}
	}
	static int digitSum(long n){
		int sum=0;
		while(n>0){
			sum+=n%10;
			n=n/10;
		}
		return sum;
	}
	static class InputReader {
		 
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;
 
        public InputReader(InputStream stream) {
            this.stream = stream;
        }
 
        public int snext() {
            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar >= snumChars) {
                curChar = 0;
                try {
                    snumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }
 
        public int nextInt() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public long nextLong() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public int[] nextIntArray(int n) {
            int a[] = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }
 
        public String readString() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = snext();
            } while (!isSpaceChar(c));
            return res.toString();
        }
 
        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
 
        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}
",2,0817_C,CODEFORCES,1083,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

public class fix {



    static long sumDigit(long z) {

        long s = 0;

        do {

            s += z%10;

        }

        while ((z/=10) > 0);

        return s;

    }



    public static void main(String[] args) throws IOException {

        long n = 0,s = 0;

        int tmp = System.in.read();

        for (;;) {

            n += tmp - '0';

            tmp = System.in.read();

            if (tmp == ' ') break;

            n *= 10;

        }

        tmp = System.in.read();

        for (;;) {

            s += tmp - '0';

            tmp = System.in.read();

            if (tmp  <'0' || tmp > '9') break;

            s *= 10;



        }

        long sIndex = 0;

        long sLevel = s;

        

        while (true) {

            sIndex = (sLevel / 10 + 1) * 10;

            if (sIndex - sumDigit(sIndex) >= s) break;

            sLevel += 10;

        }

        sIndex = 1 + n - sIndex;

        System.out.println(sIndex < 0 ? 0 : sIndex);

    }

}",2,0817_C,CODEFORCES,1098,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"






import java.io.*;
import java.util.*;
import java.math.BigInteger; 
import java.lang.*;





public class Main {
    
    
    static class sort implements Comparator<List<Integer>>
   {
        public int compare(List<Integer>  a,List<Integer> b)
        {
            
            return (a.size() - b.size());
        }
   }
    
   /*static class sort implements Comparator<int[]>
   {
        public int compare(int[] a,int[] b)
        {
            
            return -b[0]+a[0];
        }
   }*/
   static class sort1 implements Comparator<long[]>
   {
        public int compare(long[] a,long[] b)
        {
            
          long c = -(a[0]-a[1]) + (b[0]-b[1]);

          if(c==0l) return 0;
          if(c>0l) return 1;
          return -1;
        }
   }
  
   static class sort11 implements Comparator<double[]>
   {
        public int compare(double[] a,double[] b)
        {
            //if(a[0] == b[0]) return a[1]-b[1];
           if(a[1] < b[1]) return -1;
           else if(a[1] > b[1]) return 1;
           return 0;
        }
   }
   public static String[] F(BufferedReader bf) throws Exception
    {
        return (bf.readLine().split("" ""));
    }
    
   public static void pr(PrintWriter out,Object o)
   {
      
    out.println(o.toString());//out.flush();
    
   }
   public static void prW(PrintWriter out,Object o)
   {
      
    out.print(o.toString());//out.flush();
    
   }
   public static int intIn(String st)
   {
      return Integer.parseInt(st);
   }
   
   
    
    public static void pr(Object o)
    {
        System.out.println(o.toString());
    }
    public static void prW(Object o)
    {
        System.out.print(o.toString());
    }
    
   
    public static int inInt(String s)
    {
        return Integer.parseInt(s);
    }
    public static long in(String s)
    {
        return Long.parseLong(s);
    }
 
 
    static int[] toIntArray(String[] m) 
    { 
        int[] p=new int[m.length];
        for(int o=0;o<m.length;o++)
        {
            p[o]= inInt(m[o]);
        }
        return p;
    }
    static double[] toDArray(String[] m) 
    { 
        double[] p=new double[m.length];
        for(int o=0;o<m.length;o++)
        {
            p[o]= Double.parseDouble(m[o]);
        }
        return p;
    }
    static long[] toLArray(String[] m) 
    { 
       long[] p=new long[m.length];
        for(int o=0;o<m.length;o++)
        {
            p[o]= in(m[o]);
        }
        return p;
    }
   
     static long gcd(long a, long b)
        {
          if (b == 0)
            return a;
          return gcd(b, a % b); 
        }
     
        static long pow(long x, long y, long p)
      {
        if(y == 0) return 1l;
        long res = 1; // Initialize result
     
        x = x % p; // Update x if it is more than or
        // equal to p
     
        if (x == 0)
          return 0l; // In case x is divisible by p;
     
        while (y > 0)
        {
     
          // If y is odd, multiply x with result
          if ((y & 1) != 0)
            res = (res * x) % p;
     
          // y must be even now
          y = y >> 1; // y = y/2
          x = (x * x) % p;
        }
        return res;
      }
    
   
    

   
   

   
    static long __gcd(long n1, long n2)
    {

        if(n1==0l) return n2;
        if(n2==0l) return n1;
        if(n1==1l || n2==1l) return 1l;
       // long gcd = 1;
        if(n1 == n2)  return n1;
        if(n1>n2) return __gcd(n1%n2,n2);
        return __gcd(n1,n2%n1);
        
    }
    
   
    
    public static boolean ok(long l,long m)
    {
       long sum=0l;
       long h=l;
       while(l>0)
       {
        sum += (l%10);
        l=(l/10l);
       }
       long diff = h-sum;
       if(diff >= m) return true;
       return false;
    }
    public static void main (String[] args) throws Exception {
        
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);;;
        
        //int[] map=new int[1000001];
      
       int yy=1;//inInt(bf.readLine());
       


        //Long[][][] dp = new Long[100001][101][2];
        for(int w=0;w<yy;w++)
        {
             //String str = bf.readLine();
          out.flush();
         
            String[] xlp = bf.readLine().split("" "");
            //String st = bf.readLine();
        long n;//boolean bol=false;
           long  m;//long a,b,c;
          // int l;
           //int  k;//pr(out,""vbc"");

         n=in(xlp[0]);m=in(xlp[1]);//int ta=inInt(xlp[2]);int tb=inInt(xlp[3]);k=inInt(xlp[4]);

         long res = Math.max(0,(n-(18l*9l+m)));
         long v = Math.min(n,18l*9l+m);
         for(long i = m;i<=v;i++)
         {
            if(ok(i,m)) res++;
         }

         pr(out,res);

         
        





   }
    out.close();
   bf.close();//
}}


/*

10
6 4 3 9 5 2 1 10 8 7

Kickstart
 String rp;
            rp = ""Case #""+(w+1)+"": ""+(n-ans)+"" "";
static int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};

static class SegmentTreeRMQ 
    { 
    int st[]; 
    int minVal(int x, int y) { 
        return (x > y) ? x : y; 
    } 
  
    
    int getMid(int s, int e) { 
        return s + (e - s) / 2; 
    } 
  
    
    int RMQUtil(int ss, int se, int qs, int qe, int index) 
    { 
        
        if (qs <= ss && qe >= se) 
            return st[index]; 
  
        // If segment of this node is outside the given range 
        if (se < qs || ss > qe) 
            return Integer.MIN_VALUE; 
  
        // If a part of this segment overlaps with the given range 
        int mid = getMid(ss, se); 
        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), 
                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); 
    } 
  
    // Return minimum of elements in range from index qs (query 
    // start) to qe (query end).  It mainly uses RMQUtil() 
    int RMQ(int n, int qs, int qe) 
    { 
        // Check for erroneous input values 
        
  
        return RMQUtil(0, n - 1, qs, qe, 0); 
    } 
  
    // A recursive function that constructs Segment Tree for 
    // array[ss..se]. si is index of current node in segment tree st 
    int constructSTUtil(int arr[], int ss, int se, int si) 
    { 
        // If there is one element in array, store it in current 
        //  node of segment tree and return 
        if (ss == se) { 
            st[si] = arr[ss]; 
            return arr[ss]; 
        } 
  
        // If there are more than one elements, then recur for left and 
        // right subtrees and store the minimum of two values in this node 
        int mid = getMid(ss, se); 
        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), 
                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); 
        return st[si]; 
    } 
  
    
    void con(int arr[]) 
    { 
        // Allocate memory for segment tree 
  
        //Height of segment tree 
        int n = (arr.length);
        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); 
  
        //Maximum size of segment tree 
        int max_size = 2 * (int) Math.pow(2, x) - 1; 
        st = new int[max_size]; // allocate memory 
  
        // Fill the allocated memory st 
        constructSTUtil(arr, 0, n - 1, 0); 
    }
    }
     static class DSU {
    
    int[] p;int[] sz;int op;int c;;
    int[] last;
    public void G(int n)
    {
        last=new int[n];
        p=new int[n];
        sz=new int[n];c=n;
        op=n;
        for(int h=0;h<n;h++)
        {
            sz[h]=1;p[h]=h;
            last[h]=h;
        }
    }
    public int find(int x)
    {
        int y=x;
        while(x!=p[x]) x=p[x];
        while(y!=p[y])
        {
            int tem=p[y];
            p[y]=x;y=tem;
        }
        return p[y];
    }
    public void union(int a,int b)
    {
        int x,y;
        x=find(a);y=find(b);
        if(x==y) return;
        if(sz[x]>sz[y])
        {
            p[y] = x;
            sz[x]+=sz[y];
            last[x]=Math.max(last[x],last[y]);
        }
        else
        {
            p[x]=y;sz[y]+=sz[x];
            last[y]=Math.max(last[y],last[x]);
        }
        c--;
        
    }}

    static long pow(long x, long y, long p)
      {
        long res = 1; // Initialize result
     
        x = x % p; // Update x if it is more than or
        // equal to p
     
        if (x == 0)
          return 0l; // In case x is divisible by p;
     
        while (y > 0)
        {
     
          // If y is odd, multiply x with result
          if ((y & 1) != 0)
            res = (res * x) % p;
     
          // y must be even now
          y = y >> 1; // y = y/2
          x = (x * x) % p;
        }
        return res;
      }
      static long gcd(long a, long b)
        {
          if (b == 0)
            return a;
          return gcd(b, a % b); 
        }
        static int gcd(int a, int b,int o)
        {
          if (b == 0)
            return a;
          return gcd(b, a % b,o); 
        }

Geometric median

public static double F(double[] x,double[] w)
    {
        double d1,d2;
        double S=0.00;
        for(double dp : w) S += dp;
        int k = 0;
        double sum = S - w[0]; // sum is the total weight of all `x[i] > x[k]`

        while(sum > S/2)
        {
            ++k;
            sum -= w[k];
        }
        d1=x[k];
        return d1;
        k = w.length-1;
       sum = S - w[k]; // sum is the total weight of all `x[i] > x[k]`

        while(sum > S/2)
        {
            --k;
            sum -= w[k];
        }
        d2=x[k];
        return new double[]{d1,d2};
    }
*/


",2,0817_C,CODEFORCES,1054,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.math.BigInteger;
import java.util.*;
import java.io.*;

public class Main {
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }
        String next() { while (st == null || !st.hasMoreElements()) {
            try { st = new StringTokenizer(br.readLine()); }
            catch (IOException e) { e.printStackTrace(); } }
            return st.nextToken();
        }

        int nextInt() { return Integer.parseInt(next()); }
        long nextLong() { return Long.parseLong(next()); }
        double nextDouble() { return Double.parseDouble(next()); }

        String nextLine() {
            String str = """";
            try { str = br.readLine(); }
            catch (IOException e) { e.printStackTrace(); }
            return str;
        }
    }

    static boolean check(long num,long s){
        long sum=0;
        long v=num;
        while(num>0){
            sum+=num%10;
            num=num/10;
        }
        if(v-sum>=s){
            return true;
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        FastReader ip = new FastReader();
        OutputStream output = System.out;
        PrintWriter out = new PrintWriter(output);
        long n=ip.nextLong();
        long s= ip.nextLong();
        long nearest=0;
        if(s%9==0){
            nearest=s;
        }else{
            nearest=((s/9)+1)*9;
        }

        long low=nearest;
        long high=(long)Math.pow(10,18);
        while(low<=high){
            long mid=(high+low)/2;
            if(check(mid,s)){
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        long number=low;
        if(number>n){
            out.print(0);
        }else{
            out.print((n-number)+1);
        }
        out.close();
    }
}",2,0817_C,CODEFORCES,1137,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            long n = in.nextLong();
            long s = in.nextLong();
            long ans = 0;
            long i = 0;
            for (i = s; i <= n; i++) {
                long t = i - sum(i);
                if (t >= s) {
                    if (i % 10 == 9) {
                        break;
                    }
                    ans++;
                }
            }
            if (n >= s) {
                out.println(ans - i + n + 1);
            } else {
                out.println(0);
            }
        }

        static long sum(long a) {
            long sum = 0;
            while (a != 0) {
                sum += (a % 10);
                a /= 10;
            }
            return sum;
        }

    }
}

",2,0817_C,CODEFORCES,1085,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/*Author: Satyajeet Singh, Delhi Technological University*/
import java.io.*;
import java.util.*;
import java.text.*; 
import java.lang.*;

public class Main {
/*********************************************Constants******************************************/
    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static long mod=(long)1e9+7;
    static long mod1=998244353;
    static boolean sieve[];
    static ArrayList<Integer> primes;
    static ArrayList<Long> factorial;
    static HashSet<Integer> graph[];
/****************************************Solutions Begins*****************************************/
    static long sumd(long x){
        long ans=0;
        while(x!=0){
            ans+=x%10;
            x/=10;
        }
        return ans;
    }
    public static void main (String[] args) throws Exception {
        String st[]=br.readLine().split("" "");
        long n=Long.parseLong(st[0]);
        long s=Long.parseLong(st[1]);
        long start=0;
        long end=n;
        long ans=-1;
        while(start<=end){
            long mid=start+(end-start)/2;
            if(mid-sumd(mid)>=s){
                ans=mid;
                end=mid-1;
            }
            else{
                start=mid+1;
            }
        }
        if(ans!=-1)
        out.println(n-ans+1);
        else out.println(0);
  
/****************************************Solutions Ends**************************************************/
        out.flush();
        out.close();
    }
/****************************************Template Begins************************************************/
/***************************************Precision Printing**********************************************/
    static void printPrecision(double d){
        DecimalFormat ft = new DecimalFormat(""0.000000""); 
        out.println(ft.format(d));
    }
/******************************************Graph*********************************************************/
    static void Makegraph(int n){
        graph=new HashSet[n];
        for(int i=0;i<n;i++){
            graph[i]=new HashSet<>();
        }
    }
    static void addEdge(int a,int b){
        graph[a].add(b);
    }    

/*********************************************PAIR********************************************************/
    static class PairComp implements Comparator<Pair>{
        public int compare(Pair p1,Pair p2){
            if(p1.u>p2.u){
                return 1;
            }
            else if(p1.u<p2.u){
                return -1;
            }
            else{
                return p1.v-p2.v;
            }
        }
    }
    static class Pair implements Comparable<Pair> {
        int u;
        int v;
        int index=-1;
        public Pair(int u, int v) {
            this.u = u;
            this.v = v;
        }
 
        public int hashCode() {
            int hu = (int) (u ^ (u >>> 32));
            int hv = (int) (v ^ (v >>> 32));
            return 31 * hu + hv;
        }
 
        public boolean equals(Object o) {
            Pair other = (Pair) o;
            return u == other.u && v == other.v;
        }
 
        public int compareTo(Pair other) {
            if(index!=other.index)
                return Long.compare(index, other.index);
            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
        }
 
        public String toString() {
            return ""[u="" + u + "", v="" + v + ""]"";
        }
    }
/*******************************************LONG PAIR****************************************************/
    static class PairCompL implements Comparator<Pairl>{
        public int compare(Pairl p1,Pairl p2){
            if(p1.u>p2.u){
                return 1;
            }
            else if(p1.u<p2.u){
                return -1;
            }
            else{
                return 0;
            }
        }
    }
    static class Pairl implements Comparable<Pair> {
            long u;
            long v;
            int index=-1;
            public Pairl(long u, long v) {
                this.u = u;
                this.v = v;
            }
    
            public int hashCode() {
                int hu = (int) (u ^ (u >>> 32));
                int hv = (int) (v ^ (v >>> 32));
                return 31 * hu + hv;
            }
    
            public boolean equals(Object o) {
                Pair other = (Pair) o;
                return u == other.u && v == other.v;
            }
    
            public int compareTo(Pair other) {
                if(index!=other.index)
                    return Long.compare(index, other.index);
                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
            }
    
            public String toString() {
                return ""[u="" + u + "", v="" + v + ""]"";
            }
        }
/*****************************************DEBUG***********************************************************/
    public static void debug(Object... o) {
        System.out.println(Arrays.deepToString(o));
    }
/*****************************************NUMBER THEORY****************************************************/
/************************************MODULAR EXPONENTIATION***********************************************/
    static long modulo(long a,long b,long c) {
        long x=1;
        long y=a;
        while(b > 0){
            if(b%2 == 1){
                x=(x*y)%c;
            }
            y = (y*y)%c; // squaring the base
            b /= 2;
        }
        return  x%c;
    }
/********************************************GCD**********************************************************/
    static long gcd(long x, long y)
    {
        if(x==0)
            return y;
        if(y==0)
            return x;
        long r=0, a, b;
        a = (x > y) ? x : y; // a is greater number
        b = (x < y) ? x : y; // b is smaller number
        r = b;
        while(a % b != 0)
        {
            r = a % b;
            a = b;
            b = r;
        }
        return r;
    }
/******************************************SIEVE**********************************************************/
    static void sieveMake(int n){
        sieve=new boolean[n];
        Arrays.fill(sieve,true);
        sieve[0]=false;
        sieve[1]=false;
        for(int i=2;i*i<n;i++){
            if(sieve[i]){
                for(int j=i*i;j<n;j+=i){
                    sieve[j]=false;
                }
            }
        }
        primes=new ArrayList<Integer>();
        for(int i=0;i<n;i++){
            if(sieve[i]){
                primes.add(i);
            }
        }        
    }
/***************************************FACTORIAL*********************************************************/
    static void fact(int n){
        factorial=new ArrayList<>();
        factorial.add((long)1);
        for(int i=1;i<=n;i++){
            factorial.add((factorial.get(i-1)*i)%mod);
        }
    }
/*******************************************ncr*********************************************************/
    static long ncr(int n,int k){
        long aa=modulo(factorial.get(n-k),mod-2,mod);
        long bb=modulo(factorial.get(k),mod-2,mod);
        long cc=factorial.get(n);
        long ans=(aa*cc)%mod;
        ans=(ans*bb)%mod;
        return ans;
    }
/***************************************STRING REVERSE****************************************************/
    static String reverse(String str){
        char r[]=new char[str.length()];
        int j=0;
        for(int i=str.length()-1;i>=0;i--){
            r[j]=str.charAt(i);
            j++;
        }
        return new String(r);
    }
}
/********************************************End***********************************************************/",2,0817_C,CODEFORCES,1131,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author dipankar12
 */
import java.io.*;
import java.util.*;
public class r23c {
    public static void main(String args[])
    {
        fastio in=new fastio(System.in);
        PrintWriter pw=new PrintWriter(System.out);

        long n=in.nextLong();
        long s=in.nextLong();
        
        long l=1,h=n;
        long ans=-1;
        while(l<=h)
        {
            long mid=(l+h)/2;
            //pw.println(""mid is""+mid);
            long p=mid;
            long sum=0;
            while(p!=0)
            {
                sum+=p%10;
                p/=10;
            }
            
            if(mid-sum>=s)
            {
                ans=mid;
                h=mid-1;
            }
            else
                l=mid+1;
        }
        if(ans==-1)
            pw.println(0);
        else
            pw.println(n-ans+1);
        pw.close();
    }

    static class fastio {
     
            private final InputStream stream;
            private final byte[] buf = new byte[8192];
            private int cchar, snchar;
            private SpaceCharFilter filter;
     
            public fastio(InputStream stream) {
                this.stream = stream;
            }
     
            public int nxt() {
                if (snchar == -1)
                    throw new InputMismatchException();
                if (cchar >= snchar) {
                    cchar = 0;
                    try {
                        snchar = stream.read(buf);
                    } catch (IOException e) {
                        throw new InputMismatchException();
                    }
                    if (snchar <= 0)
                        return -1;
                }
                return buf[cchar++];
            }
     
            public int nextInt() {
                int c = nxt();
                while (isSpaceChar(c)) {
                    c = nxt();
                }
                int sgn = 1;
                if (c == '-') {
                    sgn = -1;
                    c = nxt();
                }
                int res = 0;
                do {
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res *= 10;
                    res += c - '0';
                    c = nxt();
                } while (!isSpaceChar(c));
                return res * sgn;
            }
     
            public long nextLong() {
                int c = nxt();
                while (isSpaceChar(c)) {
                    c = nxt();
                }
                int sgn = 1;
                if (c == '-') {
                    sgn = -1;
                    c = nxt();
                }
                long res = 0;
                do {
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res *= 10;
                    res += c - '0';
                    c = nxt();
                } while (!isSpaceChar(c));
                return res * sgn;
            }
     
            public int[] nextIntArray(int n) {
                int a[] = new int[n];
                for (int i = 0; i < n; i++) {
                    a[i] = nextInt();
                }
                return a;
            }
     
            public String readString() {
                int c = nxt();
                while (isSpaceChar(c)) {
                    c = nxt();
                }
                StringBuilder res = new StringBuilder();
                do {
                    res.appendCodePoint(c);
                    c = nxt();
                } while (!isSpaceChar(c));
                return res.toString();
            }
     
            public String nextLine() {
                int c = nxt();
                while (isSpaceChar(c))
                    c = nxt();
                StringBuilder res = new StringBuilder();
                do {
                    res.appendCodePoint(c);
                    c = nxt();
                } while (!isEndOfLine(c));
                return res.toString();
            }
     
            public boolean isSpaceChar(int c) {
                if (filter != null)
                    return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
            }
     
            private boolean isEndOfLine(int c) {
                return c == '\n' || c == '\r' || c == -1;
            }
     
            public interface SpaceCharFilter {
                public boolean isSpaceChar(int ch);
            }
        }
    

}
",2,0817_C,CODEFORCES,1121,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/*

 * 

 * @Author  Ajudiya_13(Bhargav Girdharbhai Ajudiya)

 * Dhirubhai Ambani Institute of Information And Communication Technology 

 * 

 */





import java.util.*;

import java.io.*;

import java.lang.*;



public class Code166

{

	

	

	static class InputReader {

		 

		private final InputStream stream;

		private final byte[] buf = new byte[8192];

		private int curChar, snumChars;

		private SpaceCharFilter filter;

 

		public InputReader(InputStream stream) {

			this.stream = stream;

		}

 

		public int snext() {

			if (snumChars == -1)

				throw new InputMismatchException();

			if (curChar >= snumChars) {

				curChar = 0;

				try {

					snumChars = stream.read(buf);

				} catch (IOException e) {

					throw new InputMismatchException();

				}

				if (snumChars <= 0)

					return -1;

			}

			return buf[curChar++];

		}

 

		public int nextInt() {

			int c = snext();

			while (isSpaceChar(c)) {

				c = snext();

			}

			int sgn = 1;

			if (c == '-') {

				sgn = -1;

				c = snext();

			}

			int res = 0;

			do {

				if (c < '0' || c > '9')

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = snext();

			} while (!isSpaceChar(c));

			return res * sgn;

		}

 

		public long nextLong() {

			int c = snext();

			while (isSpaceChar(c)) {

				c = snext();

			}

			int sgn = 1;

			if (c == '-') {

				sgn = -1;

				c = snext();

			}

			long res = 0;

			do {

				if (c < '0' || c > '9')

					throw new InputMismatchException();

				res *= 10;

				res += c - '0';

				c = snext();

			} while (!isSpaceChar(c));

			return res * sgn;

		}

 

		public int[] nextIntArray(int n) {

			int a[] = new int[n];

			for (int i = 0; i < n; i++) {

				a[i] = nextInt();

			}

			return a;

		}

 

		public String readString() {

			int c = snext();

			while (isSpaceChar(c)) {

				c = snext();

			}

			StringBuilder res = new StringBuilder();

			do {

				res.appendCodePoint(c);

				c = snext();

			} while (!isSpaceChar(c));

			return res.toString();

		}

 

		public String nextLine() {

			int c = snext();

			while (isSpaceChar(c))

				c = snext();

			StringBuilder res = new StringBuilder();

			do {

				res.appendCodePoint(c);

				c = snext();

			} while (!isEndOfLine(c));

			return res.toString();

		}

 

		public boolean isSpaceChar(int c) {

			if (filter != null)

				return filter.isSpaceChar(c);

			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

		}

 

		private boolean isEndOfLine(int c) {

			return c == '\n' || c == '\r' || c == -1;

		}

 

		public interface SpaceCharFilter {

			public boolean isSpaceChar(int ch);

		}

	}

	

	public static long mod = 1000000007;

	public static int d;

	public static int p;

	public static int q;

	

	public static int[] suffle(int[] a,Random gen)

	{

		int n = a.length;

		for(int i=0;i<n;i++)

		{

			int ind = gen.nextInt(n-i)+i;

			int temp = a[ind];

			a[ind] = a[i];

			a[i] = temp;

		}

		return a;

	}

	

	public static void swap(int a, int b){

		int temp = a;

		a = b;

		b = temp;

	}

	

	public static ArrayList<Integer> primeFactorization(int n)

	{

		ArrayList<Integer> a =new ArrayList<Integer>();

		for(int i=2;i*i<=n;i++)

		{

			while(n%i==0)

			{

				a.add(i);

				n/=i;

			}

		}

		if(n!=1)

			a.add(n);

		return a;

	}

	

	public static void sieve(boolean[] isPrime,int n)

	{

		for(int i=1;i<n;i++)

			isPrime[i] = true;

		

		isPrime[0] = false;

		isPrime[1] = false;

		

		for(int i=2;i*i<n;i++)

		{

			if(isPrime[i] == true)

			{

				for(int j=(2*i);j<n;j+=i)

					isPrime[j] = false;

			}

		}

	}

	

	public static int GCD(int a,int b)

	{

		if(b==0)

			return a;

		else

			return GCD(b,a%b);

	}

	

	public static long GCD(long a,long b)

	{

		if(b==0)

			return a;

		else

			return GCD(b,a%b);

	}

	

	public static void extendedEuclid(int A,int B)

	{

		if(B==0)

		{

			d = A;

			p = 1 ;

			q = 0;

		}

		else

		{

			extendedEuclid(B, A%B);

			int temp = p;

			p = q;

			q = temp - (A/B)*q;

		}

	}

	

	public static long LCM(long a,long b)

	{

		return (a*b)/GCD(a,b);

	}

	

	public static int LCM(int a,int b)

	{

		return (a*b)/GCD(a,b);

	}

	

	public static int binaryExponentiation(int x,int n)

	{

	    int result=1;

	    while(n>0)

	    {

	        if(n % 2 ==1)

	            result=result * x;

	        x=x*x;

	        n=n/2;

	    }

	    return result;

	}

	

	public static long binaryExponentiation(long x,long n)

	{

	    long result=1;

	    while(n>0)

	    {

	        if(n % 2 ==1)

	            result=result * x;

	        x=x*x;

	        n=n/2;

	    }

	    return result;

	}

	

	public static int modularExponentiation(int x,int n,int M)

	{

	    int result=1;

	    while(n>0)

	    {

	        if(n % 2 ==1)

	            result=(result * x)%M;

	        x=(x*x)%M;

	        n=n/2;

	    }

	    return result;

	}

	

	public static long modularExponentiation(long x,long n,long M)

	{

	    long result=1;

	    while(n>0)

	    {

	        if(n % 2 ==1)

	            result=(result * x)%M;

	        x=(x*x)%M;

	        n=n/2;

	    }

	    return result;

	}

	

	public static int modInverse(int A,int M)

	{

	    return modularExponentiation(A,M-2,M);

	}

	

	public static long modInverse(long A,long M)

	{

	    return modularExponentiation(A,M-2,M);

	}

	

	public static boolean isPrime(int n)

	{

	    

	    if (n <= 1)  return false;

	    if (n <= 3)  return true;

	    

	    if (n%2 == 0 || n%3 == 0) 

	    	return false;

	 

	    for (int i=5; i*i<=n; i=i+6)

	    {

	        if (n%i == 0 || n%(i+2) == 0)

	           return false;

	    }

	    

	    return true;

	}

	

	static class pair implements Comparable<pair>

	{

		Integer x, y;

		pair(int x,int y)

		{

			this.x=x;

			this.y=y;

		}

		

		public int compareTo(pair o) {

			int result = x.compareTo(o.x);

			if(result==0)

				result = y.compareTo(o.y);

			

			return result;

		}  

	}

	

	public static boolean check(long n,long s)

	{

		long sum = 0;

		long p = n;

		while(n>0)

		{

			sum+=(n%10);

			n/=10;

		}

		if(p-sum>=s)

			return true;

		else

			return false;

	}

	

	public static long binarySearch(long n,long s)

	{

		long start = 1;

		long end = n;

		long ans = 0;

		

		while(start<=end)

		{

			long mid = (start+end)/2;

			if(check(mid, s))

				end = mid-1;

			else

			{

				ans = mid;

				start = mid+1;

			}

				

		}

		return ans;

	}

	

	public static void main(String[] args)

	{

		InputReader in = new InputReader(System.in);

		PrintWriter pw = new PrintWriter(System.out);

		

		long n = in.nextLong();

		long s = in.nextLong();

		long ans = binarySearch(n, s);

		

		pw.println(n-ans);

		pw.flush();

		pw.close();

	}

}",2,0817_C,CODEFORCES,1112,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/*

ID: mchensd

LANG: JAVA

PROG: ReallyBigNumbers

 */



/**

 *

 * @author Michael

 */



import java.util.*;

import java.io.*;



public class ReallyBigNumbers {

    long s;

    

    public long sumOfDigits(long x) {

        char[] dig = ("""" + x).toCharArray();

        

        int sum = 0;

        for (int i=0; i<dig.length; ++i) {

            sum += dig[i] - '0';

        }

        return sum;

    }

    

    public boolean can(long x) {

        return x - sumOfDigits(x) >= s;

    }

    public void run(BufferedReader br, PrintWriter pw) throws IOException {

        StringTokenizer st;

        st = new StringTokenizer(br.readLine());

        long n = Long.parseLong(st.nextToken());

        s = Long.parseLong(st.nextToken());

        

        long lb = 1;

        long ub = n;

        while (true) {

            if (lb == ub) break;

            long xs = (lb + ub) / 2;

            if (can(xs)) ub = xs;

            else lb = xs + 1;

        }

        

        if (lb == n) {

            if (can(n)) pw.println(1);

            else pw.println(0);

        }

        

        else {

            pw.println(n-lb+1);

        }

    }

    public static void main(String[] args) throws IOException {

//        new ReallyBigNumbers().runFileIO(""ReallyBigNumbers"");

        new ReallyBigNumbers().runStdIO();



    }

    

    public void runFileIO(String filename) throws IOException {

        BufferedReader br = new BufferedReader(new FileReader(filename + "".in""));

        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename + "".out"")));

        run(br, pw);

        pw.close();

    }



    public void runStdIO() throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        PrintWriter pw = new PrintWriter(System.out);

        run(br, pw);

        pw.close();

    }

}



",2,0817_C,CODEFORCES,1111,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Contest03_D {

	public static void solve() {
		long n = s.nextLong();
		long st = s.nextLong();
		out.println(n-possible(n, st)+1);
	}
	
	public static long possible(long n,long st) {
		long start = 0;
		long end = n;
		long ans = n+1;
		while(start<=end) {
			long mid = (start+end)/2L;
			long actual = actual(mid);
			if(actual>=st) {
				ans = mid;
				end = mid-1;
			}else {
				start = mid+1;
			}
		}
		return ans;
	}

	public static long actual(long mid) {
		String str = Long.toString(mid);
		for(int i=0;i<str.length();i++) {
			mid-=str.charAt(i)-'0';
		}
		return mid;
	}
	
	public static void main(String[] args) {
		out = new PrintWriter(new BufferedOutputStream(System.out));
		s = new FastReader();
		solve();
		out.close();
	}

	public static FastReader s;
	public static PrintWriter out;

	public static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (Exception e) {
				e.printStackTrace();
			}
			return str;
		}
	}

	
}

	 	   		     	     	  				  			",2,0817_C,CODEFORCES,1136,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/*

 * DA-IICT

 * Author: Jugal Kalal

 */

import java.util.*;

import java.io.*;

import java.math.*;

import java.text.DecimalFormat;

public class Practice{

	static long MOD=(long)Math.pow(10,9)+7;

	public static void main(String args[]) {

        new Thread(null, new Runnable() {

            public void run() {

                try{

                    solve();

                    w.close();

                }

                catch(Exception e){

                    e.printStackTrace();

                }

            }

        }, ""1"", 1 << 26).start();

	}

	static InputReader in;

    static PrintWriter w;

    static void solve(){

        in = new InputReader(System.in);

        w = new PrintWriter(System.out);

        long n=in.nextLong();

        long s=in.nextLong();

        long low=1,high=n,ans=-1;

        while(low<=high){

        	long mid=(low+high)/2;

        	if(check(mid,s)){

        		ans=mid;

        		high=mid-1;

        	}else{

        		low=mid+1;

        	}

        }

        if(ans==-1){

        	w.println(0);

        }else

        	w.println(n-ans+1);

    }

    static boolean check(long n,long s){

    	long temp=n;

    	long sum=0;

    	while(temp>0){

    		sum+=temp%10;

    		temp=temp/10;

    	}

    	if(n-sum>=s){

    		return true;

    	}

    	return false;

    }

    static int adj[][];

//    static ArrayList<Integer> adj[]; //Adjacency Lists

    static int V;   // No. of vertices

    // Constructor

    static void Graph(int v){

        V = v;

        adj=new int[v][v];

//        adj = new ArrayList[v];

//        for (int i=0; i<v; ++i){

//        	adj[i] = new ArrayList();

//        }

    }

    // Function to add an edge into the graph

    static void addEdge(int u,int v,int w){

//		adj[u].add(v);

//		adj[v].add(u);

    	adj[u][v]=w;

    }

//    static void bfs(int s,int n){

//    	boolean visited[]=new boolean[n];

//    	LinkedList<Integer> queue=new LinkedList<Integer>();

//    	queue.add(s);

//    	visited[s]=true;

//    	while(!queue.isEmpty()){

//    		int num=queue.pop();

////    		System.out.println(ans.toString());

//    		for(int i=0;i<adj[num].size();i++){

//    			if(!visited[adj[num].get(i)]){

//    				visited[adj[num].get(i)]=true;

//    				queue.add(adj[num].get(i));

//    			}

//    		}

//    	}

//    }

    static long gcd(long a,long b){

		if(a==0){

			return b;

		}

		return gcd(b%a,a);

	}

    static long power(long base, long exponent, long modulus){

	    long result = 1L;

	    while (exponent > 0) {

	        if (exponent % 2L == 1L)

	            result = (result * base) % modulus;

	        exponent = exponent >> 1;

	        base = (base * base) % modulus;

	    }

	    return result;

	}

    static HashMap<Long,Long> primeFactors(long n){

        HashMap<Long,Long> ans=new HashMap<Long,Long>();

    	// Print the number of 2s that divide n

        while (n%2L==0L)

        {

            if(ans.containsKey(2L)){

            	ans.put(2L,ans.get(2L)+1L);

            }else{

            	ans.put(2L,1L);

            }

            n /= 2L;

        }

 

        // n must be odd at this point.  So we can

        // skip one element (Note i = i +2)

        for (long i = 3; i <= Math.sqrt(n); i+= 2L)

        {

            // While i divides n, print i and divide n

            while (n%i == 0)

            {

            	if(ans.containsKey(i)){

                	ans.put(i,ans.get(i)+1L);

                }else{

                	ans.put(i,1L);

                }

                n /= i;

            }

        }

 

        // This condition is to handle the case whien

        // n is a prime number greater than 2

        if (n > 2)

            ans.put(n,1L);

        return ans;

    }

////for marking all prime numbers greater than 1 and less than equal to N

	static void sieve(int N) {

	 boolean isPrime[]=new boolean[N+1];

	 isPrime[0] = true;

	 isPrime[1] = true;

	 for(int i = 2; i * i <= N; ++i) {

	      if(isPrime[i] == false) {//Mark all the multiples of i as composite numbers

	          for(int j = i * i; j <= N ;j += i)

	              isPrime[j] = true;

	     }

	 }

	}

//  //if  str2 (pattern) is subsequence of str1 (Text) or not

//	static boolean function(String str1,String str2){

//	     str2 = str2.replace("""", "".*"");  //returns .*a.*n.*n.*a.

//	     return (str1.matches(str2));  // returns true

//	}

    static int Arr[];

    static long size[];

  //modified initialize function:

    static void initialize(int N){

    	Arr=new int[N];

    	size=new long[N];

        for(int i = 0;i<N;i++){

        	Arr[ i ] = i ;

        	size[ i ] = 1;

        }

    }

    static boolean find(int A,int B){

        if( root(A)==root(B) )       //if A and B have same root,means they are connected.

        return true;

        else

        return false;

    }

 // modified root function.

    static void weighted_union(int A,int B,int n){

        int root_A = root(A);

        int root_B = root(B);

        if(size[root_A] < size[root_B ]){

        	Arr[ root_A ] = Arr[root_B];

        	size[root_B] += size[root_A];

        }

        else{

        	Arr[ root_B ] = Arr[root_A];

        	size[root_A] += size[root_B];

        }

    }

    static int root (int i){

        while(Arr[ i ] != i){

            Arr[ i ] = Arr[ Arr[ i ] ] ; 

            i = Arr[ i ]; 

        }

        return i;

    }

    

 

	static boolean isPrime(long n) {

		if(n < 2L) return false;

		if(n == 2L || n == 3L) return true;

		if(n%2L == 0 || n%3L == 0) return false;	

		long sqrtN = (long)Math.sqrt(n)+1L;

		for(long i = 6L; i <= sqrtN; i += 6L) {

			if(n%(i-1) == 0 || n%(i+1) == 0) return false;

		}

		return true;

	}

//	static HashMap<Integer,Integer> level;;

//	static HashMap<Integer,Integer> parent;

	static int maxlevel=0;

	

//	static boolean T[][][];

//	static void subsetSum(int input[], int total, int count) {

//        T = new boolean[input.length + 1][total + 1][count+1];

//        for (int i = 0; i <= input.length; i++) {

//        	T[i][0][0] = true;

//        	for(int j = 1; j<=count; j++){

//        		T[i][0][j] = false;

//        	}

//        }

//        int sum[]=new int[input.length+1];

//        for(int i=1;i<=input.length;i++){

//            sum[i]=sum[i-1]+input[i-1];

//        }

//        for (int i = 1; i <= input.length; i++) {

//            for (int j = 1; j <= (int)Math.min(total,sum[i]); j++) {

//            	for (int k = 1; k <= (int)Math.min(i,count); k++){

//            		 if (j >= input[i - 1]) {//Exclude and Include

//                         T[i][j][k] = T[i - 1][j][k] || T[i - 1][j - input[i - 1]][k-1];

//                     } else {

//                         T[i][j][k] = T[i-1][j][k];

//                     }

//            	}

//            }

//        }

//    }

//	static <K,V extends Comparable<? super V>>

//	SortedSet<Map.Entry<K,V>> entriesSortedByValues(Map<K,V> map) {

//	    SortedSet<Map.Entry<K,V>> sortedEntries = new TreeSet<Map.Entry<K,V>>(

//	        new Comparator<Map.Entry<K,V>>() {

//	            @Override public int compare(Map.Entry<K,V> e1, Map.Entry<K,V> e2) {

//	                int res = e2.getValue().compareTo(e1.getValue());

//	                return res != 0 ? res : 1;

//	            }

//	        }

//	    );

//	    sortedEntries.addAll(map.entrySet());

//	    return sortedEntries;

//	}

	

 

	 

	//minimum prime factor of all the numbers less than n

    static int minPrime[];

	static void minimumPrime(int n){

		minPrime=new int[n+1];

		minPrime[1]=1;

        for (int i = 2; i * i <= n; ++i) {

            if (minPrime[i] == 0) {         //If i is prime

                for (int j = i * i; j <= n; j += i) {

                    if (minPrime[j] == 0) {

                        minPrime[j] = i;

                    }

                }

            }

        }

        for (int i = 2; i <= n; ++i) {

            if (minPrime[i] == 0) {

                minPrime[i] = i;

            }

        }

	}

	static long modInverse(long A, long M)

	{

		long x=extendedEuclid(A,M)[0];

		return (x%M+M)%M;    //x may be negative

	}

	static long[] extendedEuclid(long A, long B) {

		if(B == 0) {

			long d = A;

			long x = 1;

			long y = 0;

			return new long[]{x,y,d};

		}

		else {

			long arr[]=extendedEuclid(B, A%B);

			long temp = arr[0];

			arr[0] = arr[1];

			arr[1] = temp - (A/B)*arr[1];

			return arr;

		}

	}

 

	static class InputReader {

        private final InputStream stream;

        private final byte[] buf = new byte[8192];

        private int curChar, numChars;

        private SpaceCharFilter filter;

 

        public InputReader(InputStream stream) {

            this.stream = stream;

        }

        

        public int read() {

            if (numChars == -1) {

                throw new InputMismatchException();

            }

            if (curChar >= numChars) {

                curChar = 0;

                try {

                    numChars = stream.read(buf);

                } catch (IOException e) {

                    throw new InputMismatchException();

                }

                if (numChars <= 0) {

                    return -1;

                }

            }

            return buf[curChar++];

        }

 

        public String nextLine() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            StringBuilder res = new StringBuilder();

            do {

                res.appendCodePoint(c);

                c = read();

            } while (!isEndOfLine(c));

            return res.toString();

        }

 

        public String readString() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            StringBuilder res = new StringBuilder();

            do {

                res.appendCodePoint(c);

                c = read();

            } while (!isSpaceChar(c));

            return res.toString();

        }

 

        public long nextLong() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            long res = 0;

            do {

                if (c < '0' || c > '9') {

                    throw new InputMismatchException();

                }

                res *= 10;

                res += c - '0';

                c = read();

            } while (!isSpaceChar(c));

            return res * sgn;

        }

 

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c)) {

                c = read();

            }

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            int res = 0;

            do {

                if (c < '0' || c > '9') {

                    throw new InputMismatchException();

                }

                res *= 10;

                res += c - '0';

                c = read();

            } while (!isSpaceChar(c));

            return res * sgn;

        }

 

        public int[] nextIntArray(int n) {

            int[] arr = new int[n];

            for (int i = 0; i < n; i++) {

                arr[i] = nextInt();

            }

            return arr;

        }

 

        public long[] nextLongArray(int n) {

            long[] arr = new long[n];

            for (int i = 0; i < n; i++) {

                arr[i] = nextLong();

            }

            return arr;

        }

 

        public boolean isSpaceChar(int c) {

            if (filter != null)

                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }

 

        private boolean isEndOfLine(int c) {

            return c == '\n' || c == '\r' || c == -1;

        }

        public interface SpaceCharFilter {

            public boolean isSpaceChar(int ch);

        }

	}

}",2,0817_C,CODEFORCES,1086,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"

import java.io.BufferedReader;

import java.io.File;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.StringTokenizer;



public class ReallyBigNumbers {



	static long sum(long x) {

		long sum = 0;

		while (x > 0) {

			sum += x % 10;

			x /= 10;

		}

		return sum;

	}



	static long diff(long x) {

		return x - sum(x);

	}



	public static void main(String[] args) throws IOException {

		MyScanner sc = new MyScanner(System.in);

		PrintWriter out = new PrintWriter(System.out);

		long n = sc.nextLong(), s = sc.nextLong();

		long low = 0, high = n, ans = 0;

		while (low <= high) {

			long mid = low + ((high - low) >> 1);

			if (diff(mid) >= s) {

				high = mid - 1;

				ans = mid;

			} else

				low = mid + 1;

		}

		if (ans == 0)

			out.println(0);

		else

			out.println(n - ans +1);

		out.flush();

		out.close();

	}



	static class MyScanner {

		StringTokenizer st;

		BufferedReader br;



		public MyScanner(InputStream s) {

			br = new BufferedReader(new InputStreamReader(s));

		}



		public MyScanner(String file) throws IOException {

			br = new BufferedReader(new FileReader(new File(file)));

		}



		public String next() throws IOException {

			while (st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {

			return Integer.parseInt(next());

		}



		public long nextLong() throws IOException {

			return Long.parseLong(next());

		}



		public String nextLine() throws IOException {

			return br.readLine();

		}



		public boolean ready() throws IOException {

			return br.ready();

		}

	}

}

",2,0817_C,CODEFORCES,1107,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;

import java.io.*;

public class cf

{

    static Integer arr[];

    static long s;

    static long n;

    public static long lb(long low,long high) 

    {

        while (low < high)

        {

            long mid = (low + high) / 2;

            long sum=0;

            long temp=mid;

            while(temp!=0)

            {

                sum+=temp%10;

                temp/=10;

            }

            if(mid-sum>=s) 

            high=mid;

            else

            low = mid+1;

        }

        long sum=0;

        long temp=low;

        while(temp!=0)

        {

            sum+=temp%10;

            temp/=10;

        }

        if(low-sum>=s)

        return low;

        else

        return n+1;

    }

    public static void main(String[] args)

    {

        PrintWriter out= new PrintWriter(System.out);

        Scanner sc = new Scanner(System.in);

        n=sc.nextLong();

        s=sc.nextLong();

        System.out.println(n-lb(0l,n)+1);

    }

}",2,0817_C,CODEFORCES,1120,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.OutputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.io.PrintStream;

import java.util.StringTokenizer;

import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 *

 * @author Wolfgang Beyer

 */

public class Main {

    public static void main(String[] args) {

        InputStream inputStream = System.in;

        OutputStream outputStream = System.out;

        InputReader in = new InputReader(inputStream);

        PrintWriter out = new PrintWriter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }



    static class TaskC {

        public void solve(int testNumber, InputReader in, PrintWriter out) {

            long n = in.nextLong();

            long s = in.nextLong();



            if (n - digitSum(n) < s) {

                out.println(0);

                return;

            }



            long left = 0;

            long right = n;

            while (left < right) {

                long mid = left + (right - left) / 2;

                if (mid - digitSum(mid) >= s) { // if condition(mid) == true

                    right = mid;

                } else {

                    left = mid + 1;

                }

            }

            out.println(n - left + 1);

        }



        long digitSum(long a) {

            long result = 0;

            while (a > 0) {

                result += a % 10;

                a /= 10;

            }

            return result;

        }



    }



    static class InputReader {

        private static BufferedReader in;

        private static StringTokenizer tok;



        public InputReader(InputStream in) {

            this.in = new BufferedReader(new InputStreamReader(in));

        }



        public long nextLong() {

            return Long.parseLong(next());

        }



        public String next() {

            try {

                while (tok == null || !tok.hasMoreTokens()) {

                    tok = new StringTokenizer(in.readLine());

                    //tok = new StringTokenizer(in.readLine(), "", \t\n\r\f""); //adds commas as delimeter

                }

            } catch (IOException ex) {

                System.err.println(""An IOException was caught :"" + ex.getMessage());

            }

            return tok.nextToken();

        }



    }

}



",2,0817_C,CODEFORCES,1065,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"/* 
 * UMANG PANCHAL
 * DAIICT
 */

import java.util.*;
import java.io.*;
import java.math.*;
import java.util.Comparator;
public class Main
{
 
	private static final Comparator<? super Integer> Comparator = null;
	static LinkedList<Integer> adj[];
	static ArrayList<Integer> adj1[];
	static int[] color,visited1;
	static boolean b[],visited[],possible;
	static int level[];
	static Map<Integer,HashSet<Integer>> s;
	static int totalnodes,colored;
	static int count[];
	static long sum[];
	static int nodes;
	static long ans=0;
	static long[] as=new long[10001];
	static long c1=0,c2=0;
	static int[] a,d,k;
	static int max=100000000;
	static long MOD = 1000000007,sm=0,m=Long.MIN_VALUE;
	static boolean[] prime=new boolean[1000005];
	static int[] levl;
    static int[] eat;
    static int price[];
    static int res[],par[];
    static int result=0;
    static int[] root,size,du,dv;
    static long p=Long.MAX_VALUE;
    static int start,end;
    static boolean[] vis1,vis2;
	// --------------------My Code Starts Here----------------------
	
	public static void main(String[] args) throws IOException
	{
		in=new InputReader(System.in);
	    w=new PrintWriter(System.out);
     long n=nl(),s=nl();
     long l=0,r=n+1;
     while(r-l>1)
     {
    	 long mid=l+(r-l)/2;
    	 long k=mid,sum=0;
    	 while(k>0)
    	 {
    		 sum+=k%10;
    		 k/=10;
    	 }
    	 if(mid-sum>=s)
    		 r=mid;
    	 else
    		 l=mid;
     }
    // w.println(r);
     w.print(n-r+1);
		      w.close();
    }



	// --------------------My Code Ends Here------------------------
     
	
	/*
	 *  PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>()
  			{
  				public int compare(Integer o1, Integer o2)
  				{
  					return Integer.compare(o2,o1);
  				}
  			});
	 * 
	 * 
	 */
	public static void bfs1(int u)
	{
	    Queue<Integer> q=new LinkedList();
	    q.add(u);
	    vis1[u]=true;
	    while(!q.isEmpty())
	    {
	    	//w.print(1);
	    	int p=q.poll();
	      for(int i=0;i<adj[p].size();i++)
	     { 
	    	  if(!vis1[adj[p].get(i)])
	    	  {
	    	du[adj[p].get(i)]=du[p]+1;
	    	q.add(adj[p].get(i));
	    	vis1[adj[p].get(i)]=true;
	    	  }
	    	  }
	    }
	    
	}
	public static void bfs2(int u)
	{
	    Queue<Integer> q=new LinkedList();
	    q.add(u);
	    vis2[u]=true;
	    while(!q.isEmpty())
	    {
	    	int p=q.poll();
	      for(int i=0;i<adj[p].size();i++)
	     { 
	    	  if(!vis2[adj[p].get(i)])
	    	  {
	    	dv[adj[p].get(i)]=dv[p]+1;
	    	q.add(adj[p].get(i));
	    	  
	    	vis2[adj[p].get(i)]=true;
	    	  }
	    	  }
	    }
	    
	}
	 public static void buildgraph(int n)
	 {
         adj=new LinkedList[n+1];
         visited=new boolean[n];
         level=new int[n];
         par=new int[n];
         for(int i=0;i<=n;i++)
         	{
        	 adj[i]=new LinkedList<Integer>();
         	
         	}
      
	 }
	
	/*public static long kruskal(Pair[] p)
	{
		long ans=0;
		int w=0,x=0,y=0;
		for(int i=0;i<p.length;i++)
		{
			w=p[i].w;
			x=p[i].x;
			y=p[i].y;
			if(root(x)!=root(y))
			{
				ans+=w;
				union(x,y);
			}
		}
		return ans;
	}*/
	
	 static class Pair implements Comparable<Pair>
	 {
	     char a,b;
	     
	
		Pair(char a,char b)
		{
			this.a=a;
			this.b=b;
		}
		public int compareTo(Pair o)
		{
		  //return (int)(sum-o.sum);
		  return 0;
		} 
		
	}
	
	public static int root(int i)
	{
		while(root[i]!=i)
		{
			root[i]=root[root[i]];
			i=root[i];
		}
		return i;
	}
	
	public static void init(int n)
	{
		root=new int[n+1];
		for(int i=1;i<=n;i++)
			root[i]=i;
	}
	public static void union(int a,int b)
	{
	    int root_a=root(a);	
	    int root_b=root(b);
	    root[root_a]=root_b;
	   // size[root_b]+=size[root_a];
	}


	
	public static boolean isPrime(long n)
	{
	    // Corner cases
	    if (n <= 1)  return false;
	    if (n <= 3)  return true;
	 
	    // This is checked so that we can skip 
	    // middle five numbers in below loop
	    if (n%2 == 0 || n%3 == 0)
	    	return false;
	 
	    for (long i=5; i*i<=n; i=i+6)
	        if (n%i == 0 || n%(i+2) == 0)
	           return false;
	 
	    return true;
	}
	

	
	public static String ns()
	{
		return in.nextLine();
	}
	public static int ni()
	{
		return in.nextInt();
	}
	public static long nl()
	{
		return in.nextLong();
	}
	public static int[] na(int n)
	{
		int[] a=new int[n];
		for(int i=0;i<n;i++)
		a[i]=ni();
		return a;
	}
	public static long[] nla(int n)
	{
		long[] a=new long[n];
		for(int i=0;i<n;i++)
		a[i]=nl();
		return a;
	}
	public static void sieve()
	    {
	       int n=prime.length;
	        for(int i=0;i<n;i++)
	            prime[i] = true;
	         
	        for(int p = 2; p*p <=n; p++)
	        {
	            if(prime[p] == true)
	            {
	                for(int i = p*2; i <n; i += p)
	                    prime[i] = false;
	            }
	        }
	    }

  public static String rev(String s)
	{
		StringBuilder sb=new StringBuilder(s);
		sb.reverse();
		return sb.toString();
	}
	static long lcm(long a, long b)
	{
	    return a * (b / gcd(a, b));
	}
	static long gcd(long a, long b)
	{
	    while (b > 0)
	    {
	        long temp = b;
	        b = a % b; // % is remainder
	        a = temp;
	    }
	    return a;
	}
	static InputReader in;
	static PrintWriter w;
static class InputReader 
{
 
private final InputStream stream;
private final byte[] buf = new byte[8192];
private int curChar, snumChars;
private SpaceCharFilter filter;
 
public InputReader(InputStream stream)
{
  this.stream = stream;
}
 
public int snext()
{
  if (snumChars == -1)
    throw new InputMismatchException();
  if (curChar >= snumChars)
  {
    curChar = 0;
    try 
    {
      snumChars = stream.read(buf);
    }
    catch (IOException e)
    {
      throw new InputMismatchException();
    }
    if (snumChars <= 0)
      return -1;
  }
  return buf[curChar++];
}
 
public int nextInt() 
{
  int c = snext();
  while (isSpaceChar(c)) 
  {
    c = snext();
  }
  int sgn = 1;
  if (c == '-')
  {
    sgn = -1;
    c = snext();
  }
  int res = 0;
  do
  {
    if (c < '0' || c > '9')
      throw new InputMismatchException();
    res *= 10;
    res += c - '0';
    c = snext();
  }
  while (!isSpaceChar(c));
  return res * sgn;
}
 
public long nextLong() 
{
  int c = snext();
  while (isSpaceChar(c)) 
  {
    c = snext();
  }
  int sgn = 1;
  if (c == '-')
  {
    sgn = -1;
    c = snext();
  }
  long res = 0;
  do
  {
    if (c < '0' || c > '9')
      throw new InputMismatchException();
    res *= 10;
    res += c - '0';
    c = snext();
  }
  while (!isSpaceChar(c));
  return res * sgn;
}	    
public String readString() 
{
  int c = snext();
  while (isSpaceChar(c)) 
  {
    c = snext();
  }
  StringBuilder res = new StringBuilder();
  do
  {
    res.appendCodePoint(c);
    c = snext();
  }
  while (!isSpaceChar(c));
  return res.toString();
}
 
public String nextLine() 
{
  int c = snext();
  while (isSpaceChar(c))
    c = snext();
  StringBuilder res = new StringBuilder();
  do
  {
    res.appendCodePoint(c);
    c = snext();
  }
  while (!isEndOfLine(c));
  return res.toString();
}
 
public boolean isSpaceChar(int c)
{
  if (filter != null)
    return filter.isSpaceChar(c);
  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
}
 
private boolean isEndOfLine(int c) 
{
  return c == '\n' || c == '\r' || c == -1;
}
 
public interface SpaceCharFilter
{
  public boolean isSpaceChar(int ch);
}
}
	
}",2,0817_C,CODEFORCES,1118,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
public class Prac{     
    static class InputReader { 
        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        public InputReader(InputStream st) {
            this.stream = st;
        } 
        public int read() {
            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar >= snumChars) {
                curChar = 0;
                try {
                    snumChars = stream.read(buf);
                } 
                catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }
        public int ni() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        } 
        public long nl() {
            int c = read();
            while (isSpaceChar(c)) {
            c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        } 
        public int[] nia(int n) {
            int a[] = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = ni();
            }
            return a;
        } 
        public String rs() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                    c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }
        public String nextLine() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndOfLine(c));
            return res.toString();
        } 
        public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
        } 
    }
    public static class Key {

        private final int x;
        private final int y;

        public Key(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Key)) return false;
            Key key = (Key) o;
            return x == key.x && y == key.y;
        }

        @Override
        public int hashCode() {
            int result = x;
            result = 31 * result + y;
            return result;
        }

    }
    static class Pair{
        Integer l,r;
        Long c,min;
        public Pair(Integer l,Integer r,Long c){
            this.l=l;
            this.r=r;
            this.c=c;
            this.min=0L;
        }
    }
    
    static PrintWriter w = new PrintWriter(System.out);
    static long mod=998244353L,mod1=1000000007,res;
   
    public static void main(String [] args){
        InputReader sc=new InputReader(System.in);
        long n=sc.nl(),x=sc.nl();
        long l=1,h=n,ans=-1;
        while(l<=h){
            long mid=(l+h)/2;
            long te=mid,sum=0;
            while(te>0){
                sum+=te%10;
                te/=10;
            }
            if((mid-sum)<x){
                l=mid+1;
            }
            else{
                ans=mid;
                h=mid-1;
            }
        }
        w.println(ans==-1?0:(n-ans+1));
        w.close();
    }
}",2,0817_C,CODEFORCES,1141,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.OutputStreamWriter;

import java.io.PrintWriter;

import java.util.StringTokenizer;





public class C {



	static StringTokenizer st;

	static BufferedReader br;

	static PrintWriter pw;

	public static void main(String[] args) throws IOException {

		br = new BufferedReader(new InputStreamReader(System.in));

		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

		long n = nextLong();

		long s = nextLong();

		long ans = 0;

		if (s+200 <= n)

			ans += n - (s+200) + 1;

		for (long i = s; i < s+200; i++) {

			if (i <= n && i-sumDigits(i) >= s) {

				ans++;

			}

		}

		System.out.println(ans);

		pw.close();

	}

	private static long sumDigits(long n) {

		long sum = 0;

		while (n > 0) {

			sum += n % 10;

			n /= 10;

		}

		return sum;

	}

	private static int nextInt() throws IOException {

		return Integer.parseInt(next());

	}

	private static long nextLong() throws IOException {

		return Long.parseLong(next());

	}

	private static double nextDouble() throws IOException {

		return Double.parseDouble(next());

	}

	private static String next() throws IOException {

		while (st==null || !st.hasMoreTokens())

			st = new StringTokenizer(br.readLine());

		return st.nextToken();

	}

}",2,0817_C,CODEFORCES,1063,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;



public class Main {

    private static Reader in;

    private static PrintWriter out;

    public static void main(String args[]) throws IOException {

        in = new Reader();

        out = new PrintWriter(System.out);

        long n = in.nextLong();

        long s = in.nextLong();

        long low = 0, mid = 0, high = n;

        while (low <= high) {

            mid = (low + high) / 2;

            if (func(mid, s)) {

                high = mid - 1;

            }

            else {

                low = mid + 1;

            }

        }

        out.println(n - low + 1);

        out.close();

    }



    private static boolean func(long num, long s) {

        long sum = 0, temp =  num;

        while (temp > 0) {

            sum += (temp) % 10;

            temp /= 10;

        }

        return ((num - sum) >= s);

    }



    static class Reader

    {

        final private int BUFFER_SIZE = 1 << 16;

        private DataInputStream din;

        private byte[] buffer;

        private int bufferPointer, bytesRead;



        public Reader()

        {

            din = new DataInputStream(System.in);

            buffer = new byte[BUFFER_SIZE];

            bufferPointer = bytesRead = 0;

        }



        public Reader(String file_name) throws IOException

        {

            din = new DataInputStream(new FileInputStream(file_name));

            buffer = new byte[BUFFER_SIZE];

            bufferPointer = bytesRead = 0;

        }







        public String next() throws IOException {

            byte[] buf = new byte[64]; // line length

            int cnt = 0, c;

            while ((c = read()) != -1)

            {

                if (c == ' ' || c == '\n')

                    break;

                buf[cnt++] = (byte) c;

            }

            return new String(buf, 0, cnt);

        }



        public String nextLine() throws IOException

        {

            byte[] buf = new byte[64]; // line length

            int cnt = 0, c;

            while ((c = read()) != -1)

            {

                if (c == '\n')

                    break;

                buf[cnt++] = (byte) c;

            }

            return new String(buf, 0, cnt);

        }



        public int nextInt() throws IOException

        {

            int ret = 0;

            byte c = read();

            while (c <= ' ')

                c = read();

            boolean neg = (c == '-');

            if (neg)

                c = read();

            do

            {

                ret = ret * 10 + c - '0';

            }  while ((c = read()) >= '0' && c <= '9');



            if (neg)

                return -ret;

            return ret;

        }



        public long nextLong() throws IOException

        {

            long ret = 0;

            byte c = read();

            while (c <= ' ')

                c = read();

            boolean neg = (c == '-');

            if (neg)

                c = read();

            do {

                ret = ret * 10 + c - '0';

            }

            while ((c = read()) >= '0' && c <= '9');

            if (neg)

                return -ret;

            return ret;

        }



        public double nextDouble() throws IOException

        {

            double ret = 0, div = 1;

            byte c = read();

            while (c <= ' ')

                c = read();

            boolean neg = (c == '-');

            if (neg)

                c = read();



            do {

                ret = ret * 10 + c - '0';

            }

            while ((c = read()) >= '0' && c <= '9');



            if (c == '.')

            {

                while ((c = read()) >= '0' && c <= '9')

                {

                    ret += (c - '0') / (div *= 10);

                }

            }



            if (neg)

                return -ret;

            return ret;

        }



        private void fillBuffer() throws IOException

        {

            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);

            if (bytesRead == -1)

                buffer[0] = -1;

        }



        private byte read() throws IOException

        {

            if (bufferPointer == bytesRead)

                fillBuffer();

            return buffer[bufferPointer++];

        }



        public void close() throws IOException

        {

            if (din == null)

                return;

            din.close();

        }

    }

}",2,0817_C,CODEFORCES,1077,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;
import java.lang.*;
import java.io.*;
 
 
public class Main 
{
//     HashMap<> map=new HashMap<>();
//     TreeMap<> map=new TreeMap<>();
//     map.put(p,map.getOrDefault(p,0)+1);
//     for(Map.Entry<> mx:map.entrSet()){
//           int v=mx.getValue(),k=mx.getKey();
//     }
//     ArrayList<> l=new ArrayList<>();
//     HashSet<> has=new HashSet<>();
    PrintWriter out;
    FastReader sc;
    long getSum(long n) 
    { 
        long sum; 
        for (sum = 0; n > 0; sum += n % 10, 
                                  n /= 10); 
  
        return sum; 
    }
    public void sol(){
        long n=nl(),s=nl();
        if((n-getSum(n))<s){
              pl(""0"");
        }else{
        long l = 0, r = n; 
        while (l <= r) { 
            long m = l + (r - l) / 2;   
            if ((m-getSum(m)) < s) 
                l = m + 1;
            else
                r = m - 1;  
        } 
        pl(n-l+1); 
    }
    
        
    }
    public static void main(String[] args) 
	{ 
	      Main g=new Main();
		g.out=new PrintWriter(System.out);
		g.sc=new FastReader();
		g.sol();
		g.out.flush();
	}
	static class FastReader 
	{ 
		BufferedReader br; 
		StringTokenizer st; 
 
		public FastReader() 
		{ 
			br = new BufferedReader(new
					InputStreamReader(System.in)); 
		} 
 
		String next() 
		{ 
			while (st == null || !st.hasMoreElements()) 
			{ 
				try
				{ 
					st = new StringTokenizer(br.readLine()); 
				} 
				catch (IOException e) 
				{ 
					e.printStackTrace(); 
				} 
			} 
			return st.nextToken(); 
		} 
 
		int nextInt() 
		{ 
			return Integer.parseInt(next()); 
		} 
 
		long nextLong() 
		{ 
			return Long.parseLong(next()); 
		} 
 
		double nextDouble() 
		{ 
			return Double.parseDouble(next()); 
		} 
 
		String nextLine() 
		{ 
			String str = """"; 
			try
			{ 
				str = br.readLine(); 
			} 
			catch (IOException e) 
			{ 
				e.printStackTrace(); 
			} 
			return str; 
		} 
	} public int ni(){
	      return sc.nextInt();
	}public long nl(){
	      return sc.nextLong();
	}public double nd(){
	      return sc.nextDouble();
	}public String rl(){
	      return sc.nextLine();
	}public void pl(Object s){
	      out.println(s);
	}public void pr(Object s){
	      out.print(s);
	}public String next(){
	      return sc.next();
	}public long abs(long x,long y){
	      return Math.abs(x-y);
	}
	public int abs(int x,int y){
	      return Math.abs(x-y);
	}
	public double abs(double x,double y){
	      return Math.abs(x-y);
	}
      public long pow(long x,long y){
            return (long)Math.pow(x,y);
      }
      public int pow(int x,int y){
            return (int)Math.pow(x,y);
      }
      public double pow(double x,double y){
            return Math.pow(x,y);
      }public long min(long x,long y){
            return (long)Math.min(x,y);
      }
      public int min(int x,int y){
            return (int)Math.min(x,y);
      }
      public double min(double x,double y){
            return Math.min(x,y);
      }public static int gcd(int a, int b) {
		if (a == 0)
			return b;
		return gcd(b % a, a);
	}static void sort(int[] a) {
		ArrayList<Integer> l = new ArrayList<>();
		for (int i : a) {
			l.add(i);
		}
		Collections.sort(l);
		for (int i = 0; i < a.length; i++) {
			a[i] = l.get(i);
		}
	}void sort(long[] a) {
		ArrayList<Long> l = new ArrayList<>();
		for (long i : a) {
			l.add(i);
		}
		Collections.sort(l);
		for (int i = 0; i < a.length; i++) {
			a[i] = l.get(i);
		}
	}void sort(double[] a) {
		ArrayList<Double> l = new ArrayList<>();
		for (double i : a) {
			l.add(i);
		}
		Collections.sort(l);
		for (int i = 0; i < a.length; i++) {
			a[i] = l.get(i);
		}
	}int  swap(int a,int b){
	      return a;
	}long  swap(long a,long b){
	      return a;
	}double  swap(double a,double b){
	      return a;
	}
	boolean isPowerOfTwo (int x) 
      { 
            return x!=0 && ((x&(x-1)) == 0);     
      }boolean isPowerOfTwo (long x) 
      { 
            return x!=0 && ((x&(x-1)) == 0);     
      }public long max(long x,long y){
            return (long)Math.max(x,y);
      }
      public int max(int x,int y){
            return (int)Math.max(x,y);
      }
      public double max(double x,double y){
            return Math.max(x,y);
      }long sqrt(long x){
            return (long)Math.sqrt(x);
      }int sqrt(int x){
            return (int)Math.sqrt(x);
      }
	 
} ",2,0817_C,CODEFORCES,1145,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.*;



import javax.swing.Painter;



import java.io.*;



public class C {

	FastScanner in;

	PrintWriter out;

	boolean systemIO = true;

	

	public static class Pair implements Comparable<Pair> {

		int x;

		int y;

		public Pair(int x, int y) {

			super();

			this.x = x;

			this.y = y;

		}

		@Override

		public int compareTo(Pair o) {

			return x - o.x;

		}

		

	}

	

	public static void quickSort(long[] a, int from, int to) {

		if (to - from <= 1) {

			return;

		}

		int i = from;

		int j = to - 1;

		long x = a[from + (new Random()).nextInt(to - from)];

		while (i <= j) {

			while (a[i] < x) {

				i++;

			}

			while (a[j] > x) {

				j--;

			}

			if (i <= j) {

				long t = a[i];

				a[i] = a[j];

				a[j] = t;

				i++;

				j--;

			}

		}

		quickSort(a, from, j + 1);

		quickSort(a, j + 1, to);

	}

	

	public static long check(long x) {

		long sum = 0;

		long k = x;

		while (x > 0) {

			sum += x % 10;

			x /= 10;

		}

		return k - sum;

	}

	

	public void solve() throws IOException {

		long n = in.nextLong();

		long s = in.nextLong();

		long ans = 0;

		for (long i = s; i <= Math.min(n, s + 10000L); i++) {

			if (check(i) >= s) {

				ans++;

			}

		}

		ans += (n - Math.min(n, s + 10000L));

		System.out.println(ans);

	}



	public void run() throws IOException {

		if (systemIO) {

			in = new FastScanner(System.in);

			out = new PrintWriter(System.out);

		} else {

			in = new FastScanner(new File(""input.txt""));

			out = new PrintWriter(new File(""output.txt""));

		}

		solve();



		out.close();

	}



	class FastScanner {

		BufferedReader br;

		StringTokenizer st;



		FastScanner(File f) {

			try {

				br = new BufferedReader(new FileReader(f));

			} catch (FileNotFoundException e) {

				e.printStackTrace();

			}

		}



		FastScanner(InputStream f) {

			br = new BufferedReader(new InputStreamReader(f));

		}



		String nextLine() {

			try {

				return br.readLine();

			} catch (IOException e) {

				return null;

			}

		}



		String next() {

			while (st == null || !st.hasMoreTokens()) {

				try {

					st = new StringTokenizer(br.readLine());

				} catch (IOException e) {

					e.printStackTrace();

				}

			}

			return st.nextToken();

		}



		int nextInt() {

			return Integer.parseInt(next());

		}



		long nextLong() {

			return Long.parseLong(next());

		}



		double nextDouble() {

			return Double.parseDouble(next());

		}



	}



	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

	public static void main(String[] arg) throws IOException {

		new C().run();

	}

}",2,0817_C,CODEFORCES,1062,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;

public class ReallyBigNumbers {
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		long n=scan.nextLong(), s=scan.nextLong();
		long lo=0, hi=n;
		long res=Long.MAX_VALUE;
		
		while(hi>=lo) {
			long mid=(hi+lo)/2;
			if(good(mid,s)) {
				res=Math.min(res,mid);
				hi=mid-1;
			}
			else {
				lo=mid+1;
			}
		}
		System.out.println(res==Long.MAX_VALUE?0:n-res+1);
	}
	public static boolean good(long n, long s) {
		long res=0;
		String st=n+"""";
		for(int i=0;i<st.length();i++) res+=Integer.parseInt(st.charAt(i)+"""");
		return n-res>=s;
	}
}",2,0817_C,CODEFORCES,1122,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.math.BigInteger;
import java.util.*;
public class C {
    
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong();
        long s = sc.nextLong();
        
        BigInteger k = findFirst(BigInteger.valueOf(s));
        if (BigInteger.valueOf(n).compareTo(k) >= 0)
        {
            System.out.println(n - k.longValue() + 1);
        }
        else
        {
            System.out.println(""0"");
        }
    }
    
    public static BigInteger findFirst(BigInteger s) // first number where sum of digs >= s
    {
        BigInteger b = BigInteger.ZERO;
        while (cd(b).compareTo(b.subtract(s)) > 0)
        {
            BigInteger c = BigInteger.ONE;
            while (cd(b.add(c)).compareTo(b.add(c).subtract(s)) > 0) {
                c = c.multiply(BigInteger.TEN);
            }
            // possibly overshot
            c = c.divide(BigInteger.TEN);
            if (c.compareTo(BigInteger.TEN) < 0) c = BigInteger.TEN; // always add at least 10
            b = b.add(c);
        }
        return b;
    }
    
    public static BigInteger cd(BigInteger n)
    {
        BigInteger t = BigInteger.ZERO;
        while (n.compareTo(BigInteger.ZERO) > 0)
        {
            t = t.add(n.mod(BigInteger.TEN));
            n = n.divide(BigInteger.TEN);
        }
        return t;
    }
}
",2,0817_C,CODEFORCES,1066,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.util.*;

public class TestClass {

    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String args[] ) throws Exception {

        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

    	String s[] = in.readLine().split("" "");

    	long n = Long.parseLong(s[0]);

    	long k = Long.parseLong(s[1]);

    	long x = bs(n,k);

    	out.println(n-x+1);

        out.close();

    }

    public static long bs(long n,long k)

    {

    	long l=0,h=n;

    	while(l<=h)

    	{

    		long mid = l + (h-l)/2;

    		long x = mid - sum(mid);

    		if(x>=k)

    		{

    			h = mid-1;

    		}

    		else

    		{

    			l = mid+1;

    		}

    	}

    	return l;

    }

    public static long sum(long x)

    {

    	long ans=0;

    	while(x>0)

    	{

    		ans += x%10;

    		x=x/10;

    	}

    	return ans;

    }

}

",2,0817_C,CODEFORCES,1081,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;

public class Teste {
	
	public static void main(String args[]) {
		
		//Input values
		Scanner input = new Scanner(System.in);
		long n = input.nextLong();
		long s = input.nextLong();
		input.close();
		
		//Logica
		long aux_1 = 0; // l
        long aux_2 = n + 1; // r
 
        while (aux_2 - aux_1 > 1) {
            long m = (aux_2 + aux_1) >> 1;
            if (menor(m) >= s) {
            	aux_2 = m;
            } else {
            	aux_1 = m;
            }
        }

        System.out.println(n - aux_1);
	}
	
	private static long menor(long x) {
        return x - soma(x);
    }
	
	private static long soma(long x) {
        int resp = 0;
        while (x > 0) {
            resp += x % 10;
            x /= 10;
        }
        return resp;
    }
}
	 	    		 	   				 	 	     	 		",2,0817_C,CODEFORCES,1139,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.*;

import java.math.*;

import java.security.KeyStore.Entry;

import java.util.*;





 public class Main {

	private InputStream is;

	private PrintWriter out;

	int time = 0, dp[][], DP[][], start[], parent[], end[], val[], black[], MOD = (int)(1e9+7), arr[], arr1[];

	int MAX = 10000000, N, K, p;

	ArrayList<Integer>[] amp, amp1;

	boolean b[], b1[];

	Pair prr[];

	char ch[][];

	HashSet<Integer> hs = new HashSet<>();



	public static void main(String[] args) throws Exception {

		new Thread(null, new Runnable() {

		public void run() {

			try {



		//new Main().soln();

		} catch (Exception e) {

				System.out.println(e);

			}

		}

	}, ""1"", 1 << 26).start();

		new Main().soln();

	}

	void solve() {

		long n = nl(), s = nl();

		long low = 1, high = n+1;

		long ans = high;

		while(low<=high){

			long mid = (high+low)/2;

			if((mid - getSum(mid))>=s){

				high = mid-1;

				ans = mid;

			}

			else{

				low = mid+1;

			}

		}

		System.out.println(Math.max(0, n-ans+1));

	}

	int getSum(long s){

		String str = Long.toString(s);

		int ans = 0;

		for(char ch : str.toCharArray()) ans += (ch-'0');

		return ans;

	}

	int recur(int x){

		//System.out.println(x);

		int ans = 0;

		b[x] = true;

		for(int i : amp[x]){

			if(!b[i]){

				b[i] = true;

				ans = Math.max(recur(i), ans);

				b[i] = false;

			}

		}

		return 1+ans;

	}

	int max = 0;

	int getParent(int x){

		//System.out.println(x+"" ""+parent[x]);

		if(parent[x]!=x){

			parent[x] = getParent(parent[x]);

		}

		return parent[x];

	}

	int bfs(int x){

		b[x] = true;

		Queue<Integer> q =  new LinkedList<>();

		q.add(x);

		while(!q.isEmpty()){

			int y = q.poll();

			for(int i : amp[y]){

				if(!b[i]){

					b[i] = true;

					val[i] = val[y]+1;

					max = Math.max(val[i], max);

					q.add(i);

				}

			}

		}

		return max;

	}

	class Pair implements Comparable<Pair>{

		int u, v, r;

		Pair(int u, int v){

			this.u = u;

			this.v = v;

		}public int hashCode() {

			return Objects.hash();

		}

		public boolean equals(Object o) {

			Pair other = (Pair) o;

			return ((u == other.u && v == other.v));// || (v == other.u && u == other.v));

		}

		public int compareTo(Pair other) {

			//return Integer.compare(other.r, r);

			return Long.compare(u, other.u) != 0 ? (Long.compare(u, other.u)) : (Long.compare(other.v,v));

		}	

		public String toString() {

			return ""[u="" + u + "", v="" + v + ""]"";

		}

	}

	int min(int x,int y){

		if(x<y) return x;

		return y;

	}

	int max(int x,int y){

		if(x>y) return x;

		return y;

	}

	void dfs(int x){

		b[x] = true;

		for(int i : amp[x]){

			if(!b[i]){

				dfs(i);

			}

		}

	}

	void buildGraph(int m){

		while(m-->0)

		{

			int x = ni()-1, y = ni()-1;

			amp[x].add(y);

			amp[y].add(x);

		}

	}

	long modInverse(long a, long mOD2){

        return  power(a, mOD2-2, mOD2);

	}

	long power(long x, long y, long m)

	{

		if (y == 0)

    return 1;

	long p = power(x, y/2, m) % m;

	p = (p * p) % m;



	return (y%2 == 0)? p : (x * p) % m;

	}

	boolean isPrime(int x){

		for(int i = 2;i*1L*i<=x;i++) if(x%i==0) return false;

		return true;

	}

	public long gcd(long a, long b){

		if(b==0) return a;

		return gcd(b,a%b);

	}

	void failFn(String str, int arr[]){

		int len = 0;

		arr[0] = 0;

		int i = 1;

		while(i<arr.length){

			if(str.charAt(i)==str.charAt(len)){

				arr[i++] = ++len;

				continue;

			}

			if(len == 0){

				arr[i] = len;

				i++;

				continue;

			}

			if(str.charAt(i)!=str.charAt(len)){

				len = arr[len-1];

			}

		}

	}

	static class ST1{

		int arr[], st[], size;

		ST1(int a[]){

			arr = a.clone();

			size = 10*arr.length;

			st = new int[size];

			build(0,arr.length-1,1);

		}

		void build(int ss, int se, int si){

			if(ss==se){

				st[si] = arr[ss];

				return;

			}

			int mid = (ss+se)/2;

			int val = 2*si;

			build(ss,mid,val); build(mid+1,se,val+1);

			st[si] = (st[val]+ st[val+1]);

		}

		int get(int ss, int se, int l, int r, int si){

			if(l>se || r<ss || l>r) return Integer.MAX_VALUE;

			if(l<=ss && r>=se) return st[si];

			int mid = (ss+se)/2;

			int val = 2*si;

			return (get(ss,mid,l,r,val)+ get(mid+1,se,l,r,val+1));

		}

	}

	static class ST{

		int arr[],lazy[],n;

		ST(int a){

			n = a;

			arr = new int[10*n];

			lazy = new int[10*n];

		}

		void up(int l,int r,int val){

			update(0,n-1,0,l,r,val);

		}

		void update(int l,int r,int c,int x,int y,int val){

			if(lazy[c]!=0){

				lazy[2*c+1]+=lazy[c];

				lazy[2*c+2]+=lazy[c];

				if(l==r)

					arr[c]+=lazy[c];

				lazy[c] = 0;

			}

			if(l>r||x>y||l>y||x>r)

				return;

			if(x<=l&&y>=r){

				lazy[c]+=val;

				return ;

			}

			int mid = l+r>>1;

			update(l,mid,2*c+1,x,y,val);

			update(mid+1,r,2*c+2,x,y,val);

			arr[c] = (arr[2*c+1]+ arr[2*c+2]);

		}

		int an(int ind){

			return ans(0,n-1,0,ind);

		}

		int ans(int l,int r,int c,int ind){

			if(lazy[c]!=0){

				lazy[2*c+1]+=lazy[c];

				lazy[2*c+2]+=lazy[c];

				if(l==r)

					arr[c]+=lazy[c];

				lazy[c] = 0;

			}

			if(l==r)

				return arr[c];

			int mid = l+r>>1;

			if(mid>=ind)

				return ans(l,mid,2*c+1,ind);

			return ans(mid+1,r,2*c+2,ind);

		}

	}

	public static class FenwickTree {

		

	    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates



	    public FenwickTree(int size) {

	        array = new int[size + 1];

	    }

	    public int rsq(int ind) {

	        assert ind > 0;

	        int sum = 0;

	        while (ind > 0) {

	            sum += array[ind];

	            //Extracting the portion up to the first significant one of the binary representation of 'ind' and decrementing ind by that number

	            ind -= ind & (-ind);

	        }

	        return sum;

	    }

	    public int rsq(int a, int b) {

	        assert b >= a && a > 0 && b > 0;

	        return rsq(b) - rsq(a - 1);

	    }

	    public void update(int ind, int value) {

	        assert ind > 0;

	        while (ind < array.length) {

	            array[ind] += value;

	            //Extracting the portion up to the first significant one of the binary representation of 'ind' and incrementing ind by that number

	            ind += ind & (-ind);

	        }

	    }

	    public int size() {

	        return array.length - 1;

	    }

	}

	public static int[] shuffle(int[] a, Random gen){

		for(int i = 0, n = a.length;i < n;i++)

		{ 

			int ind = gen.nextInt(n-i)+i; 

			int d = a[i]; 

			a[i] = a[ind];

			a[ind] = d; 

		} 

	return a; 

	}

	long power(long x, long y, int mod){

		long ans = 1;

		while(y>0){

			if(y%2==0){

				x = (x*x)%mod;

				y/=2;

			}

			else{

				ans = (x*ans)%mod;

				y--;

			}

		}

		return ans;

	}

	void soln() {

		is = System.in;

		out = new PrintWriter(System.out);

		long s = System.currentTimeMillis();

		solve();

		//out.close();

		out.flush();

		//tr(System.currentTimeMillis() - s + ""ms"");

	}





	// To Get Input

	// Some Buffer Methods

	private byte[] inbuf = new byte[1024];

	public int lenbuf = 0, ptrbuf = 0;



	private int readByte() {

		if (lenbuf == -1)

			throw new InputMismatchException();

		if (ptrbuf >= lenbuf) {

			ptrbuf = 0;

			try {

				lenbuf = is.read(inbuf);

			} catch (IOException e) {

				throw new InputMismatchException();

			}

			if (lenbuf <= 0)

				return -1;

		}

		return inbuf[ptrbuf++];

	}



	private boolean isSpaceChar(int c) {

		return !(c >= 33 && c <= 126);

	}



	private int skip() {

		int b;

		while ((b = readByte()) != -1 && isSpaceChar(b))

			;

		return b;

	}



	private double nd() {

		return Double.parseDouble(ns());

	}



	private char nc() {

		return (char) skip();

	}

	private String ns() {

		int b = skip();

		StringBuilder sb = new StringBuilder();

		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '

									// ')

			sb.appendCodePoint(b);

			b = readByte();

		}

		return sb.toString();

	}



	private char[] ns(int n) {

		char[] buf = new char[n];

		int b = skip(), p = 0;

		while (p < n && !(isSpaceChar(b))) {

			buf[p++] = (char) b;

			b = readByte();

		}

		return n == p ? buf : Arrays.copyOf(buf, p);

	}



	private char[][] nm(int n, int m) {

		char[][] map = new char[n][];

		for (int i = 0; i < n; i++)

			map[i] = ns(m);

		return map;

	}



	private int[] na(int n) {

		int[] a = new int[n];

		for (int i = 0; i < n; i++)

			a[i] = ni();

		return a;

	}



	private int ni() {

		int num = 0, b;

		boolean minus = false;

		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))

			;

		if (b == '-') {

			minus = true;

			b = readByte();

		}



		while (true) {

			if (b >= '0' && b <= '9') {

				num = num * 10 + (b - '0');

			} else {

				return minus ? -num : num;

			}

			b = readByte();

		}

	}



	private long nl() {

		long num = 0;

		int b;

		boolean minus = false;

		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))

			;

		if (b == '-') {

			minus = true;

			b = readByte();

		}



		while (true) {

			if (b >= '0' && b <= '9') {

				num = num * 10 + (b - '0');

			} else {

				return minus ? -num : num;

			}

			b = readByte();

		}

	}



	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;



	private void tr(Object... o) {

		if (!oj)

			System.out.println(Arrays.deepToString(o));

	}

}",2,0817_C,CODEFORCES,1060,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.util.StringTokenizer;

import java.util.Arrays;

import java.util.ArrayList;



public class C{

	

	static long s;

	public static void main(String[] args)throws IOException {

		Reader.init(System.in);

		long n=Reader.nextLong();

		s=Reader.nextLong();

		long lo=1,hi=n,mid;

		while(lo<hi){

			mid=(lo+hi)/2;

			if(diff(mid)>=s)

				hi=mid;

			else

				lo=mid+1;

		}

		if(diff(lo)>=s)

			System.out.println(n-lo+1);

		else

			System.out.println(0);

	}

	

	static long diff(long n){

		String s=String.valueOf(n);

		int sum=0;

		

		for(int i=0;i<s.length();i++){

			

			sum+=Integer.parseInt(s.valueOf(s.charAt(i)));

		}

		return (n-sum);

	}

		

		

}





		

/** Class for buffered reading int and double values */

class Reader {

    static BufferedReader reader;

    static StringTokenizer tokenizer;



    /** call this method to initialize reader for InputStream */

    static void init(InputStream input) {

        reader = new BufferedReader(

                     new InputStreamReader(input) );

        tokenizer = new StringTokenizer("""");

    }



    /** get next word */

    static String next() throws IOException {

        while ( ! tokenizer.hasMoreTokens() ) {

            //TODO add check for eof if necessary

            tokenizer = new StringTokenizer(

                   reader.readLine() );

        }

        return tokenizer.nextToken();

    }



    static int nextInt() throws IOException {

        return Integer.parseInt( next() );

    }

    

    static long nextLong() throws IOException {

        return Long.parseLong( next() );

    }

	

    static double nextDouble() throws IOException {

        return Double.parseDouble( next() );

    }

}",2,0817_C,CODEFORCES,1069,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.LongStream;


public class Main implements Runnable {
    int n, m, k;
    long n1, s;
    static boolean use_n_tests = false;
    long mod = 1_000_000_007;
    long mod1 = 998244353L;
    Long[][] dp;

    void solve(FastScanner in, PrintWriter out, int testNumber) {
        n1 = in.nextLong();
        s = in.nextLong();
        if (s > n1) {
            out.println(0);
        } else {
            int mx = (getDigits(n1).size() + 1) * 9;
            long ans = 0;
            if (s + mx < n1) {
                ans += n1 - (s + mx);
            }
            for (long l = s; l <= s + mx && l <= n1; l++) {
                if (l - Array.sum(getDigits(l)) >= s) {
                    ans++;
                }
            }
            out.println(ans);
        }
    }

    // ****************************** template code ***********

    public static class DisjointSets {
        int[] p;

        DisjointSets(int size) {
            p = new int[size];
            for (int i = 0; i < size; i++)
                p[i] = i;
        }

        public int root(int x) {
            return x == p[x] ? x : (p[x] = root(p[x]));
        }

        public void unite(int a, int b) {
            a = root(a);
            b = root(b);
            if (a != b)
                p[a] = b;
        }
    }

    boolean triangleCheck(int a, int b, int c) {
        return a + b > c && a + c > b && b + c > a;
    }

    Map<Integer, Integer> numberCompression(List<Integer> ls) {
        Collections.sort(ls);
        int id = 1;
        Map<Integer, Integer> comp = new HashMap<>();
        for (int num : ls) {
            if (!comp.containsKey(num)) {
                comp.put(num, id++);
            }
        }
        return comp;
    }

    long lcm(long a, long b) {
        return (a / gcd(a, b)) * b;
    }

    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    class Pt {
        int x, y;

        boolean sameAxis(Pt b) {
            return b.x == x || b.y == y;
        }

        int manxDist(Pt b) {
            return Math.abs(x - b.x) + Math.abs(y - b.y);
        }

        void read() {
            x = in.nextInt();
            y = in.nextInt();
        }
    }

    void swap(Integer[] a, int i, int j) {
        Integer tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    void swap(List<Integer> a, int i, int j) {
        Integer tmp = a.get(i);
        a.set(i, a.get(j));
        a.set(j, tmp);
    }

    long manhDist(long x, long y, long x1, long y1) {
        return Math.abs(x - x1) + Math.abs(y - y1);
    }

    double dist(double x, double y, double x1, double y1) {
        return Math.sqrt(Math.pow(x - x1, 2.0) + Math.pow(y - y1, 2.0));
    }

    public static class FW {
        public static void add(long[] t, int i, long value) {
            for (; i < t.length; i |= i + 1)
                t[i] += value;
        }

        public static long sum(long[] t, int i) {
            long res = 0;
            for (; i >= 0; i = (i & (i + 1)) - 1)
                res += t[i];
            return res;
        }

        public static void add(long[] t, int a, int b, long value) {
            add(t, a, value);
            add(t, b + 1, -value);
        }
    }

    int sign(int a) {
        if (a < 0) {
            return -1;
        }
        return 1;
    }

    long binpow(long a, int b) {
        long res = 1;
        while (b != 0) {
            if (b % 2 == 0) {
                b /= 2;
                a *= a;
                a %= mod;
            }

            b--;
            res *= a;
            res %= mod;
        }
        return res;
    }

    List<Integer> getDigits(long n) {
        List<Integer> res = new ArrayList<>();
        while (n != 0) {
            res.add((int) (n % 10L));
            n /= 10;
        }
        return res;
    }

    List<Integer> generatePrimes(int n) {
        List<Integer> res = new ArrayList<>();
        boolean[] sieve = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!sieve[i]) {
                res.add(i);
            }
            if ((long) i * i <= n) {
                for (int j = i * i; j <= n; j += i) {
                    sieve[j] = true;
                }
            }
        }
        return res;
    }

    int[] ask(int l) {
        System.out.printf(""? %d\n"", l);
        System.out.flush();
        return in.nextArray(n);
    }

    static int stack_size = 1 << 29;

    static class Coeff {
        long mod;
        long[][] C;
        long[] fact;
        boolean cycleWay = false;

        Coeff(int n, long mod) {
            this.mod = mod;
            fact = new long[n + 1];
            fact[0] = 1;
            for (int i = 1; i <= n; i++) {
                fact[i] = i;
                fact[i] %= mod;
                fact[i] *= fact[i - 1];
                fact[i] %= mod;
            }
        }

        Coeff(int n, int m, long mod) {
            // n > m
            cycleWay = true;
            this.mod = mod;
            C = new long[n + 1][m + 1];
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= Math.min(i, m); j++) {
                    if (j == 0 || j == i) {
                        C[i][j] = 1;
                    } else {
                        C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
                        C[i][j] %= mod;
                    }
                }
            }
        }

        public long C(int n, int m) {
            if (cycleWay) {
                return C[n][m];
            }
            return fC(n, m);
        }

        private long fC(int n, int m) {
            return (fact[n] * inv(fact[n - m] * fact[m] % mod)) % mod;
        }

        private long inv(long r) {
            if (r == 1)
                return 1;
            return ((mod - mod / r) * inv(mod % r)) % mod;
        }
    }

    class Pair {
        int first;
        long second;

        Pair(int f, long s) {
            first = f;
            second = s;
        }

        public int getFirst() {
            return first;
        }

        public long getSecond() {
            return second;
        }
    }

    class MultisetTree<T> {
        int size = 0;

        TreeMap<T, Integer> mp = new TreeMap<>();

        void add(T x) {
            mp.merge(x, 1, Integer::sum);
            size++;
        }

        void remove(T x) {
            if (mp.containsKey(x)) {
                mp.merge(x, -1, Integer::sum);
                if (mp.get(x) == 0) {
                    mp.remove(x);
                }
                size--;
            }
        }

        boolean contains(T x) {
            return mp.containsKey(x);
        }

        T greatest() {
            return mp.lastKey();
        }

        T higher(T x) {
            return mp.higherKey(x);
        }

        T smallest() {
            return mp.firstKey();
        }

        int size() {
            return size;
        }

        int diffSize() {
            return mp.size();
        }
    }

    class Multiset<T> {
        int size = 0;

        Map<T, Integer> mp = new HashMap<>();

        void add(T x) {
            mp.merge(x, 1, Integer::sum);
            size++;
        }

        boolean contains(T x) {
            return mp.containsKey(x);
        }

        void remove(T x) {
            if (mp.containsKey(x)) {
                mp.merge(x, -1, Integer::sum);
                if (mp.get(x) == 0) {
                    mp.remove(x);
                }
                size--;
            }
        }

        int size() {
            return size;
        }

        int diffSize() {
            return mp.size();
        }
    }

    static class Range {
        int l, r;
        int id;

        public int getL() {
            return l;
        }

        public int getR() {
            return r;
        }

        public Range(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    static class Array {
        static Range[] readRanges(int n, FastScanner in) {
            Range[] result = new Range[n];
            for (int i = 0; i < n; i++) {
                result[i] = new Range(in.nextInt(), in.nextInt(), i);
            }
            return result;
        }

        static List<List<Integer>> intInit2D(int n) {
            List<List<Integer>> res = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                res.add(new ArrayList<>());
            }
            return res;
        }

        static boolean isSorted(Integer[] a) {
            for (int i = 0; i < a.length - 1; i++) {
                if (a[i] > a[i + 1]) {
                    return false;
                }
            }
            return true;
        }

        static public long sum(List<Integer> a) {
            long sum = 0;
            for (int x : a) {
                sum += x;
            }
            return sum;
        }

        static public long sum(int[] a) {
            long sum = 0;
            for (int x : a) {
                sum += x;
            }
            return sum;
        }

        static public long sum(long[] a) {
            long sum = 0;
            for (long x : a) {
                sum += x;
            }
            return sum;
        }

        static public long sum(Integer[] a) {
            long sum = 0;
            for (int x : a) {
                sum += x;
            }
            return sum;
        }

        static public int min(Integer[] a) {
            int mn = Integer.MAX_VALUE;
            for (int x : a) {
                mn = Math.min(mn, x);
            }
            return mn;
        }

        static public int min(int[] a) {
            int mn = Integer.MAX_VALUE;
            for (int x : a) {
                mn = Math.min(mn, x);
            }
            return mn;
        }

        static public int max(Integer[] a) {
            int mx = Integer.MIN_VALUE;
            for (int x : a) {
                mx = Math.max(mx, x);
            }
            return mx;
        }

        static public int max(int[] a) {
            int mx = Integer.MIN_VALUE;
            for (int x : a) {
                mx = Math.max(mx, x);
            }
            return mx;
        }

        static public int[] readint(int n, FastScanner in) {
            int[] out = new int[n];
            for (int i = 0; i < out.length; i++) {
                out[i] = in.nextInt();
            }
            return out;
        }
    }

    class Graph {
        List<List<Integer>> graph;

        Graph(int n) {
            create(n);
        }

        private void create(int n) {
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            this.graph = graph;
        }

        int size() {
            return graph.size();
        }

        List<Integer> abj(int v) {
            return graph.get(v);
        }

        void read(int m, FastScanner in) {
            for (int i = 0; i < m; i++) {
                int v = in.nextInt() - 1;
                int u = in.nextInt() - 1;
                graph.get(v).add(u);
            }
        }

        void readBi(int m, FastScanner in) {
            for (int i = 0; i < m; i++) {
                int v = in.nextInt() - 1;
                int u = in.nextInt() - 1;
                addEdge(v, u);
            }
        }

        public void addEdge(int v, int u) {
            graph.get(v).add(u);
            graph.get(u).add(v);
        }
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream io) {
            br = new BufferedReader(new InputStreamReader(io));
        }

        public String line() {
            String result = """";
            try {
                result = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return result;
        }

        public String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public char[] nextc() {
            return next().toCharArray();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public int[] nextArray(int n) {
            int[] res = new int[n];
            for (int i = 0; i < n; i++) {
                res[i] = in.nextInt();
            }
            return res;
        }

        public long[] nextArrayL(int n) {
            long[] res = new long[n];
            for (int i = 0; i < n; i++) {
                res[i] = in.nextLong();
            }
            return res;
        }

        public Long[] nextArrayL2(int n) {
            Long[] res = new Long[n];
            for (int i = 0; i < n; i++) {
                res[i] = in.nextLong();
            }
            return res;
        }


        public Integer[] nextArray2(int n) {
            Integer[] res = new Integer[n];
            for (int i = 0; i < n; i++) {
                res[i] = in.nextInt();
            }
            return res;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }

    void run_t_tests() {
        int t = in.nextInt();
        int i = 0;
        while (t-- > 0) {
            solve(in, out, i++);
        }
    }

    void run_one() {
        solve(in, out, -1);
    }

    @Override
    public void run() {
        in = new FastScanner(System.in);
        out = new PrintWriter(System.out);
        if (use_n_tests) {
            run_t_tests();
        } else {
            run_one();
        }
        out.close();
    }

    static FastScanner in;
    static PrintWriter out;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(null, new Main(), """", stack_size);
        thread.start();
        thread.join();
    }
}",2,0817_C,CODEFORCES,1059,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class ReallyBigNumbers {



	public static void main(String[] args) {

		

		Scanner sc = new Scanner(System.in);

		long n = sc.nextLong();

		long s  = sc.nextLong();

		

		long m = s;

		

		while(m-digitAdd(m)<s && m<=n){

			m++;

		}

		System.out.println(Math.max(n-m+1, 0));

	}

	

	private static int digitAdd(long s){

		int sum = 0;

		

		for(long i = 0,j=1L;i<(int)Math.log10(s)+1; i++,j*=10){

			sum += (s/j)%10;

		}

		

		return sum;

	}



}

",2,0817_C,CODEFORCES,1076,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Scanner;



public class Probram3 {



	public static int get(long n) {

		int sum = 0;

		while(n != 0) {

			sum += n % 10;

			n = n / 10;

		}

		return sum;

	}

	

	public static void main(String[] args) {

		Scanner scanner = new Scanner(System.in);

		long n = scanner.nextLong();

		long s = scanner.nextLong();

		long l = 1;

		long r = Long.MAX_VALUE;

		long index = 0;

		while(l <= r) {

			long mid = (l + r) / 2;

			if(mid - get(mid) >= s) {

				index = mid;

				r = mid - 1;

			}else{

				l = mid + 1;

			}

		}

		System.out.println(Math.max(0, n-index+1));

	}

}",2,0817_C,CODEFORCES,1082,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math"
"import java.util.Arrays;
import java.util.Scanner;

public class Main {
    private static int REM = 1000000007;
    private static int dig;
    private static int[][][] dp = new int[701][701][2];

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String X = in.next();
        int N = X.length();

        int[] P = new int[701];
        P[0] = 1;
        for (int i=1; i<P.length; ++i) {
            P[i] = (int)((long)P[i-1] * 10 % REM);
        }

        int ans = 0;
        for (int d=1; d<=9; ++d) { //at least d
            dig = d;

            for (int[][] array2 : dp) {
                for (int[] array1 : array2) {
                    Arrays.fill(array1, -1);
                }
            }

            for (int c=1; c<=N; ++c) { //exact count of at least d
                for (int k=0; k<c; ++k) {
                    ans = (int)((ans + (long)f(0, c, false, X) * P[k]) % REM);
                }
            }
        }
        System.out.println(ans);
    }

    private static int f(int ps, int needed, boolean less, final String X) {
        if (needed < 0) {return 0;}
        if (dp[ps][needed][less?0:1] != -1) {return dp[ps][needed][less?0:1];}
        if (ps == X.length()) {
            if (needed == 0) {return 1;}
            return 0;
        }
        int dg = X.charAt(ps)-'0';

        int ans = 0;
        for (int d=0; d<=9; ++d) {
            if (!less && d>dg) {continue;}

            boolean nless = less || d < dg;
            ans = (int)((ans + (long)f(ps+1, needed-(d>=dig?1:0), nless, X)) % REM);
        }

        dp[ps][needed][less?0:1] = ans;
        return ans;
    }
}
",5,0908_G,CODEFORCES,3032,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"//package goodbye2017;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class G {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		char[] s = ns().toCharArray();
		int mod = 1000000007;
		int m = 702;
		
		long[] bases = new long[m+1];
		bases[0] = 1;
		for(int i = 1;i <= m;i++)bases[i] = bases[i-1] * 10 % mod;
		
		// 10*700^3*10
		long ans = 0;
		for(int d = 9;d >= 1;d--){
			int n = s.length;
			long[] sum = new long[m]; // base
			long[] num = new long[m]; // base
			long esum = 0;
			int ebase = 0;
			for(int i = 0;i < n;i++){
				long[] nsum = new long[m]; // base
				long[] nnum = new long[m]; // base
				for(int j = 0;j < m;j++){
					for(int k = 0;k <= 9;k++){
						if(k > d && j+1 < m){
							nsum[j+1] += sum[j] * 10;
							nsum[j+1] %= mod;
							nnum[j+1] += num[j];
							if(nnum[j+1] >= mod)nnum[j+1] -= mod;
						}
						if(k == d){
							nsum[j] += sum[j] * 10 + num[j] * bases[j];
							nsum[j] %= mod;
							nnum[j] += num[j];
							if(nnum[j] >= mod)nnum[j] -= mod;
						}
						if(k < d){
							nsum[j] += sum[j];
							if(nsum[j] >= mod)nsum[j] -= mod;
							nnum[j] += num[j];
							if(nnum[j] >= mod)nnum[j] -= mod;
						}
					}
				}
				
				for(int k = 0;k < s[i]-'0';k++){
					if(k > d){
						nsum[ebase+1] += esum * 10;
						nsum[ebase+1] %= mod;
						nnum[ebase+1] += 1;
						if(nnum[ebase+1] >= mod)nnum[ebase+1] -= mod;
					}
					if(k == d){
						nsum[ebase] += esum * 10 + bases[ebase];
						nsum[ebase] %= mod;
						nnum[ebase] += 1;
						if(nnum[ebase] >= mod)nnum[ebase] -= mod;
					}
					if(k < d){
						nsum[ebase] += esum;
						if(nsum[ebase] >= mod)nsum[ebase] -= mod;
						nnum[ebase] += 1;
						if(nnum[ebase] >= mod)nnum[ebase] -= mod;
					}
				}
				
				if(s[i]-'0' > d){
					esum = esum * 10;
					esum %= mod;
					ebase++;
				}else if(s[i]-'0' == d){
					esum = esum * 10 + bases[ebase];
					esum %= mod;
				}
				
				sum = nsum;
				num = nnum;
			}
			long all = esum;
			for(int j = 0;j < m;j++){
				all += sum[j];
			}
			ans += all % mod * d;
		}
		out.println(ans%mod);
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new G().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",5,0908_G,CODEFORCES,3027,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class MainG {
	static StdIn in = new StdIn();
	static PrintWriter out = new PrintWriter(System.out);
	static long M=(long)1e9+7;
	
	public static void main(String[] args) {
		char[] cs = in.next().toCharArray();
		int n=cs.length;
		int[] x = new int[n];
		for(int i=0; i<n; ++i)
			x[i]=cs[i]-'0';
		long[] dp1 = new long[n+1];
		for(int i=0; i<n; ++i) 
			dp1[i+1]=(x[i]+dp1[i]*10)%M;
		long ans=0;
		for(int d1=1; d1<=9; ++d1) {
			long[][] dp2 = new long[2][n+1];
			for(int i=0; i<n; ++i) {
				dp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];
				for(int d2=0; d2<x[i]; ++d2)
					dp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;
				for(int d2=x[i]; d2<=9; ++d2)
					dp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;
			}
			ans+=dp2[0][n]+dp2[1][n];
		}
		out.println(ans%M);
		out.close();
	}
	
	interface Input {
		public String next();
		public String nextLine();
		public int nextInt();
		public long nextLong();
		public double nextDouble();
	}
	static class StdIn implements Input {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt();
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong();
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",5,0908_G,CODEFORCES,3026,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class cf908G {
	final static int MOD = 1_000_000_007;
	
	public static void main(String[] argv) {
		cf908G pro = new cf908G();
		
		InputStream fin = null;
		if (System.getProperty(""ONLINE_JUDGE"") == null) {
			try {
				fin = new FileInputStream(""input.txt"");
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		} else {
			fin = System.in;
		}
		pro.solve(new Scanner(fin), System.out);
	}
	
	private void solve(Scanner scanner, PrintStream out) {
		long ans = 0;
		String X = scanner.next();
		for (int x = 0; x < 9; x++) {
			ans = (ans + solve2(x, X)) % MOD;
		}
		out.println((ans % MOD + MOD) % MOD);
	}

	private long solve2(int x, String X) {
		int[][][] f = new int[X.length() + 1][X.length() + 1][2];
		f[0][0][1] = 1;
		
		int n = X.length();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <= n; j++) {
				for (int u = 0; u < 2; u++) {
					int val = f[i][j][u];
					if (val == 0) continue;
					
					for (int num = 0; num < 10; num++) {
						int Xi = X.charAt(i) - '0';
						if (u == 1 && num > Xi) break;
						int _i = i + 1;
						int _j = num <= x ? j + 1 : j;
						int _u = u == 1 && num == Xi ? 1 : 0;
						
						f[_i][_j][_u] = (f[_i][_j][_u] + val) % MOD;
					}
				}
			}
		}
		
		long base = 1;
		long ret = 0;
		for (int i = n; i > 0; i--) {
			long t = 0;
			for (int j = 0; j < i; j++) {
				t = (t + f[n][j][0] + f[n][j][1]) % MOD;
			}
			
			ret = (ret + base * t) % MOD;
			
			base = (base * 10) % MOD;
		}
		return ret;
	}
	
}",5,0908_G,CODEFORCES,3035,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.atomic.AtomicIntegerArray;

public class Solution {

    public static void main(String[] args) throws Exception {
        MyReader reader = new MyReader(System.in);
//        MyReader reader = new MyReader(new FileInputStream(""input.txt""));
        MyWriter writer = new MyWriter(System.out);
        new Solution().run(reader, writer);
        writer.close();
    }

    private void run(MyReader reader, MyWriter writer) throws Exception {
        char[] c = reader.nextCharArray();
        int n = c.length;
        int[] x = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = c[i] - '0';
        }
        long mod = 1_000_000_007;
        long[] p = new long[n + 1];
        long[] s = new long[n + 1];
        p[0] = 1;
        for (int i = 1; i <= n; i++) {
            p[i] = p[i - 1] * 10 % mod;
        }
        s[n] = 1;
        for (int i = n - 1; i >= 0; i--) {
            s[i] = (p[n - i - 1] * x[i] + s[i + 1]) % mod;
        }
        long[][][] d = new long[n + 1][n + 1][2];
        long ans = 0;
        for (int i = 1; i < 10; i++) {
            for (long[][] q : d) {
                for (long[] w : q) {
                    Arrays.fill(w, 0);
                }
            }
            for (int j = 0; j <= n; j++) {
                d[j][0][0] = s[j];
                d[j][0][1] = p[n - j];
            }
            for (int j = n - 1; j >= 0; j--) {
                for (int k = 1; k <= n; k++) {
                    for (int l = 1; l >= 0; l--) {
                        int lim = l == 1 ? 10 : x[j] + 1;
                        for (int m = 0; m < lim; m++) {
                            d[j][k][l] += d[j + 1][k - (m >= i ? 1 : 0)][l == 1 || m < x[j] ? 1 : 0];
                            d[j][k][l] %= mod;
                        }
                    }
                    if (j == 0) {
                        ans = (ans + p[k - 1] * d[0][k][0]) % mod;
                    }
                }
            }
        }
        System.out.println(ans);
    }

    static class MyReader {

        final BufferedInputStream in;
        final int bufSize = 1 << 16;
        final byte buf[] = new byte[bufSize];
        int i = bufSize;
        int k = bufSize;
        boolean end = false;
        final StringBuilder str = new StringBuilder();

        MyReader(InputStream in) {
            this.in = new BufferedInputStream(in, bufSize);
        }

        int nextInt() throws IOException {
            return (int) nextLong();
        }

        int[] nextIntArray(int n) throws IOException {
            int[] m = new int[n];
            for (int i = 0; i < n; i++) {
                m[i] = nextInt();
            }
            return m;
        }

        int[][] nextIntMatrix(int n, int m) throws IOException {
            int[][] a = new int[n][0];
            for (int j = 0; j < n; j++) {
                a[j] = nextIntArray(m);
            }
            return a;
        }

        long nextLong() throws IOException {
            int c;
            long x = 0;
            boolean sign = true;
            while ((c = nextChar()) <= 32) ;
            if (c == '-') {
                sign = false;
                c = nextChar();
            }
            if (c == '+') {
                c = nextChar();
            }
            while (c >= '0') {
                x = x * 10 + (c - '0');
                c = nextChar();
            }
            return sign ? x : -x;
        }

        long[] nextLongArray(int n) throws IOException {
            long[] m = new long[n];
            for (int i = 0; i < n; i++) {
                m[i] = nextLong();
            }
            return m;
        }

        int nextChar() throws IOException {
            if (i == k) {
                k = in.read(buf, 0, bufSize);
                i = 0;
            }
            return i >= k ? -1 : buf[i++];
        }

        String nextString() throws IOException {
            if (end) {
                return null;
            }
            str.setLength(0);
            int c;
            while ((c = nextChar()) <= 32 && c != -1) ;
            if (c == -1) {
                end = true;
                return null;
            }
            while (c > 32) {
                str.append((char) c);
                c = nextChar();
            }
            return str.toString();
        }

        String nextLine() throws IOException {
            if (end) {
                return null;
            }
            str.setLength(0);
            int c = nextChar();
            while (c != '\n' && c != '\r' && c != -1) {
                str.append((char) c);
                c = nextChar();
            }
            if (c == -1) {
                end = true;
                if (str.length() == 0) {
                    return null;
                }
            }
            if (c == '\r') {
                nextChar();
            }
            return str.toString();
        }

        char[] nextCharArray() throws IOException {
            return nextString().toCharArray();
        }

        char[][] nextCharMatrix(int n) throws IOException {
            char[][] a = new char[n][0];
            for (int i = 0; i < n; i++) {
                a[i] = nextCharArray();
            }
            return a;
        }
    }

    static class MyWriter {

        final BufferedOutputStream out;
        final int bufSize = 1 << 16;
        final byte buf[] = new byte[bufSize];
        int i = 0;
        final byte c[] = new byte[30];
        static final String newLine = System.getProperty(""line.separator"");

        MyWriter(OutputStream out) {
            this.out = new BufferedOutputStream(out, bufSize);
        }

        void print(long x) throws IOException {
            int j = 0;
            if (i + 30 >= bufSize) {
                flush();
            }
            if (x < 0) {
                buf[i++] = (byte) ('-');
                x = -x;
            }
            while (j == 0 || x != 0) {
                c[j++] = (byte) (x % 10 + '0');
                x /= 10;
            }
            while (j-- > 0)
                buf[i++] = c[j];
        }

        void print(int[] m) throws IOException {
            for (int a : m) {
                print(a);
                print(' ');
            }
        }

        void print(long[] m) throws IOException {
            for (long a : m) {
                print(a);
                print(' ');
            }
        }

        void print(String s) throws IOException {
            for (int i = 0; i < s.length(); i++) {
                print(s.charAt(i));
            }
        }

        void print(char x) throws IOException {
            if (i == bufSize) {
                flush();
            }
            buf[i++] = (byte) x;
        }

        void print(char[] m) throws IOException {
            for (char c : m) {
                print(c);
            }
        }

        void println(String s) throws IOException {
            print(s);
            println();
        }

        void println() throws IOException {
            print(newLine);
        }

        void flush() throws IOException {
            out.write(buf, 0, i);
            out.flush();
            i = 0;
        }

        void close() throws IOException {
            flush();
            out.close();
        }
    }
}",5,0908_G,CODEFORCES,3036,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class CF {
    private FastScanner in;
    private PrintWriter out;

    final int mod = (int) 1e9 + 7;

    private long f(String s, int digit) {
        final int n = s.length();
        int[][] dp = new int[2][n + 1]; // [less][cntBigger] -> sum
        dp[0][0] = 1;
        int[][] ndp = new int[2][n + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 2; j++) {
                Arrays.fill(ndp[j], 0);
            }
            for (int less = 0; less < 2; less++) {
                for (int cntBigger = 0; cntBigger <= n; cntBigger++) {
                    int cur = dp[less][cntBigger];
                    if (cur == 0) {
                        continue;
                    }
                    int max = less == 1 ? 9 : (s.charAt(i) - '0');
                    for (int next = 0; next <= max; next++) {
                        int nextLess = (less == 1) || (next < max) ? 1 : 0;
                        int nextCntBigger = cntBigger + ((next >= digit) ? 1 : 0);
                        ndp[nextLess][nextCntBigger] += cur;
                        while (ndp[nextLess][nextCntBigger] >= mod) {
                            ndp[nextLess][nextCntBigger] -= mod;
                        }
                    }
                }
            }
            int[][] tmp = dp;
            dp = ndp;
            ndp = tmp;
        }
        long result = 0;
        for (int less = 0; less < 2; less++) {
            long sum = 0;
            for (int cntBigger = 1; cntBigger <= n; cntBigger++) {
                sum = (sum * 10 + 1) % mod;
                result = (result + sum * dp[less][cntBigger]) % mod;
            }
        }
        return result % mod;
    }

    private void solve() {
        final String number = in.next();
        long result = 0;
        for (int digit = 1; digit < 10; digit++) {
            long cur = f(number, digit);
            result += cur;
        }
        out.println(result % mod);
    }

    private void run() {
        try {
            in = new FastScanner(new File(""CF.in""));
            out = new PrintWriter(new File(""CF.out""));

            solve();

            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    private void runIO() {
        in = new FastScanner(System.in);
        out = new PrintWriter(System.out);

        solve();

        out.close();
    }

    private class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        FastScanner(File f) {
            try {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        FastScanner(InputStream f) {
            br = new BufferedReader(new InputStreamReader(f));
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return null;
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        boolean hasMoreTokens() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return false;
                st = new StringTokenizer(s);
            }
            return true;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    public static void main(String[] args) {
        new CF().runIO();
    }
}",5,0908_G,CODEFORCES,3034,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class MainG {
	static StdIn in = new StdIn();
	static PrintWriter out = new PrintWriter(System.out);
	static long M=(long)1e9+7;
	
	public static void main(String[] args) {
		char[] cs = in.next().toCharArray();
		int n=cs.length;
		int[] x = new int[n];
		for(int i=0; i<n; ++i)
			x[i]=cs[i]-'0';
		long[] dp1 = new long[n+1];
		for(int i=0; i<n; ++i) 
			dp1[i+1]=(x[i]+dp1[i]*10)%M;
		//out.println(Arrays.toString(dp1));
		long ans=0;
		for(int d1=1; d1<=9; ++d1) {
			long[][] dp2 = new long[2][n+1];
			for(int i=0; i<n; ++i) {
				dp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];
				dp2[1][i+1]=x[i]>=d1?(10*dp2[1][i]+dp1[i])%M:dp2[1][i];
				for(int d2=0; d2<x[i]; ++d2)
					dp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;
				for(int d2=x[i]+1; d2<=9; ++d2)
					dp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;
			}
			ans+=dp2[0][n]+dp2[1][n];
			//out.println(dp2[0][n]+"" ""+dp2[1][n]);
		}
		out.println(ans%M);
		out.close();
	}
	
	interface Input {
		public String next();
		public String nextLine();
		public int nextInt();
		public long nextLong();
		public double nextDouble();
	}
	static class StdIn implements Input {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt();
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong();
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",5,0908_G,CODEFORCES,3038,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class G {

	static final int P = 1_000_000_007;

	int[][] ways;
	int[][] pow;

	void preCalc(int sz) {
		ways = new int[sz][];
		for (int i = 0; i < ways.length; i++) {
			ways[i] = new int[i + 1];
			ways[i][0] = ways[i][i] = 1;
			for (int j = 1; j < i; j++) {
				ways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % P;
			}
		}

		pow = new int[10][sz];
		pow[0] = null;
		for (int i = 1; i <= 9; i++) {
			pow[i][0] = 1;
			for (int j = 1; j < sz; j++) {
				pow[i][j] = (int) ((long) pow[i][j - 1] * i % P);
			}
		}
	}

	int solve(String ss) {
		int n = ss.length();
		int[] s = new int[n];
		for (int i = 0; i < n; i++) {
			s[i] = ss.charAt(i) - '0';
		}

		preCalc(n + 10);

		int[] ans = new int[n + 1];

		int[] cnt = new int[10];

		for (int i = 0; i < n; i++) {

			int rest = n - i - 1;

			int dig = s[i];

			for (int j = 0; j <= (i == n - 1 ? dig : dig - 1); j++) {
				cnt[j]++; // now we have one more digit >= j

				for (int use = 1; use < 10; use++) {
					// use digits are bad, 10 - use are good
					for (int cntGood = 0; cntGood <= rest; cntGood++) {
						int delta = (int) ((long) ways[rest][cntGood]
								* pow[use][rest - cntGood] % P
								* pow[10 - use][cntGood] % P);
						int idx = cnt[use] + cntGood;
						ans[idx] += delta;
						if (ans[idx] >= P) {
							ans[idx] -= P;
						}
					}
				}

				// System.err.println(Arrays.toString(ans));

			}

			cnt[dig]++;

		}
		
		int ret = 0;
		long mult = 0;
		for (int i = 1; i < ans.length; i++) {
			mult = (10L * mult + 1) % P;
			ret += (int)(mult * ans[i] % P);
			if (ret >= P) {
				ret -= P;
			}
		}
		
		return ret;
	}

	void submit() {
		out.println(solve(nextToken()));
	}

	void stress() {

	}

	void test() {
		StringBuilder sb = new StringBuilder(""1"");
		for (int i = 0; i < 700; i++) {
			sb.append('0');
		}
		solve(sb.toString());
	}

	G() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		submit();
		// stress();
//		 test();
		out.close();
	}

	static final Random rng = new Random();

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new G();
	}

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int nextInt() {
		return Integer.parseInt(nextToken());
	}

	long nextLong() {
		return Long.parseLong(nextToken());
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}
}
",5,0908_G,CODEFORCES,3029,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jialin Ouyang (Jialin.Ouyang@gmail.com)
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    QuickScanner in = new QuickScanner(inputStream);
    QuickWriter out = new QuickWriter(outputStream);
    TaskG solver = new TaskG();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskG {
    static int MAXL = 700 + 1;
    static IntModular MOD = new IntModular();
    int n;
    char[] digits;
    int[] pow10;
    int[] ones;
    int[][][] way;

    public void solve(int testNumber, QuickScanner in, QuickWriter out) {
      digits = new char[MAXL];
      n = in.next(digits);
      initPow();
      int res = MOD.mul(calc(9), 9);
      for (int digit = 0; digit < 9; ++digit) {
        res = MOD.sub(res, calc(digit));
      }
      out.println(res);
    }

    void initPow() {
      pow10 = new int[n + 1];
      ones = new int[n + 1];
      pow10[0] = 1;
      for (int i = 1; i <= n; ++i) {
        pow10[i] = MOD.mul(pow10[i - 1], 10);
        ones[i] = MOD.add(MOD.mul(ones[i - 1], 10), 1);
      }
    }

    int calc(int targetDigit) {
      if (way == null) {
        way = new int[2][2][n + 1];
      }
      int t = 0;
      clearCnt(t);
      way[t][0][0] = 1;
      for (int i = 0; i < n; ++i) {
        int digit = digits[i] - '0';
        clearCnt(t ^ 1);
        // not free
        for (int cnt = 0; cnt <= n; ++cnt)
          if (way[t][0][cnt] > 0) {
            // not free
            int newCnt = targetDigit < digit ? cnt + 1 : cnt;
            way[t ^ 1][0][newCnt] = MOD.add(
                way[t ^ 1][0][newCnt],
                way[t][0][cnt]);
            // free
            way[t ^ 1][1][cnt] = MOD.add(
                way[t ^ 1][1][cnt],
                MOD.mul(
                    Math.min(targetDigit + 1, digit),
                    way[t][0][cnt]));
            way[t ^ 1][1][cnt + 1] = MOD.add(
                way[t ^ 1][1][cnt + 1],
                MOD.mul(
                    Math.max(digit - targetDigit - 1, 0),
                    way[t][0][cnt]));
          }
        // free
        for (int cnt = 0; cnt <= n; ++cnt)
          if (way[t][1][cnt] > 0) {
            way[t ^ 1][1][cnt] = MOD.add(
                way[t ^ 1][1][cnt],
                MOD.mul(
                    targetDigit + 1,
                    way[t][1][cnt]));
            way[t ^ 1][1][cnt + 1] = MOD.add(
                way[t ^ 1][1][cnt + 1],
                MOD.mul(
                    9 - targetDigit,
                    way[t][1][cnt]));
          }
        t ^= 1;
      }
      int res = 0;
      for (int cnt = 0; cnt <= n; ++cnt) {
        res = MOD.add(
            res,
            MOD.mul(MOD.mul(
                ones[n - cnt],
                pow10[cnt]),
                MOD.add(way[t][0][cnt], way[t][1][cnt])));
      }
      return res;
    }

    void clearCnt(int t) {
      for (int free = 0; free < 2; ++free) {
        Arrays.fill(way[t][free], 0);
      }
    }

  }

  static class QuickWriter {
    private final PrintWriter writer;

    public QuickWriter(OutputStream outputStream) {
      this.writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public QuickWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; ++i) {
        if (i > 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void println(Object... objects) {
      print(objects);
      writer.println();
    }

    public void close() {
      writer.close();
    }

  }

  static class IntModular {
    private static final int MOD = 1000000007;
    public final int mod;
    private final int[] x;

    public IntModular() {
      this(MOD);
    }

    public IntModular(int mod) {
      this.mod = mod;
      this.x = new int[2];
    }

    public int add(int a, int b) {
      return fix(a + b, mod);
    }

    public int sub(int a, int b) {
      return fix(a - b, mod);
    }

    public int mul(int a, int b) {
      return mul(a, b, mod);
    }

    public static int mul(int a, int b, int mod) {
      return a > 0
          ? (b < mod / a ? a * b : (int) ((long) a * b % mod))
          : 0;
    }

    public static int fix(int a, int mod) {
      a = slightFix(a, mod);
      return 0 <= a && a < mod ? a : slightFix(a % mod, mod);
    }

    private static int slightFix(int a, int mod) {
      return a >= mod
          ? a - mod
          : a < 0 ? a + mod : a;
    }

  }

  static class QuickScanner {
    private static final int BUFFER_SIZE = 1024;
    private InputStream stream;
    private byte[] buffer;
    private int currentPosition;
    private int numberOfChars;

    public QuickScanner(InputStream stream) {
      this.stream = stream;
      this.buffer = new byte[BUFFER_SIZE];
      this.currentPosition = 0;
      this.numberOfChars = 0;
    }

    public int next(char[] s) {
      return next(s, 0);
    }

    public int next(char[] s, int startIdx) {
      int b = nextNonSpaceChar();
      int res = 0;
      do {
        s[startIdx++] = (char) b;
        b = nextChar();
        ++res;
      } while (!isSpaceChar(b));
      return res;
    }

    public int nextNonSpaceChar() {
      int res = nextChar();
      for (; isSpaceChar(res) || res < 0; res = nextChar()) ;
      return res;
    }

    public int nextChar() {
      if (numberOfChars == -1) {
        throw new RuntimeException();
      }
      if (currentPosition >= numberOfChars) {
        currentPosition = 0;
        try {
          numberOfChars = stream.read(buffer);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        if (numberOfChars <= 0) {
          return -1;
        }
      }
      return buffer[currentPosition++];
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '\t' || isEndOfLineChar(c);
    }

    public boolean isEndOfLineChar(int c) {
      return c == '\n' || c == '\r' || c < 0;
    }

  }
}

",5,0908_G,CODEFORCES,3033,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class MainG {
	static StdIn in = new StdIn();
	static PrintWriter out = new PrintWriter(System.out);
	static long M=(long)1e9+7;
	static int n, dig;
	static int[] x;
	static long[] p10, s;
	static long[][][] dp;
	
	public static void main(String[] args) {
		char[] cs = in.next().toCharArray();
		n=cs.length;
		x = new int[n];
		for(int i=0; i<n; ++i)
			x[i]=cs[i]-'0';
		p10 = new long[n];
		p10[0]=1;
		for(int i=1; i<n; ++i)
			p10[i]=p10[i-1]*10%M;
		s = new long[n+1];
		s[n]=1;
		for(int i=n-1; i>=0; --i)
			s[i]=(s[i+1]+x[i]*p10[n-1-i])%M;
		long ans=0;
		dp = new long[2][n][n+1];
		for(dig=1; dig<=9; ++dig) {
			for(int i=0; i<n; ++i) {
				Arrays.fill(dp[0][i], -1);
				Arrays.fill(dp[1][i], -1);
			}
			for(int i=1; i<=n; ++i)
				ans=(ans+p10[i-1]*dp(0, 0, i))%M;
		}
		out.println(ans);
		out.close();
	}
	
	static long dp(int less, int ignore, int need) {
		if(need==0)
			return less==1?p10[n-ignore]:s[ignore];
		if(ignore==n)
			return 0;
		if(dp[less][ignore][need]!=-1)
			return dp[less][ignore][need];
		long res=0;
		int lim=less==1?9:x[ignore];
		for(int i=0; i<=lim; ++i)
			res=(res+dp(less|(i<lim?1:0), ignore+1, need-(i>=dig?1:0)))%M;
		return dp[less][ignore][need]=res;
	}
	
	interface Input {
		public String next();
		public String nextLine();
		public int nextInt();
		public long nextLong();
		public double nextDouble();
	}
	static class StdIn implements Input {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt();
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong();
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",5,0908_G,CODEFORCES,3028,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import static java.lang.System.exit;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class G {

	static final int MOD = 1000000007;

	static int add(int a, int b) {
		int res = a + b;
		return res >= MOD ? res - MOD : res;
	}

	static int sub(int a, int b) {
		int res = a - b;
		return res < 0 ? res + MOD : res;
	}

	static int mul(int a, int b) {
		int res = (int) ((long) a * b % MOD);
		return res < 0 ? res + MOD : res;
	}

	static int pow(int a, int e) {
		if (e == 0) {
			return 1;
		}
		int r = a;
		for (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {
			r = mul(r, r);
			if ((e & (1 << i)) != 0) {
				r = mul(r, a);
			}
		}
		return r;
	}

	static int inv(int a) {
		return pow(a, MOD - 2);
	}

	static void solve() throws Exception {
		String x = scanString();
//		char xx[] = new char[700];
//		fill(xx, '9');
//		String x = new String(xx);
		int n = x.length();
		int pows[][] = new int[10][n];
		for (int i = 0; i < 10; i++) {
			pows[i][0] = 1;
			for (int j = 1; j < n; j++) {
				pows[i][j] = mul(pows[i][j - 1], i);
			}
		}
		int ru[] = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			ru[i] = add(1, mul(10, ru[i - 1]));
		}
		int facts[] = new int[n];
		facts[0] = 1;
		for (int i = 1; i < n; i++) {
			facts[i] = mul(facts[i - 1], i);
		}
		int factsInv[] = new int[n];
		factsInv[n - 1] = inv(facts[n - 1]);
		for (int i = n - 1; i > 0; i--) {
			factsInv[i - 1] = mul(factsInv[i], i);
		}
		int ans = 0;
		int off[] = new int[10];
		for (int i = 0; i < n; i++) {
			int cd = x.charAt(i) - '0';
			int l = n - i - 1;
			for (int d = 1; d < 10; d++) {
				for (int p = 0; p <= l; p++) {
					int mul = d < cd ? add(mul(d, ru[p + off[d]]), mul(cd - d, ru[p + off[d] + 1])) : mul(cd, ru[p + off[d]]);
					ans = add(ans, mul(mul, mul(mul(pows[d][l - p], pows[10 - d][p]), mul(facts[l], mul(factsInv[p], factsInv[l - p])))));
				}
			}
			for (int d = 0; d <= cd; d++) {
				++off[d];
			}
		}
		for (int d = 1; d < 10; d++) {
			ans = add(ans, ru[off[d]]);
		}
		out.print(ans);
	}

	static int scanInt() throws IOException {
		return parseInt(scanString());
	}

	static long scanLong() throws IOException {
		return parseLong(scanString());
	}

	static String scanString() throws IOException {
		while (tok == null || !tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	public static void main(String[] args) {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			exit(1);
		}
	}
}",5,0908_G,CODEFORCES,3030,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.*;
import java.util.*;

public class MainG {
	static StdIn in = new StdIn();
	static PrintWriter out = new PrintWriter(System.out);
	static long M=(long)1e9+7;
	static int n, dig;
	static int[] x;
	static long[] p10, s;
	static long[][][] dp;
	
	public static void main(String[] args) {
		char[] cs = in.next().toCharArray();
		n=cs.length;
		x = new int[n];
		for(int i=0; i<n; ++i)
			x[i]=cs[i]-'0';
		p10 = new long[n];
		p10[0]=1;
		for(int i=1; i<n; ++i)
			p10[i]=p10[i-1]*10%M;
		s = new long[n+1];
		s[n]=1;
		for(int i=n-1; i>=0; --i)
			s[i]=(s[i+1]+x[i]*p10[n-1-i])%M;
		long ans=0;
		dp = new long[2][n][n+1];
		for(dig=1; dig<=9; ++dig) {
			for(int i=0; i<n; ++i) {
				Arrays.fill(dp[0][i], -1);
				Arrays.fill(dp[1][i], -1);
			}
			for(int i=1; i<=n; ++i)
				ans=(ans+p10[i-1]*dp(0, 0, i))%M;
		}
		out.println(ans);
		out.close();
	}
	
	static long dp(int less, int ignore, int need) {
		if(need==0)
			return less==1?p10[n-ignore]:s[ignore];
		if(ignore==n)
			return 0;
		if(dp[less][ignore][need]!=-1)
			return dp[less][ignore][need];
		long res=0;
		int lim=less==1?9:x[ignore];
		for(int i=0; i<=lim; ++i)
			res=(res+dp(less|(i<lim?1:0), ignore+1, need-(i>=dig?1:0)));
		res%=M;
		return dp[less][ignore][need]=res;
	}
	
	interface Input {
		public String next();
		public String nextLine();
		public int nextInt();
		public long nextLong();
		public double nextDouble();
	}
	static class StdIn implements Input {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt();
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong();
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",5,0908_G,CODEFORCES,3031,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskG solver = new TaskG();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskG {
        static final long MODULO = (long) (1e9 + 7);

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            String x = in.next();
            int[][] comb = new int[x.length() + 2][x.length() + 2];
            comb[0][0] = 1;
            for (int i = 1; i < comb.length; ++i) {
                comb[i][0] = 1;
                for (int j = 1; j < comb.length; ++j) {
                    comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % (int) MODULO;
                }
            }
            int[][] pow = new int[11][x.length() + 2];
            for (int i = 0; i < pow.length; ++i) {
                pow[i][0] = 1;
                for (int j = 1; j < pow[i].length; ++j) {
                    pow[i][j] = (int) (i * (long) pow[i][j - 1] % MODULO);
                }
            }
            int[] oneSum = new int[x.length() + 2];
            for (int i = 1; i < oneSum.length; ++i) {
                oneSum[i] = (int) ((10 * (long) oneSum[i - 1] + 1) % MODULO);
            }

            int[][] s1 = new int[10][x.length() + 1];
            int[][] s2 = new int[10][x.length() + 1];
            for (int what = 1; what <= 9; ++what) {
                for (int max = 0; max <= x.length(); ++max) {
                    long sum1 = 0;
                    long sum2 = 0;
                    for (int equalExtra = 0; equalExtra <= max; ++equalExtra) {
                        long cways = 1;
                        cways *= comb[max][equalExtra];
                        cways %= MODULO;
                        cways *= pow[what][max - equalExtra];
                        cways %= MODULO;
                        sum1 += cways * oneSum[equalExtra];
                        sum1 %= MODULO;
                        sum2 += cways;
                        sum2 %= MODULO;
                    }
                    s1[what][max] = (int) sum1;
                    s2[what][max] = (int) sum2;
                }
            }

            int[] sofar = new int[10];
            long res = 0;
            for (int firstLess = 0; firstLess < x.length(); ++firstLess) {
                int min = 0;
                int max = x.charAt(firstLess) - '0';
                if (firstLess < x.length() - 1) --max;
                for (int dig = min; dig <= max; ++dig) {
                    ++sofar[dig];
                    int totalSofar = firstLess + 1;
                    int sofarBigger = 0;
                    for (int what = 9; what >= 1; --what) {
                        int sofarThisOrLess = totalSofar - sofarBigger;
                        int sofarThis = sofar[what];
                        int sofarLess = sofarThisOrLess - sofarThis;
                        for (int bigger = sofarBigger; bigger + sofarThisOrLess <= x.length(); ++bigger) {
                            long ways = comb[x.length() - totalSofar][bigger - sofarBigger];
                            ways *= pow[9 - what][bigger - sofarBigger];
                            ways %= MODULO;
                            long sum1 = s1[what][x.length() - bigger - sofarThisOrLess];
                            long sum2 = s2[what][x.length() - bigger - sofarThisOrLess];
                            long sum = (sum1 * (long) pow[10][sofarThis] + sum2 * oneSum[sofarThis]) % MODULO;
                            sum *= pow[10][bigger];
                            sum %= MODULO;
                            res = (res + sum * ways % MODULO * what) % MODULO;
                        }
                        sofarBigger += sofarThis;
                    }
                    --sofar[dig];
                }
                ++sofar[x.charAt(firstLess) - '0'];
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

    }
}

",5,0908_G,CODEFORCES,3037,New Year and Original Order,"Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.
Given a number X, compute  modulo 109 + 7.
The first line of input will contain the integer X (1 ≤ X ≤ 10700).
","input
Print a single integer, the answer to the question.
output
The first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. 
","dp, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class Main {
    private static int MOD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String s = reader.readLine();
        char[] arr = s.toCharArray();
        int k = Integer.parseInt(reader.readLine());
        if (k==0) {
            System.out.println(1);
            System.exit(0);
        }
        int[] operations = new int[1001];
        for (int i=2; i<=1000; i++) {
            int ones = 0;
            char[] a = Integer.toBinaryString(i).toCharArray();
            for (char elem:a) {
                if (elem=='1') ones++;
            }
            operations[i] = operations[ones] + 1;
        }
        int n = arr.length;
        if (n<=10 && Integer.parseInt(s, 2)<=1000) {
            int x = Integer.parseInt(s, 2);
            int res = 0;
            for (int i=0; i<=x; i++) {
                if (operations[i]==k) res++;
            }
            System.out.println(res);
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i=1; i<=1000; i++) {
                if (operations[i]==k-1) list.add(i);
            }
            int[][] matr = new int[n+1][n+1];
            for (int i=0; i<=n; i++) {
                matr[i][0] = matr[i][i] = 1;
                if (i==0) continue;
                for (int j=1; j<=n; j++) {
                    matr[i][j] = (matr[i-1][j-1] + matr[i-1][j]) % MOD;
                }
            }
            int res = 0;
            for (int y=1; y<n; y++) {
                for (int x:list) {
                    if (x>y) break;
                    if (y==1 && x==1) continue;
                    res = (res + matr[y-1][x-1]) % MOD;
                }
            }
            int amount = 1;
            for (int i=1; i<n; i++) {
                if (arr[i]=='1') {
                    int y = n - i - 1;
                    for (int x:list) {
                        if (x-amount>y) break;
                        if (x-amount<0) continue;
                        res = (res + matr[y][x-amount]) % MOD;
                    }
                    amount++;
                }
            }
            if (list.contains(amount)) res = (res + 1) % MOD;
            System.out.println(res);
        }
    }
}",3,0914_C,CODEFORCES,1833,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        FastScanner in = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        new Main().run(in, out);
        out.close();
    }


    int[] x;
    int K;
    void run(FastScanner in, PrintWriter out) {

        // all numbers under 2^(1000) have <= 1000 bits
        // compute all transitions from 1000 to 1
        // for numbers > 1000, use binomial coeff to get count
        int[] transitions = new int[1001];

        for (int i = 2; i < transitions.length; i++) {
            int bitCount = Integer.bitCount(i);
            transitions[i] = transitions[bitCount]+1;
        }

        // for each number t for 1-1000, how many numbers < N go to t in one move

        x = in.next().chars().map(xx -> xx-'0').toArray();
        K = in.nextInt();

        if (K == 0) {
            out.println(1);
            return;
        }

        if (x.length == 1) {
            out.println(0);
            return;
        }

        for (int i = 1; i < transitions.length; i++) {
            if (transitions[i] == K-1) {
                go(0, i);
                if (K == 1) ret = (ret - 1) % mod;
            }
        }

        out.println(ret);

    }

    long ret = 0;

    void go(int i, int set) {

        if (set == 0) {
            ret = (ret+1)%mod;
            return;
        }
        if (i == x.length) return;

        if (x[i] == 0) go(i+1, set);
        else {
            // if 1, try to put a zero here, and choose 1s from the suffix
            int remaining = x.length-1-i;
            ret = (ret + choose(remaining, set)) % mod;
            go(i+1, set-1);
        }

    }

    public static int mod = 1_000_000_007;
    static long[] f = new long[1001];
    static {
        f[0] = 1;
        for (int i = 1; i < f.length; i++) {
            f[i] = (f[i-1] * i) % mod;
        }
    }

    long choose(int n, int k) {
        if (k > n) return 0;
        long ret = f[n];
        ret = (ret * modinv(f[n-k])) % mod;
        ret = (ret * modinv(f[k])) % mod;
        return ret;
    }

    long modinv(long a) {
        long ret = 1;
        int pow = mod-2;
        while (pow > 0) {
            if ((pow&1) > 0) ret = (ret * a) % mod;
            a = (a*a)%mod;
            pow>>=1;
        }
        return ret;
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
            st = null;
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",3,0914_C,CODEFORCES,1832,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class C {

	public static int mod = 1000000000 + 7;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String n = br.readLine();
		int k = Integer.parseInt(br.readLine());
		int l = n.length();
		
		if(k == 0) {
			System.out.println(1);
		}else {
			int max = 1000;
			if (l <= 10) {
				max = Integer.min(1000, Integer.parseInt(n, 2));
			}

			int[] steps = new int[max + 1];
					
			for (int i = 2; i <= max; i++) {
				int ones = numberOfOnes(i);
				steps[i] = 1 + steps[ones];
			}

			if (l <= 10) {
				int ans = 0;
				for (int i = 1; i <= max; i++) {
					if (steps[i] == k) {
						ans++;
					}
				}
				System.out.println(ans);
			} else {
				int[][] C = binomial(max);

				int ans = 0;
				int count = 0;

				for (int i = 0; i < l; i++) {
					if (n.charAt(i) == '1') {
						for (int j = count; j < max; j++) {
							if (steps[j] == k - 1) {
								ans = (ans + C[l - i - 1][j - count]) % mod;
								if (i == 0 && k == 1) {
									ans = (ans + mod - 1) % mod;
								}
							}
						}
						count++;
					}
				}

				int ones = 0;
				for (int i = 0; i < l; i++) {
					if (n.charAt(i) == '1') {
						ones++;
					}
				}
				if (steps[ones] == k-1) {
					ans = (ans + 1) % mod;
				}
				
				System.out.println(ans);
			}
		}
	}

	public static int numberOfOnes(int x) {
		char[] s = Integer.toBinaryString(x).toCharArray();
		int count = 0;
		for (char c : s) {
			if (c == '1') {
				count++;
			}
		}
		return count;
	}

	public static int[][] binomial(int n) {
		int[][] C = new int[n + 1][n + 1];

		for (int i = 0; i <= n; i++) {
			C[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				C[i][j] = ((C[i - 1][j - 1] % mod) + (C[i - 1][j] % mod)) % mod;
			}
		}

		return C;
	}

}
",3,0914_C,CODEFORCES,1834,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"import java.io.*;
import java.util.*;

public class LectureSleep {

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public float nextFloat() {
            return Float.parseFloat(next());
        }

    }

    static InputReader r = new InputReader(System.in);
    static PrintWriter pw = new PrintWriter(System.out);


    public static void main(String[] args) {
        int n = r.nextInt(); // duration of lecture
        int k = r.nextInt(); // number of minutes keep mishka awake
        int[] theorems = new int[n+1];
        for(int i = 1; i <= n; i++){
            theorems[i] = r.nextInt();
        }
        int[] mishka = new int[n+1];
        for(int i = 1; i <= n; i++){
            mishka[i] = r.nextInt();
        }
        int[] sums = new int[n+1];
        for(int i = 1; i <= n; i++){
            if(mishka[i] == 0){
                sums[i] = sums[i-1] + theorems[i];
            } else{
                sums[i] = sums[i-1];
            }
        }
        int max = 0;
        for(int i = 1; i <= n-k+1; i++){
            int sum = sums[i+k-1] - sums[i-1];
            max = Math.max(max, sum);
        }
        int totalSum = 0;
        for(int i = 1; i <= n; i++){
            if(mishka[i] == 1){
                totalSum += theorems[i];
            }
        }

        pw.println(totalSum + max);

        pw.close();
    }
}",3,0961_B,CODEFORCES,1849,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.List;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
public class G {
 	private static FastScanner fs=new FastScanner();
	public static void main(String[] args) {
		
		

			int n = fs.nextInt(),k = fs.nextInt();
			int a[] = fs.readArray(n);
			int b[] = fs.readArray(n);

			// From 1 to n-k+1 we can use technique
			// we can use it for j minutes 
			// j is from i tp i+k -1;
			// 

			long max = Integer.MIN_VALUE;
			long sol =0;
			int pre[] = new int[n+1];
			int prev =0;

			if(b[0]==0)
			{ 
				pre[1] = a[0];
				
			}

			for(int i=1;i<n;i++)
			{
				if(b[i]==0)
				{
					pre[i+1] += a[i];
					pre[i+1] +=pre[i];
				}
				else pre[i+1] = pre[i];
			}

			for(int i=n-1;i>=0;i--)
			{
				long sum =0;
					if(i-k+1>=0)
					{
						// for(int j=i;j>=(i-k+1);j--)
						// {
						// if(b[j]==0) dp[i][1] += a[j];
						// }
						sum +=(pre[i+1]-pre[i-k+1]);	
					}
					else
					{
						// for(int j=i;j>=0;j--)
						// {
						// 	if(b[j]==0) dp[i][0] +=a[j];
						// }
						sum +=(pre[i+1]-pre[0]);
					}
					
					if(sum>max) 
					{
						max = sum;
						
					}
					if(b[i]==1) sol +=a[i];
				
			}
			// System.out.println(max);
			sol += max;
			System.out.println(sol);
		}
	
 
	static final Random random=new Random();
	
	static void ruffleSort(long[] a) {
		int n=a.length;//shuffle, then sort 
		for (int i=0; i<n; i++) {
			int oi=random.nextInt(n); long temp=a[oi];
			a[oi]=a[i]; a[i]=temp;
		}
		Arrays.sort(a);
	}

	
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		
		int nextInt() {
			return Integer.parseInt(next());
		}
		int[] readArray(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++) a[i]=nextInt();
			return a;
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		int [] sort(int [] arr)
		{
			List<Integer> list = new ArrayList<>();
			for(int i : arr) list.add(i);	
		
			Collections.sort(list);
			int res[] = new int[arr.length];
			for(int i=0;i<arr.length;i++) res[i] = list.get(i);
			

			return res;
		}
	}
 
	
}",3,0961_B,CODEFORCES,1847,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws Exception {
        int n = in.nextInt();
        int k = in.nextInt();

        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int[] t = new int[n];
        for (int i = 0; i < n; i++) {
            t[i] = in.nextInt();
        }

        int csa[] = new int[n];
        for (int i = 0; i < n; i++) {
            csa[i] = getCs(csa, i - 1) + a[i];
        }
        int cst[] = new int[n];
        for (int i = 0; i < n; i++) {
            cst[i] = getCs(cst, i - 1) + (a[i] * t[i]);
        }

        int max = Integer.MIN_VALUE;

        for (int i = 0; i < n - k + 1; i++) {
            int l = i;
            int r = l + k - 1;
            int profit = (getCs(csa, r) - getCs(csa, l - 1)) - (getCs(cst, r) - getCs(cst, l - 1));
            if (profit > max) {
                max = profit;
            }
        }
        int totalProfit = max;
        for (int i = 0; i < n; i++) {
            int ti = t[i];
            if (ti != 0) {
                totalProfit += a[i];
            }
        }
        System.out.println(totalProfit);
    }

    private static int getCs(int[] cs, int i) {
        if (i < 0) {
            return 0;
        }
        return cs[i];
    }


    private static class in {

        private static BufferedReader reader;
        private static StringTokenizer tokenizer;

        static {
            reader = new BufferedReader(
                    new InputStreamReader(System.in));
            tokenizer = new StringTokenizer("" "");
        }

        static void init(InputStream input) {
            reader = new BufferedReader(
                    new InputStreamReader(input));
            tokenizer = new StringTokenizer("" "");
        }

        static void prevLine(String line) {
            tokenizer = new StringTokenizer(line);
        }

        static String nextLine() throws IOException {
            return reader.readLine();
        }

        static String next() throws IOException {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(
                        reader.readLine());
            }
            return tokenizer.nextToken();
        }

        static boolean hasNext() {
            return tokenizer.hasMoreTokens();
        }

        static int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        static int nextShort() throws IOException {
            return Short.parseShort(next());
        }

        static double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        static long nextLong() throws IOException {
            return Long.parseLong(next());
        }


    }
}

",3,0961_B,CODEFORCES,1848,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers"
"import java.io.*;
import java.util.*;

public class cf {

	static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        pw.println(n/2+1);
        pw.close();
    }
}",1,0964_A,CODEFORCES,621,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class CodeForces
{
	public static void main(String[] args)
	{
		Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		System.out.println(input.nextInt() / 2 + 1);
	}
}",1,0964_A,CODEFORCES,618,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"
import java.io.PrintWriter;

import java.util.*;
import java.util.Arrays ; 
import java .lang.String.* ;
import java .lang.StringBuilder ;


public class Test{
    static int pos = 0 ; 
    static int  arr[] ; 
  static LinkedList l1 = new  LinkedList() ; 
static void find(int p ,char[]x,int put[],String s){
    int c= 0 ; 
    for (int i = 0; i < s.length(); i++) {
        if(x[p]==s.charAt(i)){
        c++ ; }
    }
    put[p] = c ;  
}
static int mode(int m ,int[]x ){
    int temp = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return m-temp ; 
             
        }
    }
     return m-temp ; 
}
static int mode2(int m ,int[]x ){
    int temp = 0 ; 
    
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return x[i] ; 
             
        }
    }
     return 0 ; 
}
static int find(int x[],int temp){
    int j = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]==temp) return j+1 ; 
        j++ ; 
    }
    return -1 ; 
}
static String ch(long[]x,long b){
    for (int i = 0; i < x.length; i++) {
        if(x[i]==b)return ""YES"" ;
    }
    return ""NO"" ; 
}

    public static void main(String[] args)  {

        Scanner in = new Scanner(System.in) ;
        PrintWriter pw = new PrintWriter(System.out);   
        long n = in.nextLong() ; 
        long count =1 ; 
        long temp =n/2;
     temp+=count ;
      
       
        System.out.println(temp);
 }               
}

",1,0964_A,CODEFORCES,620,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"    import java.io.*;
    import java.util.*;
    import java.math.*;
    import java.lang.*;
     
     //@Manan Parmar

    public class Solution2 implements Runnable {


        public void run() {
            
            InputReader sc = new InputReader(System.in);
            PrintWriter out = new PrintWriter(System.out);
            
            int n=sc.nextInt();
            out.println((n/2)+1);

            out.close();
        }
     

    //========================================================================
        void quickSort(int a[],int l,int r)
        {
            if(l<r)
            {
                int pindex=partition(a,l,r);
                quickSort(a,l,pindex-1);
                quickSort(a,pindex+1,r);
            }

        }
        int partition(int a[],int l,int r)
        {
            int pivot = a[r],pindex=l;
            for(int i=l;i<r;i++)
            {
                if(a[i]<pivot)
                {
                    int temp=a[i];
                    a[i]=a[pindex];
                    a[pindex]=temp;
                    pindex++;
                }
            }
            int temp1=a[r];
            a[r]=a[pindex];
            a[pindex]=temp1;
            return pindex;
        }
        int binarySearch(int arr[], int x) 
        { 
            int l = 0, r = arr.length - 1; 
            while (l <= r) { 
                int m = l + (r - l) / 2; 
      
                // Check if x is present at mid 
                if (arr[m] >= x)
                    if(m!=0&&arr[m-1]<x) 
                        return m;
                    else if(m==0)
                        return m; 
      
                // If x greater, ignore left half 
                if (arr[m] < x) 
                    l = m + 1; 
      
                // If x is smaller, ignore right half 
                else
                    r = m - 1; 
            } 
      
            // if we reach here, then element was 
            // not present 
            return -1; 
        } 
        boolean check(char a,char b)
        {
            if(a==b)
                return true;
            else
                return false;
        }
        long binarySearch(long arr[], long x) 
        { 
            int l = 0, r = arr.length - 1,q=0; 
            while (l<=r) { 
                int m = l + (r - l) / 2; 
                if (arr[l] >=x) 
                {
                    q=1;
                    return l; 
                }
                if (arr[m] < x) 
                    l=m+1; 
                else
                    r=m;
            } 
            return -1;
        }

        static class InputReader {
            private InputStream stream;
            private byte[] buf = new byte[1024];
            private int curChar;
            private int numChars;
            private SpaceCharFilter filter;
            private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     
            public InputReader(InputStream stream) {
                this.stream = stream;
            }
           
            public int read() {
                if (numChars==-1)
                    throw new InputMismatchException();
               
                if (curChar >= numChars) {
                    curChar = 0;
                    try {
                        numChars = stream.read(buf);
                    }
                    catch (IOException e) {
                        throw new InputMismatchException();
                    }
                   
                    if(numChars <= 0)              
                        return -1;
                }
                return buf[curChar++];
            }
         
            public String nextLine() {
                String str = """";
                try {
                    str = br.readLine();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
                return str;
            }
            public int nextInt() {
                int c = read();
               
                while(isSpaceChar(c))
                    c = read();
               
                int sgn = 1;
               
                if (c == '-') {
                    sgn = -1;
                    c = read();
                }
               
                int res = 0;
                do {
                    if(c<'0'||c>'9')
                        throw new InputMismatchException();
                    res *= 10;
                    res += c - '0';
                    c = read();
                }
                while (!isSpaceChar(c));
               
                return res * sgn;
            }
           
            public long nextLong() {
                int c = read();
                while (isSpaceChar(c))
                    c = read();
                int sgn = 1;
                if (c == '-') {
                    sgn = -1;
                    c = read();
                }
                long res = 0;
               
                do {
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res *= 10;
                    res += c - '0';
                    c = read();
                }
                while (!isSpaceChar(c));
                    return res * sgn;
            }
           
            public double nextDouble() {
                int c = read();
                while (isSpaceChar(c))
                    c = read();
                int sgn = 1;
                if (c == '-') {
                    sgn = -1;
                    c = read();
                }
                double res = 0;
                while (!isSpaceChar(c) && c != '.') {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res *= 10;
                    res += c - '0';
                    c = read();
                }
                if (c == '.') {
                    c = read();
                    double m = 1;
                    while (!isSpaceChar(c)) {
                        if (c == 'e' || c == 'E')
                            return res * Math.pow(10, nextInt());
                        if (c < '0' || c > '9')
                            throw new InputMismatchException();
                        m /= 10;
                        res += (c - '0') * m;
                        c = read();
                    }
                }
                return res * sgn;
            }
           
            public String readString() {
                int c = read();
                while (isSpaceChar(c))
                    c = read();
                StringBuilder res = new StringBuilder();
                do {
                    res.appendCodePoint(c);
                    c = read();
                }
                while (!isSpaceChar(c));
               
                return res.toString();
            }
         
            public boolean isSpaceChar(int c) {
                if (filter != null)
                    return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
            }
         
            public String next() {
                return readString();
            }
           
            public interface SpaceCharFilter {
                public boolean isSpaceChar(int ch);
            }
        }

        public static void main(String args[]) throws Exception {
            new Thread(null, new Solution2(),""Main"",1<<27).start();
        }
    }
",1,0964_A,CODEFORCES,617,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"import java.util.*;
import java.io.*;

public class programA {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		if(n%2 == 0)System.out.println(n/2 +1);
		else System.out.println((int)Math.ceil((double)n/2));
	}
}




",1,0964_A,CODEFORCES,619,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"import java.util.*;
import java.math.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

public class a{ 
     static int[] count,count1,count2;
     static Node[] nodes;
     static long[] arr;
     static int[] dp,arrInt,darrInt;
     static char[] ch,ch1;
     static long[] darr,farr;
     static char[][] mat,mat1;
     static int[][] space;
     static boolean[][] vis;
     static long x,h;
     static long maxl;
     static double dec;
     static long mx = (long)1e10;
     static String s,s1,s2,s3,s4;
     static long minl;
     static int start_row;
     static int start_col;     
     static int end_row;     
     static int end_col;     
     static long mod = 998244353;
     // static int minl = -1;
     // static long n;
     static int n,n1,n2,q,r1,c1,r2,c2;
     static long a;
     static long b;
     static long c;
     static long d;
     static long y,z;
     static int m;
     static long k;
     static FastScanner sc;
     static String[] str,str1;
     static Set<Long> set,set1,set2;
     static SortedSet<Long> ss;
     static List<Long> list,list1,list2,list3;
     static PriorityQueue<Integer> pq,pq1;
     static LinkedList<Node> ll;
     static Map<Integer,List<Integer>> map1;
     static Map<Long,Integer> map;
     static StringBuilder sb,sb1,sb2;
     static int index;
     static long[] sum;
     static int[] dx = {0,-1,0,1,-1,1,-1,1};
     static int[] dy = {-1,0,1,0,-1,-1,1,1};

     // public static void solve(){

     //    FastScanner sc = new FastScanner();
     //    // int t = sc.nextInt();
     //    int t = 1;
     //    for(int tt = 0 ; tt < t ; tt++){

     //        // s = sc.next();
     //        // s1 = sc.next();

     //        n = sc.nextInt();
     //        // m = sc.nextInt();
     //        sb = new StringBuilder();
     //        // map = new HashMap<>();
     //        // q = sc.nextInt();
     //        // k = sc.nextLong();
     //        // ch = sc.next().toCharArray();
     //        // boolean ans = false;
     //        // int charge = n;
     //        // int prev = 0;

     //        count = new int[7];
           
     //        // m = sc.nextInt();
     //        // long ans = 0;
     //        // long added = 0;
     //        for(int j = 0 ; j < n ; j++){


     //        }

     //    }
        
     // }

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

     public static void solve(){

        System.out.println(a/2+1);

     }
        
     public static void main(String[] args) {

            sc = new FastScanner();
            // Scanner sc = new Scanner(System.in);
            // int t = sc.nextInt();
            int t = 1;
            // int l = 1;
            while(t > 0){
                
                // n = sc.nextInt();
                // n = sc.nextLong();
                // k = sc.nextLong();
                // x = sc.nextLong();
                // y = sc.nextLong();
                // z = sc.nextLong();

                a = sc.nextLong();
                // b = sc.nextLong();
                // c = sc.nextLong();
                // d = sc.nextLong();

                // x = sc.nextLong();
                // y = sc.nextLong();
                // z = sc.nextLong();
                // d = sc.nextLong();
                // n = sc.nextLong();

                // n = sc.nextInt();

                // n = 3;
                // n1 = sc.nextInt();

                // m = sc.nextInt();
                // q = sc.nextInt();

                // k = sc.nextLong();
                // d = sc.nextLong();
                // s = sc.next();

                // ch = sc.next().toCharArray();
                // ch1 = sc.next().toCharArray();

                // n = 3;
                // arr = new long[n];
                // for(int i = 0 ; i < n ; i++){
                //     arr[i] = sc.nextLong();
                // }

                // arrInt = new int[n];
                // for(int i = 0 ; i < n ; i++){
                //     arrInt[i] = sc.nextInt();
                // }
                // x = sc.nextLong();
                // y = sc.nextLong();
                // ch = sc.next().toCharArray();
                // m = n;
                // darr = new long[m];
                // for(int i = 0 ; i < m ; i++){
                //     darr[i] = sc.nextLong();
                // }

                // m = n;
                // darrInt = new int[m];
                // for(int i = 0 ; i < m ; i++){
                //     darrInt[i] = sc.nextInt();
                // }

                // farr = new int[n];
                // for(int i = 0; i < n ; i++){
                //     farr[i] = sc.nextInt();
                // }

                // mat = new long[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = sc.nextLong();
                //     }
                // }

                // m = n;
                // mat = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = s.charAt(j);
                //     }
                // }

                // m = n;
                // mat1 = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat1[i][j] = s.charAt(j);
                //     }
                // }

                // n= 5 ;
                // str = new String[n];
                // for(int i = 0 ; i < n ; i++)
                //     str[i] = sc.next();

                // nodes = new Node[n];
                // for(int i = 0 ; i < n ;i++)
                //     nodes[i] = new Node(sc.nextInt(),(i+1));

                // m = sc.nextInt();

                // System.out.println(solve()?""YES"":""NO"");
                 solve();       
                 // System.out.println(solve());
                 t -= 1;
            }

     }

     // public static dfs(int i){

     //    if(count[i] == 1)
     //        return;
     //    list = map.get(i);
     //    for(Integer j : list){
     //        if(j == i)
     //            continue;
     //        dfs(j);
     //    }
     // }

    public static int log(long n,long base){

         if(n == 0 || n == 1)
             return 0;

         if(n == base)
             return 1;

         double num = Math.log(n);
         double den = Math.log(base);

         if(den == 0)
             return 0;

         return (int)(num/den);
     }

    public static boolean isPrime(long n) { 
    // Corner cases 
        if (n <= 1)  
            return false; 

        if (n <= 3)  
            return true; 
      
        // This is checked so that we can skip  
        // middle five numbers in below loop 
        if (n%2 == 0 || n%3 == 0) 
            return false; 
      
        for (int i=5; i*i<=n; i=i+6) 
            if (n%i == 0 || n%(i+2) == 0) 
               return false; 
      
        return true; 
    } 

    public static long gcd(long a, long b)
    {
      if (b == 0)
        return a;
      return gcd(b, a % b); 
    }

     public static long mod_inverse(long a,long mod){
        long x1=1,x2=0;
        long p=mod,q,t;
        while(a%p!=0){
          q = a/p;
          t = x1-q*x2;
          x1=x2; x2=t;
          t=a%p;
          a=p; p=t;
        }
        return x2<0 ? x2+mod : x2;
    }

     public static void swap(int i,int j){
         long temp = arr[j];
         arr[j] = arr[i];
         arr[i] = temp;
     } 

    static final Random random=new Random();

    static void ruffleSortLong(long[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            long temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static void ruffleSortInt(int[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            int temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }
    
    static void ruffleSortChar(char[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            char temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class Node{
        Integer first;
        Integer second;
        Node(Integer f,Integer s){
            this.first = f;
            this.second = s;
        }
    }

     static class FastScanner {

                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st=new StringTokenizer("""");
                String next() {
                        while (!st.hasMoreTokens())
                                try {
                                        st=new StringTokenizer(br.readLine());
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        return st.nextToken();
                }
                
                int nextInt() {
                        return Integer.parseInt(next());
                }
                int[] readArray(int n) {
                        int[] a=new int[n];
                        for (int i=0; i<n; i++) a[i]=nextInt();
                        return a;
                }
                long nextLong() {
                        return Long.parseLong(next());
                }
        }

}",1,0964_A,CODEFORCES,616,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import static java.lang.Math.*;

public class Main {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }


    private void solve() {
        int n = scanner.nextInt();

        Map<Integer, Integer> cnt = new HashMap<>();

        for (int i = 0; i < n; i++) {
            String s = scanner.nextLine();

            LinkedList<Character> st = new LinkedList<>();

            for (char c : s.toCharArray()) {
                if (c == ')' && !st.isEmpty() && st.getLast() == '(') {
                    st.pollLast();
                    continue;
                }
                st.addLast(c);
            }

            int t = st.size();
            Set<Character> set = new HashSet<>(st);
            if (set.size() > 1) {
                continue;
            }
            if (set.isEmpty()) {
                cnt.put(0, cnt.getOrDefault(0, 0) + 1);
                continue;
            }

            if (st.getLast() == '(') {
                cnt.put(t, cnt.getOrDefault(t, 0) + 1);
            } else {
                cnt.put(-t, cnt.getOrDefault(-t, 0) + 1);
            }
        }

        long ans = 0;

        for (int next : cnt.keySet()) {
            if (next == 0) {
                ans += (long) cnt.get(next) * (cnt.get(next) - 1) + cnt.get(next);
            } else if (next > 0) {
                int t = next * -1;
                if (cnt.containsKey(t)) {
                    ans += (long) cnt.get(next) * cnt.get(t);
                }
            }
        }

        System.out.print(ans);

    }

    class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        Integer[] nextA(int n) {
            Integer a[] = new Integer[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            return a;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",3,0990_C,CODEFORCES,1885,Bracket Sequences Concatenation Problem,"A bracket sequence is a string containing only characters ""("" and "")"".
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.
You are given $$$n$$$ bracket sequences $$$s_1, s_2, \dots , s_n$$$. Calculate the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence. Operation $$$+$$$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".
If $$$s_i + s_j$$$ and $$$s_j + s_i$$$ are regular bracket sequences and $$$i \ne j$$$, then both pairs $$$(i, j)$$$ and $$$(j, i)$$$ must be counted in the answer. Also, if $$$s_i + s_i$$$ is a regular bracket sequence, the pair $$$(i, i)$$$ must be counted in the answer.
The first line contains one integer $$$n \, (1 \le n \le 3 \cdot 10^5)$$$ — the number of bracket sequences. The following $$$n$$$ lines contain bracket sequences — non-empty strings consisting only of characters ""("" and "")"". The sum of lengths of all bracket sequences does not exceed $$$3 \cdot 10^5$$$.
In the single line print a single integer — the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence.
","input
In the first example, suitable pairs are $$$(3, 1)$$$ and $$$(2, 2)$$$.
output
In the second example, any pair is suitable, namely $$$(1, 1), (1, 2), (2, 1), (2, 2)$$$.
",implementation
"//      これを翻訳している間、あなたはあなたの人生のいくつかの貴重な瞬間を無駄にしました


import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Solution {
    static PrintWriter fop = new PrintWriter(System.out);

    static int counter(String s){
        int cnt = 0 ;
        for (int i = 0; i <s.length() ; i++) {
            if (s.charAt(i) == '(')cnt++ ;
            else  cnt-- ;
            if (cnt < 0)return -1 ;
        }
        return cnt ;

    }

    static int counter2(String s){
        int cnt = 0 ;
     for(int i = s.length()-1 ; i>=0 ; i--){
         if (s.charAt(i) == ')')cnt++ ;
         else cnt-- ;
         if (cnt < 0)return -1 ;
     }
     return cnt ;

    }






    public static void main(String[] args) {

        FastScanner fsca = new FastScanner();
        int n = fsca.nextInt() ;
        String a[] = new String[n] ;
        for (int i = 0; i <n ; i++) {
            a[i] = fsca.next() ;
        }

        int dp[] = new int[400009] ;
        for (int i = 0; i <n ; i++) {
           int tt = counter(a[i]) ;
           if (tt != -1)
               dp[tt]++ ;
        }
        long cnt = 0 ;
        for (int i = 0; i <n ; i++) {
            int tt = counter2(a[i]) ;
            if (tt != -1){
                cnt += dp[tt] ;
            }
        }
        System.out.println(cnt);











        fop.flush();
        fop.close();


    }
    /*-----------------------------------------------------------------------------------------------------------------------------------------------*/


    static long gcd(long a, long b) {
        return (b == 0) ? a : gcd(b, a % b);
    }

    static int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }


    static final Random random = new Random();

    static void ruffleSort(int[] a) {
        int n = a.length;//shuffle, then sort
        for (int i = 0; i < n; i++) {
            int oi = random.nextInt(n), temp = a[oi];
            a[oi] = a[i];
            a[i] = temp;
        }
        Arrays.sort(a);
    }

    static void ruffleSort(long[] a) {
        int n = a.length;//shuffle, then sort
        for (int i = 0; i < n; i++) {
            int oi = random.nextInt(n);
            long temp = a[oi];
            a[oi] = a[i];
            a[i] = temp;
        }
        Arrays.sort(a);
    }


    static class FastScanner {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer("""");

        String next() {
            while (!st.hasMoreTokens())
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[][] readMat(int n, int m) {
            int a[][] = new int[n][m];
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    a[i][j] = nextInt();
            return a;
        }

        char[][] readCharMat(int n, int m) {
            char a[][] = new char[n][m];
            for (int i = 0; i < n; i++) {
                String s = next();
                for (int j = 0; j < m; j++)
                    a[i][j] = s.charAt(j);
            }
            return a;
        }


        int[] readArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = nextInt();
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }

    static void print(int a[], int n) {
        for (int i = 0; i < n; i++)
            fop.append((a[i]) + "" "");
        // fop.append(""\n"") ;
    }

    static void print(long a[], int n) {
        for (int i = 0; i < n; i++)
            fop.append((a[i]) + "" "");
        // fop.append(""\n"") ;
    }
}
        ",3,0990_C,CODEFORCES,1884,Bracket Sequences Concatenation Problem,"A bracket sequence is a string containing only characters ""("" and "")"".
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.
You are given $$$n$$$ bracket sequences $$$s_1, s_2, \dots , s_n$$$. Calculate the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence. Operation $$$+$$$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".
If $$$s_i + s_j$$$ and $$$s_j + s_i$$$ are regular bracket sequences and $$$i \ne j$$$, then both pairs $$$(i, j)$$$ and $$$(j, i)$$$ must be counted in the answer. Also, if $$$s_i + s_i$$$ is a regular bracket sequence, the pair $$$(i, i)$$$ must be counted in the answer.
The first line contains one integer $$$n \, (1 \le n \le 3 \cdot 10^5)$$$ — the number of bracket sequences. The following $$$n$$$ lines contain bracket sequences — non-empty strings consisting only of characters ""("" and "")"". The sum of lengths of all bracket sequences does not exceed $$$3 \cdot 10^5$$$.
In the single line print a single integer — the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence.
","input
In the first example, suitable pairs are $$$(3, 1)$$$ and $$$(2, 2)$$$.
output
In the second example, any pair is suitable, namely $$$(1, 1), (1, 2), (2, 1), (2, 2)$$$.
",implementation
"// @jagrit_07
import java.util.*;
import java.math.*;
import java.io.*;
import java.lang.*;

public class Main {
    
	public static void main(String[] args) {
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        HashMap<Integer,Integer> hm = new HashMap<>();
        //There is useless pair ))(( like this;
        //There is one use pair  ))  like this;
        // and this ((;  )(()
        String s[] = new String[n];
        for(int i =0;i<n;i++)
        {
            s[i] = sc.next();
        }
        for(int i =0;i<n;i++)
        {
            char ch[] = s[i].toCharArray();
            int open=0;
            int uo=0;
            int uc=0;
            int min=0;
            for(int j=0;j<ch.length;j++)
            {
                if(ch[j]==')')
                {
                    open--;
                }
                else
                {
                    open++;
                }
                if(open<min)
                {
                    uc++;
                    min=Math.min(open,min);
                }
                
            }
            open=0;
            min=0;
            for(int j=ch.length-1;j>=0;j--)
            {
                if(ch[j]==')')
                {
                    open++;
                }
                else
                {
                    open--;
                }
                if(open<min)
                {
                    uo++;
                    min=Math.min(open,min);
                }
            }
            //System.out.println(uo+)
            if(uo>0 && uc>0)
            {
                //this is a uselss pair;
            }
            else if(uo==0 && uc==0)
            {
                hm.put(0,hm.getOrDefault(0,0)+1);
            }
            else if(uo>0)
            {
                hm.put(uo,hm.getOrDefault(uo,0)+1);
            }
            else if(uc>0)
            {
                hm.put(-uc,hm.getOrDefault(-uc,0)+1);
            }
        }
        long count = 0;
        for(int i =0;i<n;i++)
        {
            
            char ch[] = s[i].toCharArray();
            int open=0;
            int uo=0;
            int uc=0;
            int min=0;
            for(int j=0;j<ch.length;j++)
            {
                if(ch[j]==')')
                {
                    open--;
                }
                else
                {
                    open++;
                }
                if(open<min)
                {
                    uc++;
                    min=Math.min(open,min);
                }
                
            }
            open=0;
            min=0;
            for(int j=ch.length-1;j>=0;j--)
            {
                if(ch[j]==')')
                {
                    open++;
                }
                else
                {
                    open--;
                }
                if(open<min)
                {
                    uo++;
                    min=Math.min(open,min);
                }
            }
            if(uo>0 && uc>0)
            {
                //this is a uselss pair;
            }
            else if(uo==0 && uc==0)
            {
                count = count + hm.get(uo);
            }
            else if(uo>0)
            {
                if(hm.containsKey(-uo))
                {
                    count = count + hm.get(-uo);
                }
            }
            
        }
        System.out.println(count);
        
    }


    public static int bs(int num[], long x)
    {
        int low=0;
        int high=num.length-1;
        int ans=-1;
        while(low<=high)
        {
            int mid = low + (high-low)/2;
            if(num[mid]==x)
            {
                ans = mid;
                //break;
                low = mid+1;
            }
            else if(num[mid]<x)
            {
               // ans=mid;
                ans = mid;
                low=mid+1;
            }
            else
            {
                //ans=mid;
                high=mid-1;
            }
        }
        return ans;
    }
    
    
    
    
    
    
    
    
    
    public static List<Integer> solve(char ch[], int split)
    {
        long sum = 0;
        List<Integer> l1 = new ArrayList<>();
        for(int i=0;i<split && i<ch.length;i++)
        {
            l1.add(ch[i]-'0');
        }
        List<Integer> l2 = new ArrayList<>();
        for(int i=split;i<ch.length;i++)
        {
            l2.add(ch[i]-'0');
        }
        //System.out.println(Arrays.toString(l1.toArray()));
        //System.out.println(Arrays.toString(l2.toArray()));
        int carry = 0;
        int i = l1.size()-1;
        int j = l2.size()-1;
        List<Integer> list = new ArrayList<>();
        while(i>=0 || j>=0)
        {
            int e1 = (i>=0) ? l1.get(i) : 0;
            int e2 = (j>=0) ? l2.get(j) : 0;
            i--;
            j--;
            int e3 = e1 + e2 + carry;
            if(e3>9)
            {
                list.add(e3%10);
                carry = 1;
            }
            else
            {
                list.add(e3);
                carry = 0;
            }
        }
        if(carry>0)
        {
            list.add(1);
        }
       // System.out.println(Arrays.toString(l2.toArray()));
        Collections.reverse(list);
        return list;
    }
    
    //Comparing two list;
    public static List<Integer> comp(List<Integer> l1, List<Integer> l2)
    {
        if(l1.size()<l2.size()) return l1;
        if(l2.size()<l1.size()) return l2;
        
        for(int i=0;i<l1.size();i++)
        {
            if(l1.get(i)<l2.get(i))
            {
                return l1;
            }
            else if(l2.get(i)<l1.get(i))
            {
                return l2;
            }
        }
        return l2;
    }
   
    
   
    
 
    /* to find (x^y)%p in O(log y) */
    static long power(long x, long y, int p) 
    { 
        // Initialize result 
        long ans = 1;      
         
        // Update x if it is more   
        // than or equal to p 
        x = x % p;  
  
       if (x == 0) return 0; // In case x is divisible by p;    
  
        while (y > 0) 
        { 
            if((y & 1)==1) 
            {
                 ans = ((long)(ans * x))% p;    
            }
            y = y >> 1;  //y/2; 
            x = ((long)(x * x) )% p;  
        } 
        return ans; 
    } 
    
    
    
    
    
    public static void printList(List<Integer> list)
    {
        StringBuffer bf = new StringBuffer("""");
        for(int i: list) bf.append(i+"" "");
        System.out.println(bf.toString());
    }
    
    
    
    
    
    public static int sum(int a[])
    {
        int sum=0;
        for(int i: a) sum=sum+i;
        return sum;
    }
    
  
    public static int getMax(int a[])
    {
        int m=Integer.MIN_VALUE;
        for(int i: a) m=Math.max(i,m);
        return m;
    }
    
    static class Pair
    {
        int x;
        int y;

        //int i;
        public Pair(int x, int  y)
        {
            this.x=x;
            this.y=y;
        }
    }
    static class Comp implements Comparator<Pair>
    {
        public int compare(Pair p1, Pair p2)
        {
            return  p1.x-p2.x;
        }
    }
    
    
    
    public static int partition(int arr[], int low, int high) 
    { 
        int pivot = arr[high];  
        int i = (low-1);
        for (int j=low; j<high; j++) 
        { 
            if (arr[j] < pivot) 
            { 
                i++; 
                int temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
            } 
        } 
        int temp = arr[i+1]; 
        arr[i+1] = arr[high]; 
        arr[high] = temp; 
  
        return i+1; 
    } 
    public static void sort(int arr[], int low, int high) 
    { 
        if (low < high) 
        { 
            int pi = partition(arr, low, high); 
            sort(arr, low, pi-1); 
            sort(arr, pi+1, high); 
        } 
    } 
    
    
    
    
    
    
    static long gcd(long a,long b)
    {
        if(b==0) return a;
        return gcd(b,a%b);
    }
    
    
    static void sort(int[] a) {
		ArrayList<Integer> l=new ArrayList<>();
		for (int i:a) l.add(i);
		Collections.sort(l);
		for (int i=0; i<a.length; i++) a[i]=l.get(i);
	}
    static void sort(long[] a) {
		ArrayList<Long> l=new ArrayList<>();
		for (long i:a) l.add(i);
		Collections.sort(l);
		for (int i=0; i<a.length; i++) a[i]=l.get(i);
	}
    
	static class FastReader {
		BufferedReader br;
		StringTokenizer st;
 
		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
 
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (final IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (final IOException e) {
				e.printStackTrace();
			}
			return str;
		}

		int[] nextIntArray(final int n) {
			final int a[] = new int[n];
			for (int i = 0; i < n; i++) {
				a[i] = Integer.parseInt(next());
			}
			return a;
		}

	}	
}
//private ArrayList<String[]> action = new ArrayList<String[]>();


//Templates for Comparator and Classes - @jagrit_07
/*
Arrays.sort(newEmployees, new Comparator<Employee>() {
    @Override
    public int compare(Employee emp1, Employee emp2) {
        return emp1.getName().compareTo(emp2.getName());
    }
});
class Pair
	{
		
		long i; //index;
		long l; //left;
		long c; //cost;
		public Pair(long x,long y,long z)
		{
			this.i=x;
			this.l=y;
			this.c=z;
		}
		public String toString()
		{
			return this.i+"" ""+this.l+"" ""+this.c;
		}
	}
class Comp implements Comparator<Pair>
	{
		public int compare(Pair p1, Pair p2)
		{
			if(p1.c!=p2.c)
			{
				return (int)(p1.c-p2.c); //sort acc to cost;
			}
			else{
				return (int)(p1.i-p2.i); //sort acc to index;
			}
			
		}
	}
*/

/*
System.out.println( 
      String.format(""%.5f"", b)); 
  HashMap - Put template - d.put(a1,d.getOrDefault(a1,0)+1);
  for (Map.Entry<String, Integer> entry : map.entrySet()) {
        System.out.println(entry.getKey() + "":"" + entry.getValue());
    }
  Deque<String> deque 
            = new LinkedList<String>();  
            
  List<Integer> c[] = new ArrayList[3];          
*/",3,0990_C,CODEFORCES,1883,Bracket Sequences Concatenation Problem,"A bracket sequence is a string containing only characters ""("" and "")"".
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.
You are given $$$n$$$ bracket sequences $$$s_1, s_2, \dots , s_n$$$. Calculate the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence. Operation $$$+$$$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".
If $$$s_i + s_j$$$ and $$$s_j + s_i$$$ are regular bracket sequences and $$$i \ne j$$$, then both pairs $$$(i, j)$$$ and $$$(j, i)$$$ must be counted in the answer. Also, if $$$s_i + s_i$$$ is a regular bracket sequence, the pair $$$(i, i)$$$ must be counted in the answer.
The first line contains one integer $$$n \, (1 \le n \le 3 \cdot 10^5)$$$ — the number of bracket sequences. The following $$$n$$$ lines contain bracket sequences — non-empty strings consisting only of characters ""("" and "")"". The sum of lengths of all bracket sequences does not exceed $$$3 \cdot 10^5$$$.
In the single line print a single integer — the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence.
","input
In the first example, suitable pairs are $$$(3, 1)$$$ and $$$(2, 2)$$$.
output
In the second example, any pair is suitable, namely $$$(1, 1), (1, 2), (2, 1), (2, 2)$$$.
",implementation
"import java.util.*;
import java.math.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

public class a{ 
     static int[] count,count1,count2;
     static Node[] nodes;
     static long[] arr;
     static int[] dp;
     static char[] ch,ch1;
     static long[] darr,farr;
     static char[][] mat,mat1;
     static boolean[][] vis;
     static long x,h;
     static long maxl;
     static double dec;
     static long mx = (long)1e9;
     static String s;
     static long minl;
     static int start_row;
     static int start_col;     
     static int end_row;     
     static int end_col;     
     static long mod = 998244353;
     // static int minl = -1;
     // static long n;
     static int n,n1,n2,q,r1,c1,r2,c2;
     static long a;
     static long b;
     static long c;
     static long d;
     static long y,z;
     static int m;
     static long k;
     static FastScanner sc;
     static String[] str,str1;
     static Set<Long> set,set1,set2;
     static SortedSet<Long> ss;
     static List<Long> list,list1,list2,list3;
     static PriorityQueue<Integer> pq,pq1;
     static LinkedList<Node> ll;
     static Map<Integer,Long> map;
     static Map<Integer,Integer> map1;
     static StringBuilder sb,sb1,sb2;
     static int index;
     static long ans;
     static int[] dx = {0,-1,0,1,-1,1,-1,1};
     static int[] dy = {-1,0,1,0,-1,-1,1,1};

     // public static void solve(){

     //    FastScanner sc = new FastScanner();
     //    // int t = sc.nextInt();
     //    int t = 1;
     //    for(int tt = 0 ; tt < t ; tt++){
     //        int n = sc.nextInt();
     //        // int m = sc.nextInt();
     //        // int prev = 0;
     //        int l = 0;
     //        int r = 0;
     //        sb = new StringBuilder();
     //        for(int i = 0 ; i < n ; i++){
     //            l = sc.nextInt();
     //            r = sc.nextInt();
     //            double ans = ((r*1.0)+1)/2;
     //            if((l*1.0) >= ans && ((r*1.0) >= ans))
     //                sb.append(""YES\n"");
     //            else
     //                sb.append(""NO\n"");
     //        }

     //        System.out.print(sb);
     //    }
        
        
     // }

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

     public static void solve(){

        Arrays.sort(nodes,new Comparator<Node>(){
            public int compare(Node a,Node b){
                return a.first - b.first;
            }
        });

        pq = new PriorityQueue<>();
        sb = new StringBuilder();

        long sum = 0;
        int k = m;
        map = new HashMap<>();
        for(int i = 0 ; i < n ; i++){
            sum += nodes[i].second;
            if(i <= k){
                // sb.append(sum+"" "");
            }
            else{
                if(!pq.isEmpty()){
                    Integer top = pq.poll();
                    sum -= top;
                }
                // sb.append(sum+"" "");
            }
            pq.offer(nodes[i].second);
            map.put(nodes[i].first,sum);
        }

        for(int i = 0 ; i < n ; i++){
            sb.append(map.get((int)arr[i])+"" "");
        }
        System.out.println(sb);

     }

     public static void main(String[] args) {

            sc = new FastScanner();
            // Scanner sc = new Scanner(System.in);
            // int t = sc.nextInt();
            int t = 1;
            // int l = 1;
            while(t > 0){
                
                // n = sc.nextInt();
                // n = sc.nextLong();
                // a = sc.nextLong();
                // b = sc.nextLong();
                // c = sc.nextLong();
                // d = sc.nextLong();

                // x = sc.nextLong();
                // y = sc.nextLong();
                
                // n = sc.nextLong();
                n = sc.nextInt();
                // n1 = sc.nextInt();

                m = sc.nextInt();
                // q = sc.nextInt();

                // k = sc.nextLong();
                // s = sc.next();

                // ch = sc.next().toCharArray();
                // ch1 = sc.next().toCharArray();

                arr = new long[n];
                for(int i = 0 ; i < n ; i++){
                    arr[i] = sc.nextLong();
                }
                // x = sc.nextLong();
                // y = sc.nextLong();
                // ch = sc.next().toCharArray();
                // m = n;
                darr = new long[n];
                for(int i = 0 ; i < n ; i++){
                    darr[i] = sc.nextLong();
                }

                // farr = new int[n];
                // for(int i = 0; i < n ; i++){
                //     farr[i] = sc.nextInt();
                // }

                // mat = new int[n][n];
                // for(int i = 0 ; i < n ; i++){
                //     for(int j = 0 ;  j < n ; j++){
                //         mat[i][j] = sc.nextInt();
                //     }
                // }

                // m = n;
                // mat = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = s.charAt(j);
                //     }
                // }

                // str = new String[n];
                // for(int i = 0 ; i < n ; i++)
                //     str[i] = sc.next();

                nodes = new Node[n];
                for(int i = 0 ; i < n ;i++)
                    nodes[i] = new Node((int)arr[i],(int)darr[i]);

                // System.out.println(solve()?""YES"":""NO"");
                 solve();       
                 // System.out.println(solve());
                 t -= 1;
            }

     }

    public static int log(long n,long base){

         if(n == 0 || n == 1)
             return 0;

         if(n == base)
             return 1;

         double num = Math.log(n);
         double den = Math.log(base);

         if(den == 0)
             return 0;

         return (int)(num/den);
     }

    public static boolean isPrime(long n) { 
    // Corner cases 
        if (n <= 1)  
            return false; 

        if (n <= 3)  
            return true; 
      
        // This is checked so that we can skip  
        // middle five numbers in below loop 
        if (n%2 == 0 || n%3 == 0) 
            return false; 
      
        for (int i=5; i*i<=n; i=i+6) 
            if (n%i == 0 || n%(i+2) == 0) 
               return false; 
      
        return true; 
    } 

     public static long gcd(long a,long b){

        if(b%a == 0){
            return a;
        }
        return gcd(b%a,a);

     }

     public static void swap(int i,int j){
         char temp = ch[j];
         ch[j] = ch[i];
         ch[i] = temp;
     } 

    static final Random random=new Random();
    
    static void ruffleSort(long[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            long temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class Node{
        Integer first;
        Integer second;
        Node(Integer f,Integer s){
            this.first = f;
            this.second = s;
        }
    }

     static class FastScanner {

                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st=new StringTokenizer("""");
                String next() {
                        while (!st.hasMoreTokens())
                                try {
                                        st=new StringTokenizer(br.readLine());
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        return st.nextToken();
                }
                
                int nextInt() {
                        return Integer.parseInt(next());
                }
                int[] readArray(int n) {
                        int[] a=new int[n];
                        for (int i=0; i<n; i++) a[i]=nextInt();
                        return a;
                }
                long nextLong() {
                        return Long.parseLong(next());
                }
        }

}",4,0994_B,CODEFORCES,2837,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
import java.util.Map.*;
public class codeforces {
     static int count =0;
     static boolean f=false;
     static int [] arr;
	static 	PrintWriter pw=new PrintWriter(System.out);
	static void solve(int index , int mask) {
		if(index==arr.length) {
			int sum1=0; int sum2=0;
			for(int i=0;i<arr.length;i++) {
				if((mask & 1<<i)!=0) sum1+=arr[i];
				
			}
			return;
		}
		solve(index+1, mask | 1<<index);
		solve(index+1, mask);
	}
	public static void main(String [] args) throws IOException, InterruptedException {
		Scanner sc=new Scanner(System.in);
		int x=sc.nextInt();
		int y=sc.nextInt();
		pair [] arr=new pair[x];
		for(int i=0;i<x;i++) arr[i]=new pair(i, sc.nextInt(),0);
		for(int i=0;i<x;i++) arr[i].y=sc.nextInt();
		Arrays.sort(arr);
		PriorityQueue<Integer> qq=new PriorityQueue<>();
		//pw.println(Arrays.toString(arr));
		Long [] list=new Long [x];
		long sum=0; 
		for(int i=0;i<x;i++) {
			pair w=arr[i];
			if(qq.size()<y) {
				qq.add(w.y);
				sum+=w.y;
				list[w.i]=sum;

			}else if(!qq.isEmpty()) {
				sum+=w.y;
				list[w.i]=sum;
				int first=qq.poll();
				if(w.y>first) {
					sum-=first;
					qq.add(w.y);
				}else {
					qq.add(first);
					sum-=w.y;
				}
			} else list[w.i]=(long) w.y;
			//pw.println(qq);
		}
		for(Long w:list) pw.print(w+"" ""); 
		pw.flush();
		pw.close();
	}
	
	
	static class pair implements Comparable<pair>{
		String  name; int x,y,i ;
		public pair(String name , int x) {
			this.name=name; this.x=x;
		}
		
		public pair (int i,int x,int y) {
			this.i=i; this.x=x; this.y=y; 
		}
		public int compareTo(pair o) {
			return x-o.x;
		}
		public int compareTo1(pair o) {
			if(!name.equals(o.name))
				return name.compareTo(o.name);
			return x-o.x;
		}
		public String toString() {
			return i+"" ""+x+"" ""+y;
		}
	}

   static class Scanner {
		StringTokenizer st;
		BufferedReader br;
 
		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
	}",4,0994_B,CODEFORCES,2839,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"//    A Computer is Like a mischievous genie.
//    It will give you exactly what you ask for,
//    but not always what you want
//    A code by Rahul Verma


import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;


public class Main {


    static class Clock {

        protected long start, stop;

        public void start() {
            start = System.currentTimeMillis();
        }

        public void stop() {
            stop = System.currentTimeMillis();
        }

        public String getTime() {
            return ((stop - start) + "" ms"");
        }
    }


    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String[] nextSArray() {
            String sr[] = null;
            try {
                sr = br.readLine().trim().split("" "");
            } catch (IOException e) {
                e.printStackTrace();
            }
            return sr;
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return str;
        }
    }


    static long powmodulo(long a, long p) {
        if (p == 0) {
            return 1 % mod;
        }
        if (p == 1) {
            return a % mod;
        }
        long ans = 1;
        while (p > 0) {
            if ((p & 1) > 0) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            p = p >> 1;
        }
        return ans % mod;
    }


    static long mod = 1000000007;

    static long gcd(long a, long b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    static long fast_powerNumbers(long a, long n) {
        if (n == 1) {
            return a;
        }
        long ans = fast_powerNumbers(a, n / 2);
        if (n % 2 == 0) {
            return (ans * ans);
        } else {
            return ((ans * ans) * (a));
        }
    }


    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {
        arr[i][j] = team;
        if (i - 1 >= 0 && arr[i - 1][j] == 1) {
            dfs(arr, i - 1, j, team, n, m);
        }
        if (j - 1 >= 0 && arr[i][j - 1] == 1) {
            dfs(arr, i, j - 1, team, n, m);
        }
        if (i + 1 < n && arr[i + 1][j] == 1) {
            dfs(arr, i + 1, j, team, n, m);
        }
        if (j + 1 < m && arr[i][j + 1] == 1) {
            dfs(arr, i, j + 1, team, n, m);
        }

    }

    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {
        dfs_helper(arr, i, j, team, n, m);

    }


    static int arr[];

    static void seive(int n) {
        arr = new int[n + 1];
        arr[0] = arr[1] = 1;
        for (int i = 4; i <= n; i = i + 2) {
            arr[i] = 1;
        }
        for (int i = 3; i * i <= n; i = i + 2) {
            if (arr[i] == 0) {
                for (int j = i * i; j <= n; j = j + i) {
                    arr[j] = 1;
                }

            }
        }


    }


    static int xx, yy;
    static int vis[][];

    public static void bfsm(int x, int y, int n, int m, char ch[][]) {
        vis[x][y] = 0;
        Queue<Pair> qu = new LinkedList<>();
        qu.add(new Pair(x, y));
        while (!qu.isEmpty()) {
            Pair p = qu.poll();
            int i = p.a;
            int j = p.b;
            int xx = vis[i][j] + 1;
            if (i + 1 < n) {
                if (ch[i + 1][j] == '.') {
                    // vis[i+1][j]=Math.min(vis[i+1][j],vis[i][j]+1);
                    if (vis[i + 1][j] > xx) {
                        qu.add(new Pair(i + 1, j));
                        vis[i + 1][j] = xx;
                    }
                }
            }
            if (j + 1 < m) {
                if (ch[i][j + 1] == '.') {
                    //  vis[i][j+1]=Math.min(vis[i][j+1],vis[i][j]+1);
                    if (vis[i][j + 1] > xx) {
                        qu.add(new Pair(i, j + 1));
                        vis[i][j + 1] = xx;
                    }

                }
            }
            if (i - 1 >= 0) {
                if (ch[i - 1][j] == '.') {
                    // vis[i-1][j]=Math.min(vis[i-1][j],vis[i][j]+1);
                    if (vis[i - 1][j] > xx) {
                        qu.add(new Pair(i - 1, j));
                        vis[i - 1][j] = xx;
                    }

                }
            }
            if (j - 1 >= 0) {
                if (ch[i][j - 1] == '.') {
                    // vis[i][j-1]=Math.min(vis[i][j-1],vis[i][j]+1);
                    if (vis[i][j - 1] > xx) {
                        qu.add(new Pair(i, j - 1));
                        vis[i][j - 1] = xx;
                    }

                }
            }
        }
    }

    public static boolean bfs(int x, int y, int n, int m, char ch[][]) {
        vis[x][y] = 0;
        Queue<Pair> qu = new LinkedList<>();
        qu.add(new Pair(x, y));
        while (!qu.isEmpty()) {
            Pair p = qu.poll();
            int i = p.a;
            int j = p.b;
            if (i + 1 < n) {
                if (ch[i + 1][j] == '.') {
                    if (vis[i][j] + 1 < vis[i + 1][j]) {
                        vis[i + 1][j] = vis[i][j] + 1;

                        if (i + 1 == n - 1) {
                            xx = i + 1;
                            ch[i + 1][j] = 'D';
                            yy = j;
                            return true;
                        }
                        ch[i + 1][j] = 'D';
                        qu.add(new Pair(i + 1, j));
                    }
                }
            }
            if (j + 1 < m) {
                if (ch[i][j + 1] == '.') {
                    if (vis[i][j] + 1 < vis[i][j + 1]) {
                        vis[i][j + 1] = vis[i][j] + 1;
                        if (j + 1 == m - 1) {
                            xx = i;
                            yy = j + 1;
                            ch[i][j + 1] = 'R';
                            return true;
                        }
                        ch[i][j + 1] = 'R';
                        qu.add(new Pair(i, j + 1));
                    }
                }
            }
            if (i - 1 >= 0) {
                if (ch[i - 1][j] == '.') {
                    if (vis[i][j] + 1 < vis[i - 1][j]) {
                        vis[i - 1][j] = vis[i][j] + 1;
                        if (i - 1 == 0) {
                            xx = i - 1;
                            yy = j;
                            ch[i - 1][j] = 'U';
                            return true;
                        }
                        ch[i - 1][j] = 'U';
                        qu.add(new Pair(i - 1, j));
                    }
                }
            }
            if (j - 1 >= 0) {
                if (ch[i][j - 1] == '.') {

                    if (vis[i][j] + 1 < vis[i][j - 1]) {
                        vis[i][j - 1] = vis[i][j] + 1;
                        if (j - 1 == 0) {
                            yy = j - 1;
                            xx = i;
                            ch[i][j - 1] = 'L';
                            return true;
                        }
                        ch[i][j - 1] = 'L';
                        qu.add(new Pair(i, j - 1));
                    }
                }
            }
        }
        return false;
    }


    public static void main(String[] args) throws Exception {
        FastReader sc = new FastReader();

        Clock clock = new Clock();
        clock.start();
        int n=sc.nextInt();
        int k=sc.nextInt();
        long p[][]=new long[n][3];
        long c[]=new long[n];
        for (int i = 0; i <n ; i++) {
            p[i][0]=sc.nextLong();
        }
        for (int i = 0; i <n ; i++) {
            p[i][1]=sc.nextLong();
            p[i][2]=i;
        }
        Arrays.sort(p, new Comparator<long[]>() {
            @Override
            public int compare(long[] o1, long[] o2) {
                return Long.compare(o1[0],o2[0]);
            }
        });
        PriorityQueue<Long>pq=new PriorityQueue<>();
        long sum=0;
        long [][]ans=new long[n][2];
        for (int i = 0; i <n ; i++) {
            ans[i][1]= p[i][1]+sum;
            ans[i][0] = p[i][2];
            if(pq.size()<k)
            {
                sum+=p[i][1];
                pq.add(p[i][1]);
            }
            else
            {
                sum+=p[i][1];
                pq.add(p[i][1]);
                long ele =pq.poll();
                sum-=ele;

            }
        }
        Arrays.sort(ans, new Comparator<long[]>() {
            @Override
            public int compare(long[] o1, long[] o2) {
                return Long.compare(o1[0],o2[0]);
            }
        });
        for (int i = 0; i <n ; i++) {
            out.print(ans[i][1]+"" "");
        }
        out.close();


    }
}


class Pair {

    int a;
    int b;

    Pair(int a, int b) {
        this.a = a;
        this.b = b;
    }
}


class Graph {

    HashMap<Integer, ArrayList<Integer>> hm;

    Graph() {
        hm = new HashMap<>();
    }

    Graph(int n) {

        hm = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hm.put(i, new ArrayList<Integer>());
        }
    }

    // function for adding an edge.................................................
    public void addEdge(int a, int b, boolean isDir) {
        if (isDir) {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }
        } else {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else if (!hm.containsKey(a)) {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }

            if (hm.containsKey(b)) {
                hm.get(b).add(a);
            } else if (!hm.containsKey(b)) {
                hm.put(b, new ArrayList<>(Arrays.asList(a)));
            }
        }
    }


}


class DSU {

    int parent[], rank[];

    DSU(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = -1;
            rank[i] = 1;
        }
    }

    int find(int s1) {
        if (parent[s1] == -1) {
            return s1;
        }

        parent[s1] = find(parent[s1]);
        return parent[s1];
    }

    void unite(int s1, int s2) {
        int p1 = find(s1);
        int p2 = find(s2);

        if (p1 != p2) {
            if (rank[p1] > rank[p2]) {
                parent[p2] = find(p1);
                rank[p1] += rank[p2];
            } else {
                parent[p1] = find(p2);
                rank[p2] += rank[p1];
            }
        }
    }
}

// out.println(al.toString().replaceAll(""[\\[|\\]|,]"",""""));

",4,0994_B,CODEFORCES,2838,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import java.util.*;
import java.io.*;
import java.util.Map.Entry;

public class Codeforces {

    static int n;
    static double max;
    static int[] pre;

    public static void findIntensity(int l){
        for(int i = 0, j = i + l; j < n + 1; i++, j++){
            double res = (pre[j] - pre[i]) / (double) l;
            max = Math.max(max, res);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[] heat = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i = 0; i < n; i++){
            heat[i] = Integer.parseInt(st.nextToken());
        }
        max = 0;
        pre = new int[n + 1];
        pre[0] = 0;
        for(int i = 0; i < n; i++){
            pre[i + 1] = pre[i] + heat[i];
        }
        for(int i = k; i <= n; i++){
            findIntensity(i);
        }
        System.out.println(max);
    }
}",5,1003_C,CODEFORCES,3282,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import java.util.*;
public class HeatIntense {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		double prefix[] = new double[n];
		int sum = 0;
		for(int i=0; i<n; i++)
		{
			int a = sc.nextInt();
			sum = sum + a;
			prefix[i] = sum ;
			
		}
		
		double ans = 0;
		for(int i = 0; i<=n-k; i++)
		{
			for(int j = i+k-1 ; j<n; j++)
			{
				double avg = 0;
				if(i > 0)
				{
					avg = (prefix[j] - prefix[i-1])/(j-i+1); 
					//System.out.println(prefix[j]- prefix[i-1] + "" "" + avg);
				}
				else
				{
					avg = prefix[j]/(j+1);
				//	System.out.println(prefix[j] + "" "" + avg);
				}
				ans = Math.max(avg, ans);
			}
		}
		
		System.out.println(ans);
		
	}

}
",5,1003_C,CODEFORCES,3280,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import java.util.*;
import java.io.*;
import java.math.*;

//=============================================================================
//--------------------------Main-Class---------------------------------
//=============================================================================

public class C {

	public static void process() throws IOException {

		int n = sc.nextInt(),k = sc.nextInt();
		double arr[] = new double[n];
		double sum[] = new double[n];
		double ff = 0;
		for(int i=0; i<n; i++) {
			double val = sc.nextDouble();
			ff+=val;
			arr[i] = val;
			sum[i] = ff;
		}
		
		double max = 0;
		for(int i=0; i<n; i++) {
			for(int j = i+k-1; j<n; j++) {
				if(i<=0)
					max = Math.max(sum[j]/(j-i+1),max);
				else
					max = Math.max((sum[j]-sum[i-1])/(j-i+1),max);
			}
		}
		System.out.println(max);
		
		
		

	}

	//=============================================================================
	//--------------------------Dheeraj-Bhagchandani---------------------------------
	//=============================================================================

	static FastScanner sc;
	static PrintWriter out;

	public static void main(String[] args) throws IOException {
		boolean oj = true;
		if (oj) {
			sc = new FastScanner();
			out = new PrintWriter(System.out);
		} else {
			sc = new FastScanner(100);
			out = new PrintWriter(""output.txt"");
		}
		int t = 1;
//		t = sc.nextInt();
		while (t-- > 0) {
			process();
		}
		out.flush();
		out.close();
	}

	static class Pair implements Comparable<Pair> {
		int x, y;

		Pair(int x, int y) {
			this.x = x;
			this.y = y;
		}

		@Override
		public int compareTo(Pair o) {
			return Integer.compare(this.x, o.x);
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	static void println(Object o) {
		out.println(o);
	}

	static void println() {
		out.println();
	}

	static void print(Object o) {
		out.print(o);
	}

	static void pflush(Object o) {
		out.println(o);
		out.flush();
	}

	static int ceil(int x, int y) {
		return (x % y == 0 ? x / y : (x / y + 1));
	}

	static long ceil(long x, long y) {
		return (x % y == 0 ? x / y : (x / y + 1));
	}

	static int max(int x, int y) {
		return Math.max(x, y);
	}

	static int min(int x, int y) {
		return Math.min(x, y);
	}

	static int abs(int x) {
		return Math.abs(x);
	}

	static long abs(long x) {
		return Math.abs(x);
	}

	static int log2(int N) {
		int result = (int) (Math.log(N) / Math.log(2));
		return result;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	public static int gcd(int a, int b) {
		BigInteger b1 = BigInteger.valueOf(a);
		BigInteger b2 = BigInteger.valueOf(b);
		BigInteger gcd = b1.gcd(b2);
		return gcd.intValue();
	}

	public static long gcd(long a, long b) {
		BigInteger b1 = BigInteger.valueOf(a);
		BigInteger b2 = BigInteger.valueOf(b);
		BigInteger gcd = b1.gcd(b2);
		return gcd.longValue();
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		FastScanner() throws FileNotFoundException {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		FastScanner(int a) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(""input.txt""));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		String nextLine() throws IOException {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

		int[] readArray(int n) throws IOException {
			int[] A = new int[n];
			for (int i = 0; i != n; i++) {
				A[i] = sc.nextInt();
			}
			return A;
		}

		long[] readArrayLong(int n) throws IOException {
			long[] A = new long[n];
			for (int i = 0; i != n; i++) {
				A[i] = sc.nextLong();
			}
			return A;
		}
	}

	static void ruffleSort(int[] a) {
		Random get = new Random();
		for (int i = 0; i < a.length; i++) {
			int r = get.nextInt(a.length);
			int temp = a[i];
			a[i] = a[r];
			a[r] = temp;
		}
		Arrays.sort(a);
	}

	static void ruffleSort(long[] a) {
		Random get = new Random();
		for (int i = 0; i < a.length; i++) {
			int r = get.nextInt(a.length);
			long temp = a[i];
			a[i] = a[r];
			a[r] = temp;
		}
		Arrays.sort(a);
	}
}
",5,1003_C,CODEFORCES,3281,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import java.io.*;
import java.util.*;

public class Solution {
    static class Data{
        int x,i;
        Data(int x,int i){
            this.x = x;
            this.i = i;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split(""\\s"");
        int N = Integer.parseInt(s[0]);
        int K = Integer.parseInt(s[1]);
        s = br.readLine().split(""\\s"");
        int[] arr = new int[N];
        for(int i=0;i<N;++i) arr[i] = Integer.parseInt(s[i]);
        solve(N,K,arr);   
    }
    
    private static void solve(int N,int K,int[] arr){
       PriorityQueue<Data> pq = new PriorityQueue<Data>(2000,(a,b) -> a.x - b.x == 0 ? b.i - a.i : b.x - a.x);
       for(int i=0;i<arr.length;++i){
           pq.offer(new Data(arr[i],i));
       }
       
       int tot_sum = 0;
       List<Integer> ls = new ArrayList<>();
       Set<Integer> set = new HashSet<>();
       
       for(int i=1;i<=K;++i){
           Data t = pq.poll();
           tot_sum += t.x;
           set.add(t.i);
       }
       int last = -1;
       for(int i =0;i<arr.length;++i){
           if(set.contains(i)){
               K--;
               //System.out.println(i);
               if(K == 0) ls.add(arr.length-last-1);
               else ls.add(i-last);
               last = i;
           }
       }
       
       System.out.println(tot_sum);
       int size = ls.size();
       for(int i=0;i<size;++i){
           System.out.print(ls.get(i) + "" "");
       }
    }
}",4,1006_B,CODEFORCES,2859,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings"
"import java.util.*;
import java.math.*;
import java.io.*; 
 public class A{

static FastReader scan=new FastReader();
 public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));
  static LinkedList<Edge>edges[];
  static boolean stdin = true;
    static String filein = ""input"";
    static String fileout = ""output"";
static int dx[] = { -1, 0, 1, 0 };
static int dy[] = { 0, 1, 0, -1 };
int dx_8[]={1,1,1,0,0,-1,-1,-1};
int dy_8[]={-1,0,1,-1,1,-1,0,1};
static char sts[]={'U','R','D','L'};
static boolean prime[];
static long LCM(long a,long b){
    return (Math.abs(a*b))/gcd(a,b);
   }
    public static int upperBound(long[] array, int length, long value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = low+(high-low) / 2;
            if ( array[mid]>value) {
                high = mid ;
            } else {
                low = mid+1;
            }
        }
        return low;
    }
   static long gcd(long a, long b) {
    if(a!=0&&b!=0)
        while((a%=b)!=0&&(b%=a)!=0);
    return a^b;
}
static int countSetBits(int n) 
    { 
        int count = 0; 
        while (n > 0) { 
            count += n & 1; 
            n >>= 1; 
        } 
        return count; 
    } 
 static void sieve(long n) 
    { 
        
        prime = new boolean[(int)n+1]; 
        for(int i=0;i<n;i++) 
            prime[i] = true; 
          
        for(int p = 2; p*p <=n; p++) 
        { 
           
            if(prime[p] == true) 
            { 
                
                for(int i = p*p; i <= n; i += p) 
                    prime[i] = false; 
            } 
        } 
    }  
  
 
 
           static boolean isprime(long x)
           {
            for(long i=2;i*i<=x;i++)
                if(x%i==0)
                    return false;
                return true;
           }
           static int perm=0,FOR=0;
           
     

static boolean flag=false;
static int len=100000000;

static ArrayList<Pair>inters=new ArrayList<Pair>();





static StringBuilder sb;
static void swap(int i,int j,StringBuilder st)
{
    char tmp=st.charAt(i);
    st.setCharAt(i,st.charAt(j));
    st.setCharAt(j,tmp);
}


 private static int next(int[] arr, int target)  
    {  
        int start = 0, end = arr.length - 1;  
    
        int ans = -1;  
        while (start <= end) {  
            int mid = (start + end) / 2;  
    
            // Move to right side if target is  
            // greater.  
            if(arr[mid]==target)
                return mid;
            if (arr[mid] <target) {  
                start = mid + 1;  
            }  
    
            // Move left side.  
            else {  
                ans = mid;  
                end = mid - 1;  
            }  
        }  
        return ans;  
    }  
//static boolean vis[][];
    static long solve(int h,long n,int cur)
    {
        if(h==0)
            return 0;
        long half=1L<<(h-1);
        if(n<=half)
        {
            if((cur^1)==0)
                return 1+solve(h-1,n,0);
            else 
                return 2*half+solve(h-1,n,0);
        }
        else 
        {
              if((cur^1)==0)
             return 2*half+solve(h-1,n-half,1);
            else 
                return 1+solve(h-1,n-half,1);
        }
    }
static int dist[][];
public static String removeLeadingZeroes(String str) {
      String strPattern = ""^0+(?!$)"";
      str = str.replaceAll(strPattern, """");
      return str;
   }

    static String gcd(String str1, String str2)
    {
        // If str1 length is less than
        // that of str2 then recur
        // with gcd(str2, str1)
        if (str1.length() < str2.length()) {
            return gcd(str2, str1);
        }
 
        // If str1 is not the
        // concatenation of str2
        else if (!str1.startsWith(str2)) {
            return """";
        }
 
        else if (str2.isEmpty()) {
 
            // GCD string is found
            return str1;
        }
        else {
 
            // Cut off the common prefix
            // part of str1 & then recur
            return gcd(str1.substring(str2.length()),
                       str2);
        }
    }
   static ArrayList<Long>luckies=new ArrayList<Long>();
  static int n;
  static long cnt=0;
static void d(long x)
{
    if(String.valueOf(x).length()>n)
        return;
    cnt++;
    luckies.add(x);
     d(x*10+7);
     d(x*10+8);
}

public static class comp1 implements Comparator<String>{  
public int compare(String o1,String o2){
return o1.length()-o2.length(); 
}
  }
  public static class comp2 implements Comparator<String>{  
public int compare(String o1,String o2){
return o1.compareTo(o2); 
}
  }

public static void main(String[] args)  throws Exception 
{
//SUCK IT UP AND DO IT ALRIGHT
//scan=new FastReader(""input.txt"");
//out = new PrintWriter (""output.txt"");
   // System.out.println(pow((long)1e9,(long)1e9));
    //int elem[]={1,2,3,4,5};
  //  System.out.println(upperBound(elem,elem.length,5));
int tt=1;
//tt=scan.nextInt();
outer:while(tt-->0)
{
int n=scan.nextInt(),k=scan.nextInt();
Pair arr[]=new Pair[n];
for(int i=0;i<n;i++)
arr[i]=new Pair(scan.nextInt(),i);
Arrays.sort(arr);
int i=n-1;
int ans=0;
ArrayList<Integer>a2=new ArrayList<Integer>();
while(k-->0)
{
    ans+=arr[i].x;
    a2.add(arr[i--].y+1);
}
out.println(ans);
i=0;
Collections.sort(a2);
//out.println(a2.size());
for( ;i<a2.size();i++)
{
    ans=0;
    if(i==0)
        ans+=a2.get(i);
     if(i+1==a2.size())
       ans+=n-a2.get(i);
    
if(i>0) 
    ans+=a2.get(i)-a2.get(i-1);
out.print(ans+"" "");
}
}
out.close();

//SEE UP 

}
static long binexp(long a,long n)
{
    if(n==0)
        return 1;
    long res=binexp(a,n/2);
    if(n%2==1)
        return res*res*a;
    else 
        return res*res;
}
static long powMod(long base, long exp, long mod) {
       if (base == 0 || base == 1) return base;
       if (exp == 0) return 1;
       if (exp == 1) return base % mod;
       long R = powMod(base, exp/2, mod) % mod;
       R *= R;
       R %= mod;
       if ((exp & 1) == 1) {
           return base * R % mod;
       }
       else return R % mod;
   }
static double dis(double x1,double y1,double x2,double y2)
{
    return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
static long mod(long x,long y)
    {
        if(x<0)
            x=x+(-x/y+1)*y;
        return x%y;
    }
 public static  long pow(long b, long e) {
            long r = 1;
            while (e > 0) {
                if (e % 2 == 1) r = r * b ;
                b = b * b;
                e >>= 1;
            }
            return r;
        }
private static void sort(long[] arr) {
        List<Long> list = new ArrayList<>();
        for (long object : arr) list.add(object);
        Collections.sort(list);
        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);
    }
 public static class FastReader {
        BufferedReader br;
        StringTokenizer root;
        
 
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        FastReader(String filename)throws Exception
        {

            br=new BufferedReader(new FileReader(filename));
        }

        boolean hasNext(){
            String line;
            while(root.hasMoreTokens())
                return true;
            return false;
        }
 
        String next() {
            while (root == null || !root.hasMoreTokens()) {
                try {
                    root = new StringTokenizer(br.readLine());
                } catch (Exception addd) {
                    addd.printStackTrace();
                }
            }
            return root.nextToken();
        }
 
        int nextInt() {
            return Integer.parseInt(next());
        }
 
        double nextDouble() {
            return Double.parseDouble(next());
        }
 
        long nextLong() {
            return Long.parseLong(next());
        }
 
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (Exception addd) {
                addd.printStackTrace();
            }
            return str;
        }
         public int[] nextIntArray(int arraySize) {
            int array[] = new int[arraySize];
 
            for (int i = 0; i < arraySize; i++) {
                array[i] = nextInt();
            }
 
            return array;
        }
}
 static class Pair implements Comparable<Pair>{
        public int x, y;
        public Pair(int x1, int y1) {
            x=x1;
            y=y1;
        }
        @Override
        public int hashCode() {
            return (int)(x + 31 * y);
        }
        public String toString() {
            return x + "" "" + y;
        }
        @Override
        public boolean equals(Object o){
            if (o == this) return true;
            if (o.getClass() != getClass()) return false;
            Pair t = (Pair)o;
            return t.x == x && t.y == y;
        }
public int compareTo(Pair o)
{
    return (x-o.x);

    }

static class pair{
    int i;
    int j;
pair(int i,int j){
    this.i=i;
    this.j=j;
}}}
 static class tuple{
        int x,y,z;
        tuple(int a,int b,int c){
            x=a;
            y=b;
            z=c;
        }
    }
    static class Edge{
        int d,w;
        Edge(int d,int w)
        {
            this.d=d;
            this.w=w;
        }
    }
}









",4,1006_B,CODEFORCES,2858,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings"
"

import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;


public class file{


// *********************************************BEGINS*********************************************
public static void main(String[] args) throws IOException{


// Working program using BufferedReader 
        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 
       // StringTokenizer st = new StringTokenizer(br.readLine()); 
       // int n = Integer.parseInt(st.nextToken()); 
       // int k = Integer.parseInt(st.nextToken()); 

Reader scn=new Reader();
PrintWriter pt=new PrintWriter(System.out);

int n=scn.nextInt();
int k=scn.nextInt();
int[] arr=new int[n];
PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());
for(int i=0;i<n;i++){
    arr[i]=scn.nextInt();
    pq.add(arr[i]);
}

int sum=0;
ArrayList<Integer> list=new ArrayList<>();
for(int i=0;i<k;i++){
    int data=pq.remove();
    list.add(data);
    sum+=data;
}
pt.println(sum);

int ind=-1;
for(int i=0;list.size()>1;i++){
    if(list.contains(arr[i])){
        pt.print(i-ind+"" "");
        list.remove(new Integer(arr[i]));
        ind=i;
    }
}
pt.println(n-1-ind);
pt.close();

}
// *********************************************ENDED*********************************************
static boolean isPrime(int n)
{
    if (n <= 1)
        return false;
    if (n <= 3)
        return true;
    if (n % 2 == 0 || n % 3 == 0)
        return false;
 
    for (int i = 5; i * i <= n; i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
 
    return true;
}

static void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;
 
        /* Create temp arrays */
        int L[] = new int [n1];
        int R[] = new int [n2];
 
        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];
 
 
        /* Merge the temp arrays */
 
        // Initial indexes of first and second subarrays
        int i = 0, j = 0;
 
        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
 
        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }
 
        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
 
    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l + r) / 2;
 
            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m + 1, r);
 
            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

static class Reader 
    { 
        final private int BUFFER_SIZE = 1 << 16; 
        private DataInputStream din; 
        private byte[] buffer; 
        private int bufferPointer, bytesRead; 
  

public Reader() 
        { 
            din = new DataInputStream(System.in); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        }


public Reader(String file_name) throws IOException 
        { 
            din = new DataInputStream(new FileInputStream(file_name)); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        }  

public String readLine() throws IOException 
        { 
            byte[] buf = new byte[64]; // line length 
            int cnt = 0, c; 
            while ((c = read()) != -1) 
            { 
                if (c == '\n') 
                    break; 
                buf[cnt++] = (byte) c; 
            } 
            return new String(buf, 0, cnt); 
        } 


 public int nextInt() throws IOException 
        { 
            int ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do
            { 
                ret = ret * 10 + c - '0'; 
            }  while ((c = read()) >= '0' && c <= '9'); 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 


 public long nextLong() throws IOException 
        { 
            long ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
            if (neg) 
                return -ret; 
            return ret; 
        } 


public double nextDouble() throws IOException 
        { 
            double ret = 0, div = 1; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
  
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
  
            if (c == '.') 
            { 
                while ((c = read()) >= '0' && c <= '9') 
                { 
                    ret += (c - '0') / (div *= 10); 
                } 
            } 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 

private void fillBuffer() throws IOException 
        { 
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
            if (bytesRead == -1) 
                buffer[0] = -1; 
        } 

private byte read() throws IOException 
        { 
            if (bufferPointer == bytesRead) 
                fillBuffer(); 
            return buffer[bufferPointer++]; 
        } 


public void close() throws IOException 
        { 
            if (din == null) 
                return; 
            din.close(); 
        } 
    }
  
}",4,1006_B,CODEFORCES,2857,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings"
"import java.util.Scanner;
public class _1420D {
    public static void main(String[] args) {
        Scanner input=new Scanner(System.in);
        int n=input.nextInt();
        int m=input.nextInt();
        long sum=0;
        for(int i=0;i<m;i++)
        {
            int x=input.nextInt();
            int d=input.nextInt();
            if(d<0)
            {
                if(n%2!=0)
                {
                    long val=n/2;
                    val=val*(val+1);
                    sum+=(long)val*(long)d;
                    sum+=(long)n*x;
                }
                else
                {
                    long v1=n/2;
                    v1=v1*(v1+1)/2;
                    long v2=n/2-1;
                    v2=v2*(v2+1)/2;
                    long val=v1+v2;
                    sum+=val*(long)d+(long)n*x;
                }
            }
            else
            {
                sum+=(long)(n-1)*n/2*(long)d;
                sum+=(long)n*x;
            }
        }
        double s=(double)sum;
        double av=s/(double)n;
        System.out.println(av);
    }
}",3,1009_C,CODEFORCES,2015,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math"
"import java.io.*;
import java.util.*;
import java.math.BigInteger; 

public class test1 {
    
    static int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};
   static class sort implements Comparator<int[]>
   {
        public int compare(int[] a,int[] b)
        {
            if(a[0] == b[0]) return a[1]-b[1];
           return a[0]-b[0];
        }
   }
   
   public static void pri(PrintWriter out,Object o)
   {
      
    out.println(o.toString());
    
   }
   public static void prW(PrintWriter out,Object o)
   {
      
    out.print(o.toString());
    
   }
   public static int intIn(String st)
   {
      return Integer.parseInt(st);
   }
   
   
    
    public static void pr(Object o)
    {
        System.out.println(o.toString());
    }
    public static void prW(Object o)
    {
        System.out.print(o.toString());
    }
    
   
    public static int inInt(String s)
    {
        return Integer.parseInt(s);
    }
    public static long in(String s)
    {
        return Long.parseLong(s);
    }

    static long power(long x, long y, long p)
      {
        long res = 1; // Initialize result
     
        x = x % p; // Update x if it is more than or
        // equal to p
     
        if (x == 0)
          return 0l; // In case x is divisible by p;
     
        while (y > 0)
        {
     
          // If y is odd, multiply x with result
          if ((y & 1) != 0)
            res = (res * x) % p;
     
          // y must be even now
          y = y >> 1; // y = y/2
          x = (x * x) % p;
        }
        return res;
      }
      static long gcd(long a, long b)
        {
          if (b == 0)
            return a;
          return gcd(b, a % b); 
        }
        static int gcd(int a, int b,int o)
        {
          if (b == 0)
            return a;
          return gcd(b, a % b,o); 
        }
    
      
    
    
    static int[] toIntArray(String[] m) 
    { 
        int[] p=new int[m.length];
        for(int o=0;o<m.length;o++)
        {
            p[o]= inInt(m[o]);
        }
        return p;
    }
    static long[] toLArray(String[] m) 
    { 
       long[] p=new long[m.length];
        for(int o=0;o<m.length;o++)
        {
            p[o]= in(m[o]);
        }
        return p;
    }
    public static long F(long[] arr)
    {
        //int len=arr.length;
        
       // Arrays.sort(arr);
        long med;
        if((arr.length%2) == 0)
        {
            med = (arr[arr.length/2] + arr[(arr.length/2)-1])/(2);
        }
        else
        {
            med = (arr[arr.length/2]);
        }
        long dis = 0l;

        for(long x : arr)
        {
            dis += (Math.abs(x-med));
           // prW(x+"" "");
        }
        //prW(med);
       // pr("""");
       // arr=tem;
        return dis;


    }
    static int[][] pre;// = new int[n][27];
    static int[][] fin;//
    public static String[] F(BufferedReader bf) throws Exception
    {
        return (bf.readLine().split("" ""));
    }
   
    public static void main (String[] args) throws Exception {
        
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
       // PrintWriter out = new PrintWriter(System.out);;;
        
        //int[] map=new int[1000001];
      
        int y=1;//Integer.parseInt(bf.readLine());
        
        for(int h=0;h<y;h++)
        {

            
    
            String[] xlp = bf.readLine().split("" "");
            
            int n,k,t;//boolean bol=false; int[] arr = toIntArray(F(bf));

            n=intIn(xlp[0]);
            k = intIn(xlp[1]);
            long s1,s2;
            s1=s2=0;
            for(int o=0;o<n;o++) s1+=(o+0l);
            for(int o=0;o<=((n-1)/2);o++)
            {
                s2+=(o+0l);

            }
            s2 = (2+0l)*s2;

            if((n%2) == 0) 
            {
                s2+= (n/2)+0l;
            }

            double x=0.00;
            double other=0.00;long sum=0l;
            for(int o=0;o<k;o++)
            {
                xlp = bf.readLine().split("" "");
                x+=(intIn(xlp[0]) +0.00);
                int d = intIn(xlp[1]);
                long v;
                if(d>0)
                {
                    v = (d+0l)*(s1+0l);
                }
                else
                {
                    v = (d+0l)*(s2+0l);
                }
                sum += (v);
            }

            double res = (x) + ((sum+0.00)/(n+0.00));
            pr(res);



            

            
            
            
        }
       // out.close();

    }
}
/*
3 10
10 10 10Output
NO
Answer
static class SegmentTreeRMQ 
    { 
    int st[]; 
    int minVal(int x, int y) { 
        return (x > y) ? x : y; 
    } 
  
    
    int getMid(int s, int e) { 
        return s + (e - s) / 2; 
    } 
  
    
    int RMQUtil(int ss, int se, int qs, int qe, int index) 
    { 
        
        if (qs <= ss && qe >= se) 
            return st[index]; 
  
        // If segment of this node is outside the given range 
        if (se < qs || ss > qe) 
            return Integer.MIN_VALUE; 
  
        // If a part of this segment overlaps with the given range 
        int mid = getMid(ss, se); 
        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), 
                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); 
    } 
  
    // Return minimum of elements in range from index qs (query 
    // start) to qe (query end).  It mainly uses RMQUtil() 
    int RMQ(int n, int qs, int qe) 
    { 
        // Check for erroneous input values 
        
  
        return RMQUtil(0, n - 1, qs, qe, 0); 
    } 
  
    // A recursive function that constructs Segment Tree for 
    // array[ss..se]. si is index of current node in segment tree st 
    int constructSTUtil(int arr[], int ss, int se, int si) 
    { 
        // If there is one element in array, store it in current 
        //  node of segment tree and return 
        if (ss == se) { 
            st[si] = arr[ss]; 
            return arr[ss]; 
        } 
  
        // If there are more than one elements, then recur for left and 
        // right subtrees and store the minimum of two values in this node 
        int mid = getMid(ss, se); 
        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), 
                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); 
        return st[si]; 
    } 
  
    
    void con(int arr[]) 
    { 
        // Allocate memory for segment tree 
  
        //Height of segment tree 
        int n = (arr.length);
        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); 
  
        //Maximum size of segment tree 
        int max_size = 2 * (int) Math.pow(2, x) - 1; 
        st = new int[max_size]; // allocate memory 
  
        // Fill the allocated memory st 
        constructSTUtil(arr, 0, n - 1, 0); 
    }
    }
     static class DSU {
    
    int[] p;int[] sz;int op;int c;;
    int[] last;
    public void G(int n)
    {
        last=new int[n];
        p=new int[n];
        sz=new int[n];c=n;
        op=n;
        for(int h=0;h<n;h++)
        {
            sz[h]=1;p[h]=h;
            last[h]=h;
        }
    }
    public int find(int x)
    {
        int y=x;
        while(x!=p[x]) x=p[x];
        while(y!=p[y])
        {
            int tem=p[y];
            p[y]=x;y=tem;
        }
        return p[y];
    }
    public void union(int a,int b)
    {
        int x,y;
        x=find(a);y=find(b);
        if(x==y) return;
        if(sz[x]>sz[y])
        {
            p[y] = x;
            sz[x]+=sz[y];
            last[x]=Math.max(last[x],last[y]);
        }
        else
        {
          p[x]=y;sz[y]+=sz[x];
            last[y]=Math.max(last[y],last[x]);
        }
        c--;
        
    }}
*/
",3,1009_C,CODEFORCES,2016,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class AnnoyingPresent {

	
	//UPSOLVED
	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
        long n = Long.parseLong(st.nextToken()) , m = Long.parseLong(st.nextToken());
        
        long sum = 0;
        
        for(int i=0;i<m;i++){
        	StringTokenizer st1 = new StringTokenizer(br.readLine());
            sum+= n* Long.parseLong(st1.nextToken());
            Long a= Long.parseLong(st1.nextToken());
            if(a < 0){
                if(n % 2 == 0)
                    sum += n*n / 4*a;
                else{
                    sum += (n/2) * (n/2+1) * a;
                }
            }
            else
                sum += (a*(n) * (n-1) / 2);
            
        }
        System.out.println((double)sum/n);
	}

}
",3,1009_C,CODEFORCES,2017,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;

public class Solution{
	
	static FastScanner fs = new FastScanner();
	static PrintWriter out = new PrintWriter(System.out);
	static int n, d;
	
	
    public static void main(String[] args) throws IOException {
    	
		
//    	FastScanner fs = new FastScanner();
//    	PrintWriter out = new PrintWriter(System.out);
    		
    	int tt = 1;
    	while(tt-->0) {
    		
    	
    		n = fs.nextInt();
    		int l = 1, r = 1 + n/2;
    		
    		d = getB(l);
    		if(d%2!=0) {
    			out.println(""! -1"");
    			out.flush();
    			return;
    		}
    		
    		if(d==0) {
    			out.println(""! 1"");
    			out.flush();
    			return;
    		}
    		
    		
    		
    		
    		
    		
    		
    		while(l<r) {
    			int mid = (l+r)/2;
    			if(check(mid)) {
    				l = mid + 1;
    			}
    			else {
    				r = mid;
    			}
    			int f = 1;
    		}
    		
    		
    		out.println(""! ""+l);
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    	}
    	
    	out.close();
    		
    }
    
    
    static boolean check(int i) {
    	int k = getB(i);
    	if(sig(d)==sig(k)) {
    		return true;
    	}
    	return false;
    }
    
    
    static int getB(int i) {
    	out.println(""? ""+i);
    	out.flush();
    	int x1 = fs.nextInt();
    	int j = i + n/2;
    	if(j>n) j -= n;
    	out.println(""? ""+j);
    	out.flush();
    	int x2 = fs.nextInt();
    	return x1 - x2;
    }
    
    
    static int sig(int x) {
    	if(x>0) return 1;
    	else if(x<0) return -1;
    	return 0;
    }
    
    
    
   
    
    
    
    
    
    static final Random random=new Random();
    
    static <T> void shuffle(T[] arr) {
    	int n = arr.length;
    	for(int i=0;i<n;i++	) {
    		int k = random.nextInt(n);
    		T temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;
    	}
    }
    
    	
    static void ruffleSort(int[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); int temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
    
    static void ruffleSort(long[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); long temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
   
  
    
    static void reverse(int[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    static void reverse(long[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		long temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    
    static <T> void reverse(T[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++) {
    		T temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    	
    	
    static class FastScanner{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer("""");
     
    	public String next(){
    		while(!st.hasMoreElements()){
    			try{
    				st = new StringTokenizer(br.readLine());
    			} catch(IOException e){
    				e.printStackTrace();
    			}
    		}
    		return st.nextToken();
    	}
    		
    	public String nextLine() throws IOException {
    		return br.readLine();
    	}
    		
    	public int nextInt(){
    		return Integer.parseInt(next());
    	}
     
    	public int[] readArray(int n){
    		int[] a = new int[n];
    		for(int i=0;i<n;i++)
    			a[i] = nextInt();
    		return a;
    	}
    		
    	public long nextLong() {
    		return Long.parseLong(next());
    	}
    		
    	public char nextChar() {
    		return next().toCharArray()[0];
    	}
    }
   	
}
",2,1019_B,CODEFORCES,1261,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.util.*;
import java.io.*;
import java.math.*;
public class Main
{
    static class Reader 
    { 
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} 
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} 
        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} 
        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} 
        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} 
        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} 
        public double d() throws IOException {return Double.parseDouble(s()) ;}
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; } 
        public boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; } 
        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}
    }
    
    
 
           //       |----|       /\      |    |   -----   |
           //       |   /       /  \     |    |     |     |
           //       |--/       /----\    |----|     |     |
           //       |   \     /      \   |    |     |     |
           //       |    \   /        \  |    |   -----   -------

    public static void main(String[] args)throws IOException
    {
        PrintWriter out= new PrintWriter(System.out);
        Reader sc=new Reader();
        int n=sc.i();
        System.out.println(""? ""+1);
        int a=sc.i();
        System.out.println(""? ""+(1+n/2));
        int b=sc.i();
        if(a==b)
        {
            System.out.println(""! ""+1);
            System.exit(0);
        }
        int inv=0;
        if(a>b)
        inv=1;
        
        int low=2;
        int high=n/2;
        int q=0;
        while(low<=high)
        {
            if(q==60)
            break;
            int mid=(low+high)/2;
            System.out.println(""? ""+mid);
            a=sc.i();
            System.out.println(""? ""+(mid+n/2));
            b=sc.i();
            if(a==b)
            {
                System.out.println(""! ""+mid);
                System.exit(0);
            }
            else if(a<b)
            {
                if(inv==0)
                low=mid+1;
                else
                high=mid-1;
            }
            
            else
            {
                if(inv==0)
                high=mid-1;
                else
                low=mid+1;
            }
            q++;
        }
        System.out.println(""! -1"");
        out.flush();
    }
}",2,1019_B,CODEFORCES,1258,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            int fSign = Integer.signum(BValue(low));
            if (fSign == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int mSign = Integer.signum(BValue(mid));
                if (mSign == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (mSign == -fSign) {
                    high = mid;
                } else {
                    low = mid;
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",2,1019_B,CODEFORCES,1244,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.*;
import java.util.*;

public class B {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		Task solver = new Task();
		solver.solve(1, in, out);
		out.close();
	}

	static class Task {
		int n = 0;
		int query(int p, InputReader in) {
			p %= n;
			if (p <= 0) p += n;
			System.out.println(""? "" + p);
			System.out.flush();
			int x = in.nextInt();
			return x;
		}
		public void solve(int testNumber, InputReader in, PrintWriter out) {
			n = in.nextInt();
			if (n % 4 != 0) {
				out.println(""! -1"");
				return;
			}
			int p = query(0, in);
			int q = query(n / 2, in);
			int l = 0;
			int r = n / 2;
			if (p == q) {
				out.println(""! "" + (n / 2));
				return;
			}
			while (l + 1 < r) {
				int mid = (l + r) / 2;
				int u = query(mid, in);
				int v = query(mid + n / 2, in);
				if (u == v) {
					out.println(""! "" + (mid + n / 2));
					return;
				}
				if ((p < q) == (u < v)) {
					l = mid;
				} else {
					r = mid;
				}
			}
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

	}
}",2,1019_B,CODEFORCES,1255,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class B {
	static PrintWriter out = new PrintWriter(System.out);
	static FS in;
	
	static int N;
	static final boolean debug = false;
	static int inp[] = new int[] {1,2,3,2,1,0};
	public static void main(String[] args) {
		in = new FS();
		if(!debug) N = in.nextInt();
		else N = inp.length;
		int x = solve(0, N/2-1, N/2, N-1);
		out.println(""! ""+(x+1));
		out.flush();
		out.close();
	}
	
	static int solve(int l1, int r1, int l2, int r2) {
		int sz = r1-l1+1;
		if(sz <= 0) return -2;
		int a1 = query(l1);
		int a2 = query(l2);
		if(a1 == a2) return l1;
		
		if(sz == 1) return -2;
		
		int b1 = query(l1+sz/2);
		int b2 = query(l2+sz/2);
		if(b1 == b2) return l1 + sz/2;
		
		if(sz == 2) return -2;
		
		int d1 = a2-a1;
		int d2 =  b2-b1;
		if((d1 < 0 && d2 > 0) || (d1 > 0 && d2 < 0)) {
			return solve(l1+1, l1 + sz/2 - 1, l2+1, l2 + sz/2 - 1);
		}
		else {
			return solve(l1 + sz/2 + 1, r1, l2 + sz/2 + 1, r2);
		}
	}
	
	static int query(int a) {
		out.println(""? ""+(a+1));
		out.flush();
		if(debug) return inp[a];
		else return in.nextInt();
	}
	
	static class FS{
		BufferedReader br;
		StringTokenizer st;
		public FS() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		String next() {
			while(st == null || !st.hasMoreElements()) {
				try {st = new StringTokenizer(br.readLine());}
				catch(Exception e) { throw null;}
			}
			return st.nextToken();
		}
		int nextInt() { return Integer.parseInt(next());}
		double nextDouble() { return Double.parseDouble(next());}
		long nextLong() { return Long.parseLong(next());}
		int[] NIA(int n) {
			int r[] = new int[n];
			for(int i = 0; i < n; i++) r[i] = nextInt();
			return r;
		}
		long[] NLA(int n) {
			long r[] = new long[n];
			for(int i = 0; i < n; i++) r[i] = nextLong();
			return r;
		}
		char[][] grid(int r, int c){
			char res[][] = new char[r][c];
			for(int i = 0; i < r; i++) {
				char l[] = next().toCharArray();
				for(int j = 0; j < c; j++) {
					res[i][j] = l[j];
				}
			}
			return res;
		}
	}
	
}
",2,1019_B,CODEFORCES,1253,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"//package contests.CF1019;

import java.io.*;
import java.util.StringTokenizer;

public class B {

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        int half = n/2;
        pw.println(""? 1"");
        pw.flush();
        int a = sc.nextInt();
        pw.println(""? "" + (1+half));
        pw.flush();
        int b = sc.nextInt();
        if(a - b == 0){
            pw.println(""! 1"");
        }
        else
        if((a - b)%2 != 0)
        {
            pw.println(""! -1"");
        }else{
            boolean greater = a > b;
            int lo = 1;
            int hi = half;

            boolean ans = false;
            while(lo <= hi){
                int mid = (lo + hi) /2;
                pw.println(""? "" + mid);
                pw.flush();
                a = sc.nextInt();
                pw.println(""? "" + (mid+half));
                pw.flush();
                b = sc.nextInt();

                if(a == b){
                    pw.println(""! "" + mid);
                    ans = true;
                    break;
                }

                if(a > b != greater){
                    hi = mid-1;
                }else{
                    lo = mid+1;
                    greater = a>b;
                }
            }

            if(!ans){
                pw.println(""! -1"");
            }

        }

        pw.flush();
        pw.close();
    }



    static int[][] packD(int n, int[] from, int[] to) {
        int[][] g = new int[n][];
        int[] p = new int[n];
        for (int f : from) if(f != -1) p[f]++;
        for (int i = 0; i < n; i++) g[i] = new int[p[i]];
        for (int i = 0; i < from.length; i++) if(from[i] != -1) {g[from[i]][--p[from[i]]] = to[i];}
        return g;
    }

    static void shuffle(int[] a)
    {
        int n = a.length;
        for(int i = 0; i < n; i++)
        {
            int r = i + (int)(Math.random() * (n - i));
            int tmp = a[i];
            a[i] = a[r];
            a[r] = tmp;
        }
    }

    static class Scanner
    {
        StringTokenizer st; BufferedReader br;
        public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}
        public Scanner(String s) throws FileNotFoundException {	br = new BufferedReader(new FileReader(new File(s)));}
        public String next() throws IOException {while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());return st.nextToken();}
        public int nextInt() throws IOException {return Integer.parseInt(next());}
        public long nextLong() throws IOException {return Long.parseLong(next());}
        public String nextLine() throws IOException {return br.readLine();}
        public boolean ready() throws IOException {return br.ready();}
    }
}
",2,1019_B,CODEFORCES,1260,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.*;
import java.util.*;
public class Main {
	final static int MAXN = 100005;
	static int n;
	static Scanner cin;
	static int[] a;
	static boolean[] used;
	public static int Query(int x) {
		System.out.print(""? "");
		System.out.println(x);
		System.out.flush();
		int a = cin.nextInt();
		return a;
	}
	public static int Q(int x) {
		if(used[x]) return a[x];
		used[x] = true;
		a[x] = Query(x) - Query(x + n / 2);
		if(a[x] == 0) {
			System.out.print(""! "");
			System.out.println(x);
			System.out.flush();
			cin.close();
			System.exit(0);
		}
		return a[x];
	}
	public static void main(String[] args) {
		cin = new Scanner(System.in);
		n = cin.nextInt();
		a = new int[MAXN];
		used = new boolean[MAXN];
		if(n % 4 != 0) {
			System.out.println(""! -1\n"");
			System.out.flush();
			cin.close();
			return;
		}
		int l = 1, r = n / 2, mid;
		while(l <= r) {
			mid = (l + r) / 2;
			int x = Q(mid);
			if(Q(l) * x < 0) {
				r = mid - 1;
			} else if(x * Q(r) < 0) {
				l = mid + 1;
			}
		}
		System.out.println(""! -1\n"");
		System.out.flush();
		cin.close();
	}
}
",2,1019_B,CODEFORCES,1257,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.*;
import java.util.*;

public class Main {

    private static final long MOD = 998244353;

    static int[] readArray(int size, InputReader in, boolean subOne) {
        int[] a = new int[size];
        for (int i = 0; i < size; i++) {
            a[i] = in.nextInt() + (subOne ? -1 : 0);
        }
        return a;
    }

    static long[] readLongArray(int size, InputReader in) {
        long[] a = new long[size];
        for (int i = 0; i < size; i++) {
            a[i] = in.nextLong();
        }
        return a;
    }

    static void sortArray(int[] a) {
        Random random = new Random();

        for (int i = 0; i < a.length; i++) {
            int randomPos = random.nextInt(a.length);
            int t = a[i];
            a[i] = a[randomPos];
            a[randomPos] = t;
        }
        Arrays.sort(a);
    }


    public static void main(String[] args) throws FileNotFoundException {
//        InputReader in = new InputReader(new FileInputStream(""input.txt""));
//        PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(""milkvisits.out"")));
//
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

        int n = in.nextInt();
        if (n / 2 % 2 != 0) {
            out.println(""! -1"");
            out.flush();
            out.close();
            return;
        }

        int[] a = new int[n];
        Arrays.fill(a, Integer.MAX_VALUE);

        int l1 = 0;
        int r1 = l1 + n / 2;

        int l2 = r1;
        int r2 = n;

        int ans = -1;

        while (true) {
            getValue(in, out, a, l1);
            getValue(in, out, a, r1);

            getValue(in, out, a, l2);
            getValue(in, out, a, r2 % n);

            if (a[l1] == a[l2]) {
                ans = l1;
                break;
            }
            if (a[r1] == a[r2 % n]) {
                ans = r1;
                break;
            }

            int m1 = (l1 + r1) / 2;
            getValue(in, out, a, m1);

            int m2 = (l2 + r2) / 2;
            getValue(in, out, a, m2);

            if (a[m1] == a[m2]) {
                ans = m1;
                break;
            }

            if ((a[l1] <= a[m1] && a[l2] <= a[m2]) || (a[l1] >= a[m1] && a[l2] >= a[m2])) {
                if (a[l1] <= a[l2] && a[m1] >= a[m2]) {
                    r1 = m1;
                    r2 = m2;
                    continue;
                }

                if (a[l1] >= a[l2] && a[m1] <= a[m2]) {
                    r1 = m1;
                    r2 = m2;
                    continue;
                }
            }

            if (a[l1] <= a[m1] && a[l2] >= a[m2] && a[l1] <= a[l2] && a[m1] >= a[m2]){
                r1 = m1;
                r2 = m2;
                continue;
            }

            if (a[l1] >= a[m1] && a[l2] <= a[m2] && a[l1] >= a[l2] && a[m1] <= a[m2]){
                r1 = m1;
                r2 = m2;
                continue;
            }

            l1 = m1;
            l2 = m2;
        }
        out.println(""! "" + (ans + 1));

        out.close();
    }

    private static void getValue(InputReader in, PrintWriter out, int[] a, int l) {
        if (a[l] == Integer.MAX_VALUE) {
            out.println(""? "" + (l + 1));
            out.flush();
            a[l] = in.nextInt();
        }
    }


    private static boolean check(long x, long s, long a, List<Long> divA) {
        int ind = binSearchRight(divA, x, 0, divA.size());
        if (ind >= 0 && ind < divA.size()) {
            long y = a / divA.get(ind);
            return y <= s / x;
        }
        return false;
    }

    static int binSearchRight(List<Long> list, long key, int start, int end) {
        int l = start - 1;
        int r = end;
        while (l < r - 1) {
            int m = (l + r) / 2;
            if (list.get(m) <= key) {
                l = m;
            } else {
                r = m;
            }
        }
        return l;
    }

    private static void outputArray(int[] ans, PrintWriter out, boolean addOne) {
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < ans.length; i++) {
            long an = ans[i] + (addOne ? 1 : 0);
            str.append(an).append(' ');
        }
        out.println(str);
    }

    private static void outputArray(List<Integer> ans, PrintWriter out, boolean addOne) {
        StringBuilder str = new StringBuilder();
        for (int j = 0; j < ans.size(); j++) {
            long i = ans.get(j);
            long an = i + (addOne ? 1 : 0);
            str.append(an);
            if (j < ans.size() - 1) {
                str.append(' ');
            }
        }
        out.println(str);
//        out.flush();
    }

    private static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextString() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public char nextChar() {
            return next().charAt(0);
        }

        public String nextWord() {
            return next();
        }

        private List<Integer>[] readTree(int n) {
            return readGraph(n, n - 1);
        }

        private List<Integer>[] readGraph(int n, int m) {
            List<Integer>[] result = new ArrayList[n];
            for (int i = 0; i < n; i++) {
                result[i] = new ArrayList<>();
            }
            for (int i = 0; i < m; i++) {
                int u = nextInt() - 1;
                int v = nextInt() - 1;
                result[u].add(v);
                result[v].add(u);
            }
            return result;
        }

        private Map<Integer, Long>[] readWeightedGraph(int n, int m) {
            Map<Integer, Long>[] result = new HashMap[n];
            for (int i = 0; i < n; i++) {
                result[i] = new HashMap<>();
            }
            for (int i = 0; i < m; i++) {
                int u = nextInt() - 1;
                int v = nextInt() - 1;
                long w = nextLong();
                result[u].put(v, Math.min(w, result[u].getOrDefault(v, Long.MAX_VALUE)));
                result[v].put(u, Math.min(w, result[v].getOrDefault(u, Long.MAX_VALUE)));
            }
            return result;
        }

    }
}",2,1019_B,CODEFORCES,1263,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author lewin
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        BTheHat solver = new BTheHat();
        solver.solve(1, in, out);
        out.close();
    }

    static class BTheHat {
        InputReader in;
        OutputWriter out;
        int n;

        int ask(int student) {
            student %= n;
            out.println(""? "" + (student + 1));
            out.flush();
            return in.nextInt();
        }

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            this.in = in;
            this.out = out;

            n = in.nextInt();
            int a = ask(0), b = ask(n / 2);
            if ((a + b) % 2 != 0) {
                out.println(""! -1"");
                out.flush();
                return;
            }
            if (a == b) {
                out.println(""! 1"");
                out.flush();
                return;
            }

            int lo = 0, hi = n / 2;
            while (lo < hi) {
                int mid = (lo + hi) / 2;
                int f1 = ask(mid), f2 = ask(mid + n / 2);
                if (f1 == f2) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if ((a > b) == (f1 > f2)) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            out.println(""! "" + (lo + 1));
            out.flush();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1 << 16];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (this.numChars == -1) {
                throw new InputMismatchException();
            } else {
                if (this.curChar >= this.numChars) {
                    this.curChar = 0;

                    try {
                        this.numChars = this.stream.read(this.buf);
                    } catch (IOException var2) {
                        throw new InputMismatchException();
                    }

                    if (this.numChars <= 0) {
                        return -1;
                    }
                }

                return this.buf[this.curChar++];
            }
        }

        public int nextInt() {
            int c;
            for (c = this.read(); isSpaceChar(c); c = this.read()) {
                ;
            }

            byte sgn = 1;
            if (c == 45) {
                sgn = -1;
                c = this.read();
            }

            int res = 0;

            while (c >= 48 && c <= 57) {
                res *= 10;
                res += c - 48;
                c = this.read();
                if (isSpaceChar(c)) {
                    return res * sgn;
                }
            }

            throw new InputMismatchException();
        }

        public static boolean isSpaceChar(int c) {
            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void println(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

        public void flush() {
            writer.flush();
        }

    }
}

",2,1019_B,CODEFORCES,1251,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
public class B {
    public static PrintWriter out;
    public static BufferedReader bf;
    public static int n;
    public static int[] a;
    public static void main(String[] args) throws Exception {
        bf = new BufferedReader(new InputStreamReader(System.in));
        // Scanner scan = new Scanner(System.in);
        out = new PrintWriter(new OutputStreamWriter(System.out));
        n = Integer.parseInt(bf.readLine());
        a = new int[n];
        Arrays.fill(a, Integer.MAX_VALUE);
        if((n/2) % 2 != 0) {
          out.println(""! "" + (-1));
          out.flush();
          out.close(); System.exit(0);
        }

        ask(0);
        ask(opp(0));

        int low = 0;
        int high = opp(0);
        while(true) {
          int test = (low + high)/2;
          ask(test);
          ask(opp(test));
          int l_1 = a[low];
          int l_2 = a[test];
          int r_1 = a[opp(low)];
          int r_2 = a[opp(test)];
          if(1L*(l_1 - r_1)*(l_2 - r_2) < 0L) {
            high = test;
          }
          else low = test;
        }

        // StringTokenizer st = new StringTokenizer(bf.readLine());
        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());
        // int n = Integer.parseInt(st.nextToken());
        // int n = scan.nextInt();

        //out.close(); System.exit(0);
    }
    public static int ask(int i) throws Exception { // 0 thru n-1;
      out.println(""? "" + (i+1));
      out.flush();
      int k = Integer.parseInt(bf.readLine());
      a[i] = k;
      if(a[i] == a[opp(i)]) {
        out.println(""! "" + (i+1));
        out.flush();
        out.close(); System.exit(0);
      }

      return k;
    }
    public static int opp(int k) {
      return ((k + n/2) % n);
    }
}
",2,1019_B,CODEFORCES,1249,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            if (BValue(low) == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            int fSign = Integer.signum(BValue(low));
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int mSign = Integer.signum(BValue(mid));
                if (mSign == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (mSign == -fSign) {
                    high = mid;
                } else {
                    low = mid;
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",2,1019_B,CODEFORCES,1246,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Div1_503B {

	public static void main(String[] args) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		int N = Integer.parseInt(reader.readLine());
		printer.println(""? 1"");
		printer.flush();
		int v1 = Integer.parseInt(reader.readLine());

		printer.println(""? "" + (1 + N / 2));
		printer.flush();
		int v2 = Integer.parseInt(reader.readLine());

		if ((v1 + v2) % 2 != 0) {
			printer.println(""! -1"");
			printer.close();
			return;
		}

		if (v1 == v2) {
			printer.println(""! 1"");
			printer.close();
			return;
		}
		boolean less = v1 < v2;

		int low = 1;
		int high = (1 + N / 2);

		while (low != high) {
			int mid = (low + high) >> 1;

			printer.println(""? "" + mid);
			printer.flush();
			int r1 = Integer.parseInt(reader.readLine());

			int q2 = (mid + N / 2);
			if (q2 > N) {
				q2 -= N;
			}
			printer.println(""? "" + q2);
			printer.flush();
			int r2 = Integer.parseInt(reader.readLine());

			if (r1 == r2) {
				printer.println(""! "" + mid);
				printer.close();
				return;
			}

			if (r1 < r2 == less) {
				low = mid + 1;
			} else {
				high = mid - 1;
			}
		}
		printer.println(""! "" + low);
		printer.close();
		return;
	}
}
",2,1019_B,CODEFORCES,1259,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            if (BValue(low) == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            boolean value = BValue(low) > 0;
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int BVal = BValue(mid);
                if (BVal == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (value) {
                    if (BVal < 0) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                } else {
                    if (BVal > 0) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",2,1019_B,CODEFORCES,1245,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author kessido
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        BTheHat solver = new BTheHat();
        solver.solve(1, in, out);
        out.close();
    }

    static class BTheHat {
        PrintWriter out;
        InputReader in;
        int n;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            this.out = out;
            this.in = in;
            n = in.NextInt();
            int desiredPair = -1;
            int result = query(1);
            if (result != 0) {
                int l = 2, r = 1 + n / 2;
                while (l < r) {
                    int m = (l + r) / 2;
                    int mRes = query(m);
                    if (mRes == 0) {
                        desiredPair = m;
                        break;
                    } else if (mRes == result) {
                        l = m + 1;
                    } else {
                        r = m;
                    }
                }
            } else {
                desiredPair = 1;
            }
            out.println(""! "" + desiredPair);
        }

        private int query(int i) {
            int iV = queryValue(i);
            int iN2V = queryValue(i + n / 2);
            if (iV < iN2V) {
                return -1;
            } else if (iV > iN2V) {
                return 1;
            }
            return 0;
        }

        private int queryValue(int i) {
            out.println(""? "" + i);
            out.flush();
            return in.NextInt();
        }

    }

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine(), "" \t\n\r\f,"");
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int NextInt() {
            return Integer.parseInt(next());
        }

    }
}

",2,1019_B,CODEFORCES,1247,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author ilyakor
 */
public class Main {

  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    TaskB solver = new TaskB();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskB {

    int n;

    public void solve(int testNumber, InputReader in, OutputWriter out) {
      n = in.nextInt();
      int base = calc(in, out, 0);
      if (base == 0) {
        out.printLine(""! 1"");
        out.flush();
        return;
      }
      if (Math.abs(base) % 2 != 0) {
        out.printLine(""! -1"");
        out.flush();
        return;
      }
      int down = 0, up = n / 2;
      int sdown = base < 0 ? -1 : 1;
      int sup = up < 0 ? -1 : 1;
      while (up - down > 1) {
        int t = (up + down) / 2;
        int cur = calc(in, out, t);
        if (cur == 0) {
          out.printLine(""! "" + (t + 1));
          out.flush();
          return;
        }
        int scur = cur < 0 ? -1 : 1;
        if (scur == sdown) {
          down = t;
        } else {
          up = t;
        }
      }
      throw new RuntimeException();
    }

    private int calc(InputReader in, OutputWriter out, int val) {
      out.printLine(""? "" + (val + 1));
      out.flush();
      int res1 = in.nextInt();
      out.printLine(""? "" + ((val + n / 2) % n + 1));
      out.flush();
      int res2 = in.nextInt();
      return res1 - res2;
    }

  }

  static class OutputWriter {

    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void close() {
      writer.close();
    }

    public void flush() {
      writer.flush();
    }

  }

  static class InputReader {

    private InputStream stream;
    private byte[] buffer = new byte[10000];
    private int cur;
    private int count;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public static boolean isSpace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int read() {
      if (count == -1) {
        throw new InputMismatchException();
      }
      try {
        if (cur >= count) {
          cur = 0;
          count = stream.read(buffer);
          if (count <= 0) {
            return -1;
          }
        }
      } catch (IOException e) {
        throw new InputMismatchException();
      }
      return buffer[cur++];
    }

    public int readSkipSpace() {
      int c;
      do {
        c = read();
      } while (isSpace(c));
      return c;
    }

    public int nextInt() {
      int sgn = 1;
      int c = readSkipSpace();
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new InputMismatchException();
        }
        res = res * 10 + c - '0';
        c = read();
      } while (!isSpace(c));
      res *= sgn;
      return res;
    }

  }
}

",2,1019_B,CODEFORCES,1262,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class B {
	
	public static void main(String[] args) throws IOException {
		MyScanner sc = new MyScanner();
		PrintWriter out = new PrintWriter(System.out);
		int N = sc.nextInt();
		if (N / 2 % 2 == 1) {
			output(-1, out);
		} else {
			int half = N / 2;
			int l = 1, r = half;
			int first = query(half, out, sc);
			int next = query(2 * half, out, sc);
			if (first == next) {
				output(half, out);
				return;
			}
			boolean less = first < next;
			while (l + 1 < r) {
				int med = (l + r) / 2;
				first = query(med, out, sc);
				next = query(med + half, out, sc);
				if (first == next) {
					output(med, out);
					return;
				} else if (first < next == less) {
					r = med;
				} else {
					l = med + 1;
				}
			}
			output(l, out);
		}
	}
	
	static int query(int pos, PrintWriter out, MyScanner sc) {
		out.println(""? "" + pos);
		out.flush();
		return sc.nextInt();
	}
	
	static void output(int pos, PrintWriter out) {
		out.println(""! "" + pos);
		out.flush();
	}
	
	static class MyScanner {
		private BufferedReader br;
		private StringTokenizer tokenizer;
		
		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}
		
		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
			return Long.parseLong(next());
		}
	}
}
",2,1019_B,CODEFORCES,1254,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"//package round503;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class B2 {
	Scanner in;
	PrintWriter out;
	String INPUT = """";
	
	// 12123432
	// 12343212
	
	int qc = 0;
	int n;
	
	int[] table;
	
	int val(int x)
	{
		if(table[x] != Integer.MIN_VALUE)return table[x];
		if(qc > 60)throw new RuntimeException();
		out.println(""? "" + (x+1));
		out.flush();
		table[x] = ni();
		
		if(table[x] == table[(x+table.length/2) % table.length]){
			if(x >= n/2)x -= n/2;
			out.println(""! "" + (x+1));
			out.flush();
			throw new IllegalStateException();
		}
		return table[x];
	}
	
	void solve()
	{
		n = ni();
		if(n % 4 != 0){
			out.println(""! -1"");
			out.flush();
			return;
		}
		table = new int[n];
		Arrays.fill(table, Integer.MIN_VALUE);
		Random gen = new Random(1);
		try{
			outer:
			while(true){
				int pu = gen.nextInt(n);
				int pd = (pu+n/2)%n;
				int pl = (pu + gen.nextInt(n/2-1)+1)%n;
				int pr = (pl+n/2)%n;
				
				int vu = val(pu), vd = val(pd);
				int vl = val(pl), vr = val(pr);
				if(cross(vu, vl, vd, vr)){
				}else if(cross(vu, vr, vd, vl)){
					int npu = pr, npl = pu;
					int npd = pl, npr = pd;
					pu = npu; pl = npl;
					pd = npd; pr = npr;
					vu = val(pu);
					vl = val(pl);
					vd = val(pd);
					vr = val(pr);
				}else{
					continue outer;
				}
				// u-l d-r
				while(true){
					int pul = h(pu, pl, n);
					int vul = val(pul);
					int pdr = h(pd, pr, n);
					int vdr = val(pdr);
					if(cross(vul, vu, vdr, vd)){
						pl = pul; vl = vul;
						pr = pdr; vr = vdr;
					}else{
						pu = pul; vu = vul;
						pd = pdr; vd = vdr;
					}
				}
			}
		}catch(IllegalStateException e)
		{
		}
	}
	
	int h(int a, int b, int n)
	{
		if(a > b){
			b += n;
		}
		int u = (a+b)/2;
		if(u >= n)u -= n;
		return u;
	}
	
	boolean cross(int a, int b, int c, int d)
	{
		return Integer.signum(c-a) != Integer.signum(d-b);
	}
	
	void run() throws Exception
	{
		in = oj ? new Scanner(System.in) : new Scanner(INPUT);
		out = new PrintWriter(System.out);

		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception
	{
		new B2().run();
	}
	
	int ni() { return Integer.parseInt(in.next()); }
	long nl() { return Long.parseLong(in.next()); }
	double nd() { return Double.parseDouble(in.next()); }
	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
// 
",2,1019_B,CODEFORCES,1248,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        MyInput in = new MyInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        int n;
        MyInput in;
        PrintWriter out;

        public void solve(int testNumber, MyInput in, PrintWriter out) {
            this.in = in;
            this.out = out;

            n = in.nextInt();

            if (n / 2 % 2 == 1) {
                answer(-1);
                return;
            }

            int low = 0, high = n / 2;
            int diff = query(low + n / 2) - query(low);
            while (diff != 0) {
                int mid = (low + high) / 2;
                int d = query(mid + n / 2) - query(mid);
                if (d == 0 || diff > 0 == d > 0) {
                    diff = d;
                    low = mid;
                } else {
                    high = mid;
                }
            }
            answer(low);
        }

        int query(int i) {
            out.println(""? "" + (i % n + 1));
            out.flush();
            return in.nextInt();
        }

        void answer(int i) {
            out.println(""! "" + (i < 0 ? i : (i % n + 1)));
        }

    }

    static class MyInput {
        private final BufferedReader in;
        private static int pos;
        private static int readLen;
        private static final char[] buffer = new char[1024 * 8];
        private static char[] str = new char[500 * 8 * 2];
        private static boolean[] isDigit = new boolean[256];
        private static boolean[] isSpace = new boolean[256];
        private static boolean[] isLineSep = new boolean[256];

        static {
            for (int i = 0; i < 10; i++) {
                isDigit['0' + i] = true;
            }
            isDigit['-'] = true;
            isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
            isLineSep['\r'] = isLineSep['\n'] = true;
        }

        public MyInput(InputStream is) {
            in = new BufferedReader(new InputStreamReader(is));
        }

        public int read() {
            if (pos >= readLen) {
                pos = 0;
                try {
                    readLen = in.read(buffer);
                } catch (IOException e) {
                    throw new RuntimeException();
                }
                if (readLen <= 0) {
                    throw new MyInput.EndOfFileRuntimeException();
                }
            }
            return buffer[pos++];
        }

        public int nextInt() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            int ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public char nextChar() {
            while (true) {
                final int c = read();
                if (!isSpace[c]) {
                    return (char) c;
                }
            }
        }

        int reads(int len, boolean[] accept) {
            try {
                while (true) {
                    final int c = read();
                    if (accept[c]) {
                        break;
                    }
                    if (str.length == len) {
                        char[] rep = new char[str.length * 3 / 2];
                        System.arraycopy(str, 0, rep, 0, str.length);
                        str = rep;
                    }
                    str[len++] = (char) c;
                }
            } catch (MyInput.EndOfFileRuntimeException e) {
            }
            return len;
        }

        static class EndOfFileRuntimeException extends RuntimeException {
        }

    }
}

",2,1019_B,CODEFORCES,1252,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        int N;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            N = in.nextInt();
            int low = 1;
            int lowVal = getval(1, out, in);
            int high = N / 2 + 1;
            int highVal = -lowVal;
            if (Math.abs(lowVal) % 2 == 1) {
                out.println(""! -1"");
                out.flush();
            } else {
                while (low < high) {
                    int mid = (low + high) / 2;
                    int a = getval(mid, out, in);
                    if (Integer.signum(a) == 0) {
                        out.println(""! "" + mid);
                        out.flush();
                        return;
                    } else {
                        if (Integer.signum(a) == Integer.signum(lowVal)) {
                            low = mid + 1;
                        } else {
                            high = mid;
                        }
                    }
                }
                out.println(""! "" + low);
                out.flush();
            }
        }

        int getval(int i, PrintWriter out, InputReader in) {
            out.println(""? "" + i);
            out.flush();
            int a = in.nextInt();
            out.println(""? "" + (i + N / 2));
            out.flush();
            int b = in.nextInt();
            return a - b;
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",2,1019_B,CODEFORCES,1256,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.util.*;
import java.io.*;

public class CFB {
    static int n;
    static FastScanner in;
    public static void main(String[] args) throws Exception {
        in = new FastScanner(System.in);
        n = in.nextInt();
        int a = query(1);
        if(((a % 2)+2) % 2== 1){
            System.out.println(""! -1"");
            return;
        }
        if(a == 0){
            System.out.println(""! 1"");
            return;
        }
        bins(1 , n/2 + 1 , a , -a);
    }
    static void bins(int lo , int hi , int losign , int hisign){
        int mid = (lo + hi)/2;
        int k = query(mid);
        if(k == 0){
            System.out.println(""! "" + mid);
            System.exit(0);
        }
        if(k > 0 && losign > 0 || k < 0 && losign < 0){
            bins(mid , hi , k , hisign);
        }
        else {
            bins(lo , mid , losign , k);
        }

    }
    static int query(int i){
        System.out.println(""? "" + i);
        int a1 = in.nextInt();
        System.out.println(""? "" + ((i + (n/2)) > n ? (i - (n/2)) : (i + (n/2))));
        int a2 = in.nextInt();
        return a1 - a2;
    }

    static class FastScanner {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public FastScanner(InputStream stream) {
            this.stream = stream;
        }

        int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) return -1;
            }
            return buf[curChar++];
        }

        boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        boolean isEndline(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c)) c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public String nextLine() {
            int c = read();
            while (isEndline(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndline(c));
            return res.toString();
        }
    }
}
",2,1019_B,CODEFORCES,1250,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public class B {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));

        Solver solver = new Solver();
        solver.solve(in, out);
        out.close();
    }

    static class Solver {
        int n;
        int n2;
        InputReader in;
        PrintWriter out;

        public void solve(InputReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.readInt();
            n2 = n/2;

            int res = find();
            out.print(""! "");
            out.println(res);
        }

        public int find() {
            if (n%4 != 0) return -1;
            int c = compare(0);
            if (c == 0) return 1;
            int s = 1;
            int f = n2-1;
            if (c > 0) {
                s = n2+1;
                f = n-1;
            }
            while (s <= f) {
                int m = (s+f)/2;
                int v = compare(m);
                if (v == 0) return m+1;
                else if (v < 0) s = m+1;
                else f = m-1;
            }
            return -1;
        }

        public int compare(int z) {
            out.print(""? "");
            out.println(z+1);
            out.flush();
            int r1 = in.readInt();
            out.print(""? "");
            out.println((z+n2)%n+1);
            out.flush();
            int r2 = in.readInt();
            return r1-r2;
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            this.reader = new BufferedReader(new InputStreamReader(stream));
        }

        public String read() {
            try {
                if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                    tokenizer = new StringTokenizer(reader.readLine());
                }
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
            return tokenizer.nextToken();
        }

        public int readInt() {
            return Integer.parseInt(read());
        }

        public long readLong() {
            return Long.parseLong(read());
        }

        public void readIntArrays(int[]... arrays) {
            for (int i = 0; i < arrays[0].length; i++) {
                for (int j = 0; j < arrays.length; j++) {
                    arrays[j][i] = readInt();
                }
            }
        }
    }

}",2,1019_B,CODEFORCES,1243,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.StringTokenizer;

public class Solution{
	
	static final int N = (int)5e5+10;
	static int[] cnt;
	static ArrayList<Integer>[] seg;
	static int[] last;
	
	
    public static void main(String[] args) throws IOException {
    	
		
    	FastScanner fs = new FastScanner();
    	PrintWriter out = new PrintWriter(System.out);
    	
    	
    		
    	int tt = 1;
    	while(tt-->0) {
    		
    		int n = fs.nextInt(), c = fs.nextInt();
    		
    		cnt = new int[N];
    		
    		seg = new ArrayList[N];
    		for(int i=0;i<N;i++) seg[i] = new ArrayList<Integer>();
    		
    		last = new int[N]; Arrays.fill(last, -1);
    		
    		int[] a = new int[n];
    		
    		for(int i=0;i<n;i++) {
    			a[i] = fs.nextInt();
    			cnt[i+1] = cnt[i] + ((a[i]==c)?1:0);
    		}
    		
    		
    		for(int i=0;i<n;i++) {
    			seg[a[i]].add(-getCnt(last[a[i]]+1, i-1));
    			last[a[i]] = i;
    			seg[a[i]].add(1);
    		}
    		
    		
    		int ans = 0;
    		
    		for(int i=0;i<N;i++) {
    			if(i==c) continue;
    			if(seg[i].isEmpty()) continue;
    			ans = Math.max(ans, maxSeg(seg[i]));
    		}
    		
    		out.println(getCnt(0, n-1) + ans);
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    	}
    	
    	out.close();
    		
    }
    

    static int getCnt(int l, int r) {
    	return cnt[r+1]-cnt[l];
    }
    
    
    static int maxSeg(ArrayList<Integer> l) {
    	int max = 0;
    	int cur = 0;
    	for(int a: l) {
    		cur = Math.max(0, cur + a);
    		max = Math.max(max, cur);
    	}
    	return max;
    }
    
    
    
    static final Random random=new Random();
    
    static <T> void shuffle(T[] arr) {
    	int n = arr.length;
    	for(int i=0;i<n;i++	) {
    		int k = random.nextInt(n);
    		T temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;
    	}
    }
    
    	
    static void ruffleSort(int[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); int temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
    
    static void ruffleSort(long[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); long temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
   
  
    
    static void reverse(int[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    static void reverse(long[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		long temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    
    static <T> void reverse(T[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++) {
    		T temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    	
    	
    static class FastScanner{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer("""");
     
    	public String next(){
    		while(!st.hasMoreElements()){
    			try{
    				st = new StringTokenizer(br.readLine());
    			} catch(IOException e){
    				e.printStackTrace();
    			}
    		}
    		return st.nextToken();
    	}
    		
    	public String nextLine() throws IOException {
    		return br.readLine();
    	}
    		
    	public int nextInt(){
    		return Integer.parseInt(next());
    	}
     
    	public int[] readArray(int n){
    		int[] a = new int[n];
    		for(int i=0;i<n;i++)
    			a[i] = nextInt();
    		return a;
    	}
    		
    	public long nextLong() {
    		return Long.parseLong(next());
    	}
    		
    	public char nextChar() {
    		return next().toCharArray()[0];
    	}
    }
   	
}
",3,1082_E,CODEFORCES,2101,Increasing Frequency,"You are given array $$$a$$$ of length $$$n$$$. You can choose one segment $$$[l, r]$$$ ($$$1 \le l \le r \le n$$$) and integer value $$$k$$$ (positive, negative or even zero) and change $$$a_l, a_{l + 1}, \dots, a_r$$$ by $$$k$$$ each (i.e. $$$a_i := a_i + k$$$ for each $$$l \le i \le r$$$).
What is the maximum possible number of elements with value $$$c$$$ that can be obtained after one such operation?
The first line contains two integers $$$n$$$ and $$$c$$$ ($$$1 \le n \le 5 \cdot 10^5$$$, $$$1 \le c \le 5 \cdot 10^5$$$) — the length of array and the value $$$c$$$ to obtain.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 5 \cdot 10^5$$$) — array $$$a$$$.
Print one integer — the maximum possible number of elements with value $$$c$$$ which can be obtained after performing operation described above.
","input
In the first example we can choose any segment and $$$k = 0$$$. The array will stay same.
output
In the second example we can choose segment $$$[1, 3]$$$ and $$$k = -4$$$. The array will become $$$[2, -2, 2]$$$.
","binarysearch, dp, greedy"
"/**
 * Created by Aminul on 3/14/2019.
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

import static java.lang.Math.max;

public class E_2 {
    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = in.nextInt(), k = in.nextInt(), N = (int) 5e6 + 1;
        int left = 0, right = 0;
        int a[] = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = in.nextInt();
            if (a[i] == k) left++;
        }
        int f[] = new int[N + 1];
        int ans = 0;
        for (int i = n; i >= 1; i--) {
            if (a[i] == k) left--;
            f[a[i]]++;
            f[a[i]] = max(f[a[i]], 1 + right);
            ans = max(ans, f[a[i]] + left);
            if (a[i] == k) right++;
        }
        pw.println(ans);
        pw.close();
    }

    static void debug(Object... obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;

        public FastReader(InputStream is) {
            this.is = is;
        }

        public int readByte() {
            if (lenbuf == -1) throw new InputMismatchException();
            if (ptrbuf >= lenbuf) {
                ptrbuf = 0;
                try {
                    lenbuf = is.read(inbuf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (lenbuf <= 0) return -1;
            }
            return inbuf[ptrbuf++];
        }

        public int nextInt() {
            int num = 0, b;
            boolean minus = false;
            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            while (true) {
                if (b >= '0' && b <= '9') {
                    num = (num << 3) + (num << 1) + (b - '0');
                } else {
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }
    }
}",3,1082_E,CODEFORCES,2103,Increasing Frequency,"You are given array $$$a$$$ of length $$$n$$$. You can choose one segment $$$[l, r]$$$ ($$$1 \le l \le r \le n$$$) and integer value $$$k$$$ (positive, negative or even zero) and change $$$a_l, a_{l + 1}, \dots, a_r$$$ by $$$k$$$ each (i.e. $$$a_i := a_i + k$$$ for each $$$l \le i \le r$$$).
What is the maximum possible number of elements with value $$$c$$$ that can be obtained after one such operation?
The first line contains two integers $$$n$$$ and $$$c$$$ ($$$1 \le n \le 5 \cdot 10^5$$$, $$$1 \le c \le 5 \cdot 10^5$$$) — the length of array and the value $$$c$$$ to obtain.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 5 \cdot 10^5$$$) — array $$$a$$$.
Print one integer — the maximum possible number of elements with value $$$c$$$ which can be obtained after performing operation described above.
","input
In the first example we can choose any segment and $$$k = 0$$$. The array will stay same.
output
In the second example we can choose segment $$$[1, 3]$$$ and $$$k = -4$$$. The array will become $$$[2, -2, 2]$$$.
","binarysearch, dp, greedy"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        EIncreasingFrequency solver = new EIncreasingFrequency();
        solver.solve(1, in, out);
        out.close();
    }

    static class EIncreasingFrequency {
        int n;
        int c;
        int[] arr;
        ArrayList<Integer>[] lists;
        int[] countC;

        public void readInput(Scanner sc) {
            n = sc.nextInt();
            c = sc.nextInt();
            arr = new int[n];
            lists = new ArrayList[(int) 5e5 + 1];
            for (int i = 0; i < lists.length; i++)
                lists[i] = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
                if (arr[i] != c)
                    lists[arr[i]].add(i);
            }
        }

        public void solve(int testNumber, Scanner sc, PrintWriter pw) {
            int q = 1;
            while (q-- > 0) {
                readInput(sc);
                int max = 0;
                countC = new int[n];
                for (int i = 0; i < n; i++) {
                    if (arr[i] == c)
                        countC[i] = 1;
                    if (i != 0)
                        countC[i] += countC[i - 1];
                }
                for (int i = 0; i < lists.length; i++) {
                    if (lists[i].isEmpty())
                        continue;
                    max = Math.max(max, maxSubSeg(lists[i]));
                }
                pw.println(max + countC[n - 1]);
            }
        }

        private int maxSubSeg(ArrayList<Integer> list) {
            int sum = 1;
            int max = 1;
            for (int i = 1; i < list.size(); i++) {
                int idx = list.get(i);
                int prev = list.get(i - 1);
                int remove = countC[idx] - countC[prev];
                sum += -remove + 1;
                if (sum <= 0)
                    sum = 1;
                max = Math.max(max, sum);
            }
            return max;
        }

    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public String next() {
            try {
                while (st == null || !st.hasMoreTokens())
                    st = new StringTokenizer(br.readLine());
                return st.nextToken();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",3,1082_E,CODEFORCES,2102,Increasing Frequency,"You are given array $$$a$$$ of length $$$n$$$. You can choose one segment $$$[l, r]$$$ ($$$1 \le l \le r \le n$$$) and integer value $$$k$$$ (positive, negative or even zero) and change $$$a_l, a_{l + 1}, \dots, a_r$$$ by $$$k$$$ each (i.e. $$$a_i := a_i + k$$$ for each $$$l \le i \le r$$$).
What is the maximum possible number of elements with value $$$c$$$ that can be obtained after one such operation?
The first line contains two integers $$$n$$$ and $$$c$$$ ($$$1 \le n \le 5 \cdot 10^5$$$, $$$1 \le c \le 5 \cdot 10^5$$$) — the length of array and the value $$$c$$$ to obtain.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 5 \cdot 10^5$$$) — array $$$a$$$.
Print one integer — the maximum possible number of elements with value $$$c$$$ which can be obtained after performing operation described above.
","input
In the first example we can choose any segment and $$$k = 0$$$. The array will stay same.
output
In the second example we can choose segment $$$[1, 3]$$$ and $$$k = -4$$$. The array will become $$$[2, -2, 2]$$$.
","binarysearch, dp, greedy"
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] p = new int[3][2];
        p[0][0] = sc.nextInt();
        p[0][1] = sc.nextInt();
        p[1][0] = sc.nextInt();
        p[1][1] = sc.nextInt();
        p[2][0] = sc.nextInt();
        p[2][1] = sc.nextInt();
        int dx0 = Math.abs(p[0][0] - p[1][0]);
        int dx1 = Math.abs(p[1][0] - p[2][0]);
        int dx2 = Math.abs(p[2][0] - p[0][0]);
        int x_max = Math.max(Math.max(dx0, dx1), dx2);
        int dy0 = Math.abs(p[0][1] - p[1][1]);
        int dy1 = Math.abs(p[1][1] - p[2][1]);
        int dy2 = Math.abs(p[2][1] - p[0][1]);
        int y_max = Math.max(Math.max(dy0, dy1), dy2);
        int total = x_max + y_max + 1;
        System.out.println(total);
        int count = 0;
        int x = -1, y = -1;
        for (int i = 0; i < 3; i++) {
            x = p[i][0];
            y = p[i][1];
            int x1 = p[(i + 1) % 3][0], y1 = p[(i + 1) % 3][1];
            int x2 = p[(i + 2) % 3][0], y2 = p[(i + 2) % 3][1];
            do {
                if ((x - x1) * (x - x2) > 0 || (y - y1) * (y - y2) > 0) {
                    System.out.println(x + "" "" + y);
                    count++;
                }
                if ((x - x1) * (x - x2) > 0) {
                    x += (x - x1 > 0) ? -1 : +1;
                } else if ((y - y1) * (y - y2) > 0) {
                    y += (y - y1 > 0) ? -1 : +1;
                } else {
                    break;
                }
            } while (true);
        }
        if (count < total) {
            System.out.println(x + "" "" + y);
        }
    }
}

		  					       	   	  			 			",4,1086_A,CODEFORCES,2905,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"import java.util.*;
import java.io.*;

public class Three{
    public static void main(String[] args) {
	Scanner in = new Scanner (System.in);
	PrintWriter out = new PrintWriter(System.out);

	pair[] points = new pair [3];
	for (int i = 0; i < 3; ++i) {
	    int x = in.nextInt();
	    int y = in.nextInt();
	    points[i] = new pair (x, y);
	}

	Arrays.sort(points);

	int MaxY = Math.max(Math.max(points[0].y, points[1].y), points[2].y);
	int MinY = Math.min(Math.min(points[0].y, points[1].y), points[2].y);

	out.println(MaxY - MinY + points[2].x - points[0].x + 1);
	for (int i = MinY; i <= MaxY; ++i)
	    out.println(points[1].x + "" "" + i);
	for (int i = points[0].x; i < points[1].x; ++i)
	    out.println(i + "" "" + points[0].y);
	for (int i = points[1].x + 1; i <= points[2].x; ++i)
	    out.println(i + "" "" + points[2].y);
	
	out.close();
    }

    public static class pair implements Comparable<pair> {
	int x, y;
	public pair (int x_, int y_) {
	    x = x_; y = y_;
	}

	@Override
	public int compareTo(pair o) {
	    return x - o.x;
	}
    }
}
",4,1086_A,CODEFORCES,2903,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"import java.io.*;
import java.util.*;

public class Main {
    public static point[] points;

    static class point implements Comparable<point> {
        int x, y;

        public point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public int compareTo(point o) {
            if (this.x  > o.x ) {
                return 1;
            } else if (this.x  == o.x ) {
                return 0;
            } else {
                return -1;
            }
        }

        @Override
        public String toString() {
            return x + "" "" + y;
        }

        @Override
        public boolean equals(Object obj) {
            point point = (point) obj;
            return Objects.equals(x, point.x) && Objects.equals(y, point.y);
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }

    public static void main(String[] args) throws Exception {
        points = new point[3];
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        for (int i = 0; i < 3; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            points[i] = new point(a, b);
        }

        Arrays.sort(points);

        int lMax = Math.max(Math.max(points[0].y, points[1].y), points[2].y);
        int lMin = Math.min(Math.min(points[0].y, points[1].y), points[2].y);
        int rMax = Math.max(Math.max(points[0].x, points[1].x), points[2].x);
        int rMin = Math.min(Math.min(points[0].x, points[1].x), points[2].x);

        Set<point> sets = new HashSet<>();

        for (int i = lMin; i <= lMax; i++) {
            sets.add(new point(points[1].x, i));
        }
        for (int i = rMin; i <= points[1].x; i++) {
            sets.add(new point(i, points[0].y));
        }
        for (int i = points[1].x; i <= rMax; i++) {
            sets.add(new point(i, points[2].y));
        }
        System.out.println(sets.size());
        for (point i : sets) {
            System.out.println(i);
        }
    }
}

	  			  	 		 	 			  	 	   					",4,1086_A,CODEFORCES,2904,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"import java.io.*;
import java.util.StringTokenizer;
public class Main {
    
    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int N = sc.nextInt();
        long dest = sc.nextLong();
        long max = (long)N * ((long)N + 1L) / 2L;
        if (dest < 2 * N - 1 || dest > max) {
            out.println(""No"");
            out.close();
            return;
        }
        int[] d = new int[N + 1];
        int[] f = new int[N + 1];
        int K = 1;
        for (; K <= N; K++) {
            long dep = 1L, cnt = 1L, c = 1L;
            long t = 1L;
            while (cnt < N) {
                c = c * K;
                dep++;
                t += (dep * Math.min(c, N - cnt));
                cnt += c;
            }
            if (t <= dest) break;
        }
        out.println(""Yes"");
        int dep = 1; long cnt = 1L, c = 1L;
        long t = 1L;
        d[1] = 1;
        while (cnt < N) {
            dep++; c = c * K; 
            long x = (long)N - cnt;
            int min;
            if (c >= x) min = (int)x;
            else min = (int)c;
            d[dep] = min;
            t += (dep * Math.min(c, (long)N - cnt)); cnt += c;
        }
        dest -= t;
        int curDep = dep; int nextDep = dep + 1;
        while (dest > 0) {
            if (d[curDep] <= 1) curDep--;
            d[curDep]--;
            long next = Math.min(nextDep++, dest + curDep);
            dest -= ((int)next - curDep);
            d[(int)next]++;
        }
        int first = 1;
        for (int i = 2; i < nextDep; i++) {
            int p = 0, fn = first - d[i - 1] + 1;
            for (int j = first + 1; j <= first + d[i]; j++) {
                if (p == K) {
                    fn++; p = 0;
                }
                p++; f[j] = fn;
            }
            first += d[i];
        }
        for (int i = 2; i <= N; i++)
            out.format(""%d "", f[i]);
        out.close();
    }
            
        
    static class FastScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;
        
        public FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }
        
        public String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        
        public String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }
        
        public long nextLong() {
            return Long.parseLong(next());
        }
        
        public int nextInt() {
            return Integer.parseInt(next());
        }
        
       /* public double nextDouble() {
            return Double.parseDouble(next());
        }
        
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; ++i) {
                a[i] = nextInt();
            }
            return a;
        }
        
        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }*/
    }
}",4,1098_C,CODEFORCES,2910,Construct a tree,"Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree!
Misha would like to construct a rooted tree with $$$n$$$ vertices, indexed from 1 to $$$n$$$, where the root has index 1. Every other vertex has a parent $$$p_i$$$, and $$$i$$$ is called a child of vertex $$$p_i$$$. Vertex $$$u$$$ belongs to the subtree of vertex $$$v$$$ iff $$$v$$$ is reachable from $$$u$$$ while iterating over the parents ($$$u$$$, $$$p_{u}$$$, $$$p_{p_{u}}$$$, ...). Clearly, $$$v$$$ belongs to its own subtree, and the number of vertices in the subtree is called the size of the subtree. Misha is only interested in trees where every vertex belongs to the subtree of vertex $$$1$$$.
Below there is a tree with $$$6$$$ vertices. The subtree of vertex $$$2$$$ contains vertices $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$. Hence the size of its subtree is $$$4$$$. 
The branching coefficient of the tree is defined as the maximum number of children in any vertex. For example, for the tree above the branching coefficient equals $$$2$$$. Your task is to construct a tree with $$$n$$$ vertices such that the sum of the subtree sizes for all vertices equals $$$s$$$, and the branching coefficient is minimum possible.
The only input line contains two integers $$$n$$$ and $$$s$$$ — the number of vertices in the tree and the desired sum of the subtree sizes ($$$2 \le n \le 10^5$$$; $$$1 \le s \le 10^{10}$$$).
If the required tree does not exist, output «No». Otherwise output «Yes» on the first line, and in the next one output integers $$$p_2$$$, $$$p_3$$$, ..., $$$p_n$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$.
","input
Below one can find one of the possible solutions for the first sample case. The sum of subtree sizes equals $$$3 + 1 + 1 = 5$$$, and the branching coefficient equals $$$2$$$.
output
Below one can find one of the possible solutions for the third sample case. The sum of subtree sizes equals $$$6 + 3 + 2 + 1 + 2 + 1 = 15$$$, and the branching coefficient equals $$$2$$$.
","binarysearch, constructivealgorithms, dfsandsimilar, graphs, greedy, trees"
"import java.io.*;
import java.util.*;

public class TestClass
{
    public static void main(String args[])throws Exception
    {
        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb=new StringBuilder();
        String s[]=bu.readLine().split("" "");
        int n=Integer.parseInt(s[0]),i;
        long m=Long.parseLong(s[1]);
        int ans=0;
        if(m*2>1l*n*(n+1)) ans=-1;
        else if(m<n*2-1) ans=-1;
        if(ans==-1) {System.out.print(""No""); return;}

        for(i=1;i<=n;i++)
        {
            long dep=1,cnt=1,t=1,c=1;
            while(cnt<n)
            {
                c=c*i;
                dep++;
                t+=dep*Math.min(c,n-cnt);
                cnt+=c;
            }
            if(t<=m)break;
        }

        int a[]=new int[n+1],dep=1,cnt=1;
        long t=1,c=1;
        a[1]=1;

        while(cnt<n)
        {
            dep++;
            c=c*i;
            a[dep]=(int)Math.min(c,n-cnt);
            t+=1l*Math.min(c,n-cnt)*dep;
            cnt+=c;
        }
        m-=t;

        int now=dep,aft=dep+1;
        while(m>0)
        {
            if(a[now]<=1) now--;
            a[now]--;
            long tmp=Math.min(aft++,m+now);
            m-=tmp-now;a[(int)tmp]++;
        }
        int lst=1,p=i,fa[]=new int[n+1];
        for(i=2;i<aft;i++)
        {
            int nowp=lst-a[i-1]+1,nowk=0;
            for(int j=lst+1;j<=lst+a[i];j++)
            {
                if(nowk==p) {nowp++; nowk=0;}
                nowk++;
                fa[j]=nowp;
            }
            lst+=a[i];
        }
        sb.append(""Yes\n"");
        for(i=2;i<=n;i++)
        sb.append(fa[i]+"" "");
        System.out.print(sb);
    }
}",4,1098_C,CODEFORCES,2909,Construct a tree,"Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree!
Misha would like to construct a rooted tree with $$$n$$$ vertices, indexed from 1 to $$$n$$$, where the root has index 1. Every other vertex has a parent $$$p_i$$$, and $$$i$$$ is called a child of vertex $$$p_i$$$. Vertex $$$u$$$ belongs to the subtree of vertex $$$v$$$ iff $$$v$$$ is reachable from $$$u$$$ while iterating over the parents ($$$u$$$, $$$p_{u}$$$, $$$p_{p_{u}}$$$, ...). Clearly, $$$v$$$ belongs to its own subtree, and the number of vertices in the subtree is called the size of the subtree. Misha is only interested in trees where every vertex belongs to the subtree of vertex $$$1$$$.
Below there is a tree with $$$6$$$ vertices. The subtree of vertex $$$2$$$ contains vertices $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$. Hence the size of its subtree is $$$4$$$. 
The branching coefficient of the tree is defined as the maximum number of children in any vertex. For example, for the tree above the branching coefficient equals $$$2$$$. Your task is to construct a tree with $$$n$$$ vertices such that the sum of the subtree sizes for all vertices equals $$$s$$$, and the branching coefficient is minimum possible.
The only input line contains two integers $$$n$$$ and $$$s$$$ — the number of vertices in the tree and the desired sum of the subtree sizes ($$$2 \le n \le 10^5$$$; $$$1 \le s \le 10^{10}$$$).
If the required tree does not exist, output «No». Otherwise output «Yes» on the first line, and in the next one output integers $$$p_2$$$, $$$p_3$$$, ..., $$$p_n$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$.
","input
Below one can find one of the possible solutions for the first sample case. The sum of subtree sizes equals $$$3 + 1 + 1 = 5$$$, and the branching coefficient equals $$$2$$$.
output
Below one can find one of the possible solutions for the third sample case. The sum of subtree sizes equals $$$6 + 3 + 2 + 1 + 2 + 1 = 15$$$, and the branching coefficient equals $$$2$$$.
","binarysearch, constructivealgorithms, dfsandsimilar, graphs, greedy, trees"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long max = n * (long) (n + 1) / 2;
            long s = in.nextLong();
            if (s > max) {
                out.println(""No"");
                return;
            }
            for (int d = 1; d < n; d++) {
                long thisLevel = 1;
                long min = 1;
                long togo = n - 1;
                int level = 1;
                while (togo > 0) {
                    ++level;
                    thisLevel *= d;
                    long by = Math.min(togo, thisLevel);
                    min += by * level;
                    togo -= by;
                }
                if (min > s) continue;
                int[] p = new int[n];
                p[0] = -1;
                for (int i = 1; i < n; ++i) p[i] = i - 1;
                long got = n * (long) (n + 1) / 2;
                int[] firstByLevel = new int[n + 1];
                int[] nextByLevel = new int[n + 1];
                int[] lastByLevel = new int[n + 1];
                int[] numChildren = new int[n + 1];
                for (int i = 0; i < n; ++i) {
                    firstByLevel[i + 1] = lastByLevel[i + 1] = i;
                    nextByLevel[i] = -1;
                    if (i + 1 < n) ++numChildren[i];
                }
                level = 2;
                for (int i = n - 1; i > 0 && got > s; --i) {
                    while (true) {
                        if (firstByLevel[level - 1] < 0) {
                            ++level;
                            continue;
                        }
                        if (numChildren[firstByLevel[level - 1]] == d) {
                            firstByLevel[level - 1] = nextByLevel[firstByLevel[level - 1]];
                            continue;
                        }
                        break;
                    }
                    int from = i + 1;
                    int to = level;
                    if (from <= to) throw new RuntimeException();
                    int by = (int) Math.min(from - to, got - s);
                    got -= by;
                    to = from - by;
                    if (i != firstByLevel[i + 1]) throw new RuntimeException();
                    firstByLevel[i + 1] = nextByLevel[i];
                    --numChildren[p[i]];
                    p[i] = firstByLevel[to - 1];
                    ++numChildren[p[i]];
                    if (numChildren[p[i]] > d) throw new RuntimeException();
                    nextByLevel[lastByLevel[to]] = i;
                    nextByLevel[i] = -1;
                    lastByLevel[to] = i;
                }
                out.println(""Yes"");
                for (int i = 1; i < n; ++i) {
                    out.print(p[i] + 1);
                    out.print("" "");
                }
                out.println();
                return;
            }
            out.println(""No"");
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }
}

",4,1098_C,CODEFORCES,2911,Construct a tree,"Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree!
Misha would like to construct a rooted tree with $$$n$$$ vertices, indexed from 1 to $$$n$$$, where the root has index 1. Every other vertex has a parent $$$p_i$$$, and $$$i$$$ is called a child of vertex $$$p_i$$$. Vertex $$$u$$$ belongs to the subtree of vertex $$$v$$$ iff $$$v$$$ is reachable from $$$u$$$ while iterating over the parents ($$$u$$$, $$$p_{u}$$$, $$$p_{p_{u}}$$$, ...). Clearly, $$$v$$$ belongs to its own subtree, and the number of vertices in the subtree is called the size of the subtree. Misha is only interested in trees where every vertex belongs to the subtree of vertex $$$1$$$.
Below there is a tree with $$$6$$$ vertices. The subtree of vertex $$$2$$$ contains vertices $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$. Hence the size of its subtree is $$$4$$$. 
The branching coefficient of the tree is defined as the maximum number of children in any vertex. For example, for the tree above the branching coefficient equals $$$2$$$. Your task is to construct a tree with $$$n$$$ vertices such that the sum of the subtree sizes for all vertices equals $$$s$$$, and the branching coefficient is minimum possible.
The only input line contains two integers $$$n$$$ and $$$s$$$ — the number of vertices in the tree and the desired sum of the subtree sizes ($$$2 \le n \le 10^5$$$; $$$1 \le s \le 10^{10}$$$).
If the required tree does not exist, output «No». Otherwise output «Yes» on the first line, and in the next one output integers $$$p_2$$$, $$$p_3$$$, ..., $$$p_n$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$.
","input
Below one can find one of the possible solutions for the first sample case. The sum of subtree sizes equals $$$3 + 1 + 1 = 5$$$, and the branching coefficient equals $$$2$$$.
output
Below one can find one of the possible solutions for the third sample case. The sum of subtree sizes equals $$$6 + 3 + 2 + 1 + 2 + 1 = 15$$$, and the branching coefficient equals $$$2$$$.
","binarysearch, constructivealgorithms, dfsandsimilar, graphs, greedy, trees"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * @author khokharnikunj8
 */

public class Main {
    public static void main(String[] args) {
        new Thread(null, new Runnable() {
            public void run() {
                new Main().solve();
            }
        }, ""1"", 1 << 26).start();
    }

    void solve() {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        FCookies solver = new FCookies();
        solver.solve(1, in, out);
        out.close();
    }

    static class FCookies {
        long[] BIT;
        long[] BIT1;
        int[] cookie;
        int[] time;
        long[] max;
        long T;
        int[][][] G;

        void update(int x, long delta) {
            for (; x <= 1000001; x += x & -x)
                BIT[x] += delta;
        }

        long query(int x) {
            if (x <= 0) return 0;
            long sum = 0;
            for (; x > 0; x -= x & -x)
                sum += BIT[x];
            return sum;
        }

        void update1(int x, long delta) {
            for (; x <= 1000001; x += x & -x)
                BIT1[x] += delta;
        }

        long query1(int x) {
            if (x <= 0) return 0;
            long sum = 0;
            for (; x > 0; x -= x & -x)
                sum += BIT1[x];
            return sum;
        }

        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            BIT = new long[1000001];
            BIT1 = new long[1000001];
            int n = in.scanInt();
            T = in.scanLong();
            cookie = new int[n + 1];
            time = new int[n + 1];
            max = new long[n + 1];
            for (int i = 1; i <= n; i++) cookie[i] = in.scanInt();
            for (int i = 1; i <= n; i++) time[i] = in.scanInt();
            int[] from = new int[n - 1];
            int[] to = new int[n - 1];
            int[] weight = new int[n - 1];
            for (int i = 0; i < n - 1; i++) {
                from[i] = i + 2;
                to[i] = in.scanInt();
                weight[i] = in.scanInt();
            }
            G = CodeHash.packGraphW(from, to, weight, n);
            dfs(1, -1, 0);
            out.println(max[1]);

        }

        private void dfs(int n, int p, long t) {
            update(time[n], ((long) time[n]) * cookie[n]);
            update1(time[n], cookie[n]);
            if (t > T) {
                max[n] = 0;
                update(time[n], -(((long) time[n]) * cookie[n]));
                update1(time[n], -cookie[n]);
                return;
            } else max[n] = findMax(T - t);
            long max1 = 0;
            long max2 = 0;
            for (int[] i : G[n]) {
                if (i[0] == p) continue;
                dfs(i[0], n, t + 2 * i[1]);
                if (max1 <= max[i[0]]) {
                    max2 = max1;
                    max1 = max[i[0]];
                } else if (max2 <= max[i[0]]) {
                    max2 = max[i[0]];
                }
            }
            update(time[n], -(((long) time[n]) * cookie[n]));
            update1(time[n], -cookie[n]);
            if (n != 1) max[n] = Math.max(max[n], max2);
            else max[n] = Math.max(max[n], max1);
        }

        private long findMax(long TT) {
            int index2 = -1;
            {
                int low = 0;
                int high = 1000000;
                while (low <= high) {
                    int mid = (low + high) / 2;
                    if (query(mid) <= TT) {
                        index2 = mid;
                        low = mid + 1;
                    } else {
                        high = mid - 1;
                    }
                }
            }
            if (index2 == -1) return 0;
            if (query(index2) == TT) return query1(index2);
            int index = -1;
            {
                int low = index2 + 1;
                int high = 1000000;
                while (low <= high) {
                    int mid = (low + high) / 2;
                    if (query(mid) > TT) {
                        index = mid;
                        high = mid - 1;
                    } else {
                        low = mid + 1;
                    }
                }
            }
            if (index == -1) return query1(index2);
            long index1 = -1;
            {
                long low = 0;
                long high = query1(index) - query1(index - 1);
                long prev = query(index - 1);
                while (low <= high) {
                    long mid = (low + high) / 2;
                    if (prev + ((mid) * index) <= TT) {
                        index1 = mid;
                        low = mid + 1;
                    } else {
                        high = mid - 1;
                    }
                }
            }
            if (index1 == -1) return 0;
            return query1(index - 1) + index1;

        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int index;
        private BufferedInputStream in;
        private int total;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (index >= total) {
                index = 0;
                try {
                    total = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (total <= 0) return -1;
            }
            return buf[index++];
        }

        public int scanInt() {
            int integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

        public long scanLong() {
            long integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

    }

    static class CodeHash {
        public static int[][][] packGraphW(int[] from, int[] to, int[] w, int n) {
            int[][][] g = new int[n + 1][][];
            int[] p = new int[n + 1];
            for (int i : from) p[i]++;
            for (int i : to) p[i]++;
            for (int i = 0; i <= n; i++) g[i] = new int[p[i]][2];
            for (int i = 0; i < from.length; i++) {
                --p[from[i]];
                g[from[i]][p[from[i]]][0] = to[i];
                g[from[i]][p[from[i]]][1] = w[i];
                --p[to[i]];
                g[to[i]][p[to[i]]][0] = from[i];
                g[to[i]][p[to[i]]][1] = w[i];
            }
            return g;
        }

    }
}",4,1099_F,CODEFORCES,2913,Cookies,"Mitya and Vasya are playing an interesting game. They have a rooted tree with $$$n$$$ vertices, and the vertices are indexed from $$$1$$$ to $$$n$$$. The root has index $$$1$$$. Every other vertex $$$i \ge 2$$$ has its parent $$$p_i$$$, and vertex $$$i$$$ is called a child of vertex $$$p_i$$$.
There are some cookies in every vertex of the tree: there are $$$x_i$$$ cookies in vertex $$$i$$$. It takes exactly $$$t_i$$$ time for Mitya to eat one cookie in vertex $$$i$$$. There is also a chip, which is initially located in the root of the tree, and it takes $$$l_i$$$ time to move the chip along the edge connecting vertex $$$i$$$ with its parent.
Mitya and Vasya take turns playing, Mitya goes first.
Mitya can stop the game at any his turn. Once he stops the game, he moves the chip up to the root, eating some cookies along his way. Mitya can decide how many cookies he would like to eat in every vertex on his way. The total time spent on descend, ascend and eating cookies should not exceed $$$T$$$. Please note that in the end of the game the chip is always located in the root of the tree: Mitya can not leave the chip in any other vertex, even if he has already eaten enough cookies — he must move the chip back to the root (and every move from vertex $$$v$$$ to its parent takes $$$l_v$$$ time).
Find out what is the maximum number of cookies Mitya can eat, regardless of Vasya's actions.
The first line contains two integers $$$n$$$ and $$$T$$$ — the number of vertices in the tree and the time he has to accomplish his task ($$$2\le n \le 10^5$$$; $$$1\le T\le10^{18}$$$).
The second line contains $$$n$$$ integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ — number of cookies located in the corresponding vertex ($$$1\le x_i\le10^6$$$). The third line contains $$$n$$$ integers $$$t_1$$$, $$$t_2$$$, ..., $$$t_n$$$ — how much time it takes Mitya to eat one cookie in vertex $$$i$$$ ($$$1\le t_i\le10^6$$$).
Each of the following $$$n - 1$$$ lines describe the tree. For every $$$i$$$ from $$$2$$$ to $$$n$$$, the corresponding line contains two integers $$$p_i$$$ and $$$l_i$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$ and $$$l_i$$$ denotes the time it takes Mitya to move the chip along the edge from vertex $$$i$$$ to its parent ($$$1\le p_i < i$$$, $$$0\le l_i \le 10^9$$$).
Output a single integer — maximum number of cookies Mitya can eat.
","input
In the first example test case, Mitya can start by moving the chip to vertex $$$2$$$. In this case no matter how Vasya plays, Mitya is able to eat at least $$$11$$$ cookies. Below you can find the detailed description of the moves:
output
Mitya spend $$$1+0$$$ time to go down, $$$0+1$$$ to go up, $$$7\cdot 2$$$ to eat $$$7$$$ cookies in vertex 5, $$$3\cdot 3$$$ to eat $$$3$$$ cookies in vertex 2, $$$1\cdot 1$$$ to eat $$$1$$$ cookie in vertex 1. Total time is $$$1+0+0+1+7\cdot 2+3\cdot 3+1\cdot 1=26$$$.
","binarysearch, datastructures, dfsandsimilar, dp, games, trees"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * @author khokharnikunj8
 */

public class Main {
    public static void main(String[] args) {
        new Thread(null, new Runnable() {
            public void run() {
                new Main().solve();
            }
        }, ""1"", 1 << 26).start();
    }

    void solve() {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        FCookies solver = new FCookies();
        solver.solve(1, in, out);
        out.close();
    }

    static class FCookies {
        long[] BIT;
        long[] BIT1;
        int[] cookie;
        int[] time;
        long[] max;
        long T;
        int[][][] G;

        void update(int x, long delta) {
            for (; x <= 1000001; x += x & -x)
                BIT[x] += delta;
        }

        long query(int x) {
            long sum = 0;
            for (; x > 0; x -= x & -x)
                sum += BIT[x];
            return sum;
        }

        void update1(int x, long delta) {
            for (; x <= 1000001; x += x & -x)
                BIT1[x] += delta;
        }

        long query1(int x) {
            long sum = 0;
            for (; x > 0; x -= x & -x)
                sum += BIT1[x];
            return sum;
        }

        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            // final long startTime = System.nanoTime();
            BIT = new long[1000001];
            BIT1 = new long[1000001];
            int n = in.scanInt();
            //int n = 100000;
            T = in.scanLong();
            //T = 1000000000000000000l;
            cookie = new int[n + 1];
            time = new int[n + 1];
            max = new long[n + 1];
            for (int i = 1; i <= n; i++) cookie[i] = in.scanInt();
            //for (int i = 1; i <= n; i++) cookie[i] = 1000000;
            for (int i = 1; i <= n; i++) time[i] = in.scanInt();
            //for (int i = 1; i <= n; i++) time[i] = 1000000;
            int[] from = new int[n - 1];
            int[] to = new int[n - 1];
            int[] weight = new int[n - 1];
            for (int i = 0; i < n - 1; i++) {
                from[i] = i + 2;
                to[i] = in.scanInt();
                //to[i] = i + 1;
                weight[i] = in.scanInt();
                //weight[i] = 0;
            }
            G = CodeHash.packGraphW(from, to, weight, n);
            dfs(1, -1, 0);
            out.println(max[1]);
            //final long duration = System.nanoTime() - startTime;
            // out.println(duration / 1e9);

        }

        private void dfs(int n, int p, long t) {
            update(time[n], ((long) time[n]) * cookie[n]);
            update1(time[n], cookie[n]);
            if (t > T) {
                max[n] = 0;
                update(time[n], -(((long) time[n]) * cookie[n]));
                update1(time[n], -cookie[n]);
                return;
            } else max[n] = findMax(T - t);
            long max1 = 0;
            long max2 = 0;
            for (int[] i : G[n]) {
                if (i[0] == p) continue;
                dfs(i[0], n, t + 2 * i[1]);
                if (max1 <= max[i[0]]) {
                    max2 = max1;
                    max1 = max[i[0]];
                } else if (max2 <= max[i[0]]) {
                    max2 = max[i[0]];
                }
            }
            update(time[n], -(((long) time[n]) * cookie[n]));
            update1(time[n], -cookie[n]);
            if (n != 1) max[n] = Math.max(max[n], max2);
            else max[n] = Math.max(max[n], max1);
        }

        private long findMax(long TT) {
            int index1 = -1;
            int low1 = 0;
            int high1 = 1000000;
            while (low1 <= high1) {
                int mid = (low1 + high1) / 2;
                if (query(mid) > TT) {
                    index1 = mid;
                    high1 = mid - 1;
                } else {
                    low1 = mid + 1;
                }
            }
            if (index1 == -1) return query1(1000000);
            long index2 = -1;
            long low2 = 0;
            long high2 = query1(index1) - query1(index1 - 1);
            long prev = query(index1 - 1);
            while (low2 <= high2) {
                long mid = (low2 + high2) / 2;
                if (prev + (mid * index1) <= TT) {
                    index2 = mid;
                    low2 = mid + 1;
                } else {
                    high2 = mid - 1;
                }
            }
            return query1(index1 - 1) + index2;

        }

    }

    static class CodeHash {
        public static int[][][] packGraphW(int[] from, int[] to, int[] w, int n) {
            int[][][] g = new int[n + 1][][];
            int[] p = new int[n + 1];
            for (int i : from) p[i]++;
            for (int i : to) p[i]++;
            for (int i = 0; i <= n; i++) g[i] = new int[p[i]][2];
            for (int i = 0; i < from.length; i++) {
                --p[from[i]];
                g[from[i]][p[from[i]]][0] = to[i];
                g[from[i]][p[from[i]]][1] = w[i];
                --p[to[i]];
                g[to[i]][p[to[i]]][0] = from[i];
                g[to[i]][p[to[i]]][1] = w[i];
            }
            return g;
        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int index;
        private BufferedInputStream in;
        private int total;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (index >= total) {
                index = 0;
                try {
                    total = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (total <= 0) return -1;
            }
            return buf[index++];
        }

        public int scanInt() {
            int integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

        public long scanLong() {
            long integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

    }
}

",4,1099_F,CODEFORCES,2912,Cookies,"Mitya and Vasya are playing an interesting game. They have a rooted tree with $$$n$$$ vertices, and the vertices are indexed from $$$1$$$ to $$$n$$$. The root has index $$$1$$$. Every other vertex $$$i \ge 2$$$ has its parent $$$p_i$$$, and vertex $$$i$$$ is called a child of vertex $$$p_i$$$.
There are some cookies in every vertex of the tree: there are $$$x_i$$$ cookies in vertex $$$i$$$. It takes exactly $$$t_i$$$ time for Mitya to eat one cookie in vertex $$$i$$$. There is also a chip, which is initially located in the root of the tree, and it takes $$$l_i$$$ time to move the chip along the edge connecting vertex $$$i$$$ with its parent.
Mitya and Vasya take turns playing, Mitya goes first.
Mitya can stop the game at any his turn. Once he stops the game, he moves the chip up to the root, eating some cookies along his way. Mitya can decide how many cookies he would like to eat in every vertex on his way. The total time spent on descend, ascend and eating cookies should not exceed $$$T$$$. Please note that in the end of the game the chip is always located in the root of the tree: Mitya can not leave the chip in any other vertex, even if he has already eaten enough cookies — he must move the chip back to the root (and every move from vertex $$$v$$$ to its parent takes $$$l_v$$$ time).
Find out what is the maximum number of cookies Mitya can eat, regardless of Vasya's actions.
The first line contains two integers $$$n$$$ and $$$T$$$ — the number of vertices in the tree and the time he has to accomplish his task ($$$2\le n \le 10^5$$$; $$$1\le T\le10^{18}$$$).
The second line contains $$$n$$$ integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ — number of cookies located in the corresponding vertex ($$$1\le x_i\le10^6$$$). The third line contains $$$n$$$ integers $$$t_1$$$, $$$t_2$$$, ..., $$$t_n$$$ — how much time it takes Mitya to eat one cookie in vertex $$$i$$$ ($$$1\le t_i\le10^6$$$).
Each of the following $$$n - 1$$$ lines describe the tree. For every $$$i$$$ from $$$2$$$ to $$$n$$$, the corresponding line contains two integers $$$p_i$$$ and $$$l_i$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$ and $$$l_i$$$ denotes the time it takes Mitya to move the chip along the edge from vertex $$$i$$$ to its parent ($$$1\le p_i < i$$$, $$$0\le l_i \le 10^9$$$).
Output a single integer — maximum number of cookies Mitya can eat.
","input
In the first example test case, Mitya can start by moving the chip to vertex $$$2$$$. In this case no matter how Vasya plays, Mitya is able to eat at least $$$11$$$ cookies. Below you can find the detailed description of the moves:
output
Mitya spend $$$1+0$$$ time to go down, $$$0+1$$$ to go up, $$$7\cdot 2$$$ to eat $$$7$$$ cookies in vertex 5, $$$3\cdot 3$$$ to eat $$$3$$$ cookies in vertex 2, $$$1\cdot 1$$$ to eat $$$1$$$ cookie in vertex 1. Total time is $$$1+0+0+1+7\cdot 2+3\cdot 3+1\cdot 1=26$$$.
","binarysearch, datastructures, dfsandsimilar, dp, games, trees"
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class A {
    static MyScanner sc;
    static PrintWriter pw;

    public static void main(String[] args) throws Throwable {
        sc = new MyScanner();
        pw = new PrintWriter(System.out);

        n = sc.nextInt();
        T = sc.nextLong();
        p = new int[n];
        l = new int[n];
        x = new int[n];
        t = new int[n];
        adj = new ArrayList[n];

        for (int i = 0; i < n; i++)
            x[i] = sc.nextInt();
        for (int i = 0; i < n; i++)
            t[i] = sc.nextInt();
        adj[0] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i] = new ArrayList<>();
            p[i] = sc.nextInt() - 1;
            l[i] = sc.nextInt();
            adj[p[i]].add(i);
        }

        ftCnt = new long[N];
        ftSum = new long[N];
        ans = new long[n];

        dfs(0);
        pw.println(ans[0]);

        pw.flush();
        pw.close();
    }

    static int n;
    static long T;
    static int[] p, l, x, t;
    static ArrayList<Integer>[] adj;

    static long[] ans;

    static void dfs(int u) {
        update(t[u], x[u], 1L * x[u] * t[u]);
        ans[u] = getMaxCnt();
        long[] vals = {-1, -1, -1};
        for (int v : adj[u]) {
            T -= 2 * l[v];
            dfs(v);
            vals[0] = ans[v];
            Arrays.sort(vals);
            T += 2 * l[v];
        }
        if (u != 0) {
            if (vals[1] != -1)
                ans[u] = Math.max(ans[u], vals[1]);
        } else {
            if (vals[2] != -1)
                ans[u] = Math.max(ans[u], vals[2]);
        }
        update(t[u], -x[u], -1L * x[u] * t[u]);
    }

    static int N = (int) 1e6 + 2;
    static long[] ftCnt, ftSum;

    static void update(int idx, long cnt, long val) {
        while (idx < N) {
            ftCnt[idx] += cnt;
            ftSum[idx] += val;
            idx += (idx & -idx);
        }
    }

    static long getSum(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftSum[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getCnt(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftCnt[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getMaxCnt() {
        int start = 1, end = N - 1, ans = N - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (getSum(mid) >= T) {
                ans = mid;
                end = mid - 1;
            } else
                start = mid + 1;
        }
        long remT = T - (ans > 1 ? getSum(ans - 1) : 0);
        long cnt = (ans > 1 ? getCnt(ans - 1) : 0);
        long cntOfVal = getCnt(ans) - cnt;
        cnt += Math.min(cntOfVal, remT / ans);
        return cnt;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",4,1099_F,CODEFORCES,2914,Cookies,"Mitya and Vasya are playing an interesting game. They have a rooted tree with $$$n$$$ vertices, and the vertices are indexed from $$$1$$$ to $$$n$$$. The root has index $$$1$$$. Every other vertex $$$i \ge 2$$$ has its parent $$$p_i$$$, and vertex $$$i$$$ is called a child of vertex $$$p_i$$$.
There are some cookies in every vertex of the tree: there are $$$x_i$$$ cookies in vertex $$$i$$$. It takes exactly $$$t_i$$$ time for Mitya to eat one cookie in vertex $$$i$$$. There is also a chip, which is initially located in the root of the tree, and it takes $$$l_i$$$ time to move the chip along the edge connecting vertex $$$i$$$ with its parent.
Mitya and Vasya take turns playing, Mitya goes first.
Mitya can stop the game at any his turn. Once he stops the game, he moves the chip up to the root, eating some cookies along his way. Mitya can decide how many cookies he would like to eat in every vertex on his way. The total time spent on descend, ascend and eating cookies should not exceed $$$T$$$. Please note that in the end of the game the chip is always located in the root of the tree: Mitya can not leave the chip in any other vertex, even if he has already eaten enough cookies — he must move the chip back to the root (and every move from vertex $$$v$$$ to its parent takes $$$l_v$$$ time).
Find out what is the maximum number of cookies Mitya can eat, regardless of Vasya's actions.
The first line contains two integers $$$n$$$ and $$$T$$$ — the number of vertices in the tree and the time he has to accomplish his task ($$$2\le n \le 10^5$$$; $$$1\le T\le10^{18}$$$).
The second line contains $$$n$$$ integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ — number of cookies located in the corresponding vertex ($$$1\le x_i\le10^6$$$). The third line contains $$$n$$$ integers $$$t_1$$$, $$$t_2$$$, ..., $$$t_n$$$ — how much time it takes Mitya to eat one cookie in vertex $$$i$$$ ($$$1\le t_i\le10^6$$$).
Each of the following $$$n - 1$$$ lines describe the tree. For every $$$i$$$ from $$$2$$$ to $$$n$$$, the corresponding line contains two integers $$$p_i$$$ and $$$l_i$$$, where $$$p_i$$$ denotes the parent of vertex $$$i$$$ and $$$l_i$$$ denotes the time it takes Mitya to move the chip along the edge from vertex $$$i$$$ to its parent ($$$1\le p_i < i$$$, $$$0\le l_i \le 10^9$$$).
Output a single integer — maximum number of cookies Mitya can eat.
","input
In the first example test case, Mitya can start by moving the chip to vertex $$$2$$$. In this case no matter how Vasya plays, Mitya is able to eat at least $$$11$$$ cookies. Below you can find the detailed description of the moves:
output
Mitya spend $$$1+0$$$ time to go down, $$$0+1$$$ to go up, $$$7\cdot 2$$$ to eat $$$7$$$ cookies in vertex 5, $$$3\cdot 3$$$ to eat $$$3$$$ cookies in vertex 2, $$$1\cdot 1$$$ to eat $$$1$$$ cookie in vertex 1. Total time is $$$1+0+0+1+7\cdot 2+3\cdot 3+1\cdot 1=26$$$.
","binarysearch, datastructures, dfsandsimilar, dp, games, trees"
"import java.util.*;
import java.io.*;
public class C{
    static PrintWriter out;
    static InputReader in;
    public static void main(String args[]){
        out = new PrintWriter(System.out);
        in = new InputReader();
        new C();
        out.flush(); out.close();
    }   
    C(){
       int a = solve();
       out.print(a == 0 ? ""tokitsukaze"" : a == 1 ? ""quailty"" : ""once again"");
    }
    int n, k;
    char ch[]; int a[], c0 = 0, c1 = 0;
    TreeSet<Integer> ts[] = new TreeSet[2];
    boolean check(){
        int min = 0, max = n;
        if(!ts[0].isEmpty()){
            min = ts[0].first(); max = ts[0].last();
            if(max - min + 1 > k)return true;
        }
        if(!ts[1].isEmpty()){
            min = ts[1].first(); max = ts[1].last();
            if(max - min + 1 > k)return true;   
        }
        return false;
    }
    int solve(){
        n  = in.nextInt(); k = in.nextInt();
        ch = in.next().trim().toCharArray(); a = new int[n];
        for(int i = 0; i < n; i++)c1 += a[i] = ch[i] - '0';
        c0 = n - c1;
        for(int i = 0; i < k; i++){
            if(a[i] == 0)c0--; else c1--;
        }
        if(c0 == 0 || c1 == 0)return 0;
        for(int i = k; i < n; i++){
            if(a[i] == 0)c0--; else c1--;
            if(a[i - k] == 0)c0++; else c1++;
            if(c0 == 0 || c1 == 0)return 0;
        }

        for(int i = 0; i < 2; i++)ts[i] = new TreeSet<>();
        for(int i = 0; i < n; i++){
            ts[a[i]].add(i);
        }
        for(int i = 0; i < k; i++){
            ts[a[i]].remove(i);
        }
        if(check())return 2;
        for(int i = k; i < n; i++){
            ts[a[i]].remove(i); ts[a[i - k]].add(i - k);
            if(check())return 2;
        }
        return 1;
    }
    public static class InputReader{
        BufferedReader br;
        StringTokenizer st;
        InputReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        public int nextInt(){
            return Integer.parseInt(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public String next(){
            while(st == null || !st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch(IOException e){}
            }
            return st.nextToken();
        }
    }
}
        ",3,1190_C,CODEFORCES,2157,Tokitsukaze and Duel,"""Duel!""
Betting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.
There are $$$n$$$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $$$k$$$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $$$n$$$ cards face the same direction after one's move, the one who takes this move will win.
Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 10^5$$$).
The second line contains a single string of length $$$n$$$ that only consists of $$$0$$$ and $$$1$$$, representing the situation of these $$$n$$$ cards, where the color side of the $$$i$$$-th card faces up if the $$$i$$$-th character is $$$1$$$, or otherwise, it faces down and the $$$i$$$-th character is $$$0$$$.
Print ""once again"" (without quotes) if the total number of their moves can exceed $$$10^9$$$, which is considered a draw.
In other cases, print ""tokitsukaze"" (without quotes) if Tokitsukaze will win, or ""quailty"" (without quotes) if Quailty will win.
Note that the output characters are case-sensitive, and any wrong spelling would be rejected.
In the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.
In the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.
","input
In the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.
output
The fourth example can be explained in the same way as the second example does.
","bruteforce, games, greedy"
"

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.TreeSet;


public class CFContest {
    public static void main(String[] args) throws Exception {
        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;
        boolean async = false;

        Charset charset = Charset.forName(""ascii"");

        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);
        Task task = new Task(io, new Debug(local));

        if (async) {
            Thread t = new Thread(null, task, ""dalt"", 1 << 27);
            t.setPriority(Thread.MAX_PRIORITY);
            t.start();
            t.join();
        } else {
            task.run();
        }

        if (local) {
            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");
        }

        io.flush();
    }

    public static class Task implements Runnable {
        final FastIO io;
        final Debug debug;
        int inf = (int) 1e8;

        public Task(FastIO io, Debug debug) {
            this.io = io;
            this.debug = debug;
        }

        @Override
        public void run() {
            solve();
        }

        BIT bit;
        int n;
        int k;

        public void solve() {
            n = io.readInt();
            k = io.readInt();
            char[] status = new char[n + 1];
            char[] revStatus = new char[n + 1];
            io.readString(status, 1);
            for (int i = 1; i <= n; i++) {
                revStatus[i] = status[i] == '1' ? '0' : '1';
            }

            bit = new BIT(n);
            for (int i = 1; i <= n; i++) {
                bit.update(i, status[i] - '0');
            }
            for (int i = 1; i + k - 1 <= n; i++) {
                int sum = bit.query(i - 1)
                        + bit.query(n) - bit.query(i + k - 1);
                if (sum == 0 || sum == n - k) {
                    io.cache.append(""tokitsukaze"");
                    return;
                }
            }

            //quailty win case
            if (solve0(status) && solve0(revStatus)) {
                io.cache.append(""quailty"");
                return;
            }
            io.cache.append(""once again"");
        }

        public boolean solve0(char[] status) {
            TreeSet<Integer> pos = new TreeSet<>();
            for (int i = 1; i < status.length; i++) {
                if (status[i] == '0') {
                    pos.add(i);
                }
            }
            for (int i = 1; i + k - 1 <= n; i++) {
                int l = i;
                int r = i + k - 1;
                int firstZero = pos.first();
                if (firstZero >= l && firstZero <= r) {
                    firstZero = pos.ceiling(r + 1);
                }
                int lastZero = pos.last();
                if (lastZero >= l && lastZero <= r) {
                    lastZero = pos.floor(l - 1);
                }
                if (lastZero - firstZero + 1 > k) {
                    return false;
                }
            }
            return true;
        }
    }


    /**
     * Created by dalt on 2018/5/20.
     */
    public static class BIT {
        private int[] data;
        private int n;

        /**
         * 创建大小A[1...n]
         */
        public BIT(int n) {
            this.n = n;
            data = new int[n + 1];
        }

        /**
         * 查询A[1]+A[2]+...+A[i]
         */
        public int query(int i) {
            int sum = 0;
            for (; i > 0; i -= i & -i) {
                sum += data[i];
            }
            return sum;
        }

        /**
         * 将A[i]更新为A[i]+mod
         */
        public void update(int i, int mod) {
            for (; i <= n; i += i & -i) {
                data[i] += mod;
            }
        }

        /**
         * 将A全部清0
         */
        public void clear() {
            Arrays.fill(data, 0);
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (int i = 1; i <= n; i++) {
                builder.append(query(i) - query(i - 1)).append(' ');
            }
            return builder.toString();
        }
    }


    public static class Randomized {
        static Random random = new Random();

        public static double nextDouble(double min, double max) {
            return random.nextDouble() * (max - min) + min;
        }

        public static void randomizedArray(int[] data, int from, int to) {
            to--;
            for (int i = from; i <= to; i++) {
                int s = nextInt(i, to);
                int tmp = data[i];
                data[i] = data[s];
                data[s] = tmp;
            }
        }

        public static void randomizedArray(long[] data, int from, int to) {
            to--;
            for (int i = from; i <= to; i++) {
                int s = nextInt(i, to);
                long tmp = data[i];
                data[i] = data[s];
                data[s] = tmp;
            }
        }

        public static void randomizedArray(double[] data, int from, int to) {
            to--;
            for (int i = from; i <= to; i++) {
                int s = nextInt(i, to);
                double tmp = data[i];
                data[i] = data[s];
                data[s] = tmp;
            }
        }

        public static void randomizedArray(float[] data, int from, int to) {
            to--;
            for (int i = from; i <= to; i++) {
                int s = nextInt(i, to);
                float tmp = data[i];
                data[i] = data[s];
                data[s] = tmp;
            }
        }

        public static <T> void randomizedArray(T[] data, int from, int to) {
            to--;
            for (int i = from; i <= to; i++) {
                int s = nextInt(i, to);
                T tmp = data[i];
                data[i] = data[s];
                data[s] = tmp;
            }
        }

        public static int nextInt(int l, int r) {
            return random.nextInt(r - l + 1) + l;
        }
    }

    /**
     * 模运算
     */
    public static class Modular {
        int m;

        public Modular(int m) {
            this.m = m;
        }

        public int valueOf(int x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return x;
        }

        public int valueOf(long x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return (int) x;
        }

        public int mul(int x, int y) {
            return valueOf((long) x * y);
        }

        public int plus(int x, int y) {
            return valueOf(x + y);
        }

        @Override
        public String toString() {
            return ""mod "" + m;
        }
    }

    public static class BitOperator {
        public int bitAt(int x, int i) {
            return (x >> i) & 1;
        }

        public int bitAt(long x, int i) {
            return (int) ((x >> i) & 1);
        }

        public int setBit(int x, int i, boolean v) {
            if (v) {
                x |= 1 << i;
            } else {
                x &= ~(1 << i);
            }
            return x;
        }

        public long setBit(long x, int i, boolean v) {
            if (v) {
                x |= 1L << i;
            } else {
                x &= ~(1L << i);
            }
            return x;
        }

        /**
         * Determine whether x is subset of y
         */
        public boolean subset(long x, long y) {
            return intersect(x, y) == x;
        }

        /**
         * Merge two set
         */
        public long merge(long x, long y) {
            return x | y;
        }

        public long intersect(long x, long y) {
            return x & y;
        }

        public long differ(long x, long y) {
            return x - intersect(x, y);
        }
    }

    public static class FastIO {
        public final StringBuilder cache = new StringBuilder();
        private final InputStream is;
        private final OutputStream os;
        private final Charset charset;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastIO(InputStream is, OutputStream os, Charset charset) {
            this.is = is;
            this.os = os;
            this.charset = charset;
        }

        public FastIO(InputStream is, OutputStream os) {
            this(is, os, Charset.forName(""ascii""));
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public double readDouble() {
            boolean sign = true;
            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+';
                next = read();
            }

            long val = 0;
            while (next >= '0' && next <= '9') {
                val = val * 10 + next - '0';
                next = read();
            }
            if (next != '.') {
                return sign ? val : -val;
            }
            next = read();
            long radix = 1;
            long point = 0;
            while (next >= '0' && next <= '9') {
                point = point * 10 + next - '0';
                radix = radix * 10;
                next = read();
            }
            double result = val + (double) point / radix;
            return sign ? result : -result;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

        public int readLine(char[] data, int offset) {
            int originalOffset = offset;
            while (next != -1 && next != '\n') {
                data[offset++] = (char) next;
                next = read();
            }
            return offset - originalOffset;
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

        public int readString(byte[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (byte) next;
                next = read();
            }

            return offset - originalOffset;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

        public void flush() {
            try {
                os.write(cache.toString().getBytes(charset));
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        public boolean hasMore() {
            skipBlank();
            return next != -1;
        }
    }

    public static class Debug {
        private boolean allowDebug;

        public Debug(boolean allowDebug) {
            this.allowDebug = allowDebug;
        }

        public void assertTrue(boolean flag) {
            if (!allowDebug) {
                return;
            }
            if (!flag) {
                fail();
            }
        }

        public void fail() {
            throw new RuntimeException();
        }

        public void assertFalse(boolean flag) {
            if (!allowDebug) {
                return;
            }
            if (flag) {
                fail();
            }
        }

        private void outputName(String name) {
            System.out.print(name + "" = "");
        }

        public void debug(String name, int x) {
            if (!allowDebug) {
                return;
            }

            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, long x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, double x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, int[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, long[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, double[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, Object x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, Object... x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.deepToString(x));
        }
    }
}",3,1190_C,CODEFORCES,2159,Tokitsukaze and Duel,"""Duel!""
Betting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.
There are $$$n$$$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $$$k$$$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $$$n$$$ cards face the same direction after one's move, the one who takes this move will win.
Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 10^5$$$).
The second line contains a single string of length $$$n$$$ that only consists of $$$0$$$ and $$$1$$$, representing the situation of these $$$n$$$ cards, where the color side of the $$$i$$$-th card faces up if the $$$i$$$-th character is $$$1$$$, or otherwise, it faces down and the $$$i$$$-th character is $$$0$$$.
Print ""once again"" (without quotes) if the total number of their moves can exceed $$$10^9$$$, which is considered a draw.
In other cases, print ""tokitsukaze"" (without quotes) if Tokitsukaze will win, or ""quailty"" (without quotes) if Quailty will win.
Note that the output characters are case-sensitive, and any wrong spelling would be rejected.
In the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.
In the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.
","input
In the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.
output
The fourth example can be explained in the same way as the second example does.
","bruteforce, games, greedy"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class C {

	static int N,K;
	static int ar[];
	public static void main(String[] args) {
		FS in = new FS();
		N = in.nextInt();
		K = in.nextInt();
		char c[] = in.next().toCharArray();
		ar = new int[N];
		for(int i = 0; i < N; i++) ar[i] = c[i]-'0';
		
		int suf[] = new int[2];
		int pref[] = new int[2];
		for(int i = 0; i < N; i++) {
			pref[ar[i]]++;
			if(i < N-1 && ar[i] != ar[i+1]) break;
		}
		for(int i = N-1; i >= 0; i--) {
			suf[ar[i]]++;
			if(i > 0 && ar[i] != ar[i-1]) break;
		}
		
		if(suf[0] + pref[0] + K >= N || suf[1] + pref[1] + K >= N) {
			p1Win();
			return;
		}
		
		boolean hasATie = false;
		for(int i = 0; i < N-K+1; i++) {
			// change [i, i+K-1] to 1's or 0's and see if p2 can win
			
			int newSuf[] = Arrays.copyOf(suf, 2);
			int newPref[] = Arrays.copyOf(pref, 2);
			
			// change to 0's. Opponent has to change to 0's as well to win
			for(int ch = 0; ch < 2; ch++) {
				if(newPref[ch] >= i) newPref[ch] = Math.max(newPref[ch], i+K);
				if(N-newSuf[ch] <= i+K) newSuf[ch] = Math.max(newSuf[ch], N-i);
			}
						
			boolean p2wins = (newSuf[0] + newPref[0] + K >= N && newSuf[1] + newPref[1] + K >= N);
			if(!p2wins) hasATie = true;
		}
		if(hasATie) draw();
		else p2Win();
		return;
	}
	
	static void p1Win() {
		System.out.println(""tokitsukaze"");
	}
	static void p2Win() {
		System.out.println(""quailty"");
	}
	static void draw() {
		System.out.println(""once again"");
	}
	
	static class FS{
		BufferedReader br;
		StringTokenizer st;
		public FS() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		String next() {
			while(st == null || !st.hasMoreElements()) {
				try {st = new StringTokenizer(br.readLine());}
				catch(Exception e) {}
			}
			return st.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
	}

}
",3,1190_C,CODEFORCES,2155,Tokitsukaze and Duel,"""Duel!""
Betting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.
There are $$$n$$$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $$$k$$$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $$$n$$$ cards face the same direction after one's move, the one who takes this move will win.
Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 10^5$$$).
The second line contains a single string of length $$$n$$$ that only consists of $$$0$$$ and $$$1$$$, representing the situation of these $$$n$$$ cards, where the color side of the $$$i$$$-th card faces up if the $$$i$$$-th character is $$$1$$$, or otherwise, it faces down and the $$$i$$$-th character is $$$0$$$.
Print ""once again"" (without quotes) if the total number of their moves can exceed $$$10^9$$$, which is considered a draw.
In other cases, print ""tokitsukaze"" (without quotes) if Tokitsukaze will win, or ""quailty"" (without quotes) if Quailty will win.
Note that the output characters are case-sensitive, and any wrong spelling would be rejected.
In the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.
In the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.
","input
In the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.
output
The fourth example can be explained in the same way as the second example does.
","bruteforce, games, greedy"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.util.SortedSet;
import java.util.Set;
import java.util.NavigableSet;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.InputStreamReader;
import java.util.TreeSet;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Niyaz Nigmatullin
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        FastPrinter out = new FastPrinter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, FastScanner in, FastPrinter out) {
            int n = in.nextInt();
            int k = in.nextInt();
            char[] c = in.next().toCharArray();
            NavigableSet<Integer> ones = new TreeSet<>();
            NavigableSet<Integer> zeros = new TreeSet<>();
            for (int i = 0; i < n; i++) {
                if (c[i] == '0') zeros.add(i);
                else ones.add(i);
            }
            if (ones.isEmpty() || zeros.isEmpty() || ones.last() - ones.first() + 1 <= k || zeros.last() - zeros.first() + 1 <= k) {
                out.println(""tokitsukaze"");
                return;
            }
            if (check(ones, n, k) && check(zeros, n, k)) {
                out.println(""quailty"");
                return;
            }
            out.println(""once again"");
        }

        private boolean check(NavigableSet<Integer> ones, int n, int k) {
            for (int i = 0; i + k <= n; i++) {
                int left = ones.first();
                int right = ones.last();
                if (left >= i) {
                    left = ones.higher(i + k - 1);
                }
                if (right < i + k) {
                    right = ones.lower(i);
                }
                if (right - left + 1 > k) {
                    return false;
                }
            }
            return true;
        }

    }

    static class FastPrinter extends PrintWriter {
        public FastPrinter(OutputStream out) {
            super(out);
        }

        public FastPrinter(Writer out) {
            super(out);
        }

    }

    static class FastScanner extends BufferedReader {
        public FastScanner(InputStream is) {
            super(new InputStreamReader(is));
        }

        public int read() {
            try {
                int ret = super.read();
//            if (isEOF && ret < 0) {
//                throw new InputMismatchException();
//            }
//            isEOF = ret == -1;
                return ret;
            } catch (IOException e) {
                throw new InputMismatchException();
            }
        }

        public String next() {
            StringBuilder sb = new StringBuilder();
            int c = read();
            while (isWhiteSpace(c)) {
                c = read();
            }
            if (c < 0) {
                return null;
            }
            while (c >= 0 && !isWhiteSpace(c)) {
                sb.appendCodePoint(c);
                c = read();
            }
            return sb.toString();
        }

        static boolean isWhiteSpace(int c) {
            return c >= 0 && c <= 32;
        }

        public int nextInt() {
            int c = read();
            while (isWhiteSpace(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int ret = 0;
            while (c >= 0 && !isWhiteSpace(c)) {
                if (c < '0' || c > '9') {
                    throw new NumberFormatException(""digit expected "" + (char) c
                            + "" found"");
                }
                ret = ret * 10 + c - '0';
                c = read();
            }
            return ret * sgn;
        }

        public String readLine() {
            try {
                return super.readLine();
            } catch (IOException e) {
                return null;
            }
        }

    }
}

",3,1190_C,CODEFORCES,2158,Tokitsukaze and Duel,"""Duel!""
Betting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.
There are $$$n$$$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $$$k$$$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $$$n$$$ cards face the same direction after one's move, the one who takes this move will win.
Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 10^5$$$).
The second line contains a single string of length $$$n$$$ that only consists of $$$0$$$ and $$$1$$$, representing the situation of these $$$n$$$ cards, where the color side of the $$$i$$$-th card faces up if the $$$i$$$-th character is $$$1$$$, or otherwise, it faces down and the $$$i$$$-th character is $$$0$$$.
Print ""once again"" (without quotes) if the total number of their moves can exceed $$$10^9$$$, which is considered a draw.
In other cases, print ""tokitsukaze"" (without quotes) if Tokitsukaze will win, or ""quailty"" (without quotes) if Quailty will win.
Note that the output characters are case-sensitive, and any wrong spelling would be rejected.
In the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.
In the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.
","input
In the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.
output
The fourth example can be explained in the same way as the second example does.
","bruteforce, games, greedy"
"import java.io.*;
import java.util.*;

public class Solution {

	static boolean canWinFromOneMove(char []s,int k) {
		int prefix=0;
		int n=s.length;
		for(int i=0;i<n && s[i]==s[0];i++)
			prefix++;
		int suffix=0;
		for(int i=n-1;i>=0 && s[i]==s[n-1];i--)
			suffix++;
		
		return s[0]==s[n-1] && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			
	}
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner();
		PrintWriter out = new PrintWriter(System.out);
		int n=sc.nextInt(),k=sc.nextInt();
		char []s=sc.next().toCharArray();
		if(canWinFromOneMove(s, k)) {
			System.out.println(""tokitsukaze"");
			return;
		}
		int []suff=new int [n+1];
		suff[n-1]=1;
		for(int i=n-2;i>=0;i--) {
			suff[i]=1+(s[i+1]==s[i]?suff[i+1]:0);
		}
		for(int i=n-2;i>=0;i--)
			suff[i]=Math.max(suff[i], suff[i+1]);
		int max=0,curr=0;
		boolean draw=false;
		int ones=0;
		for(int i=0;i+k<=n;i++) {
			
			// one
			int prefix=ones==i?k+ones:max;
			int suffix=i+k==n?k:s[i+k]=='1' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];
			char first=i==0?'1':s[0],last=i+k==n?'1':s[n-1];
			boolean zero=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			// zero
			 prefix=ones==0?k+ones:max;
			 suffix=i+k==n?k:s[i+k]=='0' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];
			 first=i==0?'0':s[0];
			 last=i+k==n?'0':s[n-1];
			boolean one=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			if(!zero || !one) {
//				System.err.println(i+1);
				draw=true;
			}
			if(s[i]=='1')
				ones++;
			if(i>0 && s[i]==s[i-1] )
				curr++;
			else
				curr=1;
			max=Math.max(max, curr);
		}
		out.println(draw?""once again"":""quailty"");
		out.close();

	}

	static class Scanner {
		BufferedReader br;
		StringTokenizer st;

		Scanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		Scanner(String fileName) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(fileName));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		String nextLine() throws IOException {
			return br.readLine();
		}

		int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

		double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(next());
		}

		boolean ready() throws IOException {
			return br.ready();
		}

	}

}",3,1190_C,CODEFORCES,2156,Tokitsukaze and Duel,"""Duel!""
Betting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.
There are $$$n$$$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $$$k$$$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $$$n$$$ cards face the same direction after one's move, the one who takes this move will win.
Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 10^5$$$).
The second line contains a single string of length $$$n$$$ that only consists of $$$0$$$ and $$$1$$$, representing the situation of these $$$n$$$ cards, where the color side of the $$$i$$$-th card faces up if the $$$i$$$-th character is $$$1$$$, or otherwise, it faces down and the $$$i$$$-th character is $$$0$$$.
Print ""once again"" (without quotes) if the total number of their moves can exceed $$$10^9$$$, which is considered a draw.
In other cases, print ""tokitsukaze"" (without quotes) if Tokitsukaze will win, or ""quailty"" (without quotes) if Quailty will win.
Note that the output characters are case-sensitive, and any wrong spelling would be rejected.
In the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.
In the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.
","input
In the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.
output
The fourth example can be explained in the same way as the second example does.
","bruteforce, games, greedy"
"
import java.util.Arrays;
import java.util.Scanner;

public class first {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner s=new Scanner(System.in);
		int n=s.nextInt();
		int[] a=new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i]=s.nextInt();
		}
		Arrays.sort(a);
		int count=0;
		for (int i = 0; i < a.length; i++) {
			if(a[i]!=0) {
				int x=a[i];
				count++;
				for (int j = i; j < a.length; j++) {
					if(a[j]%x==0) {
						a[j]=0;
					}
				}
			}
		}
		System.out.println(count);
	}

}
",5,1209_A,CODEFORCES,3483,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Washoum
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        inputClass in = new inputClass(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, inputClass sc, PrintWriter out) {
            int n = sc.nextInt();
            Integer[] tab = new Integer[n];
            for (int i = 0; i < n; i++) {
                tab[i] = sc.nextInt();
            }
            Arrays.sort(tab);
            boolean[] done = new boolean[n];
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (!done[i]) {
                    ans++;
                    done[i] = true;
                    for (int j = i + 1; j < n; j++) {
                        if (!done[j] && tab[j] % tab[i] == 0) {
                            done[j] = true;
                        }
                    }
                }
            }
            out.println(ans);
        }

    }

    static class inputClass {
        BufferedReader br;
        StringTokenizer st;

        public inputClass(InputStream in) {

            br = new BufferedReader(new InputStreamReader(in));
        }

        public String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",5,1209_A,CODEFORCES,3535,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
 
 
public class Main {
 
 
	public static void main(String[] args) throws Exception{
		BufferedReader  jk =  new BufferedReader(new InputStreamReader( System.in))  ; 
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)) ; 
		StringTokenizer ana = new StringTokenizer(jk.readLine()) ;
		int n = Integer.parseInt(ana.nextToken()) ; 
		
		int t[]= new int[101] ; 
		ArrayList<Integer> v = new ArrayList<>() ; 
		ana = new StringTokenizer(jk.readLine()) ;
		for(int i=0 ; i<n ;i++)
		{
			
			int y = Integer.parseInt(ana.nextToken()) ;
			t[y]=1 ; 
			v.add(y) ; 
		}
		Collections.sort(v);
		int c= 0; 
		for(int ele : v)
		{
			if(t[ele]==1)
			{
				
				for(int i=ele ; i<=100 ; i+=ele)
				{
					t[i]=2 ; 
				}
				c++ ; 
			}
		
		}
		out.println(c);
		
 
 
 
 
 
 
 
 
		out.flush();
	}
}",5,1209_A,CODEFORCES,3552,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;

	static void solve() {
		int n = ir.nextInt();
		int[] a = ir.nextIntArray(n);
		Arrays.sort(a);
		boolean[] used = new boolean[n];
		int ct = 0;
		for (int i = 0; i < n; i++) {
			if (used[i])
				continue;
			for (int j = i + 1; j < n; j++) {
				if (a[j] % a[i] == 0)
					used[j] = true;
			}
			ct++;
		}
		out.println(ct);
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		out.println(Arrays.deepToString(o));
	}
}
",5,1209_A,CODEFORCES,3553,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new PrintStream(System.out));
        int n=Integer.parseInt(f.readLine());
        StringTokenizer st=new StringTokenizer(f.readLine());
        int[]arr=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);
        int ans=0;
        boolean[]used=new boolean[n];
        for(int i=0;i<n;i++){
            if(!used[i]){
                ans++;
                for(int j=i+1;j<n;j++){
                    if(!used[j] && arr[j]%arr[i]==0){
                        used[j]=true;
                    }
                }
                used[i]=true;
            }
        }
        System.out.print(ans);
        f.close();
        out.close();
    }
}
class pair implements Comparable <pair>{
    int num;
    int idx;

    public int compareTo(pair other){
        return num- other.num;
    }


    pair(int a, int b)
    {
        num=a;
        idx=b;
    }
}
",5,1209_A,CODEFORCES,3481,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Random;
import java.util.StringTokenizer;
 
public class A {
	
	public static void main(String[] args) {
		FastReader scan = new FastReader();
		PrintWriter out = new PrintWriter(System.out);
		Task solver = new Task();
		int t = 1;
		while(t-->0) solver.solve(1, scan, out);
		out.close();
	}
	
	static class Task {
		
		public void solve(int testNumber, FastReader scan, PrintWriter out) {
			int n = scan.nextInt();
			int[] a = new int[n];
			boolean[] b = new boolean[n];
			int count = 0;
			for(int i = 0; i < n; i++) a[i] = scan.nextInt();
			Arrays.sort(a);
			for(int i = 0; i < n; i++) {
				if(b[i]) continue;
				count++;
				for(int j = i; j < n; j++) {
					if(a[j]%a[i] == 0) b[j] = true;
				}
			}
			out.println(count);
		}
	}
	
	static void shuffle(int[] a) {
		Random get = new Random();
		for(int i = 0; i < a.length; i++) {
			int r = get.nextInt(a.length);
			int temp = a[i];
			a[i] = a[r];
			a[r] = temp;
		}
	}
	
	static void shuffle(long[] a) {
		Random get = new Random();
		for(int i = 0; i < a.length; i++) {
			int r = get.nextInt(a.length);
			long temp = a[i];
			a[i] = a[r];
			a[r] = temp;
		}
	}
	
 
	static class FastReader {
		BufferedReader br;
		StringTokenizer st;
 
		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		public FastReader(String s) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(new File(s)));
		}
 
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
 
		int nextInt() {
			return Integer.parseInt(next());
		}
 
		long nextLong() {
			return Long.parseLong(next());
		}
 
		double nextDouble() {
			return Double.parseDouble(next());
		}
 
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}
 
}",5,1209_A,CODEFORCES,3480,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.*;

public class A {
	public void run() throws Exception {
		FastScanner sc = new FastScanner();
		
		int n = sc.nextInt();
		int[] arr = new int[n];
		int[] color = new int[n];
		for (int i = 0; i<n; i++) {
			arr[i]  =sc.nextInt();
		}
		Arrays.sort(arr);
		int counter = 1;
		for (int i = 0; i<n; i++) {
			if (color[i]!= 0) continue;
			for (int j = i;j<n; j++) {
				if (color[j]!= 0) continue;
				else if (arr[j]%arr[i] == 0) color[j] = counter;
			}
			counter++;
		}
	//	System.out.println(Arrays.toString(color));
		int max = 0;
		for (int i = 0; i<n; i++) {
			max = Math.max(max, color[i]);
		}
		System.out.println(max);
	}
	static class FastScanner {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public FastScanner() {
			reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String nextLine() {
			try {
				return reader.readLine();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

	}
	public static void main (String[] args) throws Exception {
		new A().run();
	}
}",5,1209_A,CODEFORCES,3527,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/**
 * @author Finn Lidbetter
 */
import java.util.*;
import java.io.*;
import java.awt.geom.*;

public class TaskA {
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringBuilder sb = new StringBuilder();

    int n = Integer.parseInt(br.readLine());
    String[] s = br.readLine().split("" "");
    int[] arr = new int[n];
    for (int i=0; i<n; i++) {
      arr[i] = Integer.parseInt(s[i]);
    }
    Arrays.sort(arr);
    boolean[] vis = new boolean[n];
    int nColours = 0;
    int nVis = 0;
    int index = 0;
    while (nVis<n) {
      while (index<n && nVis<n) {
        if (vis[index]) {
          index++;
          continue;
        }
        int val = arr[index];
        nColours++;
        while (index<n && nVis<n) {
          if (vis[index]) {
            index++;
            continue;
          }
          if (arr[index]%val==0) {
            vis[index] = true;
            nVis++;
          }
          index++;
        }
        index = 0;
      }
    }
    System.out.println(nColours);

  }
}
",5,1209_A,CODEFORCES,3558,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

import static java.lang.Math.*;

public class A {
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = in.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        Arrays.sort(a);
        int vis[] = new int[n];
        Arrays.fill(vis, -1);
        int c = 0;
        for (int i = 0; i < n; i++) {
            if (vis[i] != -1) continue;
            c++;
            for (int j = i; j < n; j++) {
                if (vis[j] == -1 && a[j] % a[i] == 0) {
                    vis[j] = c;
                }
            }
        }
        
        pw.println(c);

        pw.close();
    }

    static void debug(Object... obj) {
        System.err.println(Arrays.deepToString(obj));
    }
}",5,1209_A,CODEFORCES,3580,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main2 {

    static long mod = 998244353;
    static FastScanner scanner;

    static Set<Long> second = new HashSet<>();
    static boolean applied = false;

    public static void main(String[] args) {
        scanner = new FastScanner();
        int n = scanner.nextInt();
        int[] a = scanner.nextIntArray(n);
        int[] colors = new int[n];
        ADUtils.sort(a);
        int color = 0;
        for (int i = 0; i < n; i++) {
            if (colors[i] != 0) continue;
            color++;
            for (int j = i; j < n; j++) {
                if (a[j] % a[i] == 0) colors[j] = color;
            }
        }
        System.out.println(color);
    }

    static class WithIdx implements Comparable<WithIdx>{
        int val, idx;

        public WithIdx(int val, int idx) {
            this.val = val;
            this.idx = idx;
        }

        @Override
        public int compareTo(WithIdx o) {
            return Integer.compare(val, o.val);
        }
    }

    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            try {
                return br.readLine();
            } catch (Exception e) {
                e.printStackTrace();
                throw new RuntimeException();
            }
        }

        int nextInt() {
            return Integer.parseInt(nextToken());
        }

        long nextLong() {
            return Long.parseLong(nextToken());
        }

        double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        int[] nextIntArray(int n) {
            int[] res = new int[n];
            for (int i = 0; i < n; i++) res[i] = nextInt();
            return res;
        }

        long[] nextLongArray(int n) {
            long[] res = new long[n];
            for (int i = 0; i < n; i++) res[i] = nextLong();
            return res;
        }

        String[] nextStringArray(int n) {
            String[] res = new String[n];
            for (int i = 0; i < n; i++) res[i] = nextToken();
            return res;
        }
    }

    static class PrefixSums {
        long[] sums;

        public PrefixSums(long[] sums) {
            this.sums = sums;
        }

        public long sum(int fromInclusive, int toExclusive) {
            if (fromInclusive > toExclusive) throw new IllegalArgumentException(""Wrong value"");
            return sums[toExclusive] - sums[fromInclusive];
        }

        public static PrefixSums of(int[] ar) {
            long[] sums = new long[ar.length + 1];
            for (int i = 1; i <= ar.length; i++) {
                sums[i] = sums[i - 1] + ar[i - 1];
            }
            return new PrefixSums(sums);
        }

        public static PrefixSums of(long[] ar) {
            long[] sums = new long[ar.length + 1];
            for (int i = 1; i <= ar.length; i++) {
                sums[i] = sums[i - 1] + ar[i - 1];
            }
            return new PrefixSums(sums);
        }
    }

    static class ADUtils {
        static void sort(int[] ar) {
            Random rnd = ThreadLocalRandom.current();
            for (int i = ar.length - 1; i > 0; i--)
            {
                int index = rnd.nextInt(i + 1);
                // Simple swap
                int a = ar[index];
                ar[index] = ar[i];
                ar[i] = a;
            }
            Arrays.sort(ar);
        }

        static void reverse(int[] arr) {
            int last = arr.length / 2;
            for (int i = 0; i < last; i++) {
                int tmp = arr[i];
                arr[i] = arr[arr.length - 1 - i];
                arr[arr.length - 1 - i] = tmp;
            }
        }

        static void sort(long[] ar) {
            Random rnd = ThreadLocalRandom.current();
            for (int i = ar.length - 1; i > 0; i--)
            {
                int index = rnd.nextInt(i + 1);
                // Simple swap
                long a = ar[index];
                ar[index] = ar[i];
                ar[i] = a;
            }
            Arrays.sort(ar);
        }
    }

    static class MathUtils {
        static long[] FIRST_PRIMES = {
                2,     3,      5,      7,     11,     13,     17,     19,     23,     29,
                31,     37,     41,     43,     47,     53,     59,     61,     67,     71,
                73,     79,     83,     89  ,   97 ,    101,    103,    107,    109,    113,
                127,    131,    137,    139,    149,    151,    157,    163,    167,    173,
                179,    181,    191,    193,    197,    199,    211,    223,    227,    229,
                233,    239,    241,    251,    257,    263,    269,    271,    277,    281,
                283,    293,    307,    311,    313,    317,    331,    337,    347,    349,
                353,    359,    367,    373,    379,    383,    389,    397,    401,    409,
                419,    421,    431,    433,    439,    443,    449,    457,    461,    463,
                467,    479,    487,    491,    499,    503,    509,    521,    523,    541,
                547,    557,    563,    569,    571,    577,    587,    593,    599,    601,
                607,    613,    617,    619,    631,    641,    643,    647,    653,    659,
                661,    673,    677,    683,    691,    701,    709,    719,    727,    733,
                739,    743,    751,    757,    761,    769,    773,    787,    797,    809,
                811,    821,    823,    827,    829,    839,    853,    857,    859,    863,
                877,    881,    883,    887,    907,    911,    919,    929,    937,    941,
                947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,
                1019,   1021,   1031,   1033,   1039,   1049,   1051};

        static long[] primes(int to) {
            long[] all = new long[to + 1];
            long[] primes = new long[to + 1];
            all[1] = 1;
            int primesLength = 0;
            for (int i = 2; i <= to; i ++) {
                if (all[i] == 0) {
                    primes[primesLength++] = i;
                    all[i] = i;
                }
                for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {
                    all[(int) (i * primes[j])] = primes[j];
                }
            }
            return Arrays.copyOf(primes, primesLength);
        }

        static long modpow(long b, long e, long m) {
            long result = 1;

            while (e > 0) {
                if ((e & 1) == 1) {
                    /* multiply in this bit's contribution while using modulus to keep
                     * result small */
                    result = (result * b) % m;
                }
                b = (b * b) % m;
                e >>= 1;
            }

            return result;
        }

        static long submod(long x, long y, long m) {
            return (x - y + m) % m;
        }
    }
}

/*
5 6
1 4
2 3
3 4
4 5
5 2
3 5

5 8
1 2
2 3
1 3
4 3
3 4
4 1
4 5
5 1
 */",5,1209_A,CODEFORCES,3573,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.math.BigInteger;
public class template {
	public static void main(String[] args) throws Exception {
		FastScanner sc = new FastScanner();
		PrintWriter pw = new PrintWriter(System.out);
		int n = sc.nextInt();
		Integer[] arr = new Integer[n];
		for(int i=0;i<n;i++) {
			arr[i]=sc.nextInt();
		}
		Arrays.sort(arr);
		int ct = 0;
		boolean[] ar = new boolean[n];
		for(int i=0;i<n;i++) {
			if(!ar[i]) {
				ar[i]=true;
				ct++;
				int x = arr[i];
				for(int j=0;j<n;j++) {
					if(arr[j]%x==0) {
						ar[j]=true;
					}
				}
			}
		}
		
		pw.println(ct);
		pw.close();
	}
}
@SuppressWarnings(""all"")
class FastScanner {
    BufferedReader br;
    StringTokenizer st;
    public FastScanner(BufferedReader d) {
        br=d;
    }
    public FastScanner(String s) {
        try {
            br = new BufferedReader(new FileReader(s));
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
 
    public FastScanner() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
 
    String nextToken() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
 
    int nextInt() {
        return Integer.parseInt(nextToken());
    }
 
    long nextLong() {
        return Long.parseLong(nextToken());
    }
 
    double nextDouble() {
        return Double.parseDouble(nextToken());
    }
}",5,1209_A,CODEFORCES,3515,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class Solution {
    public static void main(String[] args) {
        FastReader in = new FastReader();
        int n = in.nextInt();
        int[] a = new int[101];
        for (int i = 0; i < n; i++) {
            a[in.nextInt()]++;
        }
        int count = 0;
        for (int i = 1; i < 101; i++) {
            if (a[i] > 0) {
                count++;
                for (int j = i; j < 101; j += i) {
                    a[j] = 0;
                }
            }
        }
        System.out.println(count);

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; ++i) array[i] = nextInt();
            return array;
        }

        public int[] nextSortedIntArray(int n) {
            int array[] = nextIntArray(n);
            Arrays.sort(array);
            return array;
        }

        public int[] nextSumIntArray(int n) {
            int[] array = new int[n];
            array[0] = nextInt();
            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();
            return array;
        }

        public long[] nextLongArray(int n) {
            long[] array = new long[n];
            for (int i = 0; i < n; ++i) array[i] = nextLong();
            return array;
        }

        public long[] nextSumLongArray(int n) {
            long[] array = new long[n];
            array[0] = nextInt();
            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();
            return array;
        }

        public long[] nextSortedLongArray(int n) {
            long array[] = nextLongArray(n);
            Arrays.sort(array);
            return array;
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",5,1209_A,CODEFORCES,3466,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"// package cf1209;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.Random;

public class CFA {
    private static final String INPUT = ""8\n"" +
            ""7 6 5 4 3 2 2 3\n"";
    private static final int MOD = 1_000_000_007;

    private PrintWriter out;
    private FastScanner sc;

    public static void main(String[] args) {
        new CFA().run();
    }

    public void run() {
        sc = new FastScanner(oj ? System.in : new ByteArrayInputStream(INPUT.getBytes()));
        out = new PrintWriter(System.out);

        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis() - s + ""ms"");
    }

    static class Color {
        int nr;
        boolean used;

        public Color(int nr) {
            this.nr = nr;
        }
    }

    private void solve() {
        int n = sc.nextInt();
        Color[] a = new Color[n];
        for (int i = 0; i < n; i++) {
            a[i] = new Color(sc.nextInt());
        }
        Arrays.sort(a, Comparator.comparingInt(c -> c.nr));

        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (a[i].used) continue;
            ans++;

            for (int j = i+1; j < n; j++) {
                if (a[j].nr % a[i].nr == 0) {
                    a[j].used = true;
                }
            }
        }
        out.println(ans);
    }

//********************************************************************************************
//********************************************************************************************
//********************************************************************************************

    static class SolutionFailedException extends Exception {
        int code;

        public SolutionFailedException(int code) {
            this.code = code;
        }
    }

    int [] sort(int [] a) {
        final int SHIFT = 16, MASK = (1 << SHIFT) - 1, SIZE = (1 << SHIFT) + 1;
        int n = a.length, ta [] = new int [n], ai [] = new int [SIZE];
        for (int i = 0; i < n; ai[(a[i] & MASK) + 1]++, i++);
        for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);
        for (int i = 0; i < n; ta[ai[a[i] & MASK]++] = a[i], i++);
        int [] t = a; a = ta; ta = t;
        ai = new int [SIZE];
        for (int i = 0; i < n; ai[(a[i] >> SHIFT) + 1]++, i++);
        for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);
        for (int i = 0; i < n; ta[ai[a[i] >> SHIFT]++] = a[i], i++);
        return ta;
    }

    private static void shuffle(int[] array) {
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            int index = random.nextInt(i + 1);
            int temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
    }

    /**
     * If searched element doesn't exist, returns index of first element which is bigger than searched value.<br>
     * If searched element is bigger than any array element function returns first index after last element.<br>
     * If searched element is lower than any array element function returns index of first element.<br>
     * If there are many values equals searched value function returns first occurrence.<br>
     */
    private static int lowerBound(long[] arr, long key) {
        int lo = 0;
        int hi = arr.length - 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if (key <= arr[mid]) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        return arr[lo] < key ? lo + 1 : lo;
    }

    /**
     * Returns index of first element which is grater than searched value.
     * If searched element is bigger than any array element, returns first index after last element.
     */
    private static int upperBound(long[] arr, long key) {
        int lo = 0;
        int hi = arr.length - 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if (key >= arr[mid]) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return arr[lo] <= key ? lo + 1 : lo;
    }

    private static int ceil(double d) {
        int ret = (int) d;
        return ret == d ? ret : ret + 1;
    }

    private static int round(double d) {
        return (int) (d + 0.5);
    }

    private static int gcd(int a, int b) {
        BigInteger b1 = BigInteger.valueOf(a);
        BigInteger b2 = BigInteger.valueOf(b);
        BigInteger gcd = b1.gcd(b2);
        return gcd.intValue();
    }

    private static long gcd(long a, long b) {
        BigInteger b1 = BigInteger.valueOf(a);
        BigInteger b2 = BigInteger.valueOf(b);
        BigInteger gcd = b1.gcd(b2);
        return gcd.longValue();
    }

    private int[] readIntArray(int n) {
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = sc.nextInt();
        }
        return res;
    }

    private long[] readLongArray(int n) {
        long[] res = new long[n];
        for (int i = 0; i < n; i++) {
            res[i] = sc.nextLong();
        }
        return res;
    }

    @SuppressWarnings(""unused"")
    static class FastScanner {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        FastScanner(InputStream stream) {
            this.stream = stream;
        }

        int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) return -1;
            }
            return buf[curChar++];
        }

        boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        boolean isEndline(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c)) c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public String nextLine() {
            int c = read();
            while (isEndline(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndline(c));
            return res.toString();
        }

    }

    private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;

    private void tr(Object... o) {
        if (!oj) System.out.println(Arrays.deepToString(o));
    }
}",5,1209_A,CODEFORCES,3503,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; ++i) a[i] = in.nextInt();
            boolean[] done = new boolean[n];
            int res = 0;
            while (true) {
                int bi = -1;
                for (int i = 0; i < n; ++i)
                    if (!done[i]) {
                        if (bi < 0 || a[i] < a[bi]) bi = i;
                    }
                if (bi < 0) break;
                ++res;
                for (int i = 0; i < n; ++i) if (!done[i] && a[i] % a[bi] == 0) done[i] = true;
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",5,1209_A,CODEFORCES,3591,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = scn.nextInt();
        scn.close();

        Arrays.sort(a);

        ArrayList<Integer> cyka = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (a[j] % a[i] == 0) {
                    boolean add = true;
                    for (int k : cyka) {
                        if (a[i] % k == 0) {
                            add = false;
                            break;
                        }
                    }
                    if (add) {
                        cyka.add(a[i]);
                    }
                }
            }
        }

        System.out.println(cyka.size());

    }
}",5,1209_A,CODEFORCES,3567,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.*;
import java.lang.*;
import java.util.*;

public class Solver {
    public static void main(String[] args) {
        FastReader in = new FastReader();
        PrintWriter out = new PrintWriter(System.out);
        TaskC solver = new TaskC(in, out);
        solver.solve();
        out.close();
    }

    static class TaskC {
        FastReader in;
        PrintWriter out;

        public TaskC(FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
        }

        public void solve() {
            solveA();
        }

        public void solveA() {
            int n = in.nextInt();
            int[] inputColors = in.nextIntArray(n);

            int colors = 0;

            Arrays.sort(inputColors);

            for (int i = 0; i < inputColors.length; i++) {
                if (inputColors[i] == -1) {
                    continue;
                }

                int colorCode = inputColors[i];
                boolean colorFound = false;
                for (int j = i; j < inputColors.length; j++) {
                    if (inputColors[j] != -1 && inputColors[j] % colorCode == 0) {
                        if (!colorFound) {
                            colorFound = true;
                            colors++;
                        }
                        inputColors[j] = -1;
                    }
                }
            }

            out.println(colors);
        }

        public void solveB() {

        }

        public void solveC() {

        }

        public void solveD() {

        }

        public void solveE() {

        }

        public void solveF() {

        }

        public void solveG() {

        }

        public void solveH() {

        }
    }

    private static long gcd(long a, long b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    private static long lcm(long a, long b) {
        return (a * b) / gcd(a, b);
    }

    private static int min(int a, int b) {
        return a < b ? a : b;
    }

    private static int max(int a, int b) {
        return a > b ? a : b;
    }

    private static int min(ArrayList<Integer> list) {
        int min = Integer.MAX_VALUE;
        for (int el : list) {
            if (el < min) {
                min = el;
            }
        }
        return min;
    }

    private static int max(ArrayList<Integer> list) {
        int max = Integer.MIN_VALUE;
        for (int el : list) {
            if (el > max) {
                max = el;
            }
        }
        return max;
    }

    private static int min(int[] list) {
        int min = Integer.MAX_VALUE;
        for (int el : list) {
            if (el < min) {
                min = el;
            }
        }
        return min;
    }

    private static int max(int[] list) {
        int max = Integer.MIN_VALUE;
        for (int el : list) {
            if (el > max) {
                max = el;
            }
        }
        return max;
    }

    private static void fill(int[] array, int value) {
        for (int i = 0; i < array.length; i++) {
            array[i] = value;
        }
    }


    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; i++) {
                array[i] = nextInt();
            }
            return array;
        }
    }
}",5,1209_A,CODEFORCES,3460,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.Scanner;


public class A {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int []a = new int [n];
		boolean []used = new boolean[n];
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
		}
		Arrays.sort(a);
		int ans = 0;
		for (int i = 0; i < used.length; i++) {
			if (!used[i]){
				ans++;
			  for (int j = i; j < used.length; j++) {
				if (a[j]%a[i] == 0){
					used[j] = true;
				}
			  }
			}
		}
		System.out.print(ans);
	}

}
",5,1209_A,CODEFORCES,3492,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"// No sorceries shall previal. //
         
import java.util.Scanner; 
import java.io.PrintWriter;
import java.util.*;
import java.util.Arrays;
     
public class InVoker {
  
   public static void main(String args[]) {
    		
    	Scanner inp = new Scanner(System.in);
    	PrintWriter out= new PrintWriter(System.out);
    	
    	int n=inp.nextInt();
    	int a[]=new int[n];
    	for(int i=0;i<n;i++)
    		a[i]=inp.nextInt();
    	Arrays.sort(a);
    	int gg=0;
    	for(int i=0;i<n;i++) {
    		if(a[i]==0)
    			continue;
    		gg++;
    		for(int j=i+1;j<n;j++) {
    			if(a[j]%a[i]==0) {
    				a[j]=0;
    			}
    		}
    	}
    	out.println(gg);
    	out.close();
    	inp.close();
    				
    }
    		
}",5,1209_A,CODEFORCES,3576,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.util.Map.Entry;

public class ProblemA {
	public static void main (String args[]) throws IOException{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int n=Integer.parseInt(br.readLine());
		String s1=br.readLine();
		String[] s=s1.split("" "");
		int a[] = new int[n];
		for(int i = 0;i<n;i++)
		{
			a[i]=Integer.parseInt(s[i]);
		}
		Arrays.sort(a);
		System.out.println(findColour(a,n));
	}
	public static int findColour(int [] a , int n)
	{
		Map <Integer,Integer> mp = new HashMap<Integer,Integer>();
		int f=0;
		for(int i = 0; i<n;i++)
		{
			f=0;
			for (Map.Entry<Integer,Integer> entry : mp.entrySet()) 
			{
				if(a[i] % entry.getKey()==0)
				{
					f=1;
					break;
				}
			}
			if(f==0)
			{
				mp.put(a[i],1);
			}
				
		}
		return mp.size();
	}
}
",5,1209_A,CODEFORCES,3508,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author gaidash
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        ARaskrashivanieChisel solver = new ARaskrashivanieChisel();
        solver.solve(1, in, out);
        out.close();
    }

    static class ARaskrashivanieChisel {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            final int MAX = 100;

            int n = in.nextInt();
            int[] a = in.nextSortedIntArray(n);

            int ret = 0;
            boolean[] used = new boolean[MAX + 1];
            for (int i = 0; i < n; i++) {
                if (!used[a[i]]) {
                    used[a[i]] = true;
                    ret++;
                    for (int j = i + 1; j < n; j++) {
                        if (a[j] % a[i] == 0 && !used[a[j]]) {
                            used[a[j]] = true;
                        }
                    }
                }
            }

            out.println(ret);
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(int i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; ++i) array[i] = nextInt();
            return array;
        }

        public int[] nextSortedIntArray(int n) {
            int array[] = nextIntArray(n);
            Arrays.sort(array);
            return array;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",5,1209_A,CODEFORCES,3479,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public final class paint_and_numers {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] a = new int[n];
        for(int i=0;i<n;i++) a[i] = in.nextInt();
        Arrays.sort(a);
        int count = 0;
        boolean[] c = new boolean[n];
        for(int i=0;i<n;i++) {
            if(c[i]==false) {
                c[i]=true;
                count++;
                for(int j=i+1;j<n;j++) {
                    if(a[j]%a[i]==0) {
                        c[j] = true;
                    }
                }
            }
        }
        System.out.println(count);
    }
}",5,1209_A,CODEFORCES,3523,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author null
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Input in = new Input(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, Input in, PrintWriter out) {
            try {
                int n = in.readInt();
                int[] a = new int[n];
                for (int i = 0; i < n; i++) {
                    a[i] = in.readInt();
                }
                Arrays.sort(a);
                boolean[] b = new boolean[n];
                int ans = 0;
                while (true) {
                    int x = 0;
                    for (int i = 0; i < n; i++) {
                        if (!b[i] && x == 0) {
                            x = a[i];
                        }
                        if (x != 0 && a[i] % x == 0) {
                            b[i] = true;
                        }
                    }
                    if (x == 0) {
                        break;
                    }
                    ans++;
                }
                out.println(ans);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

    }

    static class Input {
        public final BufferedReader reader;
        private String line = """";
        private int pos = 0;

        public Input(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream));
        }

        private boolean isSpace(char ch) {
            return ch <= 32;
        }

        public String readWord() throws IOException {
            skip();
            int start = pos;
            while (pos < line.length() && !isSpace(line.charAt(pos))) {
                pos++;
            }
            return line.substring(start, pos);
        }

        public int readInt() throws IOException {
            return Integer.parseInt(readWord());
        }

        private void skip() throws IOException {
            while (true) {
                if (pos >= line.length()) {
                    line = reader.readLine();
                    pos = 0;
                }
                while (pos < line.length() && isSpace(line.charAt(pos))) {
                    pos++;
                }
                if (pos < line.length()) {
                    return;
                }
            }
        }

    }
}

",5,1209_A,CODEFORCES,3450,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Main {

    public static void main(String[] args) throws IOException {
        new Main().run();
    }


    private void run() throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(reader.readLine());
        int[] arr = new int[n];
        String[] line = reader.readLine().split(""\\s"");

        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(line[i]);
        }

        Arrays.sort(arr);

        Set<Integer> numbers = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            Iterator<Integer> iter = numbers.iterator();
            boolean contains = false;
            while (iter.hasNext()){
                int elem = iter.next();
                if(gcd(elem, arr[i]) == elem){
                    contains = true;
                }

            }
            if(!contains)
                numbers.add(arr[i]);
        }


        System.out.println(numbers.size());

    }

    private int gcd(int a, int b){
        while (a != b){
            if(a > b)
                a -= b;
            else
                b -= a;
        }

        return a;
    }



}",5,1209_A,CODEFORCES,3565,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.awt.*;
import java.io.PrintWriter;
import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for (int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        boolean vis[]=new boolean[n];
        int c=0;
        for (int i=0;i<n;i++){
            int min=200;
            for (int j=0;j<n;j++){
                if (!vis[j] && min>arr[j]){
                    min=arr[j];
                }
            }
            for (int j=0;j<n;j++){
                if (!vis[j]&&arr[j]%min==0){
                    vis[j]=true;
//                    System.out.println(arr[j]);
                }
            }
            if (min!=200){
                c++;
//                System.out.println(min+"" k"");
            }else break;
        }
        System.out.println(c);
    }
}",5,1209_A,CODEFORCES,3544,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class Paint {
    public static void main (String srgs[] ){
        
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        TreeSet<Integer> ts=new TreeSet<>();
        for(int i=0;i<n;++i){
            ts.add(sc.nextInt());
        }
        int x=0;
        int a[]=new int[ts.size()];
        for(int y:ts){
            a[x++]=y;
        }
        for(int i=0;i<ts.size()-1;++i){
            for(int j=i+1;j<ts.size();++j){
                if((a[i]!=-1)&&(a[j]!=-1)&&(a[j]%a[i]==0)){
                    a[j]=-1;
                }
            }
        }
        int c=0;
        for(int z:a){
            if(z!=-1)++c;
        }
        System.out.print(c);
    }
}",5,1209_A,CODEFORCES,3551,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"//package Round584;

import java.util.Arrays;
import java.util.Scanner;

public class Problem1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		int n = sc.nextInt();
		int a []=new int[n];
		for(int i=0;i<n;i++) {
			a[i]=sc.nextInt();
		}
		Arrays.sort(a);
//		System.out.println(Arrays.toString(a));
		int k=a.length;
		for(int i=a.length-1;i>=0;i--) {
			int A=a[i];
			for (int j=0;j<i;j++) {
				if(A%a[j]==0) {
					k--;
					break;
				}
			}
		}
		System.out.println(k);
		sc.close();
	}

}
",5,1209_A,CODEFORCES,3588,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/*Author: Satyajeet Singh, Delhi Technological University*/
    import java.io.*;
    import java.util.*;
    import java.text.*; 
    import java.lang.*;
    import java.math.*;
 
public class Main{
/*********************************************Constants******************************************/
    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static long mod=(long)1e9+7;
    static long mod1=998244353;
    static boolean sieve[];
    static ArrayList<Integer> primes;
    static long factorial[],invFactorial[];
    static HashSet<Pair> graph[];
    static boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
/****************************************Solutions Begins***************************************/
    public static void main (String[] args) throws Exception {
        String st[]=nl();
        int n=pi(st[0]);
        int input[]=new int[n];
        st=nl();
        for(int i=0;i<n;i++){
            input[i]=pi(st[i]);
        }
        int ans=0;
        Arrays.sort(input);
        boolean dp[]=new boolean[n];
        for(int i=0;i<n;i++){
            if(!dp[i]){
                ans++;
                for(int j=input[i];j<=200;j+=input[i]){
                    for(int k=i;k<n;k++){
                        if(input[k]==j&&!dp[k])dp[k]=true;
                    }
                }
            }
        }
        out.println(ans);
/****************************************Solutions Ends**************************************************/
        out.flush();
        out.close();
    }
/****************************************Template Begins************************************************/
    static String[] nl() throws Exception{
        return br.readLine().split("" "");
    }
    static String[] nls() throws Exception{
        return br.readLine().split("""");
    }
    static int pi(String str) {
        return Integer.parseInt(str);
    }
    static long pl(String str){
        return Long.parseLong(str);
    }
    static double pd(String str){
        return Double.parseDouble(str);
    }
/***************************************Precision Printing**********************************************/
    static void printPrecision(double d){
        DecimalFormat ft = new DecimalFormat(""0.000000000000000000000""); 
        out.println(ft.format(d));
    }
/**************************************Bit Manipulation**************************************************/
    static void printMask(long mask){
        System.out.println(Long.toBinaryString(mask));
    }
    static int countBit(int mask){
        int ans=0;
        while(mask!=0){
            if(mask%2==1){
                ans++;
            }
            mask/=2;
        }
        return ans;
    }
/******************************************Graph*********************************************************/
    static void Makegraph(int n){
        graph=new HashSet[n];
        for(int i=0;i<n;i++){
            graph[i]=new HashSet<>();
        }
    }
    static void addEdge(int a,int b){
        graph[a].add(new Pair(b,1));
    }
    static void addEdge(int a,int b,int c){
        graph[a].add(new Pair(b,c));
    }    
/*********************************************PAIR********************************************************/
    static class PairComp implements Comparator<Pair>{
        public int compare(Pair p1,Pair p2){
            return p1.u-p2.u;
        }
    }
    static class Pair implements Comparable<Pair> {
        int u;
        int v;
        int index=-1;
        public Pair(int u, int v) {
            this.u = u;
            this.v = v;
        }
        public int hashCode() {
            int hu = (int) (u ^ (u >>> 32));
            int hv = (int) (v ^ (v >>> 32));
            return 31 * hu + hv;
        }
        public boolean equals(Object o) {
            Pair other = (Pair) o;
            return u == other.u && v == other.v;
        }
        public int compareTo(Pair other) {
            if(index!=other.index)
                return Long.compare(index, other.index);
            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
        }
        public String toString() {
            return ""[u="" + u + "", v="" + v + ""]"";
        }
    }
/******************************************Long Pair*******************************************************/
    static class PairCompL implements Comparator<Pairl>{
        public int compare(Pairl p1,Pairl p2){
            if(p1.u-p2.u<0){
                return -1;
            }
            else if(p1.u-p2.u>0){
                return 1;
            }
            else{
                if(p1.v-p2.v<0){
                    return -1;
                }
                else if(p1.v-p2.v>0){
                    return 1;
                }
                else{
                    return 0;
                }
            }
        }
    }
    static class Pairl implements Comparable<Pairl> {
            long u;
            long v;
            int index=-1;
            public Pairl(long u, long v) {
                this.u = u;
                this.v = v;
            }
    
            public int hashCode() {
                int hu = (int) (u ^ (u >>> 32));
                int hv = (int) (v ^ (v >>> 32));
                return 31 * hu + hv;
            }
    
            public boolean equals(Object o) {
                Pairl other = (Pairl) o;
                return u == other.u && v == other.v;
            }
    
            public int compareTo(Pairl other) {
                if(index!=other.index)
                    return Long.compare(index, other.index);
                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
            }
    
            public String toString() {
                return ""[u="" + u + "", v="" + v + ""]"";
            }
        }
/*****************************************DEBUG***********************************************************/
    public static void debug(Object... o) {
        if(!oj)
        System.out.println(Arrays.deepToString(o));
    }
/************************************MODULAR EXPONENTIATION***********************************************/
    static long modulo(long a,long b,long c) {
        long x=1;
        long y=a;
        while(b > 0){
            if(b%2 == 1){
                x=(x*y)%c;
            }
            y = (y*y)%c; // squaring the base
            b /= 2;
        }
        return  x%c;
    }
/********************************************GCD**********************************************************/
    static long gcd(long x, long y)
    {
        if(x==0)
            return y;
        if(y==0)
            return x;
        long r=0, a, b;
        a = (x > y) ? x : y; // a is greater number
        b = (x < y) ? x : y; // b is smaller number
        r = b;
        while(a % b != 0)
        {
            r = a % b;
            a = b;
            b = r;
        }
        return r;
    }
/******************************************SIEVE**********************************************************/
    static void sieveMake(int n){
        sieve=new boolean[n];
        Arrays.fill(sieve,true);
        sieve[0]=false;
        sieve[1]=false;
        for(int i=2;i*i<n;i++){
            if(sieve[i]){
                for(int j=i*i;j<n;j+=i){
                    sieve[j]=false;
                }
            }
        }
        primes=new ArrayList<Integer>();
        for(int i=0;i<n;i++){
            if(sieve[i]){
                primes.add(i);
            }
        }        
    }
/********************************************End***********************************************************/
}",5,1209_A,CODEFORCES,3575,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class PaintTheNumbers {
    public static void main(String[] args) throws IOException {
        int[] colors = new int[101];
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int N = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(f.readLine());
        for (int i = 0; i < N; i++) {
            colors[Integer.parseInt(st.nextToken())]++;
        }
        int colorCount = 0;
        for (int i = 1; i <= 100; i++) {
            if (colors[i] != 0) {
                colors[i] = 0;
                for (int multiple = 2; multiple * i <= 100; multiple++) {
                    colors[i*multiple] = 0;
                }
                colorCount++;
            }
        }
        System.out.println(colorCount);
    }
}
",5,1209_A,CODEFORCES,3484,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.math.BigInteger;
import java.util.Map.Entry;

import static java.lang.Math.*;

public class A extends PrintWriter {

    void run() {
        int n = nextInt();
        int m = 101;
        boolean[] c = new boolean[m];

        for (int i = 0; i < n; i++) {
            int v = nextInt();
            c[v] = true;
        }

        int ans = 0;

        for (int v = 1; v < m; v++) {
            if (c[v]) {
                ++ans;
                for (int u = v; u < m; u += v) {
                    c[u] = false;
                }

            }
        }

        println(ans);

    }

    boolean skip() {
        while (hasNext()) {
            next();
        }
        return true;
    }

    int[][] nextMatrix(int n, int m) {
        int[][] matrix = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                matrix[i][j] = nextInt();
        return matrix;
    }

    String next() {
        while (!tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(nextLine());
        return tokenizer.nextToken();
    }

    boolean hasNext() {
        while (!tokenizer.hasMoreTokens()) {
            String line = nextLine();
            if (line == null) {
                return false;
            }
            tokenizer = new StringTokenizer(line);
        }
        return true;
    }

    int[] nextArray(int n) {
        int[] array = new int[n];
        for (int i = 0; i < n; i++) {
            array[i] = nextInt();
        }
        return array;
    }

    int nextInt() {
        return Integer.parseInt(next());
    }

    long nextLong() {
        return Long.parseLong(next());
    }

    double nextDouble() {
        return Double.parseDouble(next());
    }

    String nextLine() {
        try {
            return reader.readLine();
        } catch (IOException err) {
            return null;
        }
    }

    public A(OutputStream outputStream) {
        super(outputStream);
    }

    static BufferedReader reader;
    static StringTokenizer tokenizer = new StringTokenizer("""");
    static Random rnd = new Random();
    static boolean OJ;

    public static void main(String[] args) throws IOException {
        OJ = System.getProperty(""ONLINE_JUDGE"") != null;
        A solution = new A(System.out);
        if (OJ) {
            reader = new BufferedReader(new InputStreamReader(System.in));
            solution.run();
        } else {
            reader = new BufferedReader(new FileReader(new File(A.class.getName() + "".txt"")));
            long timeout = System.currentTimeMillis();
            while (solution.hasNext()) {
                solution.run();
                solution.println();
                solution.println(""----------------------------------"");
            }
            solution.println(""time: "" + (System.currentTimeMillis() - timeout));
        }
        solution.close();
        reader.close();
    }
}
",5,1209_A,CODEFORCES,3488,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.text.*;
import java.math.*;
import static java.lang.Integer.*;
import static java.lang.Double.*;
import java.lang.Math.*;

public class A {

	public static void main(String[] args) throws Exception {
		new A().run();
	}

	public void run() throws Exception {
		FastIO file = new FastIO();
		int n = file.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = file.nextInt();
		Arrays.sort(a);
		boolean[] used = new boolean[n];
		int count = 0;
		for (int i = 0; i < n; i++) {
			if (!used[i]) {
				count++;
				for (int j = i; j < n; j++) {
					if (a[j] % a[i] == 0) {
						used[j] = true;
					}
				}
			}
		}
		System.out.println(count);
	}

	public static class FastIO {
		BufferedReader br;
		StringTokenizer st;

		public FastIO() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}

	public static long pow(long n, long p, long mod) {
		if (p == 0)
			return 1;
		if (p == 1)
			return n % mod;
		if (p % 2 == 0) {
			long temp = pow(n, p / 2, mod);
			return (temp * temp) % mod;
		} else {
			long temp = pow(n, (p - 1) / 2, mod);
			temp = (temp * temp) % mod;
			return (temp * n) % mod;

		}
	}

	public static long pow(long n, long p) {
		if (p == 0)
			return 1;
		if (p == 1)
			return n;
		if (p % 2 == 0) {
			long temp = pow(n, p / 2);
			return (temp * temp);
		} else {
			long temp = pow(n, (p - 1) / 2);
			temp = (temp * temp);
			return (temp * n);

		}
	}

	public static long gcd(long x, long y) {
		if (x == 0)
			return y;
		else
			return gcd(y % x, x);
	}

	public static boolean isPrime(int n) {
		if (n <= 1)
			return false;
		if (n <= 3)
			return true;

		if (n % 2 == 0 || n % 3 == 0)
			return false;

		for (int i = 5; i * i <= n; i = i + 6)
			if (n % i == 0 || n % (i + 2) == 0)
				return false;

		return true;
	}
}
",5,1209_A,CODEFORCES,3499,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
public class algo_2701
{
    public static void main(String args[])
    {
        Scanner ex=new Scanner(System.in);
        int n=ex.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        arr[i]=ex.nextInt();
        Arrays.sort(arr);
        int ans=0;
        int check[]=new int[n];
        for(int i=0;i<n;i++)
        {
            if(check[i]==0)
            {
                ans++;
                for(int j=i;j<n;j++)
                {
                    if(arr[j]%arr[i]==0)
                    check[j]=1;
                }
            }
        }
        System.out.println(ans);
    }
}",5,1209_A,CODEFORCES,3493,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author prakhar897
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            int arr[] = in.nextIntArray(n);
            Arrays.sort(arr);
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (arr[i] == -1)
                    continue;
                else {
                    //out.println(arr[i]);
                    ans++;
                    for (int j = i + 1; j < n; j++) {
                        if (arr[j] % arr[i] == 0)
                            arr[j] = -1;
                    }
                    arr[i] = -1;
                    //out.println(arr);
                }
            }
            out.println(ans);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; ++i) array[i] = nextInt();
            return array;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(int i) {
            writer.println(i);
        }

    }
}

",5,1209_A,CODEFORCES,3574,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int N = in.nextInt();
            Integer a[] = in.nextIntArray(N);
            Arrays.sort(a);
            int colors = 0;
            for (int i = 0; i < N; i++) {
                if (a[i] == -1) continue;
                colors++;
                for (int j = i + 1; j < N; j++) {
                    if (a[j] % a[i] == 0) {
                        a[j] = -1;
                    }
                }
            }
            out.printLine(colors);
        }

    }

    static class InputReader {
        BufferedReader in;
        StringTokenizer tokenizer = null;

        public InputReader(InputStream inputStream) {
            in = new BufferedReader(new InputStreamReader(inputStream));
        }

        public String next() {
            try {
                while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                    tokenizer = new StringTokenizer(in.readLine());
                }
                return tokenizer.nextToken();
            } catch (IOException e) {
                return null;
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public Integer[] nextIntArray(int size) {
            Integer array[] = new Integer[size];
            for (int i = 0; i < size; i++) {
                array[i] = nextInt();
            }
            return array;
        }

    }

    static class OutputWriter {
        PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }
}

",5,1209_A,CODEFORCES,3526,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;

public class PTM {

    public static void main(String[] args) throws Exception {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter printWriter = new PrintWriter(System.out);
        int N = Integer.parseInt(bufferedReader.readLine());
        String[] strings = bufferedReader.readLine().split("" "");
        int[] arr = new int[strings.length];
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < N; i++) {
            arr[i] = Integer.parseInt(strings[i]);
            set.add(arr[i]);
        }
        Arrays.sort(arr);
        int c = 0;
        for (int i = 0; i < N; i++) {
            int value = arr[i];
            if (!set.contains(value)) {
                continue;
            }
            for (int j = 1; j <= 100; j++) {
                if (set.contains(value * j)) {
                    set.remove(value * j);
                }
            }
            c++;
        }
        printWriter.println(c);
        printWriter.flush();
    }
}
",5,1209_A,CODEFORCES,3463,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*; 
import java.math.*;
import java.util.*;
 
public class Main {
	static final long MOD = 998244353;
	//static final long MOD = 1000000007;
	static boolean[] visited;
    public static void main(String[] args) throws IOException {
        FastScanner sc = new FastScanner();
        int N = sc.nextInt();
        int[] nums = new int[N];
        for (int i = 0; i < N; i++) {
        	nums[i] = sc.nextInt();
        }
        Arrays.sort(nums);
        boolean[] hit = new boolean[N];
        int colors = 0;
        int index = 0;
        while (index < N) {
        	if (hit[index] == false) {
        		colors++;
        		int div = nums[index];
        		for (int i = index; i < N; i++) {
        			if (nums[i] % div == 0) {
        				hit[i] = true;
        			}
        		}
        	}
        	index++;
        }
        System.out.println(colors);
    }
    
    public static int[][] sort(int[][] array) {
    	//Sort an array (immune to quicksort TLE)
		Random rgen = new Random();
		for (int i = 0; i< array.length; i++) {
		    int randomPosition = rgen.nextInt(array.length);
		    int[] temp = array[i];
		    array[i] = array[randomPosition];
		    array[randomPosition] = temp;
		}
		Arrays.sort(array, new Comparator<int[]>() {
			  @Override
			  public int compare(int[] arr1, int[] arr2) {
				  //Ascending order
				  if (arr1[0] != arr2[0])
					  return arr1[0]-arr2[0];
				  else
					  return arr2[1]-arr1[1];
			  }
		});
		return array;
	}
    
    static class FastScanner { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastScanner() { 
            br = new BufferedReader(new InputStreamReader(System.in)); 
        } 
  
        String next() { 
            while (st == null || !st.hasMoreElements()) { 
                try { 
                    st = new StringTokenizer(br.readLine());
                } catch (IOException  e) { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() { 
            String str = """"; 
            try { 
                str = br.readLine(); 
            } catch (IOException e) {
                e.printStackTrace(); 
            } 
            return str; 
        }
    }
}

class Node {
	public HashSet<Node> children;
	public int n;
	
	public Node(int n) {
		this.n = n;
		children = new HashSet<Node>();
	}
	
	public void addChild(Node node) {
		children.add(node);
	}
	
	public void removeChild(Node node) {
		children.remove(node);
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return n;
	}

	@Override
	public boolean equals(Object obj) {
		if (! (obj instanceof Node)) {
			return false;
		} else {
			Node node = (Node) obj;
			return (n == node.n);
		}
	}
	
	public String toString() {
		return (this.n+1)+"""";
	}
}",5,1209_A,CODEFORCES,3455,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class cf573 {
    public static void main(String[] args){
        Scanner scan=new Scanner(System.in);
        int n=0;
        if(scan.hasNext())
            n=scan.nextInt();
        TreeSet<Integer> set=new TreeSet<>();
        for(int i=0;i<n;i++){
            if(scan.hasNext())
                set.add(scan.nextInt());
        }
        int[] arr=new int[set.size()];
        Iterator<Integer> it=set.iterator();
        int j=0;
        while(it.hasNext()){
            arr[j++]=it.next();
        }
        int tot=1,flag;
        for(int i=1;i<arr.length;i++){
            flag=0;
            for(int k=0;k<i;k++){
                if(arr[i]%arr[k]==0){
                    flag=1;
                    break;
                }
            }
            if(flag==0){
                tot++;
            }
        }
        System.out.println(tot);
    }
}
",5,1209_A,CODEFORCES,3566,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.math.*;
 
public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        //Scanner sc = new Scanner();
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();
 
    }
 
    static int INF = (int)1e9;
    static int maxn = (int)2e5+5;
    static int mod= 998244353 ;
    static int n,m,k,t,q,d,cnt=2;
    
    void solve(PrintWriter out, Reader in) throws IOException{
        n = in.nextInt();
        
        Integer[] arr = new Integer[n];
        for(int i=0;i<n;i++) arr[i] = in.nextInt();
        
        boolean[] vis = new boolean[n];
        
        Arrays.sort(arr);
        int cnt=0;
        for(int i=0;i<n;i++){
            if(vis[i]) continue;
            cnt++;
            vis[i]=true;
            for(int j=i+1;j<n;j++){
                if(!vis[j]){
                    if(arr[j]%arr[i]==0){
                        vis[j]=true;
                    }
                }
            }
        }
        
        
        out.println(cnt);
        
    }
    
    //<>
    
    static class Reader {

    private InputStream mIs;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public Reader() {
        this(System.in);
    }

    public Reader(InputStream is) {
        mIs = is;
    }

    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();

    }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = mIs.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public String nextLine() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isEndOfLine(c));
        return res.toString();
    }

    public String next() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    double nextDouble()
    {
        return Double.parseDouble(next());
    }

    public long nextLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public int nextInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public boolean isEndOfLine(int c) {
        return c == '\n' || c == '\r' || c == -1;
    }

    }
}",5,1209_A,CODEFORCES,3554,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;

public class A {
    public static void main(String[] args) {
        FastScanner scanner = new FastScanner();
        PrintWriter out = new PrintWriter(System.out, false);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        Arrays.sort(arr);
        int[] cols = new int[n];
        Arrays.fill(cols, -1);
        int ans = 0;
        for(int i = 0; i < n; i++) {
            if (cols[i] == -1) {
                cols[i] = ans++;
                for(int j = i + 1; j < n; j++) {
                    if (arr[j] % arr[i] == 0) cols[j] = cols[i];
                }
            }
        }
        out.println(ans);
        out.flush();
    }
    
    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;
        
        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }
        
        public FastScanner() {
            this(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        int nextInt() {
            return Integer.parseInt(next());
        }
        
        long nextLong() {
            return Long.parseLong(next());
        }
        
        double nextDouble() {
            return Double.parseDouble(next());
        }
        
        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
",5,1209_A,CODEFORCES,3587,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class A {

  static int countColors(List<Integer> colors) {
    Collections.sort(colors);
    int k = 0;
    while (!colors.isEmpty()) {
      Integer c = colors.get(0);
      colors.remove(0);
      k++;

      List<Integer> toRemove = new ArrayList<>();
      for (int i = 0; i < colors.size(); i++) {
        if (colors.get(i) % c == 0) toRemove.add(i);
      }

      Collections.reverse(toRemove);
      for (Integer integer : toRemove) {
        colors.remove(integer.intValue());
      }
    }
    return k;
  }

  public static void main(String[] args) {
    try (Scanner scanner = new Scanner(System.in)) {
      int n = scanner.nextInt();
      scanner.nextLine();
      List<Integer> integers = Arrays.stream(scanner.nextLine().split("" "")).map(Integer::parseInt).collect(Collectors.toList());
      System.out.println(countColors(integers));
    }
  }
}
",5,1209_A,CODEFORCES,3590,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class PaintColor {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String input[] = br.readLine().split("" "");
        int c = 0;
        Set<Integer> s = new HashSet<>();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(input[i]);
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            if (!s.contains(arr[i])) {
                c++;
                for (int j = i; j < n; j++) {
                    if (arr[j] % arr[i] == 0) {
                        s.add(arr[j]);
                    }
                }
            }
        }
        System.out.println(c);
    }
}
",5,1209_A,CODEFORCES,3529,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Scanner;

public class first {
	static int max = 1000000000;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] tab = new int[n];
		for(int i=0;i<n;i++) {
			tab[i] = sc.nextInt();
		}
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(i!=j)
				if(tab[i]>=tab[j] && tab[i]%tab[j]==0) {
					tab[i] = max;
				}
			}
		}
		int res = 0;
		for(int i=0;i<n;i++) {
			if(tab[i]!=max) res++;
		}
		System.out.println(res);
		//System.out.println(4%-1);
	}

}
",5,1209_A,CODEFORCES,3537,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner  scan = new Scanner(System.in);
        int n = scan.nextInt();
        int[] nums = new int[n];
        for(int i = 0; i < n; i++){
            nums[i] = scan.nextInt();
        }
        Arrays.sort(nums);
        boolean[] div = new boolean[n];
        int count = 0;
        for(int i = 0; i < n; i++) {
            if (!div[i]) {

                count++;
                div[i] = true;
                for(int j = i+1; j < n; j++) {
                    if (nums[j] % nums[i] == 0) {
                        div[j] = true;
                    }
                }
            }
        }
        System.out.println(count);

    }
}
",5,1209_A,CODEFORCES,3559,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.NoSuchElementException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Egor Kulikov (egor@egork.net)
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.readInt();
            int[] a = in.readIntArray(n);
            ArrayUtils.sort(a);
            boolean[] done = new boolean[n];
            int answer = 0;
            for (int i = 0; i < n; i++) {
                if (done[i]) {
                    continue;
                }
                answer++;
                for (int j = i; j < n; j++) {
                    if (a[j] % a[i] == 0) {
                        done[j] = true;
                    }
                }
            }
            out.printLine(answer);
        }

    }

    static class Sorter {
        private static final int INSERTION_THRESHOLD = 16;

        private Sorter() {
        }

        public static void sort(IntList list, IntComparator comparator) {
            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                    comparator);
        }

        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {
            if (to - from < INSERTION_THRESHOLD) {
                insertionSort(list, from, to, comparator);
                return;
            }
            if (remaining == 0) {
                heapSort(list, from, to, comparator);
                return;
            }
            remaining--;
            int pivotIndex = (from + to) >> 1;
            int pivot = list.get(pivotIndex);
            list.swap(pivotIndex, to);
            int storeIndex = from;
            int equalIndex = to;
            for (int i = from; i < equalIndex; i++) {
                int value = comparator.compare(list.get(i), pivot);
                if (value < 0) {
                    list.swap(storeIndex++, i);
                } else if (value == 0) {
                    list.swap(--equalIndex, i--);
                }
            }
            quickSort(list, from, storeIndex - 1, remaining, comparator);
            for (int i = equalIndex; i <= to; i++) {
                list.swap(storeIndex++, i);
            }
            quickSort(list, storeIndex, to, remaining, comparator);
        }

        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {
            for (int i = (to + from - 1) >> 1; i >= from; i--) {
                siftDown(list, i, to, comparator, from);
            }
            for (int i = to; i > from; i--) {
                list.swap(from, i);
                siftDown(list, from, i - 1, comparator, from);
            }
        }

        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {
            int value = list.get(start);
            while (true) {
                int child = ((start - delta) << 1) + 1 + delta;
                if (child > end) {
                    return;
                }
                int childValue = list.get(child);
                if (child + 1 <= end) {
                    int otherValue = list.get(child + 1);
                    if (comparator.compare(otherValue, childValue) > 0) {
                        child++;
                        childValue = otherValue;
                    }
                }
                if (comparator.compare(value, childValue) >= 0) {
                    return;
                }
                list.swap(start, child);
                start = child;
            }
        }

        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {
            for (int i = from + 1; i <= to; i++) {
                int value = list.get(i);
                for (int j = i - 1; j >= from; j--) {
                    if (comparator.compare(list.get(j), value) <= 0) {
                        break;
                    }
                    list.swap(j, j + 1);
                }
            }
        }

    }

    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {
        public IntIterator intIterator();

        default public Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                private IntIterator it = intIterator();

                public boolean hasNext() {
                    return it.isValid();
                }

                public Integer next() {
                    int result = it.value();
                    it.advance();
                    return result;
                }
            };
        }

        default public int compareTo(IntStream c) {
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                int i = it.value();
                int j = jt.value();
                if (i < j) {
                    return -1;
                } else if (i > j) {
                    return 1;
                }
                it.advance();
                jt.advance();
            }
            if (it.isValid()) {
                return 1;
            }
            if (jt.isValid()) {
                return -1;
            }
            return 0;
        }

    }

    static interface IntComparator {
        public static final IntComparator DEFAULT = (first, second) -> {
            if (first < second) {
                return -1;
            }
            if (first > second) {
                return 1;
            }
            return 0;
        };

        public int compare(int first, int second);

    }

    static class IntArray extends IntAbstractStream implements IntList {
        private int[] data;

        public IntArray(int[] arr) {
            data = arr;
        }

        public int size() {
            return data.length;
        }

        public int get(int at) {
            return data[at];
        }

        public void addAt(int index, int value) {
            throw new UnsupportedOperationException();
        }

        public void removeAt(int index) {
            throw new UnsupportedOperationException();
        }

        public void set(int index, int value) {
            data[index] = value;
        }

    }

    static interface IntIterator {
        public int value() throws NoSuchElementException;

        public boolean advance();

        public boolean isValid();

    }

    static abstract class IntAbstractStream implements IntStream {
        public String toString() {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                if (first) {
                    first = false;
                } else {
                    builder.append(' ');
                }
                builder.append(it.value());
            }
            return builder.toString();
        }

        public boolean equals(Object o) {
            if (!(o instanceof IntStream)) {
                return false;
            }
            IntStream c = (IntStream) o;
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                if (it.value() != jt.value()) {
                    return false;
                }
                it.advance();
                jt.advance();
            }
            return !it.isValid() && !jt.isValid();
        }

        public int hashCode() {
            int result = 0;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                result *= 31;
                result += it.value();
            }
            return result;
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int[] readIntArray(int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = readInt();
            }
            return array;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static interface IntCollection extends IntStream {
        public int size();

        default public void add(int value) {
            throw new UnsupportedOperationException();
        }

        default public IntCollection addAll(IntStream values) {
            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {
                add(it.value());
            }
            return this;
        }

    }

    static interface IntReversableCollection extends IntCollection {
    }

    static class IntArrayList extends IntAbstractStream implements IntList {
        private int size;
        private int[] data;

        public IntArrayList() {
            this(3);
        }

        public IntArrayList(int capacity) {
            data = new int[capacity];
        }

        public IntArrayList(IntCollection c) {
            this(c.size());
            addAll(c);
        }

        public IntArrayList(IntStream c) {
            this();
            if (c instanceof IntCollection) {
                ensureCapacity(((IntCollection) c).size());
            }
            addAll(c);
        }

        public IntArrayList(IntArrayList c) {
            size = c.size();
            data = c.data.clone();
        }

        public IntArrayList(int[] arr) {
            size = arr.length;
            data = arr.clone();
        }

        public int size() {
            return size;
        }

        public int get(int at) {
            if (at >= size) {
                throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size);
            }
            return data[at];
        }

        private void ensureCapacity(int capacity) {
            if (data.length >= capacity) {
                return;
            }
            capacity = Math.max(2 * data.length, capacity);
            data = Arrays.copyOf(data, capacity);
        }

        public void addAt(int index, int value) {
            ensureCapacity(size + 1);
            if (index > size || index < 0) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            if (index != size) {
                System.arraycopy(data, index, data, index + 1, size - index);
            }
            data[index] = value;
            size++;
        }

        public void removeAt(int index) {
            if (index >= size || index < 0) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            if (index != size - 1) {
                System.arraycopy(data, index + 1, data, index, size - index - 1);
            }
            size--;
        }

        public void set(int index, int value) {
            if (index >= size) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            data[index] = value;
        }

    }

    static class ArrayUtils {
        public static int[] sort(int[] array) {
            return sort(array, IntComparator.DEFAULT);
        }

        public static int[] sort(int[] array, IntComparator comparator) {
            return sort(array, 0, array.length, comparator);
        }

        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
            if (from == 0 && to == array.length) {
                new IntArray(array).sort(comparator);
            } else {
                new IntArray(array).subList(from, to).sort(comparator);
            }
            return array;
        }

    }

    static interface IntList extends IntReversableCollection {
        public abstract int get(int index);

        public abstract void set(int index, int value);

        public abstract void addAt(int index, int value);

        public abstract void removeAt(int index);

        default public void swap(int first, int second) {
            if (first == second) {
                return;
            }
            int temp = get(first);
            set(first, get(second));
            set(second, temp);
        }

        default public IntIterator intIterator() {
            return new IntIterator() {
                private int at;
                private boolean removed;

                public int value() {
                    if (removed) {
                        throw new IllegalStateException();
                    }
                    return get(at);
                }

                public boolean advance() {
                    at++;
                    removed = false;
                    return isValid();
                }

                public boolean isValid() {
                    return !removed && at < size();
                }

                public void remove() {
                    removeAt(at);
                    at--;
                    removed = true;
                }
            };
        }

        default public void add(int value) {
            addAt(size(), value);
        }

        default public IntList sort(IntComparator comparator) {
            Sorter.sort(this, comparator);
            return this;
        }

        default public IntList subList(final int from, final int to) {
            return new IntList() {
                private final int shift;
                private final int size;

                {
                    if (from < 0 || from > to || to > IntList.this.size()) {
                        throw new IndexOutOfBoundsException(""from = "" + from + "", to = "" + to + "", size = "" + size());
                    }
                    shift = from;
                    size = to - from;
                }

                public int size() {
                    return size;
                }

                public int get(int at) {
                    if (at < 0 || at >= size) {
                        throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size());
                    }
                    return IntList.this.get(at + shift);
                }

                public void addAt(int index, int value) {
                    throw new UnsupportedOperationException();
                }

                public void removeAt(int index) {
                    throw new UnsupportedOperationException();
                }

                public void set(int at, int value) {
                    if (at < 0 || at >= size) {
                        throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size());
                    }
                    IntList.this.set(at + shift, value);
                }

                public IntList compute() {
                    return new IntArrayList(this);
                }
            };
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }

    }
}

",5,1209_A,CODEFORCES,3513,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class DivRound584ProblemA {
	static FastReader sc=new FastReader();
	
	public static void main(String args[]) throws IOException {
		int n = sc.nextInt();
		
		int a[]=new int[n];
		
		for(int i=0;i<n;i++)
			a[i]=sc.nextInt();
		
		Arrays.sort(a);
		int c=0;
		for(int i=0;i<n;i++) {
			if(a[i]<0) continue;
			c=c-1;
			for(int j=i+1;j<n;j++) {
				if(a[j]<0) continue;
				if(a[j]%a[i]==0) {
					//System.out.println(a[i]+"" : ""+a[j]);
					a[j]=c;
				}
			}
			//System.out.println(c);
		}
		System.out.println(Math.abs(c));
	}
	
	static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    }
}
",5,1209_A,CODEFORCES,3563,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            Arrays.sort(a);
            int nc = 0;
            for (int i = 0; i < n; i++) {
                boolean divs = false;
                for (int j = 0; j < i; j++) {
                    if (a[i] % a[j] == 0) {
                        divs = true;
                        break;
                    }
                }
                if (!divs) {
                    nc++;
                }
            }
            out.println(nc);
        }

    }
}

",5,1209_A,CODEFORCES,3504,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class A {
    FastScanner in;
    PrintWriter out;

    void solve() {
        int n = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        Arrays.sort(a);
        int res = 0;
        for (int i = 0; i < n; i++) {
            boolean ok = false;
            for (int j = 0; j < i; j++) {
                if (a[i] % a[j] == 0) {
                    ok = true;
                }
            }
            if (!ok) {
                res++;
            }
        }
        out.println(res);
    }

    void run() {
        try {
            in = new FastScanner(new File(""A.in""));
            out = new PrintWriter(new File(""A.out""));

            solve();

            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    void runIO() {

        in = new FastScanner(System.in);
        out = new PrintWriter(System.out);

        solve();

        out.close();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(File f) {
            try {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public FastScanner(InputStream f) {
            br = new BufferedReader(new InputStreamReader(f));
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return null;
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        boolean hasMoreTokens() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return false;
                st = new StringTokenizer(s);
            }
            return true;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    public static void main(String[] args) {
        new A().runIO();
    }
}
",5,1209_A,CODEFORCES,3464,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/**
 * ******* Created by bla on 14/9/19 6:17 PM*******
 */

import java.io.*;
import java.util.*;

public class A1209 {
    public static void main(String[] args) throws IOException {
        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {
            int n = input.nextInt();
            int[] arr = input.readIntArray(n);

            Arrays.sort(arr);
            int ans =0;
            boolean[] vis = new boolean[n];
            for(int i=0;i<n;i++){
                if(!vis[i]){
                    vis[i]=true;
                    for(int j=i+1;j<n;j++){
                        if(!vis[j] && arr[j]%arr[i]==0){
                            vis[j]=true;                    }
                    }
                    ans++;
                }
            }
            System.out.println(ans);
        }
    }

    interface Input extends Closeable {
        String next() throws IOException;

        default int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        default long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        default double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        default int[] readIntArray() throws IOException {
            return readIntArray(nextInt());
        }

        default int[] readIntArray(int size) throws IOException {
            int[] array = new int[size];
            for (int i = 0; i < array.length; i++) {
                array[i] = nextInt();
            }
            return array;
        }

        default long[] readLongArray(int size) throws IOException {
            long[] array = new long[size];
            for (int i = 0; i < array.length; i++) {
                array[i] = nextLong();
            }
            return array;
        }
    }

    private static class StandardInput implements Input {
        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        private StringTokenizer stringTokenizer;

        @Override
        public void close() throws IOException {
            reader.close();
        }

        @Override
        public String next() throws IOException {
            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {
                stringTokenizer = new StringTokenizer(reader.readLine());
            }
            return stringTokenizer.nextToken();
        }
    }
}
",5,1209_A,CODEFORCES,3500,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt();
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        int ans = 0;
        boolean[] taken = new boolean[n];
        Arrays.sort(a);
        for (int i = 0; i < n; i++) {
            if (taken[i]) continue;
            ans++;
            for (int j = i; j < n; j++)
                if (a[j] % a[i] == 0) taken[j] = true;
        }
        out.println(ans);
        out.flush();
        out.close();
    }


    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream system) {
            br = new BufferedReader(new InputStreamReader(system));
        }

        public Scanner(String file) throws Exception {
            br = new BufferedReader(new FileReader(file));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public char nextChar() throws IOException {
            return next().charAt(0);
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

        public void waitForInput() throws InterruptedException {
            Thread.sleep(3000);
        }
    }
}",5,1209_A,CODEFORCES,3496,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;import java.util.*;
import java.math.*;

public class Main{
	static int max=Integer.MAX_VALUE,min=Integer.MIN_VALUE;
	static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
    static int max(int a,int b)
    {
    	return Math.max(a, b);
    }
    static int min(int a,int b)
    {
    	return Math.min(a, b);
    }
    static int i()throws IOException
    {
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	return Integer.parseInt(st.nextToken());
    }
    static long l()throws IOException
    {
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	return Long.parseLong(st.nextToken());
    }
    static String s()throws IOException
    {
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	return st.nextToken();
    }
    static double d()throws IOException
    {
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	return Double.parseDouble(st.nextToken());
    }
    static void p(String p)
    {
    	System.out.print(p);
    }
    static void p(int p)
    {
    	System.out.print(p);
    }
    static void p(double p)
    {
    	System.out.print(p);
    }
    static void p(long p)
    {
    	System.out.print(p);
    }
    static void p(char p)
    {
    	System.out.print(p);
    }
    static void p(boolean p)
    {
    	System.out.print(p);
    }
    static void pl(String pl)
    {
    	System.out.println(pl);
    }
    static void pl(int pl)
    {
    	System.out.println(pl);
    }
    static void pl(char pl)
    {
    	System.out.println(pl);
    }
    static void pl(double pl)
    {
    	System.out.println(pl);
    }
    static void pl(long pl)
    {
    	System.out.println(pl);
    }
    static void pl(boolean pl)
    {
    	System.out.println(pl);
    }
    static void pl()
    {
    	System.out.println();
    }
    static int[] ari(int n)throws IOException
    {
    	int ar[]=new int[n];
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	for(int x=0;x<n;x++)
    		ar[x]=Integer.parseInt(st.nextToken());
    	return ar;
    }
    static int[][] ari(int n,int m)throws IOException
    {
    	int ar[][]=new int[n][m];
    	for(int x=0;x<n;x++)
    	{
    		st=new StringTokenizer(br.readLine());
    		for(int y=0;y<m;y++)
    			ar[x][y]=Integer.parseInt(st.nextToken());
    	}
    	return ar;
    }
    static long[] arl(int n)throws IOException
    {
    	long ar[]=new long[n];
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	for(int x=0;x<n;x++)
    		ar[x]=Long.parseLong(st.nextToken());
    	return ar;
    }
    static long[][] arl(int n,int m)throws IOException
    {
    	long ar[][]=new long[n][m];
    	for(int x=0;x<n;x++)
    	{
    		st=new StringTokenizer(br.readLine());
    		for(int y=0;y<m;y++)
    			ar[x][y]=Long.parseLong(st.nextToken());
    	}
    	return ar;
    }
    static String[] ars(int n)throws IOException
    {
    	String ar[]=new String[n];
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	for(int x=0;x<n;x++)
    		ar[x]=st.nextToken();
    	return ar;
    }
    static String[][] ars(int n,int m)throws IOException
    {
    	String ar[][]=new String[n][m];
    	for(int x=0;x<n;x++)
    	{
    		st=new StringTokenizer(br.readLine());
    		for(int y=0;y<m;y++)
    			ar[x][y]=st.nextToken();
    	}
    	return ar;
    }
    static double[] ard(int n)throws IOException
    {
    	double ar[]=new double[n];
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	for(int x=0;x<n;x++)
    		ar[x]=Double.parseDouble(st.nextToken());
    	return ar;
    }
    static double[][] ard(int n,int m)throws IOException
    {
    	double ar[][]=new double[n][m];
    	for(int x=0;x<n;x++)
    	{
    		st=new StringTokenizer(br.readLine());
    		for(int y=0;y<m;y++)
    			ar[x][y]=Double.parseDouble(st.nextToken());
    	}
    	return ar;
    }
    static char[] arc(int n)throws IOException
    {
    	char ar[]=new char[n];
    	if(!st.hasMoreTokens())
    		st=new StringTokenizer(br.readLine());
    	for(int x=0;x<n;x++)
    		ar[x]=st.nextToken().charAt(0);
    	return ar;
    }
    static char[][] arc(int n,int m)throws IOException
    {
    	char ar[][]=new char[n][m];
    	for(int x=0;x<n;x++)
    	{
    		st=new StringTokenizer(br.readLine());
    		for(int y=0;y<m;y++)
    			ar[x][y]=st.nextToken().charAt(0);
    	}
    	return ar;
    }
    static void par(int ar[])
    {
    	for(int a:ar)
    		System.out.print(a+"" "");
    	System.out.println();
    }
    static void par(int ar[][])
    {
    	for(int a[]:ar)
    	{
    		for(int aa:a)
    			System.out.print(aa+"" "");
    		System.out.println();
    	}
    }
    static void par(long ar[])
    {
    	for(long a:ar)
    		System.out.print(a+"" "");
    	System.out.println();
    }
    static void par(long ar[][])
    {
    	for(long a[]:ar)
    	{
    		for(long aa:a)
    			System.out.print(aa+"" "");
    		System.out.println();
    	}
    }
    static void par(String ar[])
    {
    	for(String a:ar)
    		System.out.print(a+"" "");
    	System.out.println();
    }
    static void par(String ar[][])
    {
    	for(String a[]:ar)
    	{
    		for(String aa:a)
    			System.out.print(aa+"" "");
    		System.out.println();
    	}
    }
    static void par(double ar[])
    {
    	for(double a:ar)
    		System.out.print(a+"" "");
    	System.out.println();
    }
    static void par(double ar[][])
    {
    	for(double a[]:ar)
    	{
    		for(double aa:a)
    			System.out.print(aa+"" "");
    		System.out.println();
    	}
    }
    static void par(char ar[])
    {
    	for(char a:ar)
    		System.out.print(a+"" "");
    	System.out.println();
    }
    static void par(char ar[][])
    {
    	for(char a[]:ar)
    	{
    		for(char aa:a)
    			System.out.print(aa+"" "");
    		System.out.println();
    	}
    }
    static public void main(String[] args)throws Exception{
    	st=new StringTokenizer(br.readLine());
    	int n=i();
    	int ar[]=ari(n);
    	Arrays.sort(ar);
    	int c=0;
    	
    		for(int x=0;x<n;x++)
    		{
    			if(ar[x]!=-1)
    			{
    				c++;
    				for(int y=x+1;y<n;y++)
    				{
    					if(ar[y]!=-1)
    	    			{
    						if(ar[y]%ar[x]==0)
    						{
    							ar[y]=-1;
    						}
    	    			}
    				}
    				ar[x]=-1;
    			}
    		}
    		pl(c);
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    }
}



",5,1209_A,CODEFORCES,3511,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.*;
import java.util.*;

public class Main {
    private final static long mod = 1000000007;

    private final static int MAXN = 100001;

    private static long power(long x, long y, long m) {
        long temp;
        if (y == 0)
            return 1;
        temp = power(x, y / 2, m);
        temp = (temp * temp) % m;
        if (y % 2 == 0)
            return temp;
        else
            return ((x % m) * temp) % m;
    }

    private static long power(long x, long y) {
        return power(x, y, mod);
    }

    private static long gcd(long a, long b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }

    static int nextPowerOf2(int a) {
        return 1 << nextLog2(a);
    }

    static int nextLog2(int a) {
        return (a == 0 ? 0 : 32 - Integer.numberOfLeadingZeros(a - 1));
    }

    private static long modInverse(long a, long m) {
        long m0 = m;
        long y = 0, x = 1;
        if (m == 1)
            return 0;
        while (a > 1) {
            long q = a / m;
            long t = m;
            m = a % m;
            a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0)
            x += m0;
        return x;
    }

    private static int[] getLogArr(int n) {
        int arr[] = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            arr[i] = (int) (Math.log(i) / Math.log(2) + 1e-10);
        }
        return arr;
    }

    private static int log[] = getLogArr(MAXN);

    private static int getLRMax(int st[][], int L, int R) {
        int j = log[R - L + 1];
        return Math.max(st[L][j], st[R - (1 << j) + 1][j]);
    }

    private static int[][] getSparseTable(int array[]) {
        int k = log[MAXN] + 1;
        int st[][] = new int[MAXN][k + 1];

        for (int i = 0; i < array.length; i++)
            st[i][0] = array[i];

        for (int j = 1; j <= k; j++) {
            for (int i = 0; i + (1 << j) <= array.length; i++) {
                st[i][j] = Math.max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
        return st;
    }

    static class Subset {
        int parent;
        int rank;

        @Override
        public String toString() {
            return """" + parent;
        }
    }

    static int find(Subset[] Subsets, int i) {
        if (Subsets[i].parent != i)
            Subsets[i].parent = find(Subsets, Subsets[i].parent);
        return Subsets[i].parent;
    }

    static void union(Subset[] Subsets, int x, int y) {
        int xroot = find(Subsets, x);
        int yroot = find(Subsets, y);

        if (Subsets[xroot].rank < Subsets[yroot].rank)
            Subsets[xroot].parent = yroot;
        else if (Subsets[yroot].rank < Subsets[xroot].rank)
            Subsets[yroot].parent = xroot;
        else {
            Subsets[xroot].parent = yroot;
            Subsets[yroot].rank++;
        }
    }


    private static int maxx(Integer... a) {
        return Collections.max(Arrays.asList(a));
    }


    private static class Pair<T, U> {
        T a;
        U b;

        public Pair(T a, U b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Pair pair = (Pair) o;
            return a.equals(pair.a) &&
                    b.equals(pair.b);
        }

        @Override
        public int hashCode() {
            return Objects.hash(a, b);
        }

        @Override
        public String toString() {
            return ""("" + a +
                    "","" + b +
                    ')';
        }
    }


    public static void main(String[] args) throws Exception {
        try (FastReader in = new FastReader();
             FastWriter out = new FastWriter()) {
            int t, i, j, n, k, l, r, m, c, p, q, ti, tidx;
            long x, y, z;

            //for (t = in.nextInt(), tidx = 1; tidx <= t; tidx++)
            {
                //out.print(String.format(""Case #%d: "", tidx));
                n=in.nextInt();
                int a[]=new int[101];
                for (i=0;i<n;i++){
                    a[in.nextInt()]++;
                }
                m=0;
                for(i=1;i<101;i++){
                    if(a[i]>0){
                        m++;
                        for(j=i;j<=100;j+=i){
                            a[j]=0;
                        }
                    }
                }
                out.println(m);
            }
            out.commit();
        }
    }


    static class FastReader implements Closeable {
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        private StringTokenizer st;

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] nextIntArr(int n) {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextInt();
            }
            return arr;
        }

        double[] nextDoubleArr(int n) {
            double[] arr = new double[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextDouble();
            }
            return arr;
        }

        long[] nextLongArr(int n) {
            long[] arr = new long[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextLong();
            }
            return arr;
        }

        String[] nextStrArr(int n) {
            String[] arr = new String[n];
            for (int i = 0; i < n; i++) {
                arr[i] = next();
            }
            return arr;
        }

        int[][] nextIntArr2(int n, int m) {
            int[][] arr = new int[n][m];
            for (int i = 0; i < n; i++) {
                arr[i] = nextIntArr(m);
            }
            return arr;
        }

        long[][] nextLongArr2(int n, int m) {
            long[][] arr = new long[n][m];
            for (int i = 0; i < n; i++) {
                arr[i] = nextLongArr(m);
            }
            return arr;
        }

        @Override
        public void close() throws IOException {
            br.close();
        }
    }


    static class FastWriter implements Closeable {
        BufferedWriter bw;
        StringBuilder sb = new StringBuilder();
        List<String> list = new ArrayList<>();
        Set<String> set = new HashSet<>();

        FastWriter() {
            bw = new BufferedWriter(new OutputStreamWriter(System.out));
        }

        <T> void commit() throws IOException {
            bw.write(sb.toString());
            bw.flush();
            sb = new StringBuilder();
        }

        <T> void print(T obj) {
            sb.append(obj.toString());
        }

        void println() throws IOException {
            print(""\n"");
        }

        <T> void println(T obj) throws IOException {
            print(obj.toString() + ""\n"");
        }

        <T> void printArrLn(T[] arr) throws IOException {
            for (int i = 0; i < arr.length - 1; i++) {
                print(arr[i] + "" "");
            }
            println(arr[arr.length - 1]);
        }

        <T> void printArr2(T[][] arr) throws IOException {
            for (int j = 0; j < arr.length; j++) {
                for (int i = 0; i < arr[j].length - 1; i++) {
                    print(arr[j][i] + "" "");
                }
                println(arr[j][arr.length - 1]);
            }
        }

        <T> void printColl(Collection<T> coll) throws IOException {
            for (T e : coll) {
                print(e + "" "");
            }
            println();
        }

        void printCharN(char c, int n) throws IOException {
            for (int i = 0; i < n; i++) {
                print(c);
            }
        }

        void printIntArr2(int[][] arr) throws IOException {
            for (int j = 0; j < arr.length; j++) {
                for (int i = 0; i < arr[j].length - 1; i++) {
                    print(arr[j][i] + "" "");
                }
                println(arr[j][arr.length - 1]);
            }
        }

        @Override
        public void close() throws IOException {
            bw.close();
        }
    }

}
",5,1209_A,CODEFORCES,3560,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"			import java.io.*;
			import java.util.*;
			 
			public class oK{
					    void pre() throws Exception{}
					    void solve(int TC) throws Exception{
					    int n=ni();
					    	int a[]=new int[n];
					    for(int i=0;i<n;i++) {
					    	a[i]=ni();
					    }
					    Arrays.sort(a);
					    int b[]=new int[101];
					    int flag=0;
					    int count=0;
					    for(int i=0;i<n;i++) {
					    	flag=0;
					    	if(b[a[i]]==0) {
					    		count++;
					    	}
					    	for(int j=i;j<n;j++) {
					    		if(b[a[j]]==0&&a[j]%a[i]==0) {
					    			
					    			b[a[j]]=1;
					    			
					    		}
					    		//if(flag==1)count++;
					    	}
					    	
					    	
					    }
					    pn(count);
					    
					    
					    }
					    		
					    		
					    
					    
					    
					    
					    
					   // void hold(boolean b)throws Exception{if(!b)throw new Exception(""Hold right there, Sparky!"");}
					    static boolean multipleTC = false, memory = false;
					    FastReader in;PrintWriter out;
					    void run() throws Exception{
					        in = new FastReader();
					        out = new PrintWriter(System.out);
					        int T = (multipleTC)?ni():1;
					        pre();for(int t = 1; t<= T; t++)solve(t);
					        out.flush();
					        out.close();
					    }
					    public static void main(String[] args) throws Exception{
					        if(memory)new Thread(null, new Runnable() {public void run(){try{new oK().run();}catch(Exception e){e.printStackTrace();}}}, ""1"", 1 << 28).start();
					        else new oK().run();
					    }
					    void p(Object o){out.print(o);}
					    void pn(Object o){out.println(o);}
					    void pni(Object o){out.println(o);out.flush();}
					    String n()throws Exception{return in.next();}
					    String nln()throws Exception{return in.nextLine();}
					    int ni()throws Exception{return Integer.parseInt(in.next());}
					    long nl()throws Exception{return Long.parseLong(in.next());}
					
					    class FastReader{
					        BufferedReader br;
					        StringTokenizer st;
					        public FastReader(){
					            br = new BufferedReader(new InputStreamReader(System.in));
					        }
					
					        public FastReader(String s) throws Exception{
					            br = new BufferedReader(new FileReader(s));
					        }
					
					        String next() throws Exception{
					            while (st == null || !st.hasMoreElements()){
					                try{
					                    st = new StringTokenizer(br.readLine());
					                }catch (IOException  e){
					                    throw new Exception(e.toString());
					                }
					            }
					            return st.nextToken();
					        }
					
					        String nextLine() throws Exception{
					            String str = """";
					            try{   
					                str = br.readLine();
					            }catch (IOException e){
					                throw new Exception(e.toString());
					            }  
					            return str;
					        }
					    }
					}",5,1209_A,CODEFORCES,3542,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"//package cf584d12;
import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class A {
	public static void main(String[] args) {
		MyScanner sc = new MyScanner();
		int n = sc.nextInt();
		Integer[] a = new Integer[n];
		for(int i = 0; i < n; i++)
			a[i] = sc.nextInt();
		Arrays.sort(a);
		boolean[] b = new boolean[n];
		int ans = 0;
		for(int i = 0; i < n; i++)
			if(!b[i]) {
				ans++;
				for(int j = i + 1; j < n; j++)
					if(a[j] % a[i] == 0)
						b[j] = true;
			}
		out.println(ans);
		out.close();
	}
	public static PrintWriter out  = new PrintWriter(new BufferedOutputStream(System.out));
	public static class MyScanner {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		String next() {
			while (st == null || !st.hasMoreElements())
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}
}",5,1209_A,CODEFORCES,3491,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.awt.*;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.util.*;
import java.io.*;
public class Main3 {
    static PrintWriter pr;
    static Scanner scan;
    static BufferedReader br;
    static StringTokenizer st;
    public static void main(String args[]) throws Exception {
        pr = new PrintWriter(System.out);
        scan = new Scanner(System.in);
        br = new BufferedReader(new InputStreamReader(System.in));
        int n = inputInt();
        //char[] c = br.readLine().toCharArray();
        int[] a = new int[n];
        int[] b = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i=0;i<n;i++){

            a[i]=Integer.parseInt(st.nextToken());
            //b[i]=Integer.parseInt(st.nextToken());
        }
        Arrays.sort(a);
        int ans=0;
        for(int i=0;i<n;i++){
            if(b[i]!=1){
                ans++;
                for(int j=i;j<n;j++){
                    if(a[j]%a[i]==0){
                        b[j]=1;
                    }
                }
            }
        }
        System.out.println(ans);
    }


    public static int inputInt() throws IOException{
        return Integer.parseInt(br.readLine());
    }

    public static long inputLong() throws IOException{
        return Long.parseLong(br.readLine());
    }

    public static String inputString() throws IOException{
        return br.readLine();
    }

    public static  int[] intArray(int n) throws IOException{
        int a[] = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i=0;i<n;i++){
            a[i] = Integer.parseInt(st.nextToken());
        }
        return a;
    }

    public static  long[] longArray(int n) throws IOException{
        long a[] = new long[n];
        st = new StringTokenizer(br.readLine());
        for(int i=0;i<n;i++){
            a[i] = Long.parseLong(st.nextToken());
        }
        return a;
    }

    public static String[] stringArray(int n) throws IOException{
        String a[] = new String[n];
        st = new StringTokenizer(br.readLine());
        for(int i=0;i<n;i++){
            a[i] = st.nextToken();
        }
        return a;
    }

    public static long gcd(long a,long b){
        if(b==0){
            return a;
        }
        else{
            return gcd(b,a%b);
        }
    }

    public long max(long a,long b,long c){
        return Math.max(a,Math.max(b,c));
    }
}",5,1209_A,CODEFORCES,3543,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class Problem_A {
	
	public static void main(String[] args) {
		MyScanner scan = new MyScanner();
		int n = scan.nextInt();
		int[] elements = new int[n];
		for (int i = 0; i < n; i++)
			elements[i] = scan.nextInt();
		
		int x = 0;
		
		Arrays.sort(elements);
		while(n > 0) {
			x++;
			int[] temp = new int[n];
			int j = 0;
			int size = n;
			int min = elements[0];
			n--;
			for (int i = 1; i < size; i++) {
				if (elements[i]%min == 0) {
					n--;
				}
				else {
					temp[j++] = elements[i];
				}
			}
			
			elements = temp;
		}
		
		out.println(x);
		out.close();
	}

	public static PrintWriter out  = new PrintWriter(new BufferedOutputStream(System.out));
	public static class MyScanner {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		String next() {
			while (st == null || !st.hasMoreElements())
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}
	
}
",5,1209_A,CODEFORCES,3516,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.lang.*;
import java.io.*;
//****Use Integer Wrapper Class for Arrays.sort()****
public class AG1 {
    public static void main(String[] Args){
        FastReader scan=new FastReader();
        int n=scan.nextInt();
        int[] arr=new int[n];
        for (int i = 0; i <n ; i++) {
            arr[i]=scan.nextInt();
        }
        Arrays.sort(arr);
        boolean[] done=new boolean[n];
        int ans=0;
        for(int i=0;i<n;i++){
            if(!done[i]){
                done[i]=true;
                ans++;
                for(int j=i+1;j<n;j++){
                    if(arr[j]%arr[i]==0){
                        done[j]=true;
                    }
                }
            }
        }
        System.out.println(ans);
    }
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }

}
",5,1209_A,CODEFORCES,3454,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"//package practice;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.Stack;
import java.util.regex.Pattern;

public class ROUGH {
	
	public static class FastReader {
		BufferedReader br;
		StringTokenizer st;
		//it reads the data about the specified point and divide the data about it ,it is quite fast
		//than using direct 

		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (Exception r) {
					r.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());//converts string to integer
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (Exception r) {
				r.printStackTrace();
			}
			return str;
		}
	}
	
	public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));
	static long mod = (long) (1e9+7);
	static int N = (int) 1e5;
//	Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		 FastReader sc = new FastReader();
		 int n = sc.nextInt();
		 int[] a = new int[n];
		 TreeSet<Integer> set = new TreeSet<Integer>();
		 for(int i=0;i<n;++i) {
			 a[i] = sc.nextInt();
			 set.add(a[i]);
		 }
		 long ans = 0;
		 while(set.size() > 0) {
			 ++ans;
			 int min = set.first();
			 TreeSet<Integer> temp = new TreeSet<>();
			 for(int x : set) {
				 if(x%min != 0) temp.add(x);
			 }
			 set = temp;
			 
		 }
		 out.print(ans);
		 
		 out.close();
	}
	
}",5,1209_A,CODEFORCES,3469,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter writer;

    static String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    static void banana() throws IOException {
        int n = nextInt();
        int[] a = new int[n];
        int[] color = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = nextInt();
        }
        int c = 0;
        while(true) {
            int mn = 1000;
            for (int i = 0; i < n; i++) {
                if(color[i] == 0) {
                    mn = Math.min(mn, a[i]);
                }
            }
            if (mn == 1000) {
                break;
            }
            c++;
            for (int i = 0; i < n; i++) {
                if (color[i] == 0) {
                    if (a[i] % mn == 0) {
                        color[i] = c;
                    }
                }
            }
        }
        writer.println(c);
    }

    public static void main(String[] args) throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = null;
        writer = new PrintWriter(System.out);
        banana();
        reader.close();
        writer.close();
    }
}
",5,1209_A,CODEFORCES,3459,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;


public class Colours {
    public static void main(String args[] ) throws Exception {

    
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        int n = Integer.parseInt(line);
        line = br.readLine();
        String[] values = line.split("" "");
        int[] arr = new int[n];
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(values[i]);
            set.add(arr[i]);
        }
        int count=0;
        TreeSet<Integer> copy = new TreeSet<>();
        
        // for(int i=0;i<n;i++)
        copy.addAll(set);
        int prev = copy.size();
        
        for(Integer i: set){
           // System.out.println(""i ""+i);
            if(copy.size()==0){
                break;
            }
            Iterator<Integer> iterator = copy.iterator();
            while (iterator.hasNext()) {
                Integer e = iterator.next();
                if (e % i == 0) {
                    iterator.remove();
                }
            }
            if(copy.size()!=prev){
                count++;
                prev = copy.size();
            }
           // System.out.println(""size ""+copy.size());
            
        }
        

        System.out.println(count);
    }
}
",5,1209_A,CODEFORCES,3471,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class codea{
	public static void main(String args[])
	{
	  Scanner in = new Scanner(System.in);
	  int n = in.nextInt();
	  int arr[] = new int[n];
	  for(int i =0;i<n;i++)
	   arr[i]= in.nextInt();
	  Arrays.sort(arr);
	  int max =0;
	  boolean check[]= new boolean [n];
	  int count=0;
	  for(int i =0;i<n;i++)
	  {
	   
	   if(!check[i])
	   {
	   	count++;
	   
	   for(int j=i;j<n;j++)
	   {
	   
	    if(arr[j]%arr[i]==0)
	     check[j]=true;
	   }
	   
	   }	
	  }
	  System.out.println(count);	
	}
}",5,1209_A,CODEFORCES,3456,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.*;
import java.io.*;
import java.math.*;
public class Main6{

static class Pair
	{ 
		int x;
		int y;
		int z;
		public Pair(int x,int y,int z) 
		{	 
			this.x= x; 
			this.y= y;
			this.z=z;
		}	 
		
	@Override
			public int hashCode() 
			{ 
				final int temp = 14; 
				int ans = 1; 
				ans =x*31+y*13; 
				return ans; 
			} 
	  
			// Equal objects must produce the same 
			// hash code as long as they are equal 
		@Override
		public boolean equals(Object o) 
		{ 
			if (this == o) { 
				return true; 
			} 
			if (o == null) { 
				return false; 
			} 
			if (this.getClass() != o.getClass()) { 
				return false; 
			} 
			Pair other = (Pair)o; 
			if (this.x != other.x || this.y!=other.y) { 
				return false; 
			} 
			return true; 
		} 
			
	} 
	static class Pair1
	{
		String x;
		int y;
		int z;
		
	}
	static class Compare
	{ 
		static void compare(Pair arr[], int n) 
		{ 
			// Comparator to sort the pair according to second element 
		/*	Arrays.sort(arr, new Comparator<Pair>() { 
				@Override public int compare(Pair p1, Pair p2) 
				{ 
					if(p1.start>p2.start)
					{
						return 1;
					}
					else if(p1.start==p2.start)
					{
						return 0;
					}
					else
					{
						return -1;
					}
				} 
			}); */
		}
		
	}
	
	
	public static long pow(long a, long b)
	{
		long result=1;
		while(b>0)
		{
			if (b % 2 != 0)
			{
				result=(result*a)%998244353;
				b--;
			} 
			a=(a*a)%998244353;
			b /= 2;
		}   
		return result;
	}
	public static long fact(long num)
	{
				long value=1;
				int i=0;
				for(i=2;i<num;i++)
				{
					value=((value%mod)*i%mod)%mod;
				}
				return value;
			}
			public static int gcd(int a, int b)
			{
				if (a == 0)
					return b;
				return gcd(b%a, a);
			}
			
	/*		public static long lcm(long a,long b)
			{
				return a * (b / gcd(a, b));
			}
		*/	public static long sum(int h)
			{
				return (h*(h+1)/2);
			}
			public static void dfs(int parent,boolean[] visited,int[] dp)
			{
				ArrayList<Integer> arr=new ArrayList<Integer>();
				arr=graph.get(parent);
				visited[parent]=true;
				for(int i=0;i<arr.size();i++)
				{
					int num=(int)arr.get(i);
					if(visited[num]==false)
					{
						dfs(num,visited,dp);
					}
					dp[parent]=Math.max(dp[num]+1,dp[parent]);
				}
			}
		//	static int flag1=0;
			static int[] dis;
			static int mod=1000000007;
			static ArrayList<ArrayList<Integer>> graph;
			
			public static void bfs(int num,int size)
			{
				boolean[] visited=new boolean[size+1];
				Queue<Integer> q=new LinkedList<>();
				q.add(num);
				ans[num]=1;
				visited[num]=true;
				while(!q.isEmpty())
				{
					int x=q.poll();
					ArrayList<Integer> al=graph.get(x);
					for(int i=0;i<al.size();i++)
					{
						int y=al.get(i);	
						if(visited[y]==false)
						{
							q.add(y);
							ans[y]=ans[x]+1;
							visited[y]=true;
						}
					}
				}
			}
			static int[] ans;
			
			
			
			
			
			
			
			
			
		//	static int[] a;			  
			public static int[] sort(int[] a)
			{
				int n=a.length;
				ArrayList<Integer> ar=new ArrayList<>();
				for(int i=0;i<a.length;i++)
				{
					ar.add(a[i]);
				}
				Collections.sort(ar);
				for(int i=0;i<n;i++)
				{
					a[i]=ar.get(i);
				}
				return a;
			}
			static public void main(String args[])throws IOException
			{
				int n=i();
				int[] a=new int[n];
				for(int i=0;i<n;i++)
				{
					a[i]=i();
				}
				Arrays.sort(a);
				boolean[] flag=new boolean[n];
				int ans=0;
				for(int i=0;i<n;i++)
				{
					if(flag[i]==false)
					{
						ans++;
						for(int j=0;j<n;j++)
						{
							if(a[j]%a[i]==0 && flag[j]==false)
							{
								flag[j]=true;
							}
						}
					}
				}
				pln(ans+"""");
			}
			
			
			
			/**/
			static InputReader in=new InputReader(System.in);
				static OutputWriter out=new OutputWriter(System.out);
				public static long l()
				{
					String s=in.String();
					return Long.parseLong(s);
				}
				public static void pln(String value)
				{
					System.out.println(value);
				}
				public static int i()
				{
					return in.Int();
				}
				public static String s()
				{
					return in.String();
				}
	}
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		class InputReader {
			 
			private InputStream stream;
			private byte[] buf = new byte[1024];
			private int curChar;
			private int numChars;
			private SpaceCharFilter filter;
		 
			public InputReader(InputStream stream) {
				this.stream = stream;
			}
		 
			public int read() {
				if (numChars== -1)
					throw new InputMismatchException();
				if (curChar >= numChars) {
					curChar = 0;
					try {
						numChars = stream.read(buf);
					} catch (IOException e) {
						throw new InputMismatchException();
					}
					if (numChars <= 0)
						return -1;
				}
				return buf[curChar++];
			}
		 
			public int Int() {
				int c = read();
				while (isSpaceChar(c))
					c = read();
				int sgn = 1;
				if (c == '-') {
					sgn = -1;
					c = read();
				}
				int res = 0;
				do {
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					res *= 10;
					res += c - '0';
					c = read();
				} while (!isSpaceChar(c));
				return res * sgn;
			}
		 
			public String String() {
				int c = read();
				while (isSpaceChar(c))
					c = read();
				StringBuilder res = new StringBuilder();
				do {
					res.appendCodePoint(c);
					c = read();
				} while (!isSpaceChar(c));
				return res.toString();
			}
		 
			public boolean isSpaceChar(int c) {
				if (filter != null)
					return filter.isSpaceChar(c);
				return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
			}
		 
			public String next() {
				return String();
			}
		 
			public interface SpaceCharFilter {
				public boolean isSpaceChar(int ch);
			}
		}
		 
		class OutputWriter {
			private final PrintWriter writer;
		 
			public OutputWriter(OutputStream outputStream) {
				writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
			}
		 
			public OutputWriter(Writer writer) {
				this.writer = new PrintWriter(writer);
			}
		 
			public void print(Object...objects) {
				for (int i = 0; i < objects.length; i++) {
					if (i != 0)
						writer.print(' ');
					writer.print(objects[i]);
				}
			}
		 
			public void printLine(Object...objects) {
				print(objects);
				writer.println();
			}
		 
			public void close() {
				writer.close();
			}
		 
			public void flush() {
				writer.flush();
			}
		 
			}
		 
			class IOUtils {
		 
			public static int[] readIntArray(InputReader in, int size) {
				int[] array = new int[size];
				for (int i = 0; i < size; i++)
					array[i] = in.Int();
				return array;
			}
		 
			} ",5,1209_A,CODEFORCES,3555,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.text.*;
public class Main{
    //SOLUTION BEGIN
    //Into the Hardware Mode
    void pre() throws Exception{}
    void solve(int TC)throws Exception{
        int n = ni();
        int[] a = new int[n];
        for(int i = 0; i< n; i++)a[i] = ni();
        Arrays.sort(a);
        int ans = 0;
        for(int i = 0; i< n; i++){
            if(a[i] == -1)continue;
            ans++;
            for(int j = i+1; j< n; j++)if(a[j]%a[i] == 0)a[j] = -1;
        }
        pn(ans);
    }
    //SOLUTION END
    void hold(boolean b)throws Exception{if(!b)throw new Exception(""Hold right there, Sparky!"");}
    void exit(boolean b){if(!b)System.exit(0);}
    long IINF = (long)1e18, mod = (long)1e9+7;
    final int INF = (int)1e9, MX = (int)2e6+5;
    DecimalFormat df = new DecimalFormat(""0.00000000"");
    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;
    static boolean multipleTC = false, memory = false, fileIO = false;
    FastReader in;PrintWriter out;
    void run() throws Exception{
        if(fileIO){
            in = new FastReader(""input.txt"");
            out = new PrintWriter(""output.txt"");
        }else {
            in = new FastReader();
            out = new PrintWriter(System.out);
        }
        //Solution Credits: Taranpreet Singh
        int T = (multipleTC)?ni():1;
        pre();
        for(int t = 1; t<= T; t++)solve(t);
        out.flush();
        out.close();
    }
    public static void main(String[] args) throws Exception{
        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, ""1"", 1 << 28).start();
        else new Main().run();
    }
    
    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}
    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}
    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}
    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}
    void p(Object o){out.print(o);}
    void pn(Object o){out.println(o);}
    void pni(Object o){out.println(o);out.flush();}
    String n()throws Exception{return in.next();}
    String nln()throws Exception{return in.nextLine();}
    int ni()throws Exception{return Integer.parseInt(in.next());}
    long nl()throws Exception{return Long.parseLong(in.next());}
    double nd()throws Exception{return Double.parseDouble(in.next());}
 
    class FastReader{
        BufferedReader br;
        StringTokenizer st;
        public FastReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }
 
        public FastReader(String s) throws Exception{
            br = new BufferedReader(new FileReader(s));
        }
 
        String next() throws Exception{
            while (st == null || !st.hasMoreElements()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch (IOException  e){
                    throw new Exception(e.toString());
                }
            }
            return st.nextToken();
        }
 
        String nextLine() throws Exception{
            String str = """";
            try{   
                str = br.readLine();
            }catch (IOException e){
                throw new Exception(e.toString());
            }  
            return str;
        }
    }
}",5,1209_A,CODEFORCES,3501,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.Scanner;
 
public class Codeforce {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] arr = new int[n];
		for(int i=0; i<n; i++) {
			arr[i] = sc.nextInt();
		}
		int color = 0;
		Arrays.sort(arr);
		for(int i=0; i<n; i++) {
			if(arr[i]!=0) {
				int col = arr[i];
				color++;
				for(int j=i; j<n; j++) {
					if(arr[j]%col==0) arr[j]=0;
				}
			}
		}
		System.out.println(color);
		sc.close();
	}
}",5,1209_A,CODEFORCES,3540,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.Scanner;

public class problemA {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int[] numbs = new int[n];
        int[] smallest_color = new int[n];
        for(int i =  0; i < n;i++){
            numbs[i] = scan.nextInt();
        }
        Arrays.sort(numbs);
        int count = 0;
        for(int i =0; i < n; i++){
            for(int j=0; j <n;j++ ){
                if(smallest_color[j] == 0){
                    count++;
                    smallest_color[j] = numbs[i];
                    break;
                }
                if(numbs[i] % smallest_color[j] == 0){
                    break;
                }
            }
        }
        System.out.println(count);
    }
}",5,1209_A,CODEFORCES,3453,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
public class Hack{
public static void main(String[] args){
Scanner sc = new Scanner(System.in);
int n=sc.nextInt();
int[] arr = new int[n];
for(int i=0;i<n;i++)
arr[i]=sc.nextInt();
Arrays.sort(arr);
Set<Integer> set = new TreeSet<Integer>();
for(int i=0;i<n;i++){
boolean flag=false;
for(Integer x:set){
if(arr[i]%x==0){
flag=true;
break;
}
}
if(!flag)
set.add(arr[i]);
}
System.out.println(set.size());
}
}
",5,1209_A,CODEFORCES,3548,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.*;


public class wef {
public static class FastReader {
	BufferedReader br;
	StringTokenizer st;
	//it reads the data about the specified point and divide the data about it ,it is quite fast
	//than using direct 

	public FastReader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	String next() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception r) {
				r.printStackTrace();
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(next());//converts string to integer
	}

	double nextDouble() {
		return Double.parseDouble(next());
	}

	long nextLong() {
		return Long.parseLong(next());
	}

	String nextLine() {
		String str = """";
		try {
			str = br.readLine();
		} catch (Exception r) {
			r.printStackTrace();
		}
		return str;
	}
}
static ArrayList<String>list1=new ArrayList<String>();
static void combine(String instr, StringBuffer outstr, int index,int k)
{
	if(outstr.length()==k)
	{
		list1.add(outstr.toString());return;
	}
	if(outstr.toString().length()==0)
	outstr.append(instr.charAt(index));
    for (int i = 0; i < instr.length(); i++)
    {
        outstr.append(instr.charAt(i));
       
        combine(instr, outstr, i + 1,k);
        outstr.deleteCharAt(outstr.length() - 1);
    }
   index++;
} 
static ArrayList<ArrayList<Integer>>l=new ArrayList<>();
static void comb(int n,int k,int ind,ArrayList<Integer>list)
{
	if(k==0)
	{
		l.add(new ArrayList<>(list));

		return;
	}
	
	
	for(int i=ind;i<=n;i++)
	{
		list.add(i);
		comb(n,k-1,ind+1,list);
		
		list.remove(list.size()-1);
		
	}
	
	
	
	
	

}
static long sum(long n)
{
	long sum=0;
	while(n!=0)
	{
		sum+=n%10;
		n/=10;
	}
	return sum;
}


static boolean check(HashMap<Integer,Integer>map)
{
	for(int h:map.values())
		if(h>1)
			return false;
	return true;
}

static class Pair implements Comparable<Pair>{
    int x;int y;
    Pair(int x,int y){
        this.x=x;
        this.y=y;
      //  this.i=i;
    }
	@Override
	public int compareTo(Pair o) {
		// TODO Auto-generated method stub
		return x-o.x;
		
	}
}
static boolean isPrime(int n) 
{ 
    // Corner cases 
    if (n <= 1) 
        return false; 
    if (n <= 3) 
        return true; 
  
    // This is checked so  
    // that we can skip 
    // middle five numbers 
    // in below loop 
    if (n % 2 == 0 ||  
        n % 3 == 0) 
        return false; 
  
    for (int i = 5; 
             i * i <= n; i = i + 6) 
        if (n % i == 0 || 
            n % (i + 2) == 0) 
            return false; 
  
    return true; 
} 
  

static long gcd(long a, long b) 
{ 
  if (b == 0) 
    return a; 
  return gcd(b, a % b);  
} 

public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	FastReader in=new FastReader();
	HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();
	ArrayList<Integer>list=new ArrayList<Integer>();
	TreeSet<Integer>set=new TreeSet<Integer>();

	int n=in.nextInt();
	for(int i=0;i<n;i++)
		set.add(in.nextInt());
	
	int ans=0;
	
	while(!set.isEmpty())
	{
		int f=set.first();
		int s=f;
		while(!set.isEmpty()&&s<=set.last())
		{
			if(set.contains(s))
			set.remove(new Integer(s));
			s+=f;
		}
		ans++;
		
	}
	out.println(ans);
	
	out.close();
	
	
		
	}
}
",5,1209_A,CODEFORCES,3536,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	
	public static void main(String[] args)
	{
		Scanner s=new Scanner(System.in);
		
		int n=s.nextInt();
		
		int[] arr=new int[n];
		
		for(int i=0;i<n;i++)
		{
			arr[i]=s.nextInt();
		}
		
		Arrays.sort(arr);
		
		int[] visited=new int[n];
		
		int ans=0;
		
		for(int i=0;i<n;i++)
		{
			if(visited[i]==0)
			{	
				ans++;
				
				for(int j=i+1;j<n;j++)
				{
					if(arr[j]%arr[i]==0&&visited[j]==0)
					{
						visited[j]=1;
					}
				}
			}
		}
		
		System.out.println(ans);
		
	}
	
}",5,1209_A,CODEFORCES,3528,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;

public class Contest {

    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");

    public static void main(String[] args) {
        new Contest().run();
    }

    void init() throws FileNotFoundException {
        if (ONLINE_JUDGE) {
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        } else {
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }

    public void run() {
        try {
            long t1 = System.currentTimeMillis();
            init();
            solve();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time(ms) = "" + (t2 - t1));
        } catch (Exception e) {
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }

    class MyComparator implements Comparable<MyComparator> {

        int x;
        int y;

        public MyComparator(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public int compareTo(MyComparator a) {
            if (x == a.x) {
                return (y - a.y);
            }
            return x - a.x;
        }
    }

    public static boolean isPrime(int num) {
        if (num > 2 && num % 2 == 0) {
            //System.out.println(num + "" is not prime"");
            return false;
        }
        int top = (int) Math.sqrt(num) + 1;
        for (int i = 3; i < top; i += 2) {
            if (num % i == 0) {
                //System.out.println(num + "" is not prime"");
                return false;
            }
        }
        //System.out.println(num + "" is prime"");
        return true;
    }

    private static int lowerBound(int[] a, int low, int high, int element) {
        while (low < high) {
            int middle = low + (high - low) / 2;
            if (element > a[middle]) {
                low = middle + 1;
            } else {
                high = middle;
            }
        }
        return low;
    }

    private static int upperBound(int[] a, int low, int high, int element) {
        while (low < high) {
            int middle = low + (high - low) / 2;
            if (a[middle] > element) {
                high = middle;
            } else {
                low = middle + 1;
            }
        }
        return low;
    }

    public void solve() throws IOException {

        int num_a = readInt();
        int[] array = new int[num_a];
        for (int i = 0; i < num_a; i++) {
            array[i] = readInt();
        }
        int result = 0;

        Arrays.sort(array);
        for (int i = 0; i < array.length; i++) {
            if (array[i] == -1) {
                continue;
            }
            for (int j = 0; j < array.length; j++) {
                if (array[j] != -1 && array[j] % array[i] == 0 && j != i) {
                    //System.out.println(array[j]);
                    array[j] = -1;
                    //result++;
                }
            }
            result++;
        }

        System.out.println(result);
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    private BigInteger lcm(BigInteger a, BigInteger b) {
        return a.multiply(b.divide(a.gcd(b)));
    }

}
",5,1209_A,CODEFORCES,3470,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.security.KeyPair;
import java.util.*;

public class Main {

    static long[][] c ;
    static long[] arr;
    static long n , m , k;
    static long dp[][][];

    public static void main(String[] args) throws IOException {
        Reader.init(System.in);
        int n = Reader.nextInt();
        int[] arr = new int[n];
        int[] mark = new int[n];
        for (int i = 0 ; i < n  ; i++){
            arr[i] = Reader.nextInt();
        }
        Arrays.sort(arr);
        int[] v = new int[n];
        int ans = 0;
        for (int i = 0 ; i < n ; i++){
            if (v[i]==0){
                for (int j = i ; j < n ; j++){
                    if (arr[j]%arr[i]==0){
                        v[j] = arr[i];
                    }
                }
            }
        }
        TreeSet<Integer> s = new TreeSet<>();
        for (int i = 0 ; i < n ;i++){
            s.add(v[i]);
        }
        System.out.println(s.size());





        
    }



    public static void sortbyColumn_asc(int arr[][], int col)
    {
        // Using built-in sort function Arrays.sort
        Arrays.sort(arr, new Comparator<int[]>() {

            @Override
            // Compare values according to columns
            public int compare(final int[] entry1,
                               final int[] entry2) {

                // To sort in descending order revert
                // the '>' Operator
                if (entry1[col] > entry2[col])
                    return 1;
                else
                    return -1;
            }
        });  // End of function call sort().
    }

    public static void sortbyColumn_dsc(int arr[][], int col)
    {
        // Using built-in sort function Arrays.sort
        Arrays.sort(arr, new Comparator<int[]>() {

            @Override
            // Compare values according to columns
            public int compare(final int[] entry1,
                               final int[] entry2) {

                // To sort in descending order revert
                // the '>' Operator
                if (entry1[col] > entry2[col])
                    return -1;
                else
                    return 1;
            }
        });  // End of function call sort().
    }

    static void swap(char[] arr , int i , int j){
        char tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    static void swap(int[] arr , int i , int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }





}

class Node implements Comparable<Node>{
    int a ,  b;
    Node(int a , int b){
        this.a = a;
        this.b = b;
    }
    public int compareTo(Node o) {
        if (this.a == o.a){
            return this.b - o.b;
        }
        return this.a - o.a;
    }
}
class Edge implements Comparable<Edge>{
    int x , y , w;

    public Edge(int x, int y, int w) {
        this.x = x;
        this.y = y;
        this.w = w;
    }

    @Override
    public int compareTo(Edge o) {
        return this.w - o.w;
    }
}
class Reader {
    static BufferedReader reader;
    static StringTokenizer tokenizer;

    /** call this method to initialize reader for InputStream */
    static void init(InputStream input) {
        reader = new BufferedReader(
                new InputStreamReader(input) );
        tokenizer = new StringTokenizer("""");
    }
    /** get next word */
    static String next() throws IOException {
        while ( ! tokenizer.hasMoreTokens() ) {
            //TODO add check for eof if necessary
            tokenizer = new StringTokenizer(
                    reader.readLine() );
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt( next() );
    }
    static long nextLong() throws IOException {
        return Long.parseLong( next() );
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble( next() );
    }
}
class MergeSort
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int [n1];
        int R[] = new int [n2];

        /*Copy data to temp arrays*/
        for (int i=0; i<n1; ++i)
            L[i] = arr[l + i];
        for (int j=0; j<n2; ++j)
            R[j] = arr[m + 1+ j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l+r)/2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m+1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    /* A utility function to print array of size n */
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }

    // Driver method

}",5,1209_A,CODEFORCES,3550,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = in.nextIntArray(n);
            Arrays.sort(a);
            int count = 0;
            boolean[] used = new boolean[n];
            for (int i = 0; i < n; i++) {
                if (!used[i]) {
                    count++;
                    for (int j = i; j < n; j++) {
                        if (a[j] % a[i] == 0) {
                            used[j] = true;
                        }
                    }
                }
            }
            out.println(count);
        }

    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
        }

        public FastScanner(String fileName) {
            try {
                br = new BufferedReader(new FileReader(fileName));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            while (st == null || !st.hasMoreElements()) {
                String line = null;
                try {
                    line = br.readLine();
                } catch (IOException e) {
                }
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        public int[] nextIntArray(int n) {
            int[] ret = new int[n];
            for (int i = 0; i < n; i++) {
                ret[i] = nextInt();
            }
            return ret;
        }

    }
}

",5,1209_A,CODEFORCES,3518,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*; 
import java.util.*; 
import java.util.Map.*;
import java.math.*;
//import java.lang.*;

public class q1 
{ 
    static int MOD=1000000007;
    static class Reader 
    { 
        final private int BUFFER_SIZE = 1 << 16; 
        private DataInputStream din; 
        private byte[] buffer; 
        private int bufferPointer, bytesRead; 
  
        public Reader() 
        { 
            din = new DataInputStream(System.in); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public Reader(String file_name) throws IOException 
        { 
            din = new DataInputStream(new FileInputStream(file_name)); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public String readLine() throws IOException 
        { 
            byte[] buf = new byte[1000000]; // line length 
            int cnt = 0, c; 
            while ((c = read()) != -1) 
            { 
                if (c == '\n') 
                    break; 
                buf[cnt++] = (byte) c; 
            } 
            return new String(buf, 0, cnt); 
        } 
  
        public int nextInt() throws IOException 
        { 
            int ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do
            { 
                ret = ret * 10 + c - '0'; 
            }  while ((c = read()) >= '0' && c <= '9'); 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public long nextLong() throws IOException 
        { 
            long ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public double nextDouble() throws IOException 
        { 
            double ret = 0, div = 1; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
  
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
  
            if (c == '.') 
            { 
                while ((c = read()) >= '0' && c <= '9') 
                { 
                    ret += (c - '0') / (div *= 10); 
                } 
            } 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        private void fillBuffer() throws IOException 
        { 
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
            if (bytesRead == -1) 
                buffer[0] = -1; 
        } 
  
        private byte read() throws IOException 
        { 
            if (bufferPointer == bytesRead) 
                fillBuffer(); 
            return buffer[bufferPointer++]; 
        } 
  
        public void close() throws IOException 
        { 
            if (din == null) 
                return; 
            din.close(); 
        } 
    }
    
    static boolean isPrime(int n) 
    { 
        if (n <= 1) 
            return false; 
        if (n <= 3) 
            return true; 
        if (n % 2 == 0 || n % 3 == 0) 
            return false; 
      
        for (int i = 5; i * i <= n; i = i + 6) 
            if (n % i == 0 ||  n % (i + 2) == 0) 
                return false; 
      
        return true; 
    } 
    static int gcd(int a, int b) 
    { 
      if (b == 0) 
        return a; 
      return gcd(b, a % b);  
    } 
    //Functions



    
    public static void main(String[] args) throws IOException 
    { 
       Scanner sc=new Scanner(System.in); 
       //int T=sc.nextInt();
       int T=1;
       while(T-- > 0){
           int N=sc.nextInt();
           int a[]=new int[N];
           int count=0;
           int ans=0;
           boolean flag=false;

           for(int i=0;i<N;++i){
               a[i]=sc.nextInt();
           }
           Arrays.sort(a);
           for(int i=0;i<N;++i){
               if(a[i]==-1)
                continue;
            for(int j=i+1;j<N;++j){
                if(a[j]%a[i]==0 && a[j]!=-1){
                    a[j]=-1;;
                }
            }
           }
           //int i=0;
           for(int i=0;i<N;++i){
               if(a[i]!= -1)
               count++;
           }

           System.out.println(count);
        } // End of test cases loop 

        
    }//end of main function
    
    
} //end of class",5,1209_A,CODEFORCES,3525,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
public class Paint_The_Numbers {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		ArrayList<Integer> paint = new ArrayList<Integer>();
		int num = scan.nextInt();
		for(int i = 0; i < num;i++)
			paint.add(scan.nextInt());
		Collections.sort(paint);
		int counter = 0;
		//System.out.println(paint);
		while(paint.size()!=0) {
			num = paint.remove(0);
			for(int i = 0; i<paint.size();i++) {
				if(paint.get(i)%num==0) {
					paint.remove(i--);
				}
			}
			counter++;
		}
		System.out.println(counter);
	}

}
",5,1209_A,CODEFORCES,3570,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jenish
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            int n = in.scanInt();
            int arr[] = new int[n];
            in.scanInt(arr);
            CodeX.sort(arr);
            int ans = 0;
            boolean vissited[] = new boolean[n];
            for (int i = 0; i < n; i++) {
                if (!vissited[i]) {
                    ans++;
                    for (int j = 0; j < n; j++) {
                        if (arr[j] % arr[i] == 0) {
                            vissited[j] = true;
                        }
                    }
                }
            }


            out.println(ans);
        }

    }

    static class CodeX {
        public static void sort(int arr[]) {
            merge_sort(arr, 0, arr.length - 1);
        }

        private static void merge_sort(int A[], int start, int end) {
            if (start < end) {
                int mid = (start + end) / 2;
                merge_sort(A, start, mid);
                merge_sort(A, mid + 1, end);
                merge(A, start, mid, end);
            }

        }

        private static void merge(int A[], int start, int mid, int end) {
            int p = start, q = mid + 1;
            int Arr[] = new int[end - start + 1];
            int k = 0;

            for (int i = start; i <= end; i++) {
                if (p > mid)
                    Arr[k++] = A[q++];

                else if (q > end)
                    Arr[k++] = A[p++];

                else if (A[p] < A[q])
                    Arr[k++] = A[p++];

                else
                    Arr[k++] = A[q++];
            }
            for (int i = 0; i < k; i++) {
                A[start++] = Arr[i];
            }

        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int INDEX;
        private BufferedInputStream in;
        private int TOTAL;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (INDEX >= TOTAL) {
                INDEX = 0;
                try {
                    TOTAL = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (TOTAL <= 0) return -1;
            }
            return buf[INDEX++];
        }

        public int scanInt() {
            int I = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    I *= 10;
                    I += n - '0';
                    n = scan();
                }
            }
            return neg * I;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

        public void scanInt(int[] A) {
            for (int i = 0; i < A.length; i++) A[i] = scanInt();
        }

    }
}

",5,1209_A,CODEFORCES,3541,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.stream.IntStream;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.nio.charset.Charset;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author mikit
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        LightScanner in = new LightScanner(inputStream);
        LightWriter out = new LightWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, LightScanner in, LightWriter out) {
            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);
            int n = in.ints();
            int[] a = in.ints(n);
            IntroSort.sort(a);
            boolean[] done = new boolean[n];
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (done[i]) continue;
                int d = a[i];
                ans++;
                for (int j = 0; j < n; j++) {
                    if (a[j] % d == 0) {
                        done[j] = true;
                    }
                }
            }
            out.ans(ans).ln();
        }

    }

    static class IntroSort {
        private static int INSERTIONSORT_THRESHOLD = 16;

        private IntroSort() {
        }

        static void sort(int[] a, int low, int high, int maxDepth) {
            while (high - low > INSERTIONSORT_THRESHOLD) {
                if (maxDepth-- == 0) {
                    HeapSort.sort(a, low, high);
                    return;
                }
                int cut = QuickSort.step(a, low, high);
                sort(a, cut, high, maxDepth);
                high = cut;
            }
            InsertionSort.sort(a, low, high);
        }

        public static void sort(int[] a) {
            if (a.length <= INSERTIONSORT_THRESHOLD) {
                InsertionSort.sort(a, 0, a.length);
            } else {
                sort(a, 0, a.length, 2 * BitMath.msb(a.length));
            }
        }

    }

    static final class ArrayUtil {
        private ArrayUtil() {
        }

        public static void swap(int[] a, int x, int y) {
            int t = a[x];
            a[x] = a[y];
            a[y] = t;
        }

    }

    static class LightScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;

        public LightScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public String string() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int ints() {
            return Integer.parseInt(string());
        }

        public int[] ints(int length) {
            return IntStream.range(0, length).map(x -> ints()).toArray();
        }

    }

    static final class BitMath {
        private BitMath() {
        }

        public static int count(int v) {
            v = (v & 0x55555555) + ((v >> 1) & 0x55555555);
            v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
            v = (v & 0x0f0f0f0f) + ((v >> 4) & 0x0f0f0f0f);
            v = (v & 0x00ff00ff) + ((v >> 8) & 0x00ff00ff);
            v = (v & 0x0000ffff) + ((v >> 16) & 0x0000ffff);
            return v;
        }

        public static int msb(int v) {
            if (v == 0) {
                throw new IllegalArgumentException(""Bit not found"");
            }
            v |= (v >> 1);
            v |= (v >> 2);
            v |= (v >> 4);
            v |= (v >> 8);
            v |= (v >> 16);
            return count(v) - 1;
        }

    }

    static class HeapSort {
        private HeapSort() {
        }

        private static void heapfy(int[] a, int low, int high, int i, int val) {
            int child = 2 * i - low + 1;
            while (child < high) {
                if (child + 1 < high && a[child] < a[child + 1]) {
                    child++;
                }
                if (val >= a[child]) {
                    break;
                }
                a[i] = a[child];
                i = child;
                child = 2 * i - low + 1;
            }
            a[i] = val;
        }

        static void sort(int[] a, int low, int high) {
            for (int p = (high + low) / 2 - 1; p >= low; p--) {
                heapfy(a, low, high, p, a[p]);
            }
            while (high > low) {
                high--;
                int pval = a[high];
                a[high] = a[low];
                heapfy(a, low, high, low, pval);
            }
        }

    }

    static class LightWriter implements AutoCloseable {
        private final Writer out;
        private boolean autoflush = false;
        private boolean breaked = true;

        public LightWriter(Writer out) {
            this.out = out;
        }

        public LightWriter(OutputStream out) {
            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));
        }

        public LightWriter print(char c) {
            try {
                out.write(c);
                breaked = false;
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
            return this;
        }

        public LightWriter print(String s) {
            try {
                out.write(s, 0, s.length());
                breaked = false;
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
            return this;
        }

        public LightWriter ans(String s) {
            if (!breaked) {
                print(' ');
            }
            return print(s);
        }

        public LightWriter ans(int i) {
            return ans(Integer.toString(i));
        }

        public LightWriter ln() {
            print(System.lineSeparator());
            breaked = true;
            if (autoflush) {
                try {
                    out.flush();
                } catch (IOException ex) {
                    throw new UncheckedIOException(ex);
                }
            }
            return this;
        }

        public void close() {
            try {
                out.close();
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
        }

    }

    static class QuickSort {
        private QuickSort() {
        }

        private static void med(int[] a, int low, int x, int y, int z) {
            if (a[z] < a[x]) {
                ArrayUtil.swap(a, low, x);
            } else if (a[y] < a[z]) {
                ArrayUtil.swap(a, low, y);
            } else {
                ArrayUtil.swap(a, low, z);
            }
        }

        static int step(int[] a, int low, int high) {
            int x = low + 1, y = low + (high - low) / 2, z = high - 1;
            if (a[x] < a[y]) {
                med(a, low, x, y, z);
            } else {
                med(a, low, y, x, z);
            }

            int lb = low + 1, ub = high;
            while (true) {
                while (a[lb] < a[low]) {
                    lb++;
                }
                ub--;
                while (a[low] < a[ub]) {
                    ub--;
                }
                if (lb >= ub) {
                    return lb;
                }
                ArrayUtil.swap(a, lb, ub);
                lb++;
            }
        }

    }

    static class InsertionSort {
        private InsertionSort() {
        }

        static void sort(int[] a, int low, int high) {
            for (int i = low; i < high; i++) {
                for (int j = i; j > low && a[j - 1] > a[j]; j--) {
                    ArrayUtil.swap(a, j - 1, j);
                }
            }
        }

    }
}

",5,1209_A,CODEFORCES,3592,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.*;
import java.util.*;
 
public class Kaudo {
    static Reader in =new Reader();
    static StringBuilder Sd=new StringBuilder();
    static long ans,res,lot,max;
    static List<Integer>gr[];
    static ArrayList<Integer> A=new ArrayList();
    static String ch[];
     public static void main(String [] args) {
        int n=in.nextInt(),a[]=new int [n],g=0;
        for(int i=0;i<n;i++){
        a[i]=in.nextInt();
        if(a[i]==1){System.out.println(""1"");return;}
        }
        ans=0;
        Arrays.sort(a);
        for(int i=0;i<n;i++){
            int x=a[i];
            if(x>0){ans++;
        for(int u=i;u<n;u++){
        if(a[u]%x==0){a[u]=0;}
        
        }}
        
        }
         System.out.println(ans);
     }
     static int gcd(int a,int b){
     if(b==0)return a;
     return gcd(b,a%b);
     }
   static class Reader 
    {  
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} 
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} 
        public int nextInt(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} 
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }
    }
    
}
",5,1209_A,CODEFORCES,3473,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class ques1 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int b = sc.nextInt();
        ArrayList<Integer> ar=new ArrayList<>();

        for(int i=0;i<b;i++){
            ar.add(sc.nextInt());
        }

        Collections.sort(ar);
        int count=0;
        int i=0;
        while(ar.size()!=0)
        {
            int tmep=ar.get(i);
            int v=ar.remove(i);
            count++;
            int j=0;
            while(j<ar.size()){
                if(ar.get(j)%tmep==0){
                    int a=ar.remove(j);

                }
                else
                    j++;
            }

        }
        System.out.println(count);



    }
}
",5,1209_A,CODEFORCES,3497,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.util.ArrayList;
import java.util.Scanner;

public class PaintTheNumber {

	public static void main(String[] args) {
		
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		
		ArrayList<Integer> l=new ArrayList<Integer>();
		
		for(int i=0; i<n; i++) {
			l.add(sc.nextInt());
		}
		
		boolean c=false;
		
		
			for(int i=0; i<l.size(); i++) {
				if(l.get(i)==-1)
					continue;
				for(int j=0; j<l.size(); j++) {
					
					if(i==j || l.get(j)==-1)
						continue;
					else {
						if(l.get(j)%l.get(i)==0) {
							l.set(j, -1);
						}
					}
				}
			}
			
			int nbr=0;
			for(int i=0; i<l.size(); i++)
				if(l.get(i)!=-1)
					nbr++;
			System.out.println(nbr);
	}

}
",5,1209_A,CODEFORCES,3477,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.util.*;


public class CFContest {
    public static void main(String[] args) throws Exception {
        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;
        boolean async = true;

        Charset charset = Charset.forName(""ascii"");

        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);
        Task task = new Task(io, new Debug(local));

        if (async) {
            Thread t = new Thread(null, task, ""dalt"", 1 << 27);
            t.setPriority(Thread.MAX_PRIORITY);
            t.start();
            t.join();
        } else {
            task.run();
        }

        if (local) {
            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");
        }

        io.flush();
    }

    public static class Task implements Runnable {
        final FastIO io;
        final Debug debug;
        int inf = (int) 1e8;
        long lInf = (long) 1e18;

        public Task(FastIO io, Debug debug) {
            this.io = io;
            this.debug = debug;
        }

        @Override
        public void run() {
            solve();
        }

        public void solve() {
            int n = io.readInt();
            int[] data = new int[n];
            for (int i = 0; i < n; i++) {
                data[i] = io.readInt();
            }
            Arrays.sort(data);
            boolean[] paint = new boolean[n];
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (paint[i]) {
                    continue;
                }
                cnt++;
                for (int j = i; j < n; j++) {
                    if (data[j] % data[i] == 0) {
                        paint[j] = true;
                    }
                }
            }

            io.cache.append(cnt);
        }

    }


    public static class FastIO {
        public final StringBuilder cache = new StringBuilder(20 << 20);
        private final InputStream is;
        private final OutputStream os;
        private final Charset charset;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);
        private byte[] buf = new byte[1 << 20];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastIO(InputStream is, OutputStream os, Charset charset) {
            this.is = is;
            this.os = os;
            this.charset = charset;
        }

        public FastIO(InputStream is, OutputStream os) {
            this(is, os, Charset.forName(""ascii""));
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public double readDouble() {
            boolean sign = true;
            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+';
                next = read();
            }

            long val = 0;
            while (next >= '0' && next <= '9') {
                val = val * 10 + next - '0';
                next = read();
            }
            if (next != '.') {
                return sign ? val : -val;
            }
            next = read();
            long radix = 1;
            long point = 0;
            while (next >= '0' && next <= '9') {
                point = point * 10 + next - '0';
                radix = radix * 10;
                next = read();
            }
            double result = val + (double) point / radix;
            return sign ? result : -result;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

        public int readLine(char[] data, int offset) {
            int originalOffset = offset;
            while (next != -1 && next != '\n') {
                data[offset++] = (char) next;
                next = read();
            }
            return offset - originalOffset;
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

        public int readString(byte[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (byte) next;
                next = read();
            }

            return offset - originalOffset;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

        public void flush() {
            try {
                os.write(cache.toString().getBytes(charset));
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        public boolean hasMore() {
            skipBlank();
            return next != -1;
        }
    }

    public static class Debug {
        private boolean allowDebug;

        public Debug(boolean allowDebug) {
            this.allowDebug = allowDebug;
        }

        public void assertTrue(boolean flag) {
            if (!allowDebug) {
                return;
            }
            if (!flag) {
                fail();
            }
        }

        public void fail() {
            throw new RuntimeException();
        }

        public void assertFalse(boolean flag) {
            if (!allowDebug) {
                return;
            }
            if (flag) {
                fail();
            }
        }

        private void outputName(String name) {
            System.out.print(name + "" = "");
        }

        public void debug(String name, int x) {
            if (!allowDebug) {
                return;
            }

            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, long x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, double x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, int[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, long[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, double[] x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.toString(x));
        }

        public void debug(String name, Object x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println("""" + x);
        }

        public void debug(String name, Object... x) {
            if (!allowDebug) {
                return;
            }
            outputName(name);
            System.out.println(Arrays.deepToString(x));
        }
    }
}",5,1209_A,CODEFORCES,3568,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;

import static java.lang.Math.*;


public class cfs584A {
    static long LINF = Long.MAX_VALUE / 4;
    static long IING = Integer.MAX_VALUE / 4;

    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        StringBuilder sb = new StringBuilder();
        int N = sc.nextInt();
        int[] nums = sc.readIntArray(N);
        ArrayList<Integer> num = new ArrayList<>();

        for (int i = 0; i < N; i++) {
            num.add(nums[i]);
        }


        int count = 0;
        while (!num.isEmpty()) {
            count++;
            int size = num.size();
            int min = 200;
            for (int j = size-1; j >=0; j--) {
                if (num.get(j) < min) {
                    min = num.get(j);
                }
            }
            for (int j = size-1; j >=0; j--) {
                int div = num.get(j) / min;
                if ((div * min) == num.get(j)) {
                    num.remove(j);
                }
            }
        }
        sb.append(count);

        System.out.print(sb);
    }

    static void Assert(boolean b) {
        if (!b) throw new Error(""Assertion Failed"");
    }

    static class Pair implements Comparable<Pair> {
        int x, y;

        Pair(int _x, int _y) {
            x = _x;
            y = _y;
        }

        public int compareTo(Pair o) {
            int c1 = Integer.compare(x, o.x);
            return c1 != 0 ? c1 : Integer.compare(y, o.y);
        }

    }

    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }

        public FastScanner() {
            this(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] readIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextLong();
            }
            return a;
        }
    }
}
",5,1209_A,CODEFORCES,3539,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.TreeSet;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author beginner1010
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            TreeSet<Integer> set = new TreeSet<>();
            int n = in.nextInt();
            for (int i = 0; i < n; i++) {
                int x = in.nextInt();
                set.add(x);
            }
            int ans = 0;
            while (!set.isEmpty()) {
                ans++;
                int minimal = set.first();
                int cur = minimal;
                while (cur <= 100) {
                    set.remove(cur);
                    cur += minimal;
                }
            }
            out.println(ans);
        }

    }

    static class InputReader {
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputStream stream;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isWhitespace(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isWhitespace(c));
            return res * sgn;
        }

    }
}

",5,1209_A,CODEFORCES,3524,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.lang.*;
import java.util.*;
import java.io.*;

public class Main {
    void solve() {
       int n=ni();
       int a[]=new int[n+1];
       for(int i=1;i<=n;i++) a[i]=ni();
       int vis[]=new int[101];
       int ans=0;
       Arrays.sort(a,1,n+1);
       for(int i=1;i<=n;i++){
           if(vis[a[i]]==1) continue;
           ans++;
           for(int j=a[i];j<=100;j+=a[i]) vis[j]=1;
       }
       pw.println(ans);
    }

    long M = (long)1e9+7;
    // END
    PrintWriter pw;
    StringTokenizer st;
    BufferedReader br;

    void run() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        pw.flush();
    }
    public static void main(String[] args) throws Exception {
        new Main().run();
    }

    String ns() {
        while (st == null || !st.hasMoreElements()) {

            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }

    String nextLine() throws Exception {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            throw new Exception(e.toString());
        }
        return str;
    }

    int ni() {
        return Integer.parseInt(ns());
    }

    long nl() {
        return Long.parseLong(ns());
    }

    double nd() {
        return Double.parseDouble(ns());
    }
}",5,1209_A,CODEFORCES,3458,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;


public class Main {
    static int inf = (int) 1e9 + 7;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(System.out);
        int n = nextInt();
        int a[] = new int [n];
        for(int i = 0;i < n;i++) a[i] = nextInt();
        int ans = 0;
        boolean b[] = new boolean[n];
        Arrays.sort(a);

        for(int i = 0;i < n;i++) {
            if (!b[i]) {
                for(int j = i;j < n;j++) {
                    if (a[j] % a[i] == 0) b[j] = true;
                }
                ans++;
            }
        }
        pw.println(ans);
        pw.close();
    }

    static BufferedReader br;
    static StringTokenizer st = new StringTokenizer("""");
    static PrintWriter pw;

    static String next() throws IOException {
        while (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }
}

",5,1209_A,CODEFORCES,3532,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

public class A {

	public static void main(String[] args) throws Exception {
		FastScanner sc = new FastScanner(System.in);
		FastPrinter out = new FastPrinter(System.out);
		new A().run(sc, out);
		out.close();
	}

	public void run(FastScanner sc, FastPrinter out) throws Exception {
		int N = sc.nextInt();
		int[] arr = sc.nextIntArray(N);
		Arrays.sort(arr);
		boolean[] done = new boolean[N];
		int ans = 0;
		for (int i = 0; i < N; i++) {
			if (done[i]) continue;
			ans++;
			for (int j = i; j < N; j++) {
				if (arr[j] % arr[i] == 0) {
					done[j] = true;

				}
			}
		}
		out.println(ans);
	}

	public void shuffle(int[] arr) {
		for (int i = 0; i < arr.length; i++) {
			int r = (int) (Math.random() * arr.length);
			if (i != r) {
				arr[i] ^= arr[r];
				arr[r] ^= arr[i];
				arr[i] ^= arr[r];
			}
		}
	}

	static class FastScanner {
		final private int BUFFER_SIZE = 1 << 10;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;

		public FastScanner() {
			this(System.in);
		}

		public FastScanner(InputStream stream) {
			din = new DataInputStream(stream);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}

		public FastScanner(String fileName) throws IOException {
			Path p = Paths.get(fileName);
			buffer = Files.readAllBytes(p);
			bytesRead = buffer.length;
		}

		int[] nextIntArray(int N) throws IOException {
			int[] arr = new int[N];
			for (int i = 0; i < N; i++) {
				arr[i] = nextInt();
			}
			return arr;
		}

		String nextLine() throws IOException {
			int c = read();
			while (c != -1 && isEndline(c))
				c = read();
			if (c == -1) {
				return null;
			}
			StringBuilder res = new StringBuilder();
			do {
				if (c >= 0) {
					res.appendCodePoint(c);
				}
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		String next() throws Exception {
			int c = readOutSpaces();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		public int nextInt() throws IOException {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg) c = read();
			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');

			if (neg) return -ret;
			return ret;
		}

		public long nextLong() throws IOException {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg) c = read();
			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');
			if (neg) return -ret;
			return ret;
		}

		public double nextDouble() throws IOException {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg) c = read();

			do {
				ret = ret * 10 + c - '0';
			} while ((c = read()) >= '0' && c <= '9');

			if (c == '.') {
				while ((c = read()) >= '0' && c <= '9') {
					ret += (c - '0') / (div *= 10);
				}
			}

			if (neg) return -ret;
			return ret;
		}

		private void fillBuffer() throws IOException {
			if (din == null) {
				bufferPointer = 0;
				bytesRead = -1;
			} else {
				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			}
			if (bytesRead == -1) buffer[0] = -1;
		}

		private byte read() throws IOException {
			if (bufferPointer == bytesRead) fillBuffer();
			return buffer[bufferPointer++];
		}

		private int readOutSpaces() throws IOException {
			while (true) {
				if (bufferPointer == bytesRead) fillBuffer();
				int c = buffer[bufferPointer++];
				if (!isSpaceChar(c)) {
					return c;
				}
			}
		}

		public void close() throws IOException {
			if (din == null) return;
			din.close();
		}

		public int[][] readGraph(int N, int M, boolean zeroIndexed, boolean bidirectional) throws Exception {
			int[][] adj = new int[N][];
			int[] numNodes = new int[N];
			int[][] input = new int[M][2];
			for (int i = 0; i < M; i++) {
				int a = nextInt();
				int b = nextInt();
				if (zeroIndexed) {
					a--;
					b--;
				}
				input[i][0] = a;
				input[i][1] = b;
				numNodes[a]++;
				if (bidirectional) numNodes[b]++;
			}
			for (int i = 0; i < N; i++) {
				adj[i] = new int[numNodes[i]];
				numNodes[i] = 0;
			}
			for (int i = 0; i < M; i++) {
				int a = input[i][0];
				int b = input[i][1];
				adj[a][numNodes[a]++] = b;
				if (bidirectional) adj[b][numNodes[b]++] = a;
			}
			return adj;
		}

		public int[][][] readWeightedGraph(int N, int M, boolean zeroIndexed, boolean bidirectional) throws Exception {
			int[][][] adj = new int[N][][];
			int[] numNodes = new int[N];
			int[][] input = new int[M][3];
			for (int i = 0; i < M; i++) {
				int a = nextInt();
				int b = nextInt();
				if (zeroIndexed) {
					a--;
					b--;
				}
				int d = nextInt();
				input[i][0] = a;
				input[i][1] = b;
				input[i][2] = d;
				numNodes[a]++;
				if (bidirectional) numNodes[b]++;
			}
			for (int i = 0; i < N; i++) {
				adj[i] = new int[numNodes[i]][2];
				numNodes[i] = 0;
			}
			for (int i = 0; i < M; i++) {
				int a = input[i][0];
				int b = input[i][1];
				int d = input[i][2];
				adj[a][numNodes[a]][0] = b;
				adj[a][numNodes[a]][1] = d;
				numNodes[a]++;
				if (bidirectional) {
					adj[b][numNodes[b]][0] = a;
					adj[b][numNodes[b]][1] = d;
					numNodes[b]++;
				}
			}
			return adj;
		}
	}

	static class FastPrinter {
		static final char ENDL = '\n';
		StringBuilder buf;
		PrintWriter pw;

		public FastPrinter(OutputStream stream) {
			buf = new StringBuilder();
			pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream)));
		}

		public FastPrinter(String fileName) throws Exception {
			buf = new StringBuilder();
			pw = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
		}

		public FastPrinter(StringBuilder buf) {
			this.buf = buf;
		}

		public void print(int a) {
			buf.append(a);
		}

		public void print(long a) {
			buf.append(a);
		}

		public void print(char a) {
			buf.append(a);
		}

		public void print(char[] a) {
			buf.append(a);
		}

		public void print(double a) {
			buf.append(a);
		}

		public void print(String a) {
			buf.append(a);
		}

		public void print(Object a) {
			buf.append(a.toString());
		}

		public void println() {
			buf.append(ENDL);
		}

		public void println(int a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(long a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(char a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(char[] a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(double a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(String a) {
			buf.append(a);
			buf.append(ENDL);
		}

		public void println(Object a) {
			buf.append(a.toString());
			buf.append(ENDL);
		}

		public void printf(String format, Object... args) {
			buf.append(String.format(format, args));
		}

		public void close() {
			pw.print(buf);
			pw.close();
		}

		public void flush() {
			pw.print(buf);
			pw.flush();
			buf.setLength(0);
		}

	}

}",5,1209_A,CODEFORCES,3447,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            Arrays.sort(a);
            boolean[] dead = new boolean[n];
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (dead[i]) {
                    continue;
                }
                ++ans;
                for (int j = i; j < n; j++) {
                    if (a[j] % a[i] == 0) {
                        dead[j] = true;
                    }
                }
            }
            out.println(ans);
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",5,1209_A,CODEFORCES,3595,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class TaskA {

    public static void main(String[] args) {
        FastReader in = new FastReader(System.in);
//        FastReader in = new FastReader(new FileInputStream(""input.txt""));
        PrintWriter out = new PrintWriter(System.out);
//        PrintWriter out = new PrintWriter(new FileOutputStream(""output.txt""));


        int n = in.nextInt();

        int[] a = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        Arrays.sort(a);

        int ans = 1;
        for (int i = 1; i < n; i++) {
            boolean bb = false;
            for (int j = i - 1; j >= 0; j--) {
                if (a[i] % a[j] == 0) {
                    bb = true;
                    break;
                }
            }
            if (!bb) ans++;
        }

        out.println(ans);





        out.close();
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        FastReader(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        Integer nextInt() {
            return Integer.parseInt(next());
        }

        Long nextLong() {
            return Long.parseLong(next());
        }

        Double nextDouble() {
            return Double.parseDouble(next());
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                st = new StringTokenizer(nextLine());
            }
            return st.nextToken();
        }

        String nextLine() {
            String s = """";
            try {
                s = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return s;
        }
    }
}
",5,1209_A,CODEFORCES,3485,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class A {
    public static void main(String[] args) {
        Scanner input = new Scanner();
        StringBuilder output = new StringBuilder();

        int n = input.nextInt();
        int[] a = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = input.nextInt();
        }

        Arrays.sort(a);
        boolean[] colored = new boolean[n];
        int colors = 0;
        for (int i = 0; i < n; i++) {
            if (!colored[i]) {
                colors ++;
                colored[i] = true;
                for (int j = i+1; j < n; j++) {
                    if (a[j] % a[i] == 0) {
                        colored[j] = true;
                    }
                }
            }
        }

        System.out.println(colors);
    }

    private static class Scanner {
        BufferedReader br; StringTokenizer st;
        public Scanner(Reader in) { br = new BufferedReader(in); }
        public Scanner() { this(new InputStreamReader(System.in)); }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try { st = new StringTokenizer(br.readLine());
                } catch (IOException e) { e.printStackTrace(); } }
            return st.nextToken(); }
        int nextInt() { return Integer.parseInt(next()); }
        long nextLong() { return Long.parseLong(next()); }
        double nextDouble() { return Double.parseDouble(next()); }
        String readNextLine() {
            String str = """";
            try { str = br.readLine();
            } catch (IOException e) { e.printStackTrace(); }
            return str; }
        int[] readIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) { a[idx] = nextInt(); }
            return a; }
        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) { a[idx] = nextLong(); }
            return a; }
    } // end Scanner
}
",5,1209_A,CODEFORCES,3478,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{
 
        public static void main(String[] args) {
            Scanner s = new Scanner(System.in);
            int n=s.nextInt();
            int a[]=new int[n];
            for(int i=0;i<n;i++)
            a[i]=s.nextInt();
            Arrays.sort(a);
            ArrayList<Integer>al=new ArrayList();
            int k=a[0];
            int count=0;
            for(int j=0;j<n;j++)
            {k=a[j];
                if(Collections.frequency(al,a[j])==0)
                {for(int i=0;i<n;i++)
            {if(a[i]%k==0)
            {al.add(a[i]);}}
            count++;}}
            System.out.println(count);}}",5,1209_A,CODEFORCES,3586,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"


import java.io.*;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

@SuppressWarnings(""Duplicates"")

public class solveLOL {
    FastScanner in;
    PrintWriter out;
    boolean systemIO = true, multitests = false;
    int INF = Integer.MAX_VALUE / 2;


    void solve() {
        int n = in.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
        }
        Arrays.sort(arr);
        boolean used[] = new boolean[n];
        int k = 0;
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                used[i] = true;
                for (int j = i + 1; j < n; j++) {
                    if (!used[j] && arr[j] % arr[i] == 0) {
                        used[j] = true;
                    }
                }
                k++;
            }
        }
        System.out.println(k);



    }

    class pair implements Comparable<pair> {
        int a;
        int b;

        pair(int A, int B) {
            this.a = A;
            this.b = B;
        }

        public int compareTo(pair o) {
            return a != o.a ? Double.compare(a, o.a) : b - o.b;
        }
    }

    void shuffleArray(long[] ar) {
        Random rnd = ThreadLocalRandom.current();
        for (int i = ar.length - 1; i > 0; i--) {
            int index = rnd.nextInt(i + 1);
            long a = ar[index];
            ar[index] = ar[i];
            ar[i] = a;
        }
    }

    void printArray(long[] ar) {
        for (long k : ar) {
            System.out.print(k + "" "");
        }
        System.out.println();
    }

    void reverseArray(long[] ar) {
        for (int i = 0, j = ar.length - 1; i < j; i++, j--) {
            long a = ar[i];
            ar[i] = ar[j];
            ar[j] = a;
        }
    }

    private void run() throws IOException {
        if (systemIO) {
            in = new solveLOL.FastScanner(System.in);
            out = new PrintWriter(System.out);
        } else {
            in = new solveLOL.FastScanner(new File(""input.txt""));
            out = new PrintWriter(new File(""output.txt""));
        }
        for (int t = multitests ? in.nextInt() : 1; t-- > 0; )
            solve();

        out.close();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        FastScanner(File f) {
            try {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        FastScanner(InputStream f) {
            br = new BufferedReader(new InputStreamReader(f));
        }

        String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

    }

    public static void main(String[] arg) throws IOException {
        new solveLOL().run();
    }

}",5,1209_A,CODEFORCES,3494,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * @author khokharnikunj8
 */

public class Main {
    public static void main(String[] args) {
        new Thread(null, new Runnable() {
            public void run() {
                new Main().solve();
            }
        }, ""1"", 1 << 26).start();
    }

    void solve() {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            int n = in.scanInt();
            int[] hash = new int[101];
            boolean[] hash1 = new boolean[101];
            for (int i = 0; i < n; i++) hash[in.scanInt()]++;
            int ans = 0;
            for (int i = 1; i <= 100; i++) {
                if (hash1[i]) continue;
                if (hash[i] == 0) continue;
                for (int j = i; j <= 100; j += i) hash1[j] = true;
                ans++;
            }
            out.println(ans);

        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int index;
        private BufferedInputStream in;
        private int total;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (index >= total) {
                index = 0;
                try {
                    total = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (total <= 0) return -1;
            }
            return buf[index++];
        }

        public int scanInt() {
            int integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

    }
}

",5,1209_A,CODEFORCES,3585,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import static java.lang.Math.*;
import static java.util.Arrays.* ;

import java.math.BigInteger;
import java.util.*;
import java.io.*;

public class D
{
    int [][] adjList ;
    int dfs(int u , int p )
    {
        int size = 1 ;
        for(int v : adjList[u])
            if(v != p )
            {
                int curr = dfs(v,  u) ;
                size += curr ;
            }
        return size ;
    }

    void main() throws Exception
    {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt() ;
        int [] a = new int [n] ;
        boolean [] vis = new boolean[n] ;
        int cnt = 0 ;
        for(int i = 0 ;i < n ; i++)
            a[i] = sc.nextInt() ;
        sort(a);
        for(int i = 0 ;i  < n ; i ++)
        {
            if(!vis[i])
            {
                for(int j= i  ; j < n ; j++)
                    if(a[j] % a[i] == 0)
                        vis[j] = true ;

                cnt ++ ;
            }
        }

        out.println(cnt);
        out.flush();
        out.close();
    }

    class SegmentTree
    {
        int [] sTree ;
        int [] lazy ;
        int N ;

        SegmentTree(int n)
        {
            N = 1 << (32 - Integer.numberOfLeadingZeros(n - 1)) ;
            sTree = new int [N << 1] ;
            lazy= new int [N << 1] ;
        }
        void push(int node , int b , int e , int mid)
        {
            sTree[node << 1] += (mid - b + 1) * lazy[node] ;
            sTree[node << 1 | 1] += (e - mid) * lazy[node] ;
            lazy[node << 1] += lazy[node] ;
            lazy[node << 1 | 1] += lazy[node] ;
            lazy[node] = 0 ;
        }
        void updateRange(int node , int b , int e , int i , int j , int val)
        {
            if(i > e || j < b)return;

            if(i <= b && e <= j)
            {
                sTree[node] += (e - b + 1) * val ;
                lazy[node] += val ;
                return;
            }

            int mid = b + e >> 1 ;
            push(node , b , e , mid) ;
            updateRange(node << 1 , b , mid , i , j , val);
            updateRange(node << 1 | 1 , mid + 1 , e , i , j , val);
            sTree[node] = sTree[node << 1] + sTree[node << 1 | 1] ;
        }
        int query(int node , int b , int e , int i , int j)
        {
            if(i > e || j < b)
                return 0 ;
            if(i <= b && e <= j)
                return sTree[node] ;
            int mid = b + e >> 1 ;
            push(node  , b , e , mid);
            return query(node << 1 , b , mid , i , j) + query(node << 1 | 1 , mid + 1 , e , i , j) ;
        }

    }
    class Compressor
    {
        TreeSet<Integer> set = new TreeSet<>() ;
        TreeMap<Integer ,Integer> map = new TreeMap<>()  ;

        void add(int x)
        {
            set.add(x) ;
        }
        void fix()
        {
            for(int x : set)
                map.put(x , map.size() + 1) ;
        }
        int get(int x)
        {
            return map.get(x) ;
        }
    }
    class Scanner
    {
        BufferedReader br ;
        StringTokenizer st ;

        Scanner(InputStream in)
        {
            br = new BufferedReader(new InputStreamReader(in)) ;
        }
        String next() throws Exception
        {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine()) ;
            return st.nextToken() ;
        }
        int nextInt() throws Exception
        {
            return Integer.parseInt(next()) ;
        }
        long nextLong() throws Exception
        {
            return Long.parseLong(next()) ;
        }
        double nextDouble() throws Exception
        {
            return Double.parseDouble(next()) ;
        }
    }

    public static void main (String [] args) throws Exception {(new D()).main();}

}",5,1209_A,CODEFORCES,3545,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*; 
import java.util.*; 
//import javafx.util.*; 
import java.math.*;
//import java.lang.*;
public class Main 
{ 
  //  static int n;static ArrayList<Integer> arr[];
   // int ans[];
 
    public static void main(String[] args) throws IOException { 
    //    Scanner sc=new Scanner(System.in);
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        br = new BufferedReader(new InputStreamReader(System.in));
        int n=nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=nextInt();
        }
        Arrays.sort(arr);
        int c=0;
        for(int i=0;i<n;i++){
            if(arr[i]!=0){
                int a=arr[i];
                c++;
                for(int j=i;j<n;j++){
                  //  System.out.println(arr[i]+"" ""+arr[j]);
                    if(arr[j]%a==0){
                        arr[j]=0;
                    }
                }
            }
        }
        pw.println(c);
        pw.close();

    }
    
    static long maxSubArraySum(long a[],int size)  
{  
      
    long max_so_far = 0, max_ending_here = 0;  
  
    for (int i = 0; i < size; i++)  
    {  
        max_ending_here = max_ending_here + a[i]; 
        if (max_ending_here < 0)  
            max_ending_here = 0;  
          
        /* Do not compare for all 
           elements. Compare only  
           when max_ending_here > 0 */
        else if (max_so_far < max_ending_here)  
            max_so_far = max_ending_here;  
          
    }  
    return max_so_far;  
}  
    public static BufferedReader br;
    public static StringTokenizer st;
    public static String next() {
        while (st == null || !st.hasMoreTokens()) {
       try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }
 
    public static Integer nextInt() {
        return Integer.parseInt(next());
    }
 
    public static Long nextLong() {
        return Long.parseLong(next());
    }
 
    public static Double nextDouble() {
        return Double.parseDouble(next());
    }
    static class Pair{
        int x;int y;int z;
        Pair(int x,int y,int z){
            this.x=x;
            this.y=y;
            this.z=z;
          //  this.i=i;
        }
    }
    static class sorting implements Comparator<Pair>{
        public int compare(Pair a,Pair b){
            //return (a.y)-(b.y);
            return (a.x-b.x);
        }
    }
    public static int[] na(int n)throws IOException{
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = nextInt();
        return a;
    }
    static class query implements Comparable<query>{
        int l,r,idx,block;
        static int len;
        query(int l,int r,int i){
            this.l=l;
            this.r=r;
            this.idx=i;
            this.block=l/len;
        }   
        public int compareTo(query a){
            return block==a.block?r-a.r:block-a.block;
        }
    }
    static boolean isPrime(int n) { 
        if (n <= 1) 
            return false; 
        if (n <= 3) 
            return true; 
        if (n % 2 == 0 ||  
            n % 3 == 0) 
            return false; 
      
        for (int i = 5; 
                 i * i <= n; i = i + 6) 
            if (n % i == 0 || 
                n % (i + 2) == 0) 
                return false; 
      
        return true; 
    } 
    static long gcd(long a, long b) { 
      if (b == 0) 
        return a; 
      return gcd(b, a % b);  
    }  
    static long modInverse(long a, long m) { 
        long g = gcd(a, m); 
        if (g != 1) 
            return -1; 
        else{ 
            // If a and m are relatively prime, then modulo inverse 
            // is a^(m-2) mode m 
            return (power(a, m - 2, m)); 
        } 
    } 
      
    // To compute x^y under modulo m 
    static long power(long x, long y, long m){ 
        if (y == 0) 
            return 1;      
        long p = power(x, y / 2, m) % m; 
        p = (p * p) % m; 
      
        if (y % 2 == 0) 
            return p; 
        else
            return (x * p) % m; 
    }
    static long fast_pow(long base,long n,long M){
        if(n==0)
           return 1;
        if(n==1)
        return base;
        long halfn=fast_pow(base,n/2,M);
        if(n%2==0)
            return ( halfn * halfn ) % M;
        else
            return ( ( ( halfn * halfn ) % M ) * base ) % M;
    }
       static long modInverse(long n,int M){
        return fast_pow(n,M-2,M);
    }
    
} ",5,1209_A,CODEFORCES,3519,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author KharYusuf
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, FastReader s, PrintWriter w) {
            int n = s.nextInt();
            boolean[] b = new boolean[n];
            int[] a = new int[n];
            int ans = 0;
            for (int i = 0; i < n; i++) {
                a[i] = s.nextInt();
            }
            func.sort(a);
            for (int i = 0; i < n; i++) {
                if (!b[i]) {
                    ans++;
                    b[i] = true;
                    for (int j = i + 1; j < n; j++) {
                        //w.println(a[j]+"" ""+a[i]);
                        if (a[j] % a[i] == 0) {
                            b[j] = true;
                        }
                    }
                }
            }
            w.println(ans);
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {

            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {

                curChar = 0;

                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }

            return buf[curChar++];
        }

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();

                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public boolean isSpaceChar(int c) {

            if (filter != null)
                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class func {
        public static void sort(int[] arr) {
            int n = arr.length, mid, h, s, l, i, j, k;
            int[] res = new int[n];
            for (s = 1; s < n; s <<= 1) {
                for (l = 0; l < n - 1; l += (s << 1)) {
                    h = Math.min(l + (s << 1) - 1, n - 1);
                    mid = Math.min(l + s - 1, n - 1);
                    i = l;
                    j = mid + 1;
                    k = l;
                    while (i <= mid && j <= h) res[k++] = (arr[i] <= arr[j] ? arr[i++] : arr[j++]);
                    while (i <= mid) res[k++] = arr[i++];
                    while (j <= h) res[k++] = arr[j++];
                    for (k = l; k <= h; k++) arr[k] = res[k];
                }
            }
        }

    }
}

",5,1209_A,CODEFORCES,3467,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Scanner;

public class Loader {
    private final static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {
        int n = in.nextInt();
        ArrayList<Integer> l = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            l.add(in.nextInt());
        }

        Collections.sort(l);


        int k = 0;
        for (int i = 0; i < l.size(); i++) {
            if (l.get(i) == 0) continue;
            for (int j = i + 1; j < l.size(); j++) {
                if (l.get(j) == 0) continue;
                if (l.get(j) % l.get(i) == 0) {
                    l.set(j, 0);
                }
            }

            l.set(i, 0);
            k++;
        }

        System.out.println(k);
    }
}",5,1209_A,CODEFORCES,3509,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.math.*;

public class A {
	public static void main(String[] args) throws IOException {

		/**/
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		/*/
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(""src/a.in""))));
		/**/
		
		int n = sc.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = sc.nextInt();
		Arrays.sort(a);
		int ans = 0;
		boolean[] v = new boolean[n];
		for (int i = 0; i < n; i++) {
			if (v[i])
				continue;
			v[i] = true;
			ans++;
			for (int j = i; j < n; j++) {
				if (a[j]%a[i]==0)
					v[j] = true;
			}
		}
		System.out.println(ans);
	}
}",5,1209_A,CODEFORCES,3520,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/**
 * Date: 14 Sep, 2019
 * Link: 
 * 
 * @author Prasad-Chaudhari
 * @linkedIn: XXXX
 * @git: XXXX
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

public class newProgram5 {

    public static void main(String[] args) throws IOException {
        // TODO code application logic here
        FastIO in = new FastIO();
        int n = in.ni();
        int a[] = in.gia(n);
        int freq[] = new int[100 + 1];
        for (int i = 0; i < n; i++) {
            freq[a[i]]++;
        }
        int k = 0;
        for (int i = 1; i <= 100; i++) {
            if (freq[i] > 0) {
                for (int j = i; j <= 100; j += i) {
                    freq[j] = 0;
                }
                k++;
                // System.out.println(i);
            }
        }
        System.out.println(k);
        in.bw.flush();
    }

    static class FastIO {

        private final BufferedReader br;
        private final BufferedWriter bw;
        private String s[];
        private int index;
        private final StringBuilder sb;

        public FastIO() throws IOException {
            br = new BufferedReader(new InputStreamReader(System.in));
            bw = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));
            s = br.readLine().split("" "");
            sb = new StringBuilder();
            index = 0;
        }

        public int ni() throws IOException {
            return Integer.parseInt(nextToken());
        }

        public double nd() throws IOException {
            return Double.parseDouble(nextToken());
        }

        public long nl() throws IOException {
            return Long.parseLong(nextToken());
        }

        public String next() throws IOException {
            return nextToken();
        }

        public String nli() throws IOException {
            try {
                return br.readLine();
            } catch (IOException ex) {

            }
            return null;
        }

        public int[] gia(int n) throws IOException {
            int a[] = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = ni();
            }
            return a;
        }

        public int[] gia(int n, int start, int end) throws IOException {
            validate(n, start, end);
            int a[] = new int[n];
            for (int i = start; i < end; i++) {
                a[i] = ni();
            }
            return a;
        }

        public double[] gda(int n) throws IOException {
            double a[] = new double[n];
            for (int i = 0; i < n; i++) {
                a[i] = nd();
            }
            return a;
        }

        public double[] gda(int n, int start, int end) throws IOException {
            validate(n, start, end);
            double a[] = new double[n];
            for (int i = start; i < end; i++) {
                a[i] = nd();
            }
            return a;
        }

        public long[] gla(int n) throws IOException {
            long a[] = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nl();
            }
            return a;
        }

        public long[] gla(int n, int start, int end) throws IOException {
            validate(n, start, end);
            long a[] = new long[n];
            for (int i = start; i < end; i++) {
                a[i] = nl();
            }
            return a;
        }

        public int[][][] gwtree(int n) throws IOException {
            int m = n - 1;
            int adja[][] = new int[n + 1][];
            int weight[][] = new int[n + 1][];
            int from[] = new int[m];
            int to[] = new int[m];
            int count[] = new int[n + 1];
            int cost[] = new int[n + 1];
            for (int i = 0; i < m; i++) {
                from[i] = i + 1;
                to[i] = ni();
                cost[i] = ni();
                count[from[i]]++;
                count[to[i]]++;
            }
            for (int i = 0; i <= n; i++) {
                adja[i] = new int[count[i]];
                weight[i] = new int[count[i]];
            }
            for (int i = 0; i < m; i++) {
                adja[from[i]][count[from[i]] - 1] = to[i];
                adja[to[i]][count[to[i]] - 1] = from[i];
                weight[from[i]][count[from[i]] - 1] = cost[i];
                weight[to[i]][count[to[i]] - 1] = cost[i];
                count[from[i]]--;
                count[to[i]]--;
            }
            return new int[][][] { adja, weight };
        }

        public int[][][] gwg(int n, int m) throws IOException {
            int adja[][] = new int[n + 1][];
            int weight[][] = new int[n + 1][];
            int from[] = new int[m];
            int to[] = new int[m];
            int count[] = new int[n + 1];
            int cost[] = new int[n + 1];
            for (int i = 0; i < m; i++) {
                from[i] = ni();
                to[i] = ni();
                cost[i] = ni();
                count[from[i]]++;
                count[to[i]]++;
            }
            for (int i = 0; i <= n; i++) {
                adja[i] = new int[count[i]];
                weight[i] = new int[count[i]];
            }
            for (int i = 0; i < m; i++) {
                adja[from[i]][count[from[i]] - 1] = to[i];
                adja[to[i]][count[to[i]] - 1] = from[i];
                weight[from[i]][count[from[i]] - 1] = cost[i];
                weight[to[i]][count[to[i]] - 1] = cost[i];
                count[from[i]]--;
                count[to[i]]--;
            }
            return new int[][][] { adja, weight };
        }

        public int[][] gtree(int n) throws IOException {
            int adja[][] = new int[n + 1][];
            int from[] = new int[n - 1];
            int to[] = new int[n - 1];
            int count[] = new int[n + 1];
            for (int i = 0; i < n - 1; i++) {
                from[i] = i + 1;
                to[i] = ni();
                count[from[i]]++;
                count[to[i]]++;
            }
            for (int i = 0; i <= n; i++) {
                adja[i] = new int[count[i]];
            }
            for (int i = 0; i < n - 1; i++) {
                adja[from[i]][--count[from[i]]] = to[i];
                adja[to[i]][--count[to[i]]] = from[i];
            }
            return adja;
        }

        public int[][] gg(int n, int m) throws IOException {
            int adja[][] = new int[n + 1][];
            int from[] = new int[m];
            int to[] = new int[m];
            int count[] = new int[n + 1];
            for (int i = 0; i < m; i++) {
                from[i] = ni();
                to[i] = ni();
                count[from[i]]++;
                count[to[i]]++;
            }
            for (int i = 0; i <= n; i++) {
                adja[i] = new int[count[i]];
            }
            for (int i = 0; i < m; i++) {
                adja[from[i]][--count[from[i]]] = to[i];
                adja[to[i]][--count[to[i]]] = from[i];
            }
            return adja;
        }

        public void print(String s) throws IOException {
            bw.write(s);
        }

        public void println(String s) throws IOException {
            bw.write(s);
            bw.newLine();
        }

        public void print(int s) throws IOException {
            bw.write(s + """");
        }

        public void println(int s) throws IOException {
            bw.write(s + """");
            bw.newLine();
        }

        public void print(long s) throws IOException {
            bw.write(s + """");
        }

        public void println(long s) throws IOException {
            bw.write(s + """");
            bw.newLine();
        }

        public void print(double s) throws IOException {
            bw.write(s + """");
        }

        public void println(double s) throws IOException {
            bw.write(s + """");
            bw.newLine();
        }

        private String nextToken() throws IndexOutOfBoundsException, IOException {
            if (index == s.length) {
                s = br.readLine().split("" "");
                index = 0;
            }
            return s[index++];
        }

        private void validate(int n, int start, int end) {
            if (start < 0 || end >= n) {
                throw new IllegalArgumentException();
            }
        }
    }

    static class Data implements Comparable<Data> {

        int a, b;

        public Data(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public int compareTo(Data o) {
            if (a == o.a) {
                return Integer.compare(b, o.b);
            }
            return Integer.compare(a, o.a);
        }

        public static void sort(int a[]) {
            Data d[] = new Data[a.length];
            for (int i = 0; i < a.length; i++) {
                d[i] = new Data(a[i], 0);
            }
            Arrays.sort(d);
            for (int i = 0; i < a.length; i++) {
                a[i] = d[i].a;
            }
        }
    }
}
",5,1209_A,CODEFORCES,3505,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        HashSet<Integer> set = new HashSet<>();

        for (int i = 0; i < count; i++) {
            set.add(sc.nextInt());
        }

        ArrayList<Integer> list = new ArrayList<>(set);

        Collections.sort(list);

        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {

                if (list.get(i) % list.get(j) == 0 ||
                        list.get(j) % list.get(i) == 0) {
                    list.remove(j);
                    j--;
                }
            }
        }

        System.out.println(list.size());
    }
}
",5,1209_A,CODEFORCES,3564,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.*;
import java.math.*;
import static java.lang.Math.*;
import static java.util.Arrays.sort;
import static java.util.Collections.sort;
import static java.util.Arrays.fill;
import static java.util.Arrays.copyOfRange;
import static java.util.Arrays.binarySearch;
 
import static java.lang.Math.min;
import static java.lang.Math.max;
 
import static java.lang.Math.min;
import static java.lang.Math.max;
 
import java.util.*;
import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;

public class Main {

	public static void main(String[] args) throws IOException {
		int n = in.nextInt();
		int[] a = in.nextIntArray(n);
		sort(a);
		int ans = 0;
		boolean[] done = new boolean[n];
		for(int i = 0; i < n; i ++) {
			if(done[i])
				continue;
			ans ++;
			for(int j = i + 1; j < n; j ++)
				if(a[j] % a[i] == 0)
					done[j] = true;
		}
		out.write(ans + ""\n"");
		out.flush();
	}
 
	public static FastReader in = new FastReader();
	public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void gcj(int cn, Object ans) throws IOException {
		System.out.print(""Case #"" + cn + "": "" + ans + ""\n"");
	}
	
	public static ArrayList <Integer>[] ALArrayI(int size) {
		ArrayList <Integer>[] l = new ArrayList[size];
		for(int i = 0; i < size; i ++)
			l[i] = new ArrayList <> ();
		return l;
	}
	
	public static ArrayList <Long>[] ALArrayL(int size) {
		ArrayList <Long>[] l = new ArrayList[size];
		for(int i = 0; i < size; i ++)
			l[i] = new ArrayList <> ();
		return l;
	}
	
	public static Integer[] integerList(int fi, int fo) {
		Integer[] l = new Integer[fo - fi];
		for(int i = 0; i < fo - fi; i ++)
			l[i] = fi + i;
		return l;
	}
}
 
class Graph {
	TreeSet <Integer>[] g;
	
	public Graph(int n) {
		g = new TreeSet[n];
		for(int i = 0; i < n; i ++)
			g[i] = new TreeSet <> ();
	}
	
	public void addEdge(int u, int v) {
		g[u].add(v);
	}
	
	public TreeSet <Integer> getAdj(int u) {
		return g[u];
	}
	
	public int nodes() {
		return g.length;
	}
}
 
class FastReader {
    BufferedReader br;
    StringTokenizer st;
 
    public FastReader() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
    
    public String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException  e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
 
    public char nextChar() {
    	return next().charAt(0);
    }
    
    public int nextInt() {
        return Integer.parseInt(next());
    }
 
    public long nextLong() {
        return Long.parseLong(next());
    }
 
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public String nextLine() {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
    
    public int[] nextIntArray(int n) {
    	int[] a = new int[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextInt();
    	return a;
    }
    
    public Integer[] nextIntegerArray(int n) {
    	Integer[] a = new Integer[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextInt();
    	return a;
    }
    
    public long[] nextLongArray(int n) {
    	long[] a = new long[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextLong();
    	return a;
    }
    
    public double[] nextDoubleArray(int n) {
    	double[] a = new double[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextDouble();
    	return a;
    }
    
    public String[] nextStringArray(int n) {
    	String[] a = new String[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = next();
    	return a;
    }
}",5,1209_A,CODEFORCES,3475,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
 
 
 
public class Main {
	
	static InputReader in = new InputReader(System.in);
	static PrintWriter out = new PrintWriter(System.out);
	
	static int oo = (int)1e9;
	static int mod = 1000000007;
	
	public static void main(String[] args) throws IOException {
 
		int n = in.nextInt();
		int[] a = in.nextIntArray(n);
		Arrays.sort(a);
		boolean[] color = new boolean[n];
		int cnt = 0;
		for(int i = 0; i < n; ++i) {
			if(!color[i]) {
				cnt++;
				for(int j = i; j < n; j++) {
					if(a[j] % a[i] == 0)
						color[j] = true;
				}
			}
		}
		System.out.println(cnt);
		
		out.close();
	}
	
	
	static class SegmentTree {
		int n;
		long[] a, seg;
		int DEFAULT_VALUE = 0;
		
		public SegmentTree(long[] a, int n) {
			super();
			this.a = a;
			this.n = n;
			seg = new long[n * 4 + 1];
			build(1, 0, n-1);
		}
		
		private long build(int node, int i, int j) {
			if(i == j)
				return seg[node] = a[i];
			long first = build(node * 2, i, (i+j) / 2);
			long second = build(node * 2 + 1, (i+j) / 2 + 1, j);
			return seg[node] = combine(first, second);
		}
		
		long update(int k, long value) {
			return update(1, 0, n-1, k, value);
		}
		
		private long update(int node, int i, int j, int k, long value) {
			if(k < i || k > j)
				return seg[node];
			if(i == j && j == k) {
				a[k] = value;
				seg[node] = value;
				return value;
			}
			
			int m = (i + j) / 2;
			long first = update(node * 2, i, m, k, value);
			long second = update(node * 2 + 1, m + 1, j, k, value);
			return seg[node] = combine(first, second);
		}
		
		long query(int l, int r) {
			return query(1, 0, n-1, l, r);
		}
		
		private long query(int node, int i, int j, int l, int r) {
			if(l <= i && j <= r)
				return seg[node];
			if(j < l || i > r)
				return DEFAULT_VALUE;
			int m = (i + j) / 2;
			long first = query(node * 2, i, m, l, r);
			long second = query(node * 2 + 1, m+1, j, l, r);
			return combine(first, second);
		}
 
		private long combine(long a, long b) {
			return a + b;
		}
	}
	
	static class DisjointSet {
		int n;
		int[] g;
		int[] h;
		public DisjointSet(int n) {
			super();
			this.n = n;
			g = new int[n];
			h = new int[n];
			for(int i = 0; i < n; ++i) {
				g[i] = i;
				h[i] = 1;
			}
		}
		int find(int x) {
			if(g[x] == x)
				return x;
			return g[x] = find(g[x]);
		}
		void union(int x, int y) {
			x = find(x); y = find(y);
			if(x == y)
				return;
			if(h[x] >= h[y]) {
				g[y] = x;
				if(h[x] == h[y])
					h[x]++;
			}
			else {
				g[x] = y;
			}
		}
	}
	
	
	static int[] getPi(char[] a) {
		int m = a.length;
		int j = 0;
		int[] pi = new int[m];
		for(int i = 1; i < m; ++i) {
			while(j > 0 && a[i] != a[j])
				j = pi[j-1];
			if(a[i] == a[j]) {
				pi[i] = j + 1;
				j++;
			}
		}
		return pi;
	}
	
	static long lcm(long a, long b) {
		return a * b / gcd(a, b);
	}
	
	static boolean nextPermutation(int[] a) {
		for(int i = a.length - 2; i >= 0; --i) {
			if(a[i] < a[i+1]) {
				for(int j = a.length - 1; ; --j) {
					if(a[i] < a[j]) {
						int t = a[i];
						a[i] = a[j];
						a[j] = t;
						for(i++, j = a.length - 1; i < j; ++i, --j) {
							t = a[i];
							a[i] = a[j];
							a[j] = t;
						}
						return true;
					}
				}
			}
		}
		return false;
	}
	
	
	static void shuffle(int[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			int t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static void shuffle(long[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			long t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static int lower_bound(int[] a, int n, int k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	static int lower_bound(long[] a, int n, long k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	
	static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	static long gcd(long a, long b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	
	static class Pair implements Comparable<Pair> {
		int first, second;
 
		public Pair(int first, int second) {
			super();
			this.first = first;
			this.second = second;
		}
 
		@Override
		public int compareTo(Pair o) {
			return this.first != o.first ? this.first - o.first : this.second - o.second;
		}
 
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + first;
			result = prime * result + second;
			return result;
		}
 
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Pair other = (Pair) obj;
			if (first != other.first)
				return false;
			if (second != other.second)
				return false;
			return true;
		}
	}
}
 
 
 
class InputReader {
 
	private final InputStream stream;
	private final byte[] buf = new byte[8192];
	private int curChar, snumChars;
 
	public InputReader(InputStream st) {
		this.stream = st;
	}
 
	public int read() {
		if (snumChars == -1)
			throw new InputMismatchException();
		if (curChar >= snumChars) {
			curChar = 0;
			try {
				snumChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (snumChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
 
	public int nextInt() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public long nextLong() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public int[] nextIntArray(int n) {
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		return a;
	}
 
	public String readString() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}
 
	public String nextLine() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isEndOfLine(c));
		return res.toString();
	}
 
	public boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
	private boolean isEndOfLine(int c) {
		return c == '\n' || c == '\r' || c == -1;
	}
 
}",5,1209_A,CODEFORCES,3589,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class task1 {
    static void print(Object... a) {
        for (Object aa : a) {
            System.out.println(aa.toString());
        }
    }

    static Map<Character, Integer> stringToCharsMap(String str) {
        Map<Character, Integer> charcount = new HashMap<Character, Integer>();
        for (Character c : str.toCharArray()) {
            if (charcount.containsKey(c)) {
                charcount.put(c, charcount.get(c) + 1);
            } else {
                charcount.put(c, 1);
            }
        }
        return charcount;
    }

    static Set<Character> stringToCharsSet(String str) {
        Set<Character> chars = new HashSet<>();
        for (Character c : str.toCharArray()) {
            chars.add(c);
        }
        return chars;
    }

    static int[] readArrayOfInt() {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int array[] = new int[a];
        for (int i = 0; i < a; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }

    static class Point {
        double x;
        double y;

        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }

        double distance(Point p) {
            return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));
        }

        double distance(Line l) {
            return Math.abs(l.a * this.x + l.b * this.y + l.c) / Math.sqrt(l.a * l.a + l.b * l.b);
        }
    }

    static class Line {
        double a;
        double b;
        double c;
        double EPS = 1e-6;

        Line(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        Line(Point f, Point s) {
            this.a = f.y - s.y;
            this.b = s.x - f.x;
            this.c = -this.a * f.x - this.b * f.y;
        }

        double distance(Point p) {
            return Math.abs(this.a * p.x + this.b * p.y + this.c) / Math.sqrt(this.a * this.a + this.b * this.b);
        }

        boolean isPointOnLine(Point p) {
            return p.x * this.a + p.y * this.b + this.c < EPS;
        }

        Point linesIntersection(Line a) {
            double x = -(this.c * a.b - a.c * this.b) / (this.a * a.b - a.a * this.b);
            double y = -(this.a * a.c - a.a * this.c) / (this.a * a.b - a.a * this.b);
            return new Point(x, y);
        }
    }

    static HashMap<Integer, Integer> getDels(int a) {
        HashMap<Integer, Integer> h = new HashMap<>();
        int i = 2;
        while (a != 1) {
            if (a % i == 0) {
                if (h.containsKey(i)) {
                    h.put(i, h.get(i) + 1);
                } else {
                    h.put(i, 1);
                }
                a = a / i;
            } else {
                i++;
            }
        }
        return h;
    }

    static class Rect {
        Point fcorner;
        Point scorner;

        Rect(Point f, Point s) {
            fcorner = f;
            scorner = s;
        }

        double volume() {
            return Math.abs((fcorner.x - scorner.x) * (fcorner.y - scorner.y));
        }
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        int c[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int count = 1;
        c[0] = 1;
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] % arr[j] == 0) {
                    c[i] = c[j];
                    break;
                }
            }
            if (c[i] == 0) {
                c[i] = count + 1;
                count++;
            }
        }
        System.out.println(count);
    }
}
",5,1209_A,CODEFORCES,3534,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class A {
	FastScanner in;
	PrintWriter out;
	boolean systemIO = true;

	public class Fenvik {
		int[] sum;

		public Fenvik(int n) {
			sum = new int[n];
		}

		public void add(int x) {
			for (; x < sum.length; x = (x | (x + 1))) {
				sum[x]++;
			}
		}

		public int sum(int r) {
			int ans = 0;
			for (; r >= 0; r = (r & (r + 1)) - 1) {
				ans += sum[r];
			}
			return ans;
		}
	}
	
	public int gcd(int x, int y) {
		if (y == 0) {
			return x;
		}
		if (x == 0) {
			return y;
		}
		return gcd(y, x % y);
	}
	
	
	public class Edge {
		int to;
		long s;

		public Edge(int to, long s) {
			this.to = to;
			this.s = s;
		}
	}
	
	public long dfs(int v, int prev, long sumth, long minsum, long s) {
		tin[v] = timer;
		timer++;
		up[v][0] = new Edge(prev, s);
		for (int i = 1; i <= l; i++) {
			Edge e = up[v][i - 1];
			up[v][i] = new Edge(up[e.to][i - 1].to, up[e.to][i - 1].s + e.s);
		}
		minsum = Math.min(minsum, sumth);
		maxup[v] = sumth - minsum;
		long mxdown = sumth;
		for (Edge e : list[v]) {
			if (e.to != prev) {
				mxdown = Math.max(mxdown, dfs(e.to, v, sumth + e.s, minsum, e.s));
			}
		}
		tout[v] = timer;
		timer++;
		maxdown[v] = mxdown - sumth;
		return mxdown;
	}
	
	public boolean upper(int a1, int b1) {
		return tin[a1] <= tin[b1] && tout[a1] >= tout[b1];
	}
	
	public Edge lca(int a, int b) {
		if (a == b) {
			return new Edge(a, 0);
		}
		int v = -1;
		int a1 = a;
		int b1 = b;
		if (tin[a] <= tin[b] && tout[a] >= tout[b]) {
			v = b;
			long lenb = 0;
			for (int i = l; i >= 0; i--) {
				a1 = up[v][i].to;
				b1 = a;
				if (!(tin[a1] <= tin[b1] && tout[a1] >= tout[b1])) {
					lenb += up[v][i].s;
					v = up[v][i].to;
				}
			}
			lenb += up[v][0].s;
			v = up[v][0].to;
			return new Edge(v, lenb);
		}
		if (upper(b, a)) {
			v = a;
			long lena = 0;
			for (int i = l; i >= 0; i--) {
				a1 = up[v][i].to;
				b1 = b;
				if (!(tin[a1] <= tin[b1] && tout[a1] >= tout[b1])) {
					lena += up[v][i].s;
					v = up[v][i].to;
				}
			}
			lena += up[v][0].s;
			v = up[v][0].to;
			return new Edge(v, lena);
		}
		v = a;
		long lena = 0;
		for (int i = l; i >= 0; i--) {
			a1 = up[v][i].to;
			b1 = b;
			if (!(tin[a1] <= tin[b1] && tout[a1] >= tout[b1])) {
				lena += up[v][i].s;
				v = up[v][i].to;
			}
		}
		lena += up[v][0].s;
		v = up[v][0].to;
		v = b;
		long lenb = 0;
		for (int i = l; i >= 0; i--) {
			a1 = up[v][i].to;
			b1 = a;
			if (!(tin[a1] <= tin[b1] && tout[a1] >= tout[b1])) {
				lenb += up[v][i].s;
				v = up[v][i].to;
			}
		}
		lenb += up[v][0].s;
		v = up[v][0].to;
		return new Edge(v, lena + lenb);
	}
	
	int n;
	int l;
	int[] tin;
	int[] tout;
	int timer = 0;
	long[] maxup;
	long[] maxdown;
	Edge[][] up;
	ArrayList<Edge>[] list;

	public void solve() {
		int n = in.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = in.nextInt();
		}
		Arrays.sort(a);
		int ans = 0;
		boolean[] used = new boolean[n];
		for (int i = 0; i < used.length; i++) {
			if (!used[i]) {
				ans++;
				for (int j = i; j < used.length; j++) {
					if (a[j] % a[i] == 0) {
						used[j] = true;
					}
				}
			}
		}
		out.print(ans);
	}

	public void run() {
		try {
			if (systemIO) {
				in = new FastScanner(System.in);
				out = new PrintWriter(System.out);
			} else {
				in = new FastScanner(new File(""input.txt""));
				out = new PrintWriter(new File(""output.txt""));
			}
			solve();

			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		FastScanner(File f) {
			try {
				br = new BufferedReader(new FileReader(f));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		FastScanner(InputStream f) {
			br = new BufferedReader(new InputStreamReader(f));
		}

		String nextLine() {
			try {
				return br.readLine();
			} catch (IOException e) {
				return null;
			}
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

	}

	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	public static void main(String[] arg) {
		new A().run();
	}
}",5,1209_A,CODEFORCES,3487,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String [] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int numbers[] = new int[n];
        for (int i = 0; i < n; i++) {
            numbers[i] = scanner.nextInt();
        }
        scanner.close();
        Arrays.sort(numbers);

        boolean[] colored = new boolean[n];
        int res = 0;

        for (int i = 0; i < n; i++) {
            if (!colored[i]) {
                res += 1;
            }
            for (int j = i; j < n; j++) {
                if (numbers[j] % numbers[i] == 0) {
                    colored[j] = true;
                }
            }
        }

        System.out.println(res);
    }
}
",5,1209_A,CODEFORCES,3468,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
 
 
public class Main {
	public static void main(String[] args) throws Exception {
		MScanner sc=new MScanner(System.in);
		PrintWriter pw=new PrintWriter(System.out);
		int n=sc.nextInt();HashSet<Integer>nums=new HashSet<Integer>();
		int[]in=new int[n];for(int i=0;i<n;i++)in[i]=sc.nextInt();
		Arrays.sort(in);
		int ans=0;
		boolean vis[]=new boolean[n];
		for(int i=0;i<n;i++) {
			if(vis[i])continue;
			for(int j=i+1;j<n;j++) {
				if(in[j]%in[i]==0) {
					vis[j]=true;
				}
			}
			ans++;
		}
		pw.println(ans);
		
		pw.flush();
	}
    static class MScanner {
		StringTokenizer st;
		BufferedReader br;
 
		public MScanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public MScanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}",5,1209_A,CODEFORCES,3557,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;

public class paint {
	static PriorityQueue<Integer> sequence;
	
	public static void main (String [] args) throws IOException {
	    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
	    PrintWriter out = new PrintWriter(System.out, true);
	    int numSeq = Integer.parseInt(f.readLine());
	    sequence = new PriorityQueue<Integer>();
	    
	    StringTokenizer st = new StringTokenizer(f.readLine());
	    for(int i = 0; i < numSeq; i++) {
	    	sequence.add(Integer.parseInt(st.nextToken()));
	    }
	    
	    int numColors = 0;
	    while(sequence.size() > 0) {
	    	numColors++;
	    	int smallest = sequence.poll();
	    	PriorityQueue<Integer> temp = new PriorityQueue<Integer>();
	    	for(int each: sequence) {
	    		if(each % smallest != 0) {
	    			temp.add(each);
	    		}
	    	}
	    	sequence = temp;
	    }
	    
	    System.out.println(numColors);
	    out.close();
	}
	
}
",5,1209_A,CODEFORCES,3549,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class A {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine());
        String str[] = reader.readLine().split("" "");
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(str[i]);
        }
        Arrays.sort(a);
        int k = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] == 0){
                continue;
            }
            for (int j = i + 1; j < n; j++) {
                if (a[j] % a[i] == 0){
                    a[j] = 0;
                }
            }
            k++;
        }
        System.out.println(k);
    }
}
",5,1209_A,CODEFORCES,3569,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
        }
        Arrays.sort(arr);
        int cnt = 0;
        int pos = 0;
        while (true) {
            while (pos < n && arr[pos] == -1) pos++;
            if (pos == n) break;
            int min = arr[pos];
            arr[pos] = -1;
            cnt++;
            for (int i = pos + 1; i < n; i++) {
                if (arr[i] % min == 0) {
                    arr[i] = -1;
                }
            }
        }
        System.out.println(cnt);
    }
}",5,1209_A,CODEFORCES,3521,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import javax.print.DocFlavor;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Round584_a {
        public static void main(String[] args) throws Exception {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st;

                int n = Integer.parseInt(br.readLine());
                st = new StringTokenizer(br.readLine());
                int a[] = new int[n];
                for(int i=0 ; i<n ; i++) {
                        a[i] = Integer.parseInt(st.nextToken());
                }

                Arrays.sort(a);

                boolean vis[] = new boolean[n];
                int count = 0;
                for(int i=0 ; i<n ; i++) {
                        if(!vis[i]) {
                                for(int j=i ; j<n ; j++) {
                                        if(!vis[j]) {
                                                if(a[j]%a[i] == 0) {
                                                        vis[j] = true;
                                                }
                                        }
                                }
                                count++;
                        }
                }

                System.out.println(count);
        }
}

/*import java.io.BufferedReader;
        import java.io.InputStreamReader;
        import java.util.StringTokenizer;

public class Round584_a {
        public static void main(String[] args) throws Exception {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st;
        }
}*/

",5,1209_A,CODEFORCES,3578,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.ArrayList;
import java.util.Scanner;

public class kosyaDetka {
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);

        int t = scan.nextInt();

        ArrayList<Integer> arr = new ArrayList<>();

        for(int i = 0; i < t; i++){
            arr.add( scan.nextInt());
        }

        int count = 0;

        while (arr.size() != 0){

            int min = Integer.MAX_VALUE;

            for(int i = 0; i < arr.size(); i++){
                int temp = arr.get(i);
                if( temp < min){
                    min = temp;
                }
            }


            for(int i = 0; i < arr.size(); i++){
                int temp = arr.get(i);
                if( temp % min == 0){
                    arr.remove(i);
                    i--;
                }
            }

            count++;
        }

        System.out.println(count);
    }
}
",5,1209_A,CODEFORCES,3562,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"

import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;


public class Mainm {
    static int mod1 = (int) (1e9 + 7);

    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String nextString() throws IOException {
            String str00 = scan.next();
            return str00;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        String next() throws IOException {
            int c;
            for (c = read(); c <= 32; c = read());
            StringBuilder sb = new StringBuilder();
            for (; c > 32; c = read()) {
                sb.append((char) c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.') {
                while ((c = read()) >= '0' && c <= '9') {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException {
            if (din == null)
                return;
            din.close();
        }

        public int[] nextArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextInt();
            }
            return a;
        }
    }


    static int GCD(int a, int b)
    {
        if (b == 0)
            return a;
        return GCD(b, a % b);
    }


    static  long power(long x, long y, long p)
    {
        int res = 1;      // Initialize result

        return res;
    }


    static boolean primeCheck(long num0) {
        boolean b1 = true;
        if (num0 == 1) {
            b1 = false;
        } else {
            int num01 = (int) (Math.sqrt(num0)) + 1;
            me1:
            for (int i = 2; i < num01; i++) {
                if (num0 % i == 0) {
                    b1 = false;
                    break me1;
                }
            }
        }
        return b1;
    }

    public static int dev(long num1)
    {
        int count00=0;
        while (num1%2==0)
        {
            count00++;
            num1/=2;
        }
        HashMap<Long,Long> hashMap=new HashMap<>();
        if(count00!=0)
        {
            hashMap.put(2L,(long)count00);
        }
        for (int i = 3; i <= (int)Math.sqrt(num1); i = i + 2)
        {
            // While i divides n, print i and divide n
            if(num1%i==0) {
                int count01 = 0;

                while (num1 % i == 0) {
                    num1 /= i;
                    count01++;
                }
                hashMap.put((long)i,(long)count01);
            }
        }
        if(num1>2)
        {
            hashMap.put((long)num1,1L);
        }
        long numOfDiv=1;
        for(long num00:hashMap.keySet())
        {
            long cDiv0=hashMap.get(num00);
            numOfDiv*=(cDiv0+1);
        }

        return (int)(numOfDiv);
    }



    public static long solve(long[] arr1, long N)
    {
        int n=(int)N;
        HashMap<Long,Integer> hm=new HashMap<>();
        for(int i=0;i<n;i++)
        {
            if(hm.containsKey(arr1[i]))
            {

            }
            else
            {
                hm.put(arr1[i],1);
            }
        }

        long count1=0;
        for(int i=0;i<n;i++)
        {
            long num1=arr1[i]*arr1[i];
            if(hm.containsKey(num1))
            {
                count1+=hm.get(num1);
                if(arr1[i]==1)
                {
                    count1--;
                }

            }
        }
        return count1;
    }




    public static void main(String[] args) throws IOException {
        Reader r = new Reader();
        //PrintWriter writer=new PrintWriter(System.out);
        //Scanner r = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        //Scanner r=new Scanner(System.in);
        OutputWriter770 out77 = new OutputWriter770(System.out);

        int num1=r.nextInt();
        int[] arr1=r.nextArray(num1);
        Arrays.sort(arr1);

        int res1=0;
        for(int i=0;i<num1;i++)
        {
            if(arr1[i]!=-1)
            {
                res1++;
                int num2=arr1[i];
                arr1[i]=-1;
                for(int j=i+1;j<num1;j++)
                {
                    if(arr1[j]%num2==0)
                    {
                        arr1[j]=-1;
                    }
                }
            }
        }
        out77.print(res1+"""");
        r.close();
        out77.close();
    }
}




class OutputWriter770
{
    BufferedWriter writer;

    public OutputWriter770(OutputStream stream)
    {
        writer = new BufferedWriter(new OutputStreamWriter(stream));
    }
    public void print(int i) throws IOException
    {
        writer.write(i + """");
    }

    public void println(int i) throws IOException
    {
        writer.write(i + ""\n"");
    }

    public void print(String s) throws IOException
    {
        writer.write(s + """");
    }

    public void println(String s) throws IOException
    {
        writer.write(s + ""\n"");
    }

    public void print(char[] c) throws IOException
    {
        writer.write(c);
    }

    public void close() throws IOException
    {
        writer.flush();
        writer.close();
    }
}

class node
{
    int source,dest;
    long difDist;
    node(int source,int dest,long tDst, long hDst)
    {
        this.source=source;
        this.dest=dest;
        this.difDist=hDst-tDst;
    }
}",5,1209_A,CODEFORCES,3538,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.math.*;
import java.util.*;

public class paintNumbers {
	public static int minIndex(List<Integer> list) {
		int min = list.get(0);
		int minIndex = 0;
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i) < min) {
				min = list.get(i);
				minIndex = i;
			}
		}
		return minIndex;
	}
    public static void main(String[] args) throws IOException {
        FastScanner sc = new FastScanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        
        int n = sc.nextInt();
        List<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
        	list.add(sc.nextInt());
        }
        int count = 0;
        while (list.size() > 0) {
        	count++;
        	int temp = list.get(minIndex(list));
//        	pw.println(""min = "" + temp);
        	for (int j = 0; j < list.size(); j++) {
        		if (list.get(j) % temp == 0) {
//        			pw.println(""j = "" + list.get(j));
//        			pw.println(""min = "" + temp);
        			list.remove(j);
        			j--;
        		}
        	}
//        	for (int i = 0; i < list.size(); i++) {
//        		pw.println(list.get(i) + "" "");
//        	}
        }
        pw.println(count);
        
        pw.close();
    }
    static class FastScanner {
    	private boolean finished = false;

        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;

        public FastScanner(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw   new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }
        public int peek() {
            if (numChars == -1) {
                return -1;
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    return -1;
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public String nextString() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                if (Character.isValidCodePoint(c)) {
                    res.appendCodePoint(c);
                }
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private String readLine0() {
            StringBuilder buf = new StringBuilder();
            int c = read();
            while (c != '\n' && c != -1) {
                if (c != '\r') {
                    buf.appendCodePoint(c);
                }
                c = read();
            }
            return buf.toString();
        }
        public String readLine() {
            String s = readLine0();
            while (s.trim().length() == 0) {
                s = readLine0();
            }
            return s;
        }
        public String readLine(boolean ignoreEmptyLines) {
            if (ignoreEmptyLines) {
                return readLine();
            } else {
                return readLine0();
            }
        }

        public BigInteger readBigInteger() {
            try {
                return new BigInteger(nextString());
            } catch (NumberFormatException e) {
                throw new InputMismatchException();
            }
        }

        public char nextCharacter() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            return (char) c;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E') {
                    return res * Math.pow(10, nextInt());
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E') {
                        return res * Math.pow(10, nextInt());
                    }
                    if (c < '0' || c > '9') {
                        throw new InputMismatchException();
                    }
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public boolean isExhausted() {
            int value;
            while (isSpaceChar(value = peek()) && value != -1) {
                read();
            }
            return value == -1;
        }
    public String next() {
            return nextString();
        }

        public SpaceCharFilter getFilter() {
            return filter;
        }

        public void setFilter(SpaceCharFilter filter) {
            this.filter = filter;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
        public int[] nextIntArray(int n){
            int[] array=new int[n];
            for(int i=0;i<n;++i)array[i]=nextInt();
            return array;
        }
        public int[] nextSortedIntArray(int n){
            int array[]=nextIntArray(n);
            PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
            for(int i = 0; i < n; i++){
                pq.add(array[i]);
            }
            int[] out = new int[n];
            for(int i = 0; i < n; i++){
                out[i] = pq.poll();
            }
            return out;
        }
        public int[] nextSumIntArray(int n){
            int[] array=new int[n];
            array[0]=nextInt();
            for(int i=1;i<n;++i)array[i]=array[i-1]+nextInt();
            return array;
        }
        public ArrayList<Integer>[] nextGraph(int n, int m){
            ArrayList<Integer>[] adj = new ArrayList[n];
            for(int i = 0; i < n; i++){
                adj[i] = new ArrayList<Integer>();
            }
            for(int i = 0; i < m; i++){
                int u = nextInt(); int v = nextInt();
                u--; v--;
                adj[u].add(v); adj[v].add(u);
            }
            return adj;
        }
        public ArrayList<Integer>[] nextTree(int n){
            return nextGraph(n, n-1);
        }

        public long[] nextLongArray(int n){
            long[] array=new long[n];
            for(int i=0;i<n;++i)array[i]=nextLong();
            return array;
        }
        public long[] nextSumLongArray(int n){
            long[] array=new long[n];
            array[0]=nextInt();
            for(int i=1;i<n;++i)array[i]=array[i-1]+nextInt();
            return array;
        }
        public long[] nextSortedLongArray(int n){
            long array[]=nextLongArray(n);
            Arrays.sort(array);
            return array;
        }
    }
}",5,1209_A,CODEFORCES,3583,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.lang.*;
import java.io.*;

public class Main
{
	PrintWriter out = new PrintWriter(System.out);
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer tok = new StringTokenizer("""");
    String next() throws IOException {
        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }
        return tok.nextToken();
    }
    int ni() throws IOException { return Integer.parseInt(next()); }
    long nl() throws IOException { return Long.parseLong(next()); }
  
    void solve() throws IOException {
        int n=ni();
        int[]A=new int[n];
        for (int x=0;x<n;x++) A[x]=ni();
        Arrays.sort(A);
        ArrayList<Integer>B=new ArrayList();
        B.add(A[0]);
        int ans=1;
        
        Outer:
        for (int x=1;x<n;x++) {
            for (int y=0;y<B.size();y++) {
                if (A[x]%B.get(y)==0) continue Outer;
            }
            ans++;
            B.add(A[x]);
        }
        System.out.println(ans);   
        
    }
    
    public static void main(String[] args) throws IOException {
        new Main().solve();
    }
}",5,1209_A,CODEFORCES,3594,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.BufferedReader;
import java.io.InputStreamReader;
 
import java.util.*;
 
 
// Warning: Printing unwanted or ill-formatted data to output will cause the test cases to fail
 
public class Ideone {
    public static void main(String args[] ) throws Exception{
       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       int n,i,j,k,temp ;
       n = ni(br.readLine());
       int[] a = nia(br);
       Arrays.sort(a);
       int c = 0;
       for( i = 0; i< n ; i++) {
    	   if(a[i] > 0) {
    		   c++;
    		   temp = a[i];
    		   for(j = i+1; j< n; j++) {
    			   if(a[j] % temp == 0)
    				    a[j] = 0;
    		   }
    	   }
       }
       
       
       System.out.println(c);
	
    }
    static Integer[] nIa(BufferedReader br) throws Exception{
        String sa[]=br.readLine().split("" "");
        Integer [] a = new Integer [sa.length];
        for(int i = 0; i< sa.length; i++){
            a[i]= ni(sa[i]);
        }
        return a;
   }
    static int[] nia(BufferedReader br) throws Exception{
        String sa[]=br.readLine().split("" "");
        int [] a = new int [sa.length];
        for(int i = 0; i< sa.length; i++){
            a[i]= ni(sa[i]);
        }
        return a;
   }
    
    static int ni(String s){
        return Integer.parseInt(s);
    }
    static float nf(String s){
        return Float.parseFloat(s);
    }
    static double nd(String s){
        return Double.parseDouble(s);
    }

  
}
",5,1209_A,CODEFORCES,3452,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.math.*;

public class Es1
{
    static IO io = new IO();
    public static void main(String[] args)
    {
		int n = io.getInt();
		int[] a = new int[n];
		for(int i=0; i<n; i++)
			a[i] = io.getInt();
		
		Arrays.sort(a);
		int[] color = new int[n];
		int num = 1;
		for(int i=0; i<n; i++){
			if(color[i]==0){
				for(int j=i+1; j<n; j++){
					if(a[j]%a[i]==0)
						color[j] = num;
				}
				num++;
			}
		}
		
		io.println(num-1);

		
		
		
        io.close();
    }
}



class IO extends PrintWriter {
	public IO() {
        super(new BufferedOutputStream(System.out));
        r = new BufferedReader(new InputStreamReader(System.in));
    }

    public IO(String fileName) {
        super(new BufferedOutputStream(System.out));
        try{
            r = new BufferedReader(new FileReader(fileName));
        } catch (FileNotFoundException e) {
            this.println(""File Not Found"");
        }
    }

    public boolean hasMoreTokens() {
        return peekToken() != null;
    }

    public int getInt() {
        return Integer.parseInt(nextToken());
    }

    public double getDouble() {
        return Double.parseDouble(nextToken());
    }

    public long getLong() {
        return Long.parseLong(nextToken());
    }

    public String getWord() {
        return nextToken();
    }

	public String getLine(){
        try{
            st = null;
            return r.readLine();
        }
        catch(IOException ex){}
        return null;
    }
	

    private BufferedReader r;
    private String line;
    private StringTokenizer st;
    private String token;

    private String peekToken() {
        if (token == null)
            try {
                while (st == null || !st.hasMoreTokens()) {
                    line = r.readLine();
                    if (line == null) return null;
                    st = new StringTokenizer(line);
                }
                token = st.nextToken();
            } catch (IOException e) { }
        return token;
    }

    private String nextToken() {
        String ans = peekToken();
        token = null;
        return ans;
    }
}
",5,1209_A,CODEFORCES,3489,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class a1 {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		int a[] = new int[n];
		HashMap<Integer,ArrayList<Integer>> h = new HashMap<>();
		boolean visited[] = new boolean[n];
		for(int i=0;i<n;i++)
		{
			a[i] = s.nextInt();
			
			
		}
		Arrays.sort(a);
		for(int i=0;i<n;i++) {
			if(h.containsKey(a[i])) {
							
							ArrayList<Integer> temp = h.get(a[i]);
							temp.add(i);
							h.put(a[i],temp);
						}
						else {
							ArrayList<Integer> k =new ArrayList<>();
							k.add(i);
							h.put(a[i], k);
						}
		}
		int ctr=0;
		for(int i=0;i<n;i++) {
			if(!visited[i]) {
				//System.out.println(a[i]);
				ctr++;
				for(int j=a[i];j<=100;j+=a[i]) {
					if(h.containsKey(j)) {
						ArrayList<Integer> m = h.get(j);
						for(int k=0;k<m.size();k++) {
							visited[m.get(k)]=true;
						}
						h.remove(j);
					}
				}
			}
		}
		System.out.println(ctr);
	}
}
",5,1209_A,CODEFORCES,3462,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;

import java.lang.reflect.Array;
import java.math.*;
import java.util.*;

public class icpc
{
    public static void main(String[] args) throws IOException
    {
        Reader in = new Reader();
//        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = in.nextInt();
        boolean[] A = new boolean[n];
        int count = 0;
        int[] B = new int[n];
        for (int i=0;i<n;i++)
            B[i] = in.nextInt();
        Arrays.sort(B);
        for (int i=0;i<n;i++)
        {
            if (!A[i])
            {
                int gcd = B[i];
                for (int j=0;j<n;j++)
                {
                    if(!A[j])
                    {
                        gcd = gcd(B[j], gcd);
                        if(gcd == B[i])
                        {
                            A[j] = true;
                        }
                        else
                        {
                            gcd = B[i];
                        }
                    }
                }
                count++;
                A[i] = true;
            }
        }
        System.out.println(count);
    }
    public static int gcd(int a, int b)
    {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
}
class DSU
{
    int[] parent;
    int[] size;
    //Pass number of total nodes as parameter to the constructor
    DSU(int n)
    {
        this.parent = new int[n];
        this.size = new int[n];
        Arrays.fill(parent, -1);
    }

    public void makeSet(int v)
    {
        parent[v] = v;
        size[v] = 1;
    }

    public int findSet(int v)
    {
        if (v == parent[v]) return v;
        return parent[v] = findSet(parent[v]);
    }

    public void unionSets(int a, int b)
    {
        a = findSet(a);
        b = findSet(b);
        if (a != b)
        {
            if (size[a] < size[b])
            {
                int temp = a;
                a = b;
                b = temp;
            }
            parent[b] = a;
            size[a] += size[b];
        }
    }
}
class FastFourierTransform
{
    private void fft(double[] a, double[] b, boolean invert)
    {
        int count = a.length;
        for (int i = 1, j = 0; i < count; i++)
        {
            int bit = count >> 1;
            for (; j >= bit; bit >>= 1)
                j -= bit;
            j += bit;
            if (i < j)
            {
                double temp = a[i];
                a[i] = a[j];
                a[j] = temp;
                temp = b[i];
                b[i] = b[j];
                b[j] = temp;
            }
        }
        for (int len = 2; len <= count; len <<= 1)
        {
            int halfLen = len >> 1;
            double angle = 2 * Math.PI / len;
            if (invert)
                angle = -angle;
            double wLenA = Math.cos(angle);
            double wLenB = Math.sin(angle);
            for (int i = 0; i < count; i += len)
            {
                double wA = 1;
                double wB = 0;
                for (int j = 0; j < halfLen; j++)
                {
                    double uA = a[i + j];
                    double uB = b[i + j];
                    double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;
                    double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;
                    a[i + j] = uA + vA;
                    b[i + j] = uB + vB;
                    a[i + j + halfLen] = uA - vA;
                    b[i + j + halfLen] = uB - vB;
                    double nextWA = wA * wLenA - wB * wLenB;
                    wB = wA * wLenB + wB * wLenA;
                    wA = nextWA;
                }
            }
        }
        if (invert)
        {
            for (int i = 0; i < count; i++)
            {
                a[i] /= count;
                b[i] /= count;
            }
        }
    }

    public long[] multiply(long[] a, long[] b)
    {
        int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) << 2;
        resultSize = Math.max(resultSize, 1);
        double[] aReal = new double[resultSize];
        double[] aImaginary = new double[resultSize];
        double[] bReal = new double[resultSize];
        double[] bImaginary = new double[resultSize];
        for (int i = 0; i < a.length; i++)
            aReal[i] = a[i];
        for (int i = 0; i < b.length; i++)
            bReal[i] = b[i];
        fft(aReal, aImaginary, false);
        fft(bReal, bImaginary, false);
        for (int i = 0; i < resultSize; i++)
        {
            double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];
            aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];
            aReal[i] = real;
        }
        fft(aReal, aImaginary, true);
        long[] result = new long[resultSize];
        for (int i = 0; i < resultSize; i++)
            result[i] = Math.round(aReal[i]);
        return result;
    }
}
class NumberTheory
{
    public boolean isPrime(long n)
    {
        if(n < 2)
            return false;
        for(long x = 2;x * x <= n;x++)
        {
            if(n % x == 0)
                return false;
        }
        return true;
    }
    public ArrayList<Long> primeFactorisation(long n)
    {
        ArrayList<Long> f = new ArrayList<>();
        for(long x=2;x * x <= n;x++)
        {
            while(n % x == 0)
            {
                f.add(x);
                n /= x;
            }
        }
        if(n > 1)
            f.add(n);
        return f;
    }
    public int[] sieveOfEratosthenes(int n)
    {
        //Returns an array with the smallest prime factor for each number and primes marked as 0
        int[] sieve = new int[n + 1];
        for(int x=2;x * x <= n;x++)
        {
            if(sieve[x] != 0)
                continue;
            for(int u=x*x;u<=n;u+=x)
            {
                if(sieve[u] == 0)
                {
                    sieve[u] = x;
                }
            }
        }
        return sieve;
    }
    public long gcd(long a, long b)
    {
        if(b == 0)
            return a;
        return gcd(b, a % b);
    }
    public long phi(long n)
    {
        double result = n;

        for(long p=2;p*p<=n;p++)
        {
            if(n % p == 0)
            {
                while (n % p == 0)
                    n /= p;
                result *= (1.0 - (1.0 / (double)p));
            }
        }
        if(n > 1)
            result *= (1.0 - (1.0 / (double)n));
        return (long)result;
    }
    public Name extendedEuclid(long a, long b)
    {
        if(b == 0)
            return new Name(a, 1, 0);
        Name n1 = extendedEuclid(b, a % b);
        Name n2 = new Name(n1.d, n1.y, n1.x - (long)Math.floor((double)a / b) * n1.y);
        return n2;
    }
    public long modularExponentiation(long a, long b, long n)
    {
        long d = 1L;
        String bString = Long.toBinaryString(b);
        for(int i=0;i<bString.length();i++)
        {
            d = (d * d) % n;
            if(bString.charAt(i) == '1')
                d = (d * a) % n;
        }
        return d;
    }
}
class Name
{
    long d;
    long x;
    long y;

    public Name(long d, long x, long y)
    {
        this.d = d;
        this.x = x;
        this.y = y;
    }
}
class SuffixArray
{
    int ALPHABET_SZ = 256, N;
    int[] T, lcp, sa, sa2, rank, tmp, c;

    public SuffixArray(String str)
    {
        this(toIntArray(str));
    }

    private static int[] toIntArray(String s)
    {
        int[] text = new int[s.length()];
        for (int i = 0; i < s.length(); i++) text[i] = s.charAt(i);
        return text;
    }

    public SuffixArray(int[] text)
    {
        T = text;
        N = text.length;
        sa = new int[N];
        sa2 = new int[N];
        rank = new int[N];
        c = new int[Math.max(ALPHABET_SZ, N)];
        construct();
        kasai();
    }

    private void construct()
    {
        int i, p, r;
        for (i = 0; i < N; ++i) c[rank[i] = T[i]]++;
        for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];
        for (i = N - 1; i >= 0; --i) sa[--c[T[i]]] = i;
        for (p = 1; p < N; p <<= 1)
        {
            for (r = 0, i = N - p; i < N; ++i) sa2[r++] = i;
            for (i = 0; i < N; ++i) if (sa[i] >= p) sa2[r++] = sa[i] - p;
            Arrays.fill(c, 0, ALPHABET_SZ, 0);
            for (i = 0; i < N; ++i) c[rank[i]]++;
            for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];
            for (i = N - 1; i >= 0; --i) sa[--c[rank[sa2[i]]]] = sa2[i];
            for (sa2[sa[0]] = r = 0, i = 1; i < N; ++i)
            {
                if (!(rank[sa[i - 1]] == rank[sa[i]]
                        && sa[i - 1] + p < N
                        && sa[i] + p < N
                        && rank[sa[i - 1] + p] == rank[sa[i] + p])) r++;
                sa2[sa[i]] = r;
            }
            tmp = rank;
            rank = sa2;
            sa2 = tmp;
            if (r == N - 1) break;
            ALPHABET_SZ = r + 1;
        }
    }

    private void kasai()
    {
        lcp = new int[N];
        int[] inv = new int[N];
        for (int i = 0; i < N; i++) inv[sa[i]] = i;
        for (int i = 0, len = 0; i < N; i++)
        {
            if (inv[i] > 0)
            {
                int k = sa[inv[i] - 1];
                while ((i + len < N) && (k + len < N) && T[i + len] == T[k + len]) len++;
                lcp[inv[i] - 1] = len;
                if (len > 0) len--;
            }
        }
    }
}
class ZAlgorithm
{
    public int[] calculateZ(char input[])
    {
        int Z[] = new int[input.length];
        int left = 0;
        int right = 0;
        for(int k = 1; k < input.length; k++) {
            if(k > right) {
                left = right = k;
                while(right < input.length && input[right] == input[right - left]) {
                    right++;
                }
                Z[k] = right - left;
                right--;
            } else {
                //we are operating inside box
                int k1 = k - left;
                //if value does not stretches till right bound then just copy it.
                if(Z[k1] < right - k + 1) {
                    Z[k] = Z[k1];
                } else { //otherwise try to see if there are more matches.
                    left = k;
                    while(right < input.length && input[right] == input[right - left]) {
                        right++;
                    }
                    Z[k] = right - left;
                    right--;
                }
            }
        }
        return Z;
    }
    public ArrayList<Integer> matchPattern(char text[], char pattern[])
    {
        char newString[] = new char[text.length + pattern.length + 1];
        int i = 0;
        for(char ch : pattern) {
            newString[i] = ch;
            i++;
        }
        newString[i] = '$';
        i++;
        for(char ch : text) {
            newString[i] = ch;
            i++;
        }
        ArrayList<Integer> result = new ArrayList<>();
        int Z[] = calculateZ(newString);

        for(i = 0; i < Z.length ; i++) {
            if(Z[i] == pattern.length) {
                result.add(i - pattern.length - 1);
            }
        }
        return result;
    }
}
class KMPAlgorithm
{
    public int[] computeTemporalArray(char[] pattern)
    {
        int[] lps = new int[pattern.length];

        int index = 0;
        for(int i=1;i<pattern.length;)
        {
            if(pattern[i] == pattern[index])
            {
                lps[i] = index + 1;
                index++;
                i++;
            }
            else
            {
                if(index != 0)
                {
                    index = lps[index - 1];
                }
                else
                {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    public ArrayList<Integer> KMPMatcher(char[] text, char[] pattern)
    {
        int[] lps = computeTemporalArray(pattern);

        int j = 0;
        int i = 0;
        int n = text.length;
        int m = pattern.length;
        ArrayList<Integer> indices = new ArrayList<>();
        while(i < n)
        {
            if(pattern[j] == text[i])
            {
                i++;
                j++;
            }
            if(j == m)
            {
                indices.add(i - j);
                j = lps[j - 1];
            }
            else if(i < n && pattern[j] != text[i])
            {
                if(j != 0)
                    j = lps[j - 1];
                else
                    i = i + 1;
            }
        }
        return indices;
    }
}
class Hashing
{
    public long[] computePowers(long p, int n, long m)
    {
        long[] powers = new long[n];
        powers[0] = 1;
        for(int i=1;i<n;i++)
        {
            powers[i] = (powers[i - 1] * p) % m;
        }
        return powers;
    }
    public long computeHash(String s)
    {
        long p = 31;
        long m = 1_000_000_009;
        long hashValue = 0L;
        long[] powers = computePowers(p, s.length(), m);
        for(int i=0;i<s.length();i++)
        {
            char ch = s.charAt(i);
            hashValue = (hashValue + (ch - 'a' + 1) * powers[i]) % m;
        }
        return hashValue;
    }
}
class BasicFunctions
{
    public long min(long[] A)
    {
        long min = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            min = Math.min(min, A[i]);
        }
        return min;
    }
    public long max(long[] A)
    {
        long max = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            max = Math.max(max, A[i]);
        }
        return max;
    }
}
class MergeSortInt
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

}
class MergeSortLong
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(long arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        long L[] = new long[n1];
        long R[] = new long[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(long arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }
}
class Node
{
    String s;
    Node(String s)
    {
        this.s = s;
    }

    @Override
    public boolean equals(Object ob)
    {
        if(ob == null)
            return false;
        if(!(ob instanceof Node))
            return false;
        if(ob == this)
            return true;
        Node obj = (Node)ob;
        if(this.s.equals(obj.s))
            return true;
        return false;
    }

    @Override
    public int hashCode()
    {
        return (int)this.s.length();
    }
}
class Reader
{
    final private int BUFFER_SIZE = 1 << 16;
    private DataInputStream din;
    private byte[] buffer;
    private int bufferPointer, bytesRead;

    public Reader()
    {
        din = new DataInputStream(System.in);
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public Reader(String file_name) throws IOException
    {
        din = new DataInputStream(new FileInputStream(file_name));
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public String readLine() throws IOException
    {
        byte[] buf = new byte[64]; // line length
        int cnt = 0, c;
        while ((c = read()) != -1)
        {
            if (c == '\n')
                break;
            buf[cnt++] = (byte) c;
        }
        return new String(buf, 0, cnt);
    }

    public int nextInt() throws IOException
    {
        int ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do
        {
            ret = ret * 10 + c - '0';
        }  while ((c = read()) >= '0' && c <= '9');

        if (neg)
            return -ret;
        return ret;
    }

    public long nextLong() throws IOException
    {
        long ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');
        if (neg)
            return -ret;
        return ret;
    }

    public double nextDouble() throws IOException
    {
        double ret = 0, div = 1;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();

        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');

        if (c == '.')
        {
            while ((c = read()) >= '0' && c <= '9')
            {
                ret += (c - '0') / (div *= 10);
            }
        }

        if (neg)
            return -ret;
        return ret;
    }

    private void fillBuffer() throws IOException
    {
        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
        if (bytesRead == -1)
            buffer[0] = -1;
    }

    private byte read() throws IOException
    {
        if (bufferPointer == bytesRead)
            fillBuffer();
        return buffer[bufferPointer++];
    }

    public void close() throws IOException
    {
        if (din == null)
            return;
        din.close();
    }
}
class FenwickTree
{
    public void update(long[] fenwickTree,long delta,int index)
    {
        index += 1;
        while(index < fenwickTree.length)
        {
            fenwickTree[index] += delta;
            index = index + (index & (-index));
        }
    }
    public long prefixSum(long[] fenwickTree,int index)
    {
        long sum = 0L;
        index += 1;
        while(index > 0)
        {
            sum += fenwickTree[index];
            index -= (index & (-index));
        }
        return sum;
    }
}
class SegmentTree
{
    public int nextPowerOfTwo(int num)
    {
        if(num == 0)
            return 1;
        if(num > 0 && (num & (num - 1)) == 0)
            return num;
        while((num &(num - 1)) > 0)
        {
            num = num & (num - 1);
        }
        return num << 1;
    }
    public int[] createSegmentTree(int[] input)
    {
        int np2 = nextPowerOfTwo(input.length);
        int[] segmentTree = new int[np2 * 2 - 1];

        for(int i=0;i<segmentTree.length;i++)
            segmentTree[i] = Integer.MIN_VALUE;

        constructSegmentTree(segmentTree,input,0,input.length-1,0);
        return segmentTree;

    }
    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)
    {
        if(low == high)
        {
            segmentTree[pos] = input[low];
            return;
        }
        int mid = (low + high)/ 2;
        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);
        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);
        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);
    }
    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)
    {
        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);
    }
    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)
    {
        if(qlow <= low && qhigh >= high){
            return segmentTree[pos];
        }
        if(qlow > high || qhigh < low){
            return Integer.MIN_VALUE;
        }
        int mid = (low+high)/2;
        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),
                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));
    }
}
class Trie
{

    private class TrieNode
    {
        Map<Character, TrieNode> children;
        boolean endOfWord;
        public TrieNode()
        {
            children = new HashMap<>();
            endOfWord = false;
        }
    }

    private final TrieNode root;
    public Trie()
    {
        root = new TrieNode();
    }

    public void insert(String word)
    {
        TrieNode current = root;
        for (int i = 0; i < word.length(); i++)
        {
            char ch = word.charAt(i);
            TrieNode node = current.children.get(ch);
            if (node == null)
            {
                node = new TrieNode();
                current.children.put(ch, node);
            }
            current = node;
        }
        current.endOfWord = true;
    }

    public boolean search(String word)
    {
        TrieNode current = root;
        for (int i = 0; i < word.length(); i++)
        {
            char ch = word.charAt(i);
            TrieNode node = current.children.get(ch);
            if (node == null)
            {
                return false;
            }
            current = node;
        }
        return current.endOfWord;
    }

    public void delete(String word)
    {
        delete(root, word, 0);
    }

    private boolean delete(TrieNode current, String word, int index)
    {
        if (index == word.length())
        {
            if (!current.endOfWord)
            {
                return false;
            }
            current.endOfWord = false;
            return current.children.size() == 0;
        }
        char ch = word.charAt(index);
        TrieNode node = current.children.get(ch);
        if (node == null)
        {
            return false;
        }
        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);

        if (shouldDeleteCurrentNode)
        {
            current.children.remove(ch);
            return current.children.size() == 0;
        }
        return false;
    }
}
class SegmentTreeLazy
{
    public int nextPowerOfTwo(int num)
    {
        if(num == 0)
            return 1;
        if(num > 0 && (num & (num - 1)) == 0)
            return num;
        while((num &(num - 1)) > 0)
        {
            num = num & (num - 1);
        }
        return num << 1;
    }

    public int[] createSegmentTree(int input[])
    {
        int nextPowOfTwo = nextPowerOfTwo(input.length);
        int segmentTree[] = new int[nextPowOfTwo*2 -1];

        for(int i=0; i < segmentTree.length; i++){
            segmentTree[i] = Integer.MAX_VALUE;
        }
        constructMinSegmentTree(segmentTree, input, 0, input.length - 1, 0);
        return segmentTree;
    }

    private void constructMinSegmentTree(int segmentTree[], int input[], int low, int high,int pos)
    {
        if(low == high)
        {
            segmentTree[pos] = input[low];
            return;
        }
        int mid = (low + high)/2;
        constructMinSegmentTree(segmentTree, input, low, mid, 2 * pos + 1);
        constructMinSegmentTree(segmentTree, input, mid + 1, high, 2 * pos + 2);
        segmentTree[pos] = Math.min(segmentTree[2*pos+1], segmentTree[2*pos+2]);
    }

    public void updateSegmentTreeRangeLazy(int input[], int segmentTree[], int lazy[], int startRange, int endRange, int delta)
    {
        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, 0, input.length - 1, 0);
    }

    private void updateSegmentTreeRangeLazy(int segmentTree[], int lazy[], int startRange, int endRange, int delta, int low, int high, int pos)
    {
        if(low > high)
        {
            return;
        }
        if (lazy[pos] != 0)
        {
            segmentTree[pos] += lazy[pos];
            if (low != high)
            {
                lazy[2 * pos + 1] += lazy[pos];
                lazy[2 * pos + 2] += lazy[pos];
            }
            lazy[pos] = 0;
        }

        if(startRange > high || endRange < low)
        {
            return;
        }

        if(startRange <= low && endRange >= high)
        {
            segmentTree[pos] += delta;
            if(low != high) {
                lazy[2*pos + 1] += delta;
                lazy[2*pos + 2] += delta;
            }
            return;
        }

        int mid = (low + high)/2;
        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, low, mid, 2*pos+1);
        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, mid+1, high, 2*pos+2);
        segmentTree[pos] = Math.min(segmentTree[2*pos + 1], segmentTree[2*pos + 2]);
    }

    public int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int len)
    {
        return rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, 0, len - 1, 0);
    }

    private int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int low, int high, int pos)
    {
        if(low > high)
        {
            return Integer.MAX_VALUE;
        }
        if (lazy[pos] != 0)
        {
            segmentTree[pos] += lazy[pos];
            if (low != high)
            {
                lazy[2 * pos + 1] += lazy[pos];
                lazy[2 * pos + 2] += lazy[pos];
            }
            lazy[pos] = 0;
        }

        if(qlow > high || qhigh < low)
        {
            return Integer.MAX_VALUE;
        }

        if(qlow <= low && qhigh >= high)
        {
            return segmentTree[pos];
        }

        int mid = (low+high)/2;
        return Math.min(rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, low, mid, 2 * pos + 1), rangeMinimumQueryLazy(segmentTree, lazy,  qlow, qhigh, mid + 1, high, 2 * pos + 2));
    }
}
",5,1209_A,CODEFORCES,3547,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;

public class Main {

	static Scanner console;
	public static void main(String[] args) {
		console = new Scanner(System.in);
		int n = console.nextInt();
		List<Integer> arr= new ArrayList<>();		
		for(int i = 0; i < n; i++) arr.add( console.nextInt());
		Collections.sort(arr);
		List<Integer> groups = new ArrayList<>();
//		System.out.println(arr);
		for(int i = 0; i < arr.size() - 1; i++) {
			int j = i+1;
			groups.add(arr.get(i));
//			System.out.println(groups);
			while(j < arr.size()) {
//				System.out.println(j);
				if(arr.get(j) % arr.get(i) == 0) {
					arr.remove(j);
					
				}
				else {
//					groups.add(arr.get(j));
					j++;
				}
			}
		}
//		System.out.println(arr);
		System.out.println(arr.size());
	}
}
",5,1209_A,CODEFORCES,3451,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class Main {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] colors = new int[n];
        for (int i = 0; i < n; i++) {
            colors[i] = scanner.nextInt();
        }
        Arrays.sort(colors);
        int amountOfColors = 0;
        for (int i = 0; i < n; i++) {
            if (colors[i] != 0){
                amountOfColors++;
                int color = colors[i];
                for (int j = i; j < n; j++) {
                    if (colors[j] % color == 0){
                        colors[j] = 0;
                    }
                }
            }
        }
        System.out.println(amountOfColors);
    }
}",5,1209_A,CODEFORCES,3495,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
  
public class A1 {   
 
	public static BufferedReader br;
    public static StringTokenizer st;
    public static String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }
 
    public static Integer nextInt() {
        return Integer.parseInt(next());
    }
 
    public static Long nextLong() {
        return Long.parseLong(next());
    }
 
    public static Double nextDouble() {
        return Double.parseDouble(next());
    }
 
    static long fast_pow(long base,long n,long M)
    {
        if(n==0)
           return 1;
        if(n==1)
        return base;
        long halfn=fast_pow(base,n/2,M);
        if(n%2==0)
            return ( halfn * halfn ) % M;
        else
            return ( ( ( halfn * halfn ) % M ) * base ) % M;
    }
 
    static long finextDoubleMMI_fermat(long n,int M)
    {
        return fast_pow(n,M-2,M);
    }
 
    static long nCrModPFermat(int n, int r, int p) 
    { 
        if (r == 0) 
            return 1; 
        long[] fac = new long[n+1]; 
        fac[0] = 1;           
        for (int i = 1 ;i <= n; i++) 
            fac[i] = fac[i-1] * i % p;       
        return (fac[n]* finextDoubleMMI_fermat(fac[r], p)% p * finextDoubleMMI_fermat(fac[n-r], p) % p) % p; 
    } 
 
    static void merge(int arr[], int l, int m, int r) 
    { 
        int n1 = m - l + 1; 
        int n2 = r - m; 
  
        int L[] = new int [n1]; 
        int R[] = new int [n2]; 
  
        for (int i=0; i<n1; ++i) 
            L[i] = arr[l + i]; 
        for (int j=0; j<n2; ++j) 
            R[j] = arr[m + 1+ j]; 
        int i = 0, j = 0; 
        
        int k = l; 
        while (i < n1 && j < n2) 
        { 
            if (L[i] <= R[j]) 
            { 
                arr[k] = L[i]; 
                i++; 
            } 
            else
            { 
                arr[k] = R[j]; 
                j++; 
            } 
            k++; 
        } 
  
        while (i < n1) 
        { 
            arr[k] = L[i]; 
            i++; 
            k++; 
        } 
  
        while (j < n2) 
        { 
            arr[k] = R[j]; 
            j++; 
            k++; 
        } 
    } 
  
    static void sort(int arr[], int l, int r) 
    { 
        if (l < r) 
        { 
            int m = (l+r)/2; 
            sort(arr, l, m); 
            sort(arr , m+1, r); 
            merge(arr, l, m, r); 
        } 
    } 
 
    static void sort(int arr[]) 
    { 
        int l=0;
        int r=arr.length-1;
        if (l < r) 
        { 
            int m = (l+r)/2; 
            sort(arr, l, m); 
            sort(arr , m+1, r); 
            merge(arr, l, m, r); 
        } 
    } 

    static long gcd(long a, long b){
        if(a%b==0)
            return b;
        if(b%a==0)
            return a;
        if(a>b)
            return gcd(a%b,b);
        return gcd(a,b%a);
    }
 
    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 
    public static void main(String args[])throws IOException{
    	int i,j;
        br = new BufferedReader(new InputStreamReader(System.in));
        int n=nextInt();
        int a[]=new int[n];
        for(i=0;i<n;i++)
            a[i]=nextInt();
        Arrays.sort(a);
        int l=0;
        for(i=0;i<n;i++){
            if(a[i]!=-1){
                int p=a[i];
                for(j=i;j<n;j++){
                    if(a[j]%p==0)
                        a[j]=-1;
                }
                l++;
            }
        }
        pw.println(l);
        pw.close();
    }
}	




",5,1209_A,CODEFORCES,3572,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Arrays;

public class a{
    public static void main(String[] args)throws IOException{
	br = new BufferedReader(new InputStreamReader(System.in));
	PrintWriter out = new PrintWriter(System.out);
	int n = nextInt();
	int v[] = new int[n];
	int fv[] = new int[101];
	for(int i = 0; i<n;i++){
	    v[i] = nextInt();
	}
	Arrays.sort(v);
	for(int i = 0; i<n;i++){
	    for(int j = i; j<n;j++){
		if(v[j]%v[i]==0){
		    v[j] = v[i];
		    fv[v[j]]++;
		}
	    }
	}
	int ans = 0;
	for(int i = 0; i<101;i++){
	    if(fv[i]!=0){
		ans++;
	    }
	}
	out.println(ans);
	out.close();
    }

    static BufferedReader br;
    static StringTokenizer st = new StringTokenizer("""");

    static String next()throws IOException{
	while(!st.hasMoreTokens()){
	    st = new StringTokenizer(br.readLine());
	}
	return st.nextToken();
    }
    static int nextInt()throws IOException{
	return Integer.parseInt(next());
    }
    
}
",5,1209_A,CODEFORCES,3507,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class mainA {
    public static PrintWriter out = new PrintWriter(System.out);
    public static FastScanner enter = new FastScanner(System.in);
    public static void main(String[] args) throws IOException {
        solve();
        out.close();
    }
    public static boolean[] was;
    private static void solve() throws IOException{
        int n=enter.nextInt();
        int[] arr=new int[n];
        was=new boolean[n];
        for (int i = 0; i <n ; i++) {
            arr[i]=enter.nextInt();
        }
        Arrays.sort(arr);
        int ans=0;
        for (int i = 0; i <n ; i++) {
            if(was[i]) continue;
            find(i, arr);
            ans++;
        }
        out.println(ans);
    }

    public static void find (int num, int[] arr){
        for (int i = num+1; i <arr.length ; i++) {
            if(arr[i]%arr[num]==0) was[i]=true;
        }
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer stok;

        FastScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        String next() throws IOException {
            while (stok == null || !stok.hasMoreTokens()) {
                String s = br.readLine();
                if (s == null) {
                    return null;
                }
                stok = new StringTokenizer(s);
            }
            return stok.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        char nextChar() throws IOException {
            return (char) (br.read());
        }

        String nextLine() throws IOException {
            return br.readLine();
        }
    }
}
",5,1209_A,CODEFORCES,3502,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.io.*;
import java.util.*;
import java.lang.*;
import static java.lang.Math.*;

public class TaskA implements Runnable {
    long m = (int) 1e9 + 7;
    PrintWriter w;
    InputReader c;
    /*Global Variables*/

    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);
        int n = c.nextInt();
        int a[] = scanArrayI(n);
        boolean vis[] = new boolean[n];
        Arrays.sort(a);
        int ans=0;
        for(int i=0;i<n;i++){
            if(vis[i]) continue;
            vis[i] = true;
            for(int j=i+1;j<n;j++){
                if(a[j]%a[i] == 0){
                    vis[j] = true;
                }
            }
            ans++;
            boolean check = false;
            for(int j=0;j<n;j++){
                if(!vis[j]) check = true;
            }
            if(!check) break;
        }

        w.println(ans);

        w.close();
    }

    class pair{
        int x,y,step;

        @Override
        public String toString() {
            return ""pair{"" +
                    ""x="" + x +
                    "", y="" + y +
                    "", step="" + step +
                    '}';
        }

        public pair(int x, int y, int s) {
            this.x = x;
            this.y = y;
            step = s;
        }
    }
    /*Template Stuff*/
    class HashMapUtil<T, U> {
        void addHash(HashMap<T, Integer> hm, T a) {
            if (hm.containsKey(a)) hm.put(a, hm.get(a) + 1);
            else hm.put(a, 1);
        }

        void iterateHashMap(HashMap<T, U> hm) {
            for (Map.Entry<T, U> e : hm.entrySet()) {
                T key = e.getKey();
                U value = e.getValue();
            }
        }
    }
    public int search(int input[], int search) {
        int low = 0;
        int high = input.length - 1;
        int mid;
        while (low <= high) {
            mid = low + ((high - low) / 2);
            if (input[mid] == search) {
                return mid;
            } else if (input[mid] < search) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }
    public void sort(int arr[]) {
        int n = arr.length, mid, h, s, l, i, j, k;
        int[] res = new int[n];
        for (s = 1; s < n; s <<= 1) {
            for (l = 0; l < n - 1; l += (s << 1)) {
                h = min(l + (s << 1) - 1, n - 1);
                mid = min(l + s - 1, n - 1);
                i = l;
                j = mid + 1;
                k = l;
                while (i <= mid && j <= h) res[k++] = (arr[i] <= arr[j] ? arr[i++] : arr[j++]);
                while (i <= mid) res[k++] = arr[i++];
                while (j <= h) res[k++] = arr[j++];
                for (k = l; k <= h; k++) arr[k] = res[k];
            }
        }
    }
    public int nextPowerOf2(int num) {
        if (num == 0) {
            return 1;
        }
        if (num > 0 && (num & (num - 1)) == 0) {
            return num;
        }
        while ((num & (num - 1)) > 0) {
            num = num & (num - 1);
        }
        return num << 1;
    }
    static long gcd(long a, long b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static void sortbyColumn(int arr[][], int col) {
        Arrays.sort(arr, new Comparator<int[]>() {
            public int compare(int[] o1, int[] o2) {
                return (Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    public void printArray(int[] a) {
        for (int i = 0; i < a.length; i++)
            w.print(a[i] + "" "");
        w.println();
    }
    public int[] scanArrayI(int n) {
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n) {
        long a[] = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a) {
        for (int i = 0; i < a.length; i++)
            w.print(a[i] + "" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskA(), ""TaskA"", 1 << 26).start();
    }
}",5,1209_A,CODEFORCES,3476,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
public class A {
    public static void main(String[] args) throws Exception {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(bf.readLine());
        StringTokenizer st = new StringTokenizer(bf.readLine());
        int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());

        int counter = 0;
        TreeSet<Integer> val = new TreeSet<Integer>();
        for(int i : a) val.add(i);
        while(!val.isEmpty()) {
          int min = val.first();
          Set<Integer> toRemove = new HashSet<Integer>();
          for(int i : val) if(i % min == 0) toRemove.add(i);
          for(int i : toRemove) val.remove(i);
          counter++;
        }
        out.println(counter);
        // int n = Integer.parseInt(st.nextToken());

        out.close(); System.exit(0);
    }
}
",5,1209_A,CODEFORCES,3533,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
public class Main
{
	public static void main(String[] args) throws Exception
	{
	    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	    int n=Integer.parseInt(br.readLine());
	    String s=br.readLine();
	    String ss[]=s.split("" "");
	    int arr[]=new int[n];
	    for(int i=0;i<n;i++)
	    arr[i]=Integer.parseInt(ss[i]);
	    Arrays.sort(arr);
	    int coun=0,coun2=0;
	    for(int i=arr[0],k=0;k<n;)
	    {
	        for(int j=k;j<n;j++)
	        {
	            if(arr[j]%i==0)
	            {
	                arr[j]=-1;
	                coun2++;
	            }
	        }
	        Arrays.sort(arr);
	        k=coun2;
	        coun++;
	        if(coun2<n)
	        i=arr[coun2];
	        else
	        break;
	        
	    }
		System.out.println(coun);
	}
}
",5,1209_A,CODEFORCES,3449,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
import java.io.*;
 
public class Main{
	
	public static void main (String[] args) {
		Scanner scan = new Scanner(System.in);
		
		int n = scan.nextInt(), min[] = new int[n];
		boolean used[] = new boolean[n];
		HashSet<Integer> set = new HashSet<>();
		
		
		for (int i = 0; i < n; i++) {
			min[i] = scan.nextInt();
		}
		
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
					if (min[i] > min[j]) {
						if (min[i] % min[j] == 0)
							min[i] = min[j];
					}
					else if (min[j] % min[i] == 0)
							min[j] = min[i];
				}
		}
		
		for (int i = 0; i < n; i++) {
			set.add(min[i]);
		}
		
		System.out.print(set.size());
	}
}",5,1209_A,CODEFORCES,3531,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"// Working program using Reader Class 
import java.io.DataInputStream; 
import java.io.FileInputStream; 
import java.io.IOException; 
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 

public class Main1 
{ 
	static class Reader 
	{ 
		final private int BUFFER_SIZE = 1 << 16; 
		private DataInputStream din; 
		private byte[] buffer; 
		private int bufferPointer, bytesRead; 

		public Reader() 
		{ 
			din = new DataInputStream(System.in); 
			buffer = new byte[BUFFER_SIZE]; 
			bufferPointer = bytesRead = 0; 
		} 

		public Reader(String file_name) throws IOException 
		{ 
			din = new DataInputStream(new FileInputStream(file_name)); 
			buffer = new byte[BUFFER_SIZE]; 
			bufferPointer = bytesRead = 0; 
		} 

		public String readLine() throws IOException 
		{ 
			byte[] buf = new byte[64]; // line length 
			int cnt = 0, c; 
			while ((c = read()) != -1) 
			{ 
				if (c == '\n') 
					break; 
				buf[cnt++] = (byte) c; 
			} 
			return new String(buf, 0, cnt); 
		} 

		public int nextInt() throws IOException 
		{ 
			int ret = 0; 
			byte c = read(); 
			while (c <= ' ') 
				c = read(); 
			boolean neg = (c == '-'); 
			if (neg) 
				c = read(); 
			do
			{ 
				ret = ret * 10 + c - '0'; 
			} while ((c = read()) >= '0' && c <= '9'); 

			if (neg) 
				return -ret; 
			return ret; 
		} 

		public long nextLong() throws IOException 
		{ 
			long ret = 0; 
			byte c = read(); 
			while (c <= ' ') 
				c = read(); 
			boolean neg = (c == '-'); 
			if (neg) 
				c = read(); 
			do { 
				ret = ret * 10 + c - '0'; 
			} 
			while ((c = read()) >= '0' && c <= '9'); 
			if (neg) 
				return -ret; 
			return ret; 
		} 

		public double nextDouble() throws IOException 
		{ 
			double ret = 0, div = 1; 
			byte c = read(); 
			while (c <= ' ') 
				c = read(); 
			boolean neg = (c == '-'); 
			if (neg) 
				c = read(); 

			do { 
				ret = ret * 10 + c - '0'; 
			} 
			while ((c = read()) >= '0' && c <= '9'); 

			if (c == '.') 
			{ 
				while ((c = read()) >= '0' && c <= '9') 
				{ 
					ret += (c - '0') / (div *= 10); 
				} 
			} 

			if (neg) 
				return -ret; 
			return ret; 
		} 

		private void fillBuffer() throws IOException 
		{ 
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
			if (bytesRead == -1) 
				buffer[0] = -1; 
		} 

		private byte read() throws IOException 
		{ 
			if (bufferPointer == bytesRead) 
				fillBuffer(); 
			return buffer[bufferPointer++]; 
		} 

		public void close() throws IOException 
		{ 
			if (din == null) 
				return; 
			din.close(); 
		} 
	} 

	public static void main(String[] args) throws IOException 
	{ 
		Reader s=new Reader(); 
		int n = s.nextInt(), i, j, ans=0;
		int[] a = new int[101];
		for(i=0;i<n;i++){
			a[s.nextInt()]++;
		}
		for(i=1;i<=100;i++){
			if(a[i]>0){
				ans++;
				for(j=i;j<=100;j++){
					if(j%i==0){
						a[j]=0;
					}
				}
			}
		}
		System.out.println(ans);
	} 
} 
",5,1209_A,CODEFORCES,3593,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;


public class Main {

    static StringBuilder data = new StringBuilder();
    final static FastReader in = new FastReader();


    public static void main(String[] args) {
        int n = in.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        Arrays.sort(a);
        int answ = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] != 0) {
                for (int j = i + 1; j < n; j++) {
                    if (a[j] % a[i] == 0) {
                        a[j] = 0;
                    }
                }
                answ++;
                a[i]=0;
            }
        }
        System.out.println(answ);
    }


    static void fileOut(String s) {
        File out = new File(""output.txt"");
        try {
            FileWriter fw = new FileWriter(out);
            fw.write(s);
            fw.flush();
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public FastReader(String path) {
            try {
                br = new BufferedReader(new
                        InputStreamReader(new FileInputStream(path)));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        float nextFloat() {
            return Float.parseFloat(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }


        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",5,1209_A,CODEFORCES,3482,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class code_1 {

	public static void main(String[] args) {
		
		Scanner in=new Scanner(System.in);
		
		int n=in.nextInt();
		
		int a[]=new int[n];
		
		for(int i=0;i<n;i++)
			a[i]=in.nextInt();
		
		Arrays.sort(a);
		
		for(int i=0;i<n-1;i++) {
			
			if(a[i]!=-1) {
				for(int j=i+1;j<n;j++) {
					
					if(a[j]%a[i]==0)
						a[j]=-1;
				}
			}	
		}
		
		int count=0;
		
		for(int i=0;i<n;i++) {
			
			if(a[i]!=-1)
				count++;
		}
		
		System.out.println(count);

	}

}
",5,1209_A,CODEFORCES,3571,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] ar = new int[n];
            for (int i = 0; i < n; i++)
                ar[i] = in.nextInt();
            Arrays.sort(ar);
            boolean[] u = new boolean[n];
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (!u[i]) {
                    u[i] = true;
                    ans++;
                    for (int j = 0; j < n; j++) {
                        if (!u[j] && ar[j] % ar[i] == 0) {
                            u[j] = true;
                        }
                    }
                }
            }
            out.println(ans);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",5,1209_A,CODEFORCES,3530,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Scanner;


public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int min;
        int count = 0;
        int c = 0;
        while (count != n) {
            min = 1000;
            for (int i = 0; i < n; i++) {
                if (a[i] < min) {
                    min = a[i];
                }
            }
            for (int i = 0; i < n; i++) {
                if (a[i] != 1000 && a[i] % min == 0) {
                    count++;
                    a[i] = 1000;
                }
            }
            c++;
        }
        System.out.println(c);
    }
}",5,1209_A,CODEFORCES,3490,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Asgar Javadov
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            int[] a = in.readIntArray(n);

            ArrayUtils.radixSort(a);

            int answer = 0;
            boolean[] used = new boolean[a.length];
            for (int i = 0; i < a.length; ++i) {
                if (used[i]) continue;

                used[i] = true;
                answer++;
                for (int j = i + 1; j < a.length; ++j)
                    if (a[j] % a[i] == 0)
                        used[j] = true;
            }

            out.println(answer);
        }

    }

    static class ArrayUtils {
        public static void radixSort(int[] array) {
            int[] ordered = new int[array.length];
            {
                int[] freq = new int[0xFFFF + 2];
                for (int i = 0; i < array.length; ++i) freq[(array[i] & 0xFFFF) + 1]++;
                for (int i = 1; i < freq.length; ++i) freq[i] += freq[i - 1];

                for (int i = 0; i < array.length; ++i)
                    ordered[freq[array[i] & 0xFFFF]++] = array[i];
                for (int i = 0; i < array.length; ++i)
                    array[i] = ordered[i];
            }
            {
                int[] freq = new int[0xFFFF + 2];
                for (int i = 0; i < array.length; ++i) freq[(array[i] >>> 16) + 1]++;
                for (int i = 1; i < freq.length; ++i) freq[i] += freq[i - 1];

                for (int i = 0; i < array.length; ++i)
                    ordered[freq[array[i] >>> 16]++] = array[i];

                int indexOfFirstNegative = freq[0x7FFF];
                int index = 0;
                for (int i = indexOfFirstNegative; i < ordered.length; ++i, ++index)
                    array[index] = ordered[i];
                for (int i = 0; i < indexOfFirstNegative; ++i, ++index)
                    array[index] = ordered[i];
            }
        }

    }

    static class OutputWriter extends PrintWriter {
        public OutputWriter(OutputStream outputStream) {
            super(outputStream);
        }

        public OutputWriter(Writer writer) {
            super(writer);
        }

        public OutputWriter(String filename) throws FileNotFoundException {
            super(filename);
        }

        public void close() {
            super.close();
        }

    }

    static class InputReader extends BufferedReader {
        StringTokenizer tokenizer;

        public InputReader(InputStream inputStream) {
            super(new InputStreamReader(inputStream), 32768);
        }

        public InputReader(String filename) {
            super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(readLine());
                } catch (IOException e) {
                    throw new RuntimeException();
                }
            }
            return tokenizer.nextToken();
        }

        public Integer nextInt() {
            return Integer.valueOf(next());
        }

        public int[] readIntArray(int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++)
                array[i] = nextInt();
            return array;
        }

    }
}

",5,1209_A,CODEFORCES,3517,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import static java.lang.System.exit;
import static java.util.Arrays.sort;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class A {

	static void solve() throws Exception {
		int n = scanInt();
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = scanInt();
		}
		sort(a);
		int ans = 0;
		ans: while (true) {
			for (int i = 0;; i++) {
				if (i == n) {
					break ans;
				}
				if (a[i] != 0) {
					++ans;
					int t = a[i];
					a[i] = 0;
					for (i++; i < n; i++) {
						if (a[i] % t == 0) {
							a[i] = 0;
						}
					}
					break;
				}
			}
		}
		out.print(ans);
	}

	static int scanInt() throws IOException {
		return parseInt(scanString());
	}

	static long scanLong() throws IOException {
		return parseLong(scanString());
	}

	static String scanString() throws IOException {
		while (tok == null || !tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	public static void main(String[] args) {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			exit(1);
		}
	}
}",5,1209_A,CODEFORCES,3448,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class PaintTheNumers {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);    
        
        int nums = sc.nextInt();
        
        HashSet<Integer> elements = new HashSet<Integer>();
        for (int i = 0; i < nums; i++) {
            elements.add(sc.nextInt());
        }
        
        ArrayList<Integer> sortedElements = new ArrayList<Integer>(elements);

        Collections.sort(sortedElements);
        
        ArrayList<Integer> lcms = new ArrayList<Integer>();
        
        outer:
        for (int i = 0; i < sortedElements.size(); i++) {
            int ele = sortedElements.get(i);
            for (int j = 0; j < lcms.size(); j++) {
                if (ele % lcms.get(j) == 0) {
                    continue outer;
                }
            }
            lcms.add(ele);
        }
        System.out.println(lcms.size());
        sc.close();
    }
}
   
",5,1209_A,CODEFORCES,3514,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);

        Set<Integer> div = new HashSet<>();
        boolean[] d = new boolean[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0 ; j < n; j++) {
                if (d[j]) {
                    continue;
                }
                if (a[j]%a[i] == 0) {
                    d[j] = true;
                    div.add(a[i]);
                }
            }
        }

        System.out.println(div.size());
    }
}
",5,1209_A,CODEFORCES,3579,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"
import java.util.*;
import java.io.*;
import java.math.*;
import java.awt.geom.*;
import static java.lang.Math.*;
public class Main implements Runnable
{
    boolean multiiple = false;

    void solve() throws Exception
    {
        int n = sc.nextInt();

        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++)
            list.add(sc.nextInt());
        Collections.sort(list);
        int ans = 0;
        while (!list.isEmpty())
        {
            ans++;
            int next = list.get(0);
            for (int i = list.size() - 1; i >= 1; i--)
            {
                if (list.get(i) % next == 0)
                    list.remove(i);
            }
            list.remove(0);
        }

        System.out.println(ans);
    }

    @Override
    public void run()
    {
        try
        {
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
            sc = new FastScanner(in);
            if (multiiple)
            {
                int q = sc.nextInt();
                for (int i = 0; i < q; i++)
                    solve();
            }
            else
                solve();
        }
        catch (Throwable uncaught)
        {
            Main.uncaught = uncaught;
        }
        finally
        {
            out.close();
        }
    }

    public static void main(String[] args) throws Throwable {
        Thread thread = new Thread(null, new Main(), """", (1 << 26));
        thread.start();
        thread.join();
        if (Main.uncaught != null) {
            throw Main.uncaught;
        }
    }

    static Throwable uncaught;
    BufferedReader in;
    FastScanner sc;
    PrintWriter out;
}

class FastScanner
{
    BufferedReader in;
    StringTokenizer st;

    public FastScanner(BufferedReader in)
    {
        this.in = in;
    }

    public String nextToken() throws Exception {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    public int nextInt() throws Exception {
        return Integer.parseInt(nextToken());
    }

    public long nextLong() throws Exception {
        return Long.parseLong(nextToken());
    }

    public double nextDouble() throws Exception {
        return Double.parseDouble(nextToken());
    }

}",5,1209_A,CODEFORCES,3472,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"//package round584;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class A {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int n = ni();
		int[] a = na(n);
		Arrays.sort(a);
		boolean[] done = new boolean[n];
		int ans = 0;
		for(int i = 0;i < n;i++){
			if(!done[i]){
				ans++;
				for(int j = i+1;j < n;j++){
					if(a[j] % a[i] == 0){
						done[j] = true;
					}
				}
			}
		}
		out.println(ans);
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new A().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",5,1209_A,CODEFORCES,3584,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.math.*;

public class A {

	public void realMain() throws Exception {

		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in), 1000000);

		String in = fin.readLine();

		String[] ar = in.split("" "");

		int n = Integer.parseInt(ar[0]);
		
		int[] a = new int[n];

		for(int i = 0; i < n; i++) {
			int ret = 0;
			boolean dig = false;
			for (int ch = 0; (ch = fin.read()) != -1; ) {
        			if (ch >= '0' && ch <= '9') {
            				dig = true;
           				ret = ret * 10 + ch - '0';
        			} else if (dig) break;
    			}

			a[i] = ret;
			
		}

		int ret = 0;

		Arrays.sort(a);

		boolean[] colored = new boolean[n];

		for(int i = 0; i < n; i++) {
			if(!colored[i]) {
				ret++;
				for(int j = i; j < n; j++) {
					if(a[j] % a[i] == 0) {
						colored[j] = true;
					}
				}
			}
		}

		System.out.println(ret);



	}


	public static void main(String[] args) throws Exception {
		A a = new A();
		a.realMain();
	}
}",5,1209_A,CODEFORCES,3512,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
public class paintTheNumbers {
    public static void main (String [] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int [] arr = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = scanner.nextInt();
        }
        System.out.print(paint(arr));
    }
    public static int paint(int [] arr){
        Arrays.sort(arr);
        HashSet<Integer> set = new HashSet<>();
        int num = arr[0];
        set.add(num);
        for(int i = 1; i < arr.length; i++){
            if(!divBySet(set, arr[i])){
                set.add(arr[i]);
            }

        }
        return set.size();
    }

    /**
     *
     * @param set
     * @param a
     * @return
     */
    public static boolean divBySet(HashSet<Integer> set, int a){
        for(int s: set){
            if(a % s == 0){
                return true;
            }
        }
        return false;
    }

}
",5,1209_A,CODEFORCES,3522,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author unknown
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.i();
            int[] a = in.ia(n);
            RadixSort.radixSort(a);
            boolean[] flag = new boolean[n];
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (!flag[i]) {
                    ++count;
                    flag[i] = true;
                    for (int j = 0; j < n; j++) {
                        if (!flag[j] && a[j] % a[i] == 0) {
                            flag[j] = true;
                        }
                    }
                }
            }
            out.printLine(count);
        }

    }

    static class RadixSort {
        public static int[] radixSort(int[] f) {
            return radixSort(f, f.length);
        }

        public static int[] radixSort(int[] f, int n) {
            // credits uwi
            int[] to = new int[n];
            {
                int[] b = new int[65537];
                for (int i = 0; i < n; i++) b[1 + (int) (f[i] & 0xffff)]++;
                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];
                for (int i = 0; i < n; i++) to[b[(int) (f[i] & 0xffff)]++] = f[i];
                int[] d = f;
                f = to;
                to = d;
            }
            {
                int[] b = new int[65537];
                for (int i = 0; i < n; i++) b[1 + (int) (f[i] >>> 16 & 0xffff)]++;
                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];
                for (int i = 0; i < n; i++) to[b[(int) (f[i] >>> 16 & 0xffff)]++] = f[i];
                int[] d = f;
                f = to;
                to = d;
            }
            return f;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0;
        private int ptrbuf = 0;

        public InputReader(InputStream is) {
            this.is = is;
        }

        private int readByte() {
            if (lenbuf == -1) throw new InputMismatchException();
            if (ptrbuf >= lenbuf) {
                ptrbuf = 0;
                try {
                    lenbuf = is.read(inbuf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (lenbuf <= 0) return -1;
            }
            return inbuf[ptrbuf++];
        }

        public int[] ia(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = i();
            return a;
        }

        public int i() {
            int num = 0, b;
            boolean minus = false;
            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
            if (b == '-') {
                minus = true;
                b = readByte();
            }

            while (true) {
                if (b >= '0' && b <= '9') {
                    num = num * 10 + (b - '0');
                } else {
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

    }
}

",5,1209_A,CODEFORCES,3486,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author ilyakor
 */
public class Main {

  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    TaskA solver = new TaskA();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskA {

    public void solve(int testNumber, InputReader in, OutputWriter out) {
      int n = in.nextInt();
      boolean[] a = new boolean[218];
      for (int i = 0; i < n; ++i) {
        a[in.nextInt()] = true;
      }
      int res = 0;
      for (int i = 1; i < a.length; ++i) {
        if (a[i]) {
          ++res;
          for (int j = i; j < a.length; j += i) {
            a[j] = false;
          }
        }
      }
      out.printLine(res);
    }

  }

  static class OutputWriter {

    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void close() {
      writer.close();
    }

  }

  static class InputReader {

    private InputStream stream;
    private byte[] buffer = new byte[10000];
    private int cur;
    private int count;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public static boolean isSpace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int read() {
      if (count == -1) {
        throw new InputMismatchException();
      }
      try {
        if (cur >= count) {
          cur = 0;
          count = stream.read(buffer);
          if (count <= 0) {
            return -1;
          }
        }
      } catch (IOException e) {
        throw new InputMismatchException();
      }
      return buffer[cur++];
    }

    public int readSkipSpace() {
      int c;
      do {
        c = read();
      } while (isSpace(c));
      return c;
    }

    public int nextInt() {
      int sgn = 1;
      int c = readSkipSpace();
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new InputMismatchException();
        }
        res = res * 10 + c - '0';
        c = read();
      } while (!isSpace(c));
      res *= sgn;
      return res;
    }

  }
}

",5,1209_A,CODEFORCES,3577,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;
import java.math.*;

public class Dasha {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out), pw2 = new PrintWriter(System.out);

    public static void main(String[] args) throws IOException {
        int n=sc.nextInt();
        int[] arr=new int[101];
        for(int i=0;i<n;i++)
            arr[sc.nextInt()]++;
        boolean [] vis=new boolean[101];
        int c=0;
        for(int i=1;i<=100;i++){
            if(!vis[i]&&arr[i]>0){
                c++;
                for(int j=i+i;j<=100;j+=i)
                    vis[j]=true;
            }
        }
        pw.println(c);
        pw.flush();
    }

    public static <E> void print2D(E[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                pw.println(arr[i][j]);
            }
        }
    }

    public static int digitSum(String s) {
        int toReturn = 0;
        for (int i = 0; i < s.length(); i++) toReturn += Integer.parseInt(s.charAt(i) + "" "");
        return toReturn;
    }

    public static boolean isPrime(long n) {
        if (n <= 1)
            return false;
        if (n <= 3)
            return true;

        if (n % 2 == 0 || n % 3 == 0)
            return false;

        for (long i = 5; i * i <= n; i = i + 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;
        return true;
    }

    public static long pow(long a, long pow) {
        return pow == 0 ? 1 : pow % 2 == 0 ? pow(a * a, pow >> 1) : a * pow(a * a, pow >> 1);
    }

    public static long sumNum(long a) {
        return a * (a + 1) / 2;
    }

    public static int gcd(int n1, int n2) {
        return n2 == 0 ? n1 : gcd(n2, n1 % n2);
    }

    public static long factorial(long a) {
        return a == 0 || a == 1 ? 1 : a * factorial(a - 1);
    }

    public static void sort(int arr[]) {
        shuffle(arr);
        Arrays.sort(arr);
    }

    public static void shuffle(int arr[]) {
        Random rnd = new Random();
        for (int i = arr.length - 1; i > 0; i--) {
            int index = rnd.nextInt(i + 1);
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }

    public static Double[] solveQuadratic(double a, double b, double c) {
        double result = (b * b) - 4.0 * a * c;
        double r1;
        if (result > 0.0) {
            r1 = ((double) (-b) + Math.pow(result, 0.5)) / (2.0 * a);
            double r2 = ((double) (-b) - Math.pow(result, 0.5)) / (2.0 * a);
            return new Double[]{r1, r2};
        } else if (result == 0.0) {
            r1 = (double) (-b) / (2.0 * a);
            return new Double[]{r1, r1};
        } else {
            return new Double[]{null, null};
        }
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public boolean ready() throws IOException {
            return br.ready();
        }
    }

    static class pair<E1, E2> implements Comparable<pair> {
        E1 x;
        E2 y;

        pair(E1 x, E2 y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public int compareTo(pair o) {
            return x.equals(o.x) ? (Integer) y - (Integer) o.y : (Integer) x - (Integer) o.x;
        }

        @Override
        public String toString() {
            return x + "" "" + y;
        }

        public double pointDis(pair p1) {
            return Math.sqrt(((Integer) y - (Integer) p1.y) * ((Integer) y - (Integer) p1.y) + ((Integer) x - (Integer) p1.x) * ((Integer) x - (Integer) p1.x));
        }
    }

}
",5,1209_A,CODEFORCES,3465,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class Main {
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        StringTokenizer tokenizer = new StringTokenizer(br.readLine());
        boolean[] arr = new boolean[101];
        int[] nums = new int[n+1];
        int colors = 0;
        for(int i = 1; i <= n; i++) {
            nums[i] = Integer.parseInt(tokenizer.nextToken());
            arr[nums[i]] = true;
        }
        Arrays.parallelSort(nums);
        for(int i = 1; i <= n; i++) {
            boolean newColor = false;
            if(!arr[nums[i]]) {
                continue;
            }
            for(int j = nums[i]; j <= 100; j += nums[i]) {
                if(arr[j]) {
                    arr[j] = false;
                    newColor = true;
                }
            }
            if(newColor) {
                colors++;
            }
        }
        
        bw.write(String.valueOf(colors));
        br.close();
        bw.close();
    }
}
",5,1209_A,CODEFORCES,3498,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.*;
import java.util.*;

public class A
{
    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer tok;

    public void go() throws IOException
    {
        ntok();
        int n = ipar();
        ArrayList<Integer> list = new ArrayList<>();
        ntok();
        for (int i = 0; i < n; i++)
        {
            list.add(ipar());
        }
        Collections.sort(list);
        HashSet<Integer> set = new HashSet<>();
        for (int x : list)
        {
            boolean add = true;
            for (int y : set)
            {
                if (x % y == 0)
                {
                    add = false;
                    break;
                }
            }
            if (add)
            {
                set.add(x);
            }
        }
        out.println(set.size());

        out.flush();
        in.close();
    }

    public void ntok() throws IOException
    {
        tok = new StringTokenizer(in.readLine());
    }

    public int ipar()
    {
        return Integer.parseInt(tok.nextToken());
    }

    public int[] iapar(int n)
    {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
        {
            arr[i] = ipar();
        }
        return arr;
    }

    public long lpar()
    {
        return Long.parseLong(tok.nextToken());
    }

    public long[] lapar(int n)
    {
        long[] arr = new long[n];
        for (int i = 0; i < n; i++)
        {
            arr[i] = lpar();
        }
        return arr;
    }

    public double dpar()
    {
        return Double.parseDouble(tok.nextToken());
    }

    public String spar()
    {
        return tok.nextToken();
    }

    public static void main(String[] args) throws IOException
    {
        new A().go();
    }
}
",5,1209_A,CODEFORCES,3546,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/**
 * Created by Alyssa Herbst on 9/14/19 9:05 AM.
 */

import java.util.*;
import java.io.*;

import static java.lang.Math.*;

public class B {
    static StringBuilder sb;
    static int N;
    static int[] A;
    static boolean[] B;
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        //Scanner sc = new Scanner(System.in);
        sb = new StringBuilder();
        N = sc.nextInt();
        A = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }
        Arrays.sort(A);
        B = new boolean[N];
        int count = 0;
        for (int i = 0; i < A.length; i++) {
            if(B[i]) {
                continue;
            }
            else {
                count++;
                B[i] = true;
            }
            for (int j = i + 1; j < A.length; j++) {
                if(A[j] % A[i] == 0) {
                    B[j] = true;
                }
            }
        }
        sb.append(count);
        System.out.println(sb);
    }

    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }

        public FastScanner() {
            this(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] readIntBrray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }

        long[] readLongBrray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextLong();
            }
            return a;
        }
    }
}",5,1209_A,CODEFORCES,3506,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"/**
 * Created at 22:05 on 2019-09-14
 */

import java.io.*;
import java.util.*;

public class Main {

  static FastScanner sc = new FastScanner();
  static Output out = new Output(System.out);

  static final int[] dx = {0, 1, 0, -1};
  static final int[] dy = {-1, 0, 1, 0};

  static final long MOD = (long) (1e9 + 7);
  static final long INF = Long.MAX_VALUE / 2;

  static final int e5 = (int) 1e5;

  public static class Solver {
    public Solver() {

      int N = sc.nextInt();

      boolean[] flag = new boolean[101];
      for (int i=0; i<N; i++) {
        flag[sc.nextInt()] = true;
      }

      int ans = 0;
      for (int i=1; i<=100; i++) {
        if (flag[i]) {
          ans++;
          for (int j=i*2; j<=100; j+=i) {
            flag[j] = false;
          }
        }
      }

      out.println(ans);

    }

    public static void sort(int[] a) {
      shuffle(a);
      Arrays.sort(a);
    }

    public static void sort(long[] a) {
      shuffle(a);
      Arrays.sort(a);
    }

    public static void shuffle(int[] arr){
      int n = arr.length;
      Random rnd = new Random();
      for(int i=0; i<n; ++i){
        int tmp = arr[i];
        int randomPos = i + rnd.nextInt(n-i);
        arr[i] = arr[randomPos];
        arr[randomPos] = tmp;
      }
    }

    public static void shuffle(long[] arr){
      int n = arr.length;
      Random rnd = new Random();
      for(int i=0; i<n; ++i){
        long tmp = arr[i];
        int randomPos = i + rnd.nextInt(n-i);
        arr[i] = arr[randomPos];
        arr[randomPos] = tmp;
      }
    }
  }

  public static void main(String[] args) {
    new Solver();
    out.flush();
  }

  static class FastScanner {
    private InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;


    public void load() {
      try {
        in = new FileInputStream(next());
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    private boolean hasNextByte() {
      if (ptr < buflen) {
        return true;
      } else {
        ptr = 0;
        try {
          buflen = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (buflen <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    public long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }

    public int nextInt() {
      return (int) nextLong();
    }

    public int[] nextIntArray(int N, boolean oneBased) {
      if (oneBased) {
        int[] array = new int[N + 1];
        for (int i = 1; i <= N; i++) {
          array[i] = sc.nextInt();
        }
        return array;
      } else {
        int[] array = new int[N];
        for (int i = 0; i < N; i++) {
          array[i] = sc.nextInt();
        }
        return array;
      }
    }

    public long[] nextLongArray(int N, boolean oneBased) {
      if (oneBased) {
        long[] array = new long[N + 1];
        for (int i = 1; i <= N; i++) {
          array[i] = sc.nextLong();
        }
        return array;
      } else {
        long[] array = new long[N];
        for (int i = 0; i < N; i++) {
          array[i] = sc.nextLong();
        }
        return array;
      }
    }
  }

  static class Output extends PrintWriter {

    private long startTime;

    public Output(PrintStream ps) {
      super(ps);
    }

    public void print(int[] a, String separator) {
      for (int i = 0; i < a.length; i++) {
        if (i == 0) print(a[i]);
        else print(separator + a[i]);
      }
      println();
    }

    public void print(long[] a, String separator) {
      for (int i = 0; i < a.length; i++) {
        if (i == 0) print(a[i]);
        else print(separator + a[i]);
      }
      println();
    }

    public void print(String[] a, String separator) {
      for (int i = 0; i < a.length; i++) {
        if (i == 0) print(a[i]);
        else print(separator + a[i]);
      }
      println();
    }

    public void print(ArrayList a, String separator) {
      for (int i = 0; i < a.size(); i++) {
        if (i == 0) print(a.get(i));
        else print(separator + a.get(i));
      }
      println();
    }

    public void start() {
      startTime = System.currentTimeMillis();
    }

    public void time(String s) {
      long time = System.currentTimeMillis() - startTime;
      println(s + ""("" + time + "")"");
    }

  }

}
",5,1209_A,CODEFORCES,3446,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.StringTokenizer;



public class Tt {

	public static void main(String[] args) throws IOException {
		FastScanner fs=new FastScanner(System.in);
		int j = fs.nextInt();
		ArrayList<Integer> a =new ArrayList<Integer>();
		for(int i=0;i<j;i++) {
			a.add(fs.nextInt());
		}
		Collections.sort(a);
		Collections.reverse(a);
		int c=0;
		while(a.size()!=0) {
			int f=a.get(a.size()-1);
			c+=1;
			for(int q=a.size()-1;q>-1;q--)
			if(a.get(q)%f==0) {
				a.remove(q);
			}
		}
		System.out.println(c);
		}
	static class FastScanner {
	    BufferedReader br;
	    StringTokenizer st;
	    public FastScanner(InputStream i){
	        br = new BufferedReader(new InputStreamReader(i));
	        st = new StringTokenizer("""");
	    }
	    public String next() throws IOException{
	        if(st.hasMoreTokens()) return st.nextToken();
	        else st = new StringTokenizer(br.readLine());
	        return next();
	    }
	    public long nextLong() throws IOException{ return Long.parseLong(next()); }
	    public int nextInt() throws IOException { return Integer.parseInt(next()); }
	    public double nextDouble() throws IOException { return Double.parseDouble(next()); }
	    public String nextLine() throws IOException {
	        if(!st.hasMoreTokens()) 
	            return br.readLine();
	        String ret = st.nextToken();
	        while(st.hasMoreTokens()) 
	            ret += "" "" + st.nextToken();
	        return ret;
	    }
	}}

",5,1209_A,CODEFORCES,3582,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

/**
 * XXXX
 */
public class TaskA {

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Set<Integer> set = new HashSet<>();
    for (int i = 0; i < n; i++) {
        int a = sc.nextInt();

        boolean flag = false; // true = не нужно добавлять
        List<Integer> toRemove = new ArrayList<>();
        for (int b : set) {
            if (a % b == 0) {
                flag = true;
                break;
            } else if (b % a == 0 && a < b) {
                toRemove.add(b);
            }
        }
        for (int r: toRemove) {
            set.remove(r);
        }
        if (!flag) {
            set.add(a);
        }
    }
    System.out.println(set.size());
}
}
",5,1209_A,CODEFORCES,3510,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class PaintNumbers {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = in.nextInt();
        }

        boolean[] visited = new boolean[n];
        int min = Integer.MAX_VALUE;
        int a = 0;
        boolean cont = true;
        while (cont) {
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    min = Math.min(min, nums[i]);
                }
            }

            cont = false;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && nums[i] % min == 0) {
                    cont = true;
                    visited[i] = true;
                }
            }
            a++;
            min = Integer.MAX_VALUE;
        }
        System.out.println(a - 1);
    }



}
",5,1209_A,CODEFORCES,3474,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"//package Round584;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
public class typeA {
	public static void main(String[] args) {
		FastReader s = new FastReader();
		int n = s.nextInt();
		int[] arr = new int[n];
		for(int i=0;i<n;i++) {
			arr[i]=s.nextInt();
		}
		boolean[] arr2  = new boolean[n];
		Arrays.sort(arr);
		for(int i=0;i<arr2.length;i++) {
			arr2[i]=true;
		}
		//arr2[0]=true;
		for(int i=0;i<n-1;i++) {
			for(int j=i+1;j<n;j++) {
					if(arr[j]%arr[i]==0) {
						arr2[j]=false;
					}
				}
			}
		int count=0;
		for(int i=0;i<n;i++) {
			if(arr2[i]==true) {
				count++;
			}
		}
		System.out.println(count);
	}
	static class FastReader 
	
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
	
}
",5,1209_A,CODEFORCES,3457,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main {

    public static void main(String args[]) {
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        IntStream.range(0, 1).forEach(tc -> {
            new Solver(tc, in, out).solve();
            out.flush();
        });
        out.close();
    }
}

class InputReader {
    BufferedReader reader;
    StringTokenizer tokenizer;

    InputReader(InputStream in) {
        reader = new BufferedReader(new InputStreamReader(in));
    }

    String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken();
    }

    int nextInt() {
        return Integer.valueOf(next());
    }

    double nextDouble() {
        return Double.valueOf(next());
    }

    String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class Solver {
    private InputReader in;
    private PrintWriter out;
    private Integer tc;

    Solver(Integer tc, InputReader in, PrintWriter out) {
        this.in = in;
        this.out = out;
        this.tc = tc;
    }

    void solve() {
        Integer n = in.nextInt();
        TreeSet<Integer> list = IntStream.range(0, n)
                .map(i -> in.nextInt())
                .boxed()
                .collect(Collectors.toCollection(TreeSet::new));

        Integer answer = 0;
        while (!list.isEmpty()) {
            Integer x = list.pollFirst();
            list = list.stream().filter(y -> y % x != 0).collect(Collectors.toCollection(TreeSet::new));
            answer++;
        }

        out.println(answer);
    }
}
",5,1209_A,CODEFORCES,3581,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.Arrays;
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner cin = new Scanner(System.in);
        int a[] = new int[105];
        int vis[] = new int[105];
        Arrays.fill(vis, 0);
        int n = cin.nextInt();
        for(int i = 0; i < n; i++)
            a[i] = cin.nextInt();
        Arrays.sort(a, 0, n);
        int ans = 0;

        for(int i = 0; i < n; i++){
            int x = a[i];
            if(vis[x] == 0){
                ans++;
                for(int j = x; j < 105; j += x)
                    vis[j] = 1;
            }
        }
        System.out.println(ans);
    }
}
		   					 				   	 		",5,1209_A,CODEFORCES,3445,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author anand.oza
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();

            int[] a = in.readIntArray(n);

            Arrays.sort(a);

            int answer = 0;
            for (int i = 0; i < n; i++) {
                if (a[i] == 0)
                    continue;

                answer++;
                for (int j = 0; j < n; j++) {
                    if (j == i)
                        continue;
                    if (a[j] % a[i] == 0) {
                        a[j] = 0;
                    }
                }

                a[i] = 0;
            }

            out.println(answer);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public int[] readIntArray(int n) {
            int[] x = new int[n];
            for (int i = 0; i < n; i++) {
                x[i] = nextInt();
            }
            return x;
        }

    }
}

",5,1209_A,CODEFORCES,3561,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = Integer.parseInt(sc.next());
        int[] a = new int[N];
        int[] flag = new int[N];
        int ans = 0;
        for (int i=0;i<N;i++) {
            a[i] = Integer.parseInt(sc.next());
        }
        Arrays.sort(a);
        for (int i=0;i<N;i++) {
            int used = 0;
            for (int j=0;j<N;j++) {
                if (flag[j]==1) {
                    continue;
                } else {
                    if (a[j]%a[i]==0) {
                        used=1;
                        flag[j]=1;
                    }
                }
            }
            if (used==1) {
                ans++;
            }
        }
        System.out.println(ans);
    }
}",5,1209_A,CODEFORCES,3461,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"

import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader sc = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, sc, out);
        out.close();
    }

    static class Task {
        public void solve(int testNumber, InputReader sc, PrintWriter out) {
            int n=sc.nextInt();
            int[] a=new int[n];
            boolean[] jud=new boolean[101];
            
            for(int i=0;i<n;i++)
            	a[i]=sc.nextInt();
            Arrays.sort(a);
            int ans=0;
            for(int i=0;i<n;i++) {
            	if(jud[a[i]])
            		continue;
            	ans++;
            	for(int j=a[i];j<=100;j+=a[i])
            		jud[j]=true;
            }
            out.println(ans);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }
}
",5,1209_A,CODEFORCES,3556,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
"import java.util.*;
public class Main {
    public static void main(String args[]) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int arr[] = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = s.nextInt();
        }
        Arrays.sort(arr);
        int count = 0;
        boolean visited[] = new boolean[n];
        for(int i = 0; i < n; i++){
            if(visited[i] == true){
                continue;
            }
            count++;
            for(int j = 0; j < n; j++){
                if(arr[j] % arr[i] == 0){
                    visited[j] = true;
                }
            }
            if(check(visited)){
                System.out.println(count);
            }
        }
    }
    public static boolean check(boolean visited[]){
        for(int i = 0; i < visited.length; i++){
            if(visited[i] == false){
                return false;
            }
        }
        return true;
    }
}",5,1209_A,CODEFORCES,3444,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math"
