{"forwhile": "def reverse(s):\n    reverse = \"\"\n    i = len(s) - 1\n    while i >= 0:\n        reverse = reverse + s[i]\n        i -= 1\n    return reverse\n\ndef main(args):\n    n = int(input())\n    m = int(input())\n    x = m % (2 ** n)\n    print(x)\n", "src": "public class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "index": 2, "complexity": "0"}
{"forwhile": "class C:\n\n    st = StringBuilder()\n\n    @staticmethod\n    def main(args):\n        freq = [0, 0, 0, 0, 0]\n        k = 3\n        while k > 0:\n            x = int(input())\n            if x <= 4:\n                freq[x] += 1\n            k -= 1\n\n        freq[2] += freq[4] // 2\n\n        if freq[1] >= 1 or freq[2] >= 2 or freq[3] >= 3:\n            print('YES')\n        else:\n            print('NO')\n\n\n    class Scanner:\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n\n        def next(self):\n            while self.st is None or not self.st.hasMoreTokens():\n                self.st = StringTokenizer(self.br.readLine())\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n\n    @staticmethod\n    def shuffle(a):\n      n = len(a)\n      i = 0\n      while i < n:\n          r = i + int((Math.random()) * (n - i))\n          tmp = a[i]\n          a[i] = a[r]\n          a[r] = tmp\n          i += 1", "src": "public class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 4, "complexity": "0"}
{"forwhile": "public class TrickyAlchemy:\n    in = BufferedReader(InputStreamReader(System.in))\n    out = PrintWriter(BufferedOutputStream(System.out))\n    st = None\n\n    def main(args) -> None:\n        a = nextLong()\n        b = nextLong()\n        x = nextLong()\n        y = nextLong()\n        z = nextLong()\n        print(max(2*x+y-a, 0) + max(y+3*z-b, 0))\n    \n    def nextLine() -> str:\n        return in.readLine()\n\n    def nextString() -> str:\n        if st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readLine())\n        return st.nextToken()\n    \n    def nextInt() -> int:\n        return int(nextString())\n\n    def nextLong() -> int:\n        return int(nextString())\n\n    def intArray(n) -> List[int]:\n        a = []\n        i = 0\n        while i in range(n):\n            a.append(nextInt())\n            i += 1\n        return a\n    \n    def intArray(n, m) -> List[List[int]]:\n        a = []\n        i = 0\n        while i in range(n):\n            j = 0\n            while j in range(m):\n                a[i].append(nextInt())\n                j += 1\n            i += 1\n        return a\n    \n    def longArray(n) -> List[int]:\n        a = []\n        i = 0\n        while i in range(n):\n            a.append(nextLong())\n            i += 1\n        return a\n", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 5, "complexity": "0"}
{"forwhile": "from sys import stdin\nfor line in stdin:\n\tline = line.strip()\n\tparts = line.split()\n\tn = int(parts[0])\n\tpos = int(parts[1])\n\tl = int(parts[2])\n\tr = int(parts[3])\n\tif l == 1 and r == n:\n\t\tprint(0)\n\telif l == 1 and r < n:\n\t\tprint(abs(r - pos) + 1)\n\telif l > 1 and r == n:\n\t\tprint(abs(l - pos) + 1)\n\telif l > 1 and r < n:\n\t\tc = min(abs(r - pos), abs(l - pos))\n\t\tprint(c + 2 + r - l)", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}", "index": 9, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "index": 10, "complexity": "0"}
{"forwhile": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Param {\npublic static  void main( String[]args) {\nMyScanner param = new MyScanner();\nout = new PrintWriter(new BufferedOutputStream(System.out));\nint highestcoin=param.nextInt();\nint sum=param.nextInt();\nint remainder=sum%highestcoin;\nif(remainder!=0){\nremainder=1;\n} else{\nremainder=0;\n}\nint count=(sum-remainder)/highestcoin;\nif (highestcoin>=sum){\nSystem.out.println(\"1\");\n} else{\nSystem.out.println(count+remainder);\n}\nout.close();\n}\npublic static PrintWriter out;\npublic static class MyScanner {\nBufferedReader br;\nStringTokenizer st;\npublic MyScanner() {\nbr = new BufferedReader(new InputStreamReader(System.in));\n}\nString next() {\nwhile (st == null || !st.hasMoreElements()) {\ntry {\nst = new StringTokenizer(br.readLine());\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\nreturn st.nextToken();\n}\nint nextInt() {\nreturn Integer.parseInt(next());\n}\nlong nextLong() {\nreturn Long.parseLong(next());\n}\ndouble nextDouble() {\nreturn Double.parseDouble(next());\n}\nString nextLine(){\nString str = \"\";\ntry {\nstr = br.readLine();\n} catch (IOException e) {\ne.printStackTrace();\n}\nreturn str;\n}\n}\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 11, "complexity": "0"}
{"forwhile": "class EhabAndAnotherConstructionProblem:\n    @staticmethod\n    def main(args):\n        x = EhabAndAnotherConstructionProblem.nextInt()\n        print(-1) if x == 1 else print(str(x) + \" \" + str(x))\n\n    @staticmethod\n    def nextLine():\n        return input()\n\n    @staticmethod\n    def nextString():\n        try:\n            while True:\n                st = input().split()\n                for token in st:\n                    yield token\n        except EOFError:\n            return None\n\n    @staticmethod\n    def nextInt():\n        return int(EhabAndAnotherConstructionProblem.nextString())\n\n    @staticmethod\n    def nextLong():\n        return int(EhabAndAnotherConstructionProblem.nextString())\n\n    @staticmethod\n    def intArray(length):\n        a = []\n        i = 0\n        while i < length:\n            a.append(EhabAndAnotherConstructionProblem.nextInt())\n            i += 1\n        return a\n\n    @staticmethod\n    def intArray(n, m):\n        a = []\n        i = 0\n        while i < n:\n            j = 0\n            while j < m:\n                a1 = []\n                a1.append(EhabAndAnotherConstructionProblem.nextInt())\n                j += 1\n            a.append(a1)\n            i += 1\n        return a\n\n    @staticmethod\n    def longArray(length):\n        a = []\n        i = 0\n        while i < length:\n            a.append(EhabAndAnotherConstructionProblem.nextLong())\n            i += 1\n        return a", "src": "public class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 16, "complexity": "0"}
{"forwhile": "class A1008:\n    def main(args):\n        inputReader = System.in\n        outputReader = System.out\n        in_ = InputReader(inputReader)\n        out = PrintWriter(outputReader)\n        solver = Algorithm()\n        solver.solve(in_, out)\n        out.close()\n\n\nclass Algorithm:\n    def solve(ir, pw):\n\n        n = ir.nextLong()\n        k = ir.nextLong()\n        l = max(1, k - n)\n        r = (k + 1) / 2\n        l = max(0, r - l)\n        pw.print(l)\n\n\n\nclass InputReader:\n    def __init__(self, stream):\n        self.reader = BufferedReader(stream, 32768)\n        self.tokenizer = None\n\n    def next(self):\n        while self.tokenizer == None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = StringTokenizer(self.reader.readLine())\n            except IOException as e:\n                raise RuntimeException(e)\n        return self.tokenizer.nextToken()\n\n    def nextLine(self):\n        fullLine = None\n        while self.tokenizer == None or not self.tokenizer.hasMoreTokens():\n            try:\n                fullLine = self.reader.readLine()\n            except IOException as e:\n                raise RuntimeException(e)\n        return fullLine\n\n    def toArray(self):\n        return self.nextLine().split(\" \")\n\n    def nextInt(self):\n        return Integer.parseInt(self.next())\n\n    def nextDouble(self):\n        return Double.parseDouble(self.next())\n\n    def nextLong(self):\n        return Long.parseLong(self.next())", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 17, "complexity": "0"}
{"forwhile": "first = ''\nsecond = ''\ni = 0\nwhile i < 126:\n    first += '9'\n    second += '9'\n    i += 1\ni = 0\nwhile i < 125:\n    first += '0'\n    i += 1\nfirst += '1'\nout.println(first + ' ' + second)\n\nout.flush()\nout.close()\n\n\ndef sumDigits(num):\n    ans = 0\n    for _ in range(num):\n        ans += num % 10\n        num //= 10\n    return ans\n\nclass Scanner:\n    def __init__(self):\n        self.br = BufferedReader(InputStreamReader(System.in))\n        self.st = None\n\n    def next(self):\n        while self.st == None or not self.st.hasMoreTokens():\n            self.st = StringTokenizer(self.br.readLine())\n        return self.st.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n\n    def nextDouble(self):\n        return float(self.next())\n\n    def nextChar(self):\n        return self.next()[0]\n\n    def nextCharArray(self):\n        return list(self.next())\n", "src": "public class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}", "index": 18, "complexity": "0"}
{"forwhile": "class A_KingEscape:\n    def main(self):\n        inputStream = sys.stdin\n        outputStream = sys.stdout\n        inp = InputReader(inputStream)\n        out = outputStream\n        solver = Solver()\n        solver.solve(inp, out)\n\n\nclass Solver:\n    def solve(self, inp, out):\n        n = inp.nextInt()\n        Qx, Qy = inp.nextInt(), inp.nextInt()\n        Kx, Ky = inp.nextInt(), inp.nextInt()\n        Tx, Ty = inp.nextInt(), inp.nextInt()\n        if ((Kx < Qx and Tx < Qx) or (Kx > Qx and Tx > Qx)) and ((Ky < Qy and Ty < Qy) or (Ky > Qy and Ty > Qy)):\n            out.write('YES\\n')\n        else:\n            out.write('NO\\n')\n\n\nclass InputReader:\n    def __init__(self, stream):\n        self.reader = stream\n        self.tokenizer = None\n\n    def next(self):\n        while self.tokenizer == None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = tokenizer.StringTokenizer(self.reader.readLine())\n            except:\n                raise RuntimeError\n        return self.tokenizer.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n", "src": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 20, "complexity": "0"}
{"forwhile": "class A1008:\n    def main(args):\n        inputReader = System.in\n        outputReader = System.out\n        in = InputReader(inputReader)\n        out = PrintWriter(outputReader)\n        solver = Algorithm()\n        solver.solve(in, out)\n        out.close()\n\nclass Algorithm:\n    def solve(ir, pw):\n        n = ir.nextLong()\n        k = ir.nextLong()\n        pw.print((n + k - 1) / n)\n\n    def Qsort(array, low, high):\n        i = low\n        j = high\n        x = array[low + (high - low) // 2]\n        while i <= j:\n            while array[i] < x:\n                i += 1\n            while array[j] > x:\n                j -= 1\n            if i <= j:\n                tmp = array[i]\n                array[i] = array[j]\n                array[j] = tmp\n                i += 1\n                j -= 1\n        if low < j:\n            Qsort(array, low, j)\n        if i < high:\n            Qsort(array, i, high)\n\nclass InputReader:\n    def __init__(self, stream):\n        self.reader = BufferedReader(InputStreamReader(stream), 32768)\n        self.tokenizer = None\n\n    def next(self):\n        while self.tokenizer == None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = StringTokenizer(self.reader.readLine())\n            except IOException as e:\n                raise RuntimeException(e)\n        return self.tokenizer.nextToken()\n\n    def nextLine(self):\n        fullLine = None\n        while self.tokenizer == None or not self.tokenizer.hasMoreTokens():\n            try:\n                fullLine = self.reader.readLine()\n            except IOException as e:\n                raise RuntimeException(e)\n        return fullLine\n\n    def toArray(self):\n        return self.nextLine().split(' ')\n\n    def nextInt(self):\n        return Integer.parseInt(self.next())\n\n    def nextDouble(self):\n        return Double.parseDouble(self.next())\n\n    def nextLong(self):\n        return Long.parseLong(self.next())", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 22, "complexity": "0"}
{"forwhile": "highestcoin = int(input())\nsum = int(input())\nremainder = sum % highestcoin\nif remainder != 0:\n    remainder = 1\nelse:\n    remainder = 0\ncount = (sum - remainder) // highestcoin\nif highestcoin >= sum:\n    print('1')\nelse:\n    print(count + remainder)", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 23, "complexity": "0"}
{"forwhile": "def taskSolver(speedScanner, out):\n    n = speedScanner.nextLong()\n    m = speedScanner.nextLong()\n    k = speedScanner.nextLong()\n    l = speedScanner.nextLong()\n    tempM = None\n\n    if (k + l) < m:\n        if n < m:\n            out.print(-1)\n        else:\n            out.print(1)\n    else:\n        tempM = (k + l) / m\n        if (k + l) % m == 0:\n            if tempM * m <= n:\n                out.print(tempM)\n            else:\n                out.print(-1)\n        else:\n            if (tempM + 1) * m <= n:\n                out.print(tempM + 1)\n            else:\n                out.print(-1)", "src": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "index": 24, "complexity": "0"}
{"forwhile": "n = in.nextInt()\nk = in.nextInt()\nansw = 0\nif n*2 > k:\n    i = 0\n    while i < (n*2)//k:\n        if (n*2)%k == 0:\n            answ += (n*2)//k\n        else:\n            answ += ((n*2)//k) + 1\n        i += 1\nelse:\n    answ += 1\nif n*5 > k:\n    i = 0\n    while i < (n*5)//k:\n        if (n*5)%k == 0:\n            answ += (n*5)//k\n        else:\n            answ += ((n*5)//k) + 1\n        i += 1\nelse:\n    answ += 1\nif n*8 > k:\n    i = 0\n    while i < (n*8)//k:\n        if (n*8)%k == 0:\n            answ += (n*8)//k\n        else:\n            answ += ((n*8)//k) + 1\n        i += 1\nelse:\n    answ += 1\nprint(answ)", "src": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 25, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "index": 27, "complexity": "0"}
{"forwhile": "class FirstApp:\n    @staticmethod\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in_obj = InputReader(inputStream)\n        out = PrintWriter(outputStream)\n        solve = TaskA()\n        solve.solve(1, in_obj, out)\n        out.close()\n\n\nclass TaskA:\n    def solve(self, testNumber, in_obj, out):\n        number = in_obj.nextInt()\n\n        if number > 2 and number % 2 == 0:\n            out.println(\"YES\")\n        else:\n            out.println(\"NO\")\n\n\nclass InputReader:\n    def __init__(self, stream):\n        self.reader = BufferedReader(InputStreamReader(stream), 32768)\n        self.tokenizer = None\n\n    def next(self):\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = StringTokenizer(self.reader.readLine())\n            except IOException, e:\n                raise RuntimeException(e)\n        return self.tokenizer.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n", "src": "public class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "index": 30, "complexity": "0"}
{"forwhile": "maxLength = 100\nline = [0] * maxLength\nlength = 0\ninput = None\nwhile length < maxLength:\n    input = sys.stdin.read(1)\n    if input == '' or input == '\\n':\n        break\n    line[length] = chr(input)\n    length += 1\n\nif input == '' and length == 0:\n    print(None)\nelse:\n    print(''.join(line[:length]))", "src": "public class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      while (length < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "index": 31, "complexity": "0"}
{"forwhile": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\tfor (; kai.hasNext();) {\n\t\t\tint a = kai.nextInt();\n\t\t\tfor (; (a & 1) == 0;) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\t\t\tfor (; (a & 1) != 0;) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 33, "complexity": "0"}
{"forwhile": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n        do\n        {\n            if(st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n        while (st == null || !st.hasMoreElements());\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        int i = 0;\n        while (i < Integer.parseInt(next()))\n        {\n            return i;\n        }\n    }\n\n    long nextLong(){\n        long num = 0;\n        for (int i = 0; i < Long.parseLong(next()); i++)\n        {\n            num = i;\n        }\n        return num;\n    }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() {\n        float num = 0;\n        int i = 0;\n        do\n        {\n            num = i;\n            i++;\n        }\n        while (num == 0);\n        return num;\n    }\n\n    boolean nextBoolean() {\n        boolean bool = false;\n        while (Boolean.parseBoolean(next()))\n        {\n            bool = true;\n        }\n        return bool;\n    }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try\n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    for (long i = 0; i < n; i += 2)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    while (a != 0)\n    {\n        long temp = a;\n        a = b % a;\n        b = temp;\n    }\n    return b;\n  }\n  public void main(String[] args) throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() {\n      int i = 0;\n      while (i < first)\n      {\n          return i;\n      }\n  }\n  public int second() {\n      int i = 0;\n      while (i < second)\n      {\n          return i;\n      }\n  }\n  public void setFirst(int first) {\n      int i = 0;\n      do\n      {\n          this.first = first;\n      }\n      while (i < first);\n  }\n  public void setSecond(int second) {\n      int i = 0;\n      do\n      {\n          this.second = second;\n      }\n      while (i < second);\n  }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    for (int i = 0; i < a.first; i++)\n    {\n        return (a.first - b.first);\n    }\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    int i = 0;\n    while (i < dat.length)\n    {\n      m_array[i + 1] = dat[i];\n      i++;\n    }\n    i = 1;\n    while (i < m_array.length)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n      i++;\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    do\n    {\n        ++i;\n        result = result + m_array[i];\n    }\n    while (i > 0);\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      ++to;\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length;)\n    {\n      m_array[i] = m_array[i] + add;\n      i = i + (i & -i);\n    }\n  }\n}", "src": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}", "index": 34, "complexity": "0"}
{"forwhile": "import java.util.*;\nimport java.io.*;\npublic class SolutionB {\n   public static void main(String args[])throws IOException{\n      Scanner sc = new Scanner(System.in);\n      long a[] = new long[14];\n      int i = 0;\n      while (i < 14){\n         a[i] = sc.nextLong();\n         i++;\n      }\n      long cpy[] = new long[14];\n      long max = 0;\n      int i = 0;\n      while (i < 14){\n         if(a[i] == 0){\n            i++;\n            continue;\n         }\n         long score = 0;\n         long curr = a[i];\n         int j = 0;\n         while (j < 14){\n            cpy[j] = a[j];\n            j++;\n         }\n         cpy[i] = 0;\n         long amnt = curr / 14l;\n         int j = 0;\n         while (j < 14){\n            cpy[j] += amnt;\n            j++;\n         }\n         amnt = curr % 14;\n         int j = i + 1;\n         while (j < i + 1 + amnt){\n            cpy[j % 14]++;\n            j++;\n         }\n         int j = 0;\n         while (j < 14){\n            if(cpy[j] % 2 == 0){\n               score += cpy[j];\n            }\n            j++;\n         }\n         max = Math.max(max, score);\n         i++;\n      }\n      System.out.println(max);\n   }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "index": 35, "complexity": "0"}
{"forwhile": "from abc import InputStream, OutputStream, InputReader, OutputWriter;\nclass Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = InputReader(inputStream)\n        out = OutputWriter(outputStream)\n        solver = A979()\n        solver.solve(1, in, out)\n        out.close()\n    class A979:\n        def solve(testNumber, in, out):\n            n = in.nextLong()\n            n = n + 1\n            if (n % 2 == 0):\n                out.println(n / 2)\n            else:\n                if (n != 1):\n                    out.println(n)\n                else:\n                    out.println(0)\n    class OutputWriter:\n        def __init__(outputStream):\n            writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))\n        def close():\n            writer.close()\n        def println(i):\n            writer.println(i)\n    class InputReader:\n        def __init__(stream):\n            this.stream = stream\n        def read():\n            if (numChars == -1):\n                raise InputMismatchException()\n            if (curChar >= numChars):\n                curChar = 0\n                try:\n                    numChars = stream.read(buf)\n                except IOException:\n                    raise InputMismatchException()\n                if (numChars <= 0):\n                    return -1\n            return buf[curChar++]\n        def nextLong():\n            c = read()\n            while (isSpaceChar(c)):\n                c = read()\n            sgn = 1\n            if (c == '-':\n                sgn = -1\n                c = read()\n            res = 0\n            do:\n                if (c < '0' or c > '9':\n                    raise InputMismatchException()\n                res *= 10\n                res += c - '0'\n                c = read()\n            while (!isSpaceChar(c))\n            return res * sgn\n        def isSpaceChar(c):\n            if (filter != null):\n                return filter.isSpaceChar(c)\n            return isWhitespace(c)\n        def isWhitespace(c):\n            return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n        def interface SpaceCharFilter:\n            def isSpaceChar(ch):\n\n\nMain.main(args)", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 36, "complexity": "0"}
{"forwhile": "ERROR:Expecting ':' delimiter: line 29 column 1977 (char 25524)", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "index": 37, "complexity": "0"}
{"forwhile": "from sys import stdin, stdout\nfrom math import cos, pi\nfrom io import BufferedWriter, BytesIO\nimport os\n import sys\nimport io\nimport re\nimport time\nimport random\n\nstart_time = time.time()\n\nclass InputReader:\n    def __init__(self):\n        self.stream = BytesIO()\n    def readline(self):\n        while not self.stream.tell():\n            self.stream.write(os.read(0, 1000))\n        return self.stream.readline()\n    def read(self):\n        while not self.stream.tell():\n            self.stream.write(os.read(0, 1000))\n        return self.stream.read()\n    def read_int(self):\n        return int(self.readline())\n\ndef main():\n    inp = InputReader()\n    n, r = inp.read_int(), inp.read_int()\n    x = cos((n - 2) * pi / (2 * n))\n    print(r * x / (1 - x))\n\nif __name__ == '__main__':\n    main()\n", "src": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 39, "complexity": "0"}
{"forwhile": "class HelloWorld: \n    @staticmethod\n    def main(args): \n        inputStream = sys.stdin\n        outputStream = sys.stdout\n        inreader = InputReader(inputStream)\n        out = PrintWriter(outputStream)\n        solver = Palindrome()\n        solver.solve(1, inreader, out)\n        out.close()\n\n\nclass Palindrome: \n    def solve(self, testNumber, inreader, out): \n        l = inreader.nextLong()\n        \n        if l % 4 == 0 or l % 4 == 3: \n            out.print(\"0\")\n        else: \n            out.print(\"1\")\n\n\nclass InputReader: \n    def __init__(self, stream): \n        self.reader = BufferedReader(stream, 32768)\n        self.tokenizer = None\n\n    def next(self): \n        while True: \n            if self.tokenizer is None or not self.tokenizer.hasMoreTokens(): \n                try: \n                    self.tokenizer = StringTokenizer(self.reader.readLine()) \n                except IOException as e: \n                    raise RuntimeException(e) \n            yield self.tokenizer.nextToken()\n            \n    def nextLong(self): \n        for token in self.next(): \n            return int(token)\n", "src": "public class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "index": 40, "complexity": "0"}
{"forwhile": " class Main: \n\n    def main(args): \n\n        n = int(input()) \n        sumA = 0 \n        sumB = 0 \n        rem = n % 4 \n        i = rem \n        while i >= 1: \n            if sumB <= sumA: \n                sumB += i \n            else: \n                sumA += i \n            i -= 1 \n\n        print(abs(sumA - sumB)) \n\nif __name__ == '__main__': \n    Main.main(None) \n", "src": "public class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "index": 41, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}", "index": 42, "complexity": "0"}
{"forwhile": "n, v = fr.nextInt(), fr.nextInt()\nif v >= n:\n    out.println(n - 1)\nelse:\n    out.println((n - v) * (n - v + 1) // 2 + v - 1)\nout.flush()\n\nwhile st == None or not st.hasMoreElements():\n    try:\n        st = StringTokenizer(br.readLine())\n    except IOException as e:\n        e.printStackTrace()\n\nfor i in range(n):\n    a[i] = fr.nextInt()\n\nar = [val] * n", "src": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "index": 44, "complexity": "0"}
{"forwhile": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (; sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (;;) {\n\t\t\t\tif (n % 2 != 0) {\n\t\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "index": 45, "complexity": "0"}
{"forwhile": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        for(;sc.hasNext();) {\n            int n=sc.nextInt();\n            if(n%2==0) {\n                System.out.println(\"Mahmoud\");\n            } else {\n                System.out.println(\"Ehab\");\n            }\n        }\n    }\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 46, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}", "index": 48, "complexity": "0"}
{"forwhile": "class Main_1100C:\n\n\tdef solve():\n\t\tn = int(input())\n\t\tr = int(input())\n\n\t\tsin = math.sin(math.pi / n)\n\t\tans = r * sin / (1 - sin)\n\t\t\n\t\tprint('%.7f' % ans)\n\n\t\ndef main():\n\t\t\t\n\t\tsolve()\n\n\tif __name__ == '__main__':\n\t\tmain()", "src": "public class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}", "index": 53, "complexity": "0"}
{"forwhile": "n = int(input())\nif n % 2 == 0:\n\tn = n // 2\n\twhile not n % 2 == 0:\n\t\tprint(1)\n\t\tn = 0\nelse:\n\tn += 1\n\tn = n // 2\n\twhile not n % 2 == 0:\n\t\tprint(1)\n\t\tn = 0", "src": "public class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 54, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n        \n    \n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        \n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   static void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "index": 55, "complexity": "0"}
{"forwhile": "import java.io.BufferedReader;\nimport java.io.BufferedOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\npublic class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tst = new StringTokenizer(in.readLine());\n\t\twhile (st.hasMoreTokens())\n\t\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tint j = 0;\n\t\t\twhile (j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 56, "complexity": "0"}
{"forwhile": "class DLL: \n\n    class Node: \n        def __init__(self, data): \n            self.data = data \n            self.prev = None \n            self.next = None \n\n    def push(self, new_data): \n        new_Node = self.Node(new_data) \n        new_Node.next = self.head \n        new_Node.prev = None \n        if self.head != None: \n            self.head.prev = new_Node \n        self.head = new_Node \n\n    def printlist(self, node): \n        last = None \n        for node in iter(node, None): \n            print(node.data, end=' ') \n            last = node \n        print() \n    \n    def deleteNode(self, head_ref, delNode): \n        if self.head == None or delNode == None: \n            return \n        if self.head == delNode: \n            self.head = delNode.next \n        if delNode.next != None: \n            delNode.next.prev = delNode.prev \n        if delNode.prev != None: \n            delNode.prev.next = delNode.next \n        return \n\nif __name__ == '__main__': \n    dll = DLL() \n    dll.push(2) \n    dll.push(4) \n    dll.push(8) \n    dll.push(10) \n    print('Created DLL is:', end=' ') \n    dll.printlist(dll.head) \n    dll.deleteNode(dll.head, dll.head) \n    print('\\nList after deleting first node:', end=' ') \n    dll.printlist(dll.head) \n    dll.deleteNode(dll.head, dll.head.next) \n    print('\\nList after Deleting middle node:', end=' ') \n    dll.printlist(dll.head)", "src": "public\nclass\nDLL { \n\nNode head; \n\n\n\n\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n\n\n\n\n\n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n\n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\n\n\nNode new_Node = \nnew\nNode(new_data); \n\n\n\n\n\n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n\n\nhead = new_Node; \n\n} \n\n\n\n\n\n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n\n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n\n\n\n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n\n\n\n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n\n\nreturn\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nDLL dll = \nnew\nDLL(); \n\n\n\n\ndll.push(\n2\n); \n\n\n\n\ndll.push(\n4\n); \n\n\n\n\ndll.push(\n8\n); \n\n\n\n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head); \n\n\n\n\n\n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n}", "index": 57, "complexity": "0"}
{"forwhile": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Param {\n    public static void main(String[] args) {\n        MyScanner param = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        long l2 = param.nextLong();\n        long dice1 = param.nextLong();\n        long dice2 = param.nextLong();\n        long l1 = 1;\n        long r1 = 1;\n        long r2 = l2;\n        long count = 0;\n        long check = 0;\n        count = l2 - dice1;\n        count = count + (r2 - dice2);\n        check = dice1 - l1;\n        check = check + (dice2 - r1);\n        if (check <= count) {\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n        out.close();\n    }\n    public static PrintWriter out;\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            for (; st == null || !st.hasMoreElements(); ) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 63, "complexity": "0"}
{"forwhile": "class Dont: \n    jin = BufferedReader(InputStreamReader(System.in)) \n    n = 0 \n    x = 0 \n    y = 0 \n\n    def main(*args): \n        Dont.n = nextLong() \n        Dont.x = nextLong() \n        Dont.y = nextLong() \n        print('Black' if (max(Dont.n-Dont.x, Dont.n-Dont.y) < max(Dont.x-1, Dont.y-1)) else 'White') \n\n    @staticmethod \n    def max(a, b): \n        return a if a > b else b \n\n    @staticmethod \n    def nextLong(): \n        res = 0 \n        ch = Dont.jin.read() \n        while ch < '0' or '9' < ch: ch = Dont.jin.read() \n        temp_arr = [] \n        for i in range(2): \n            while '0' <= ch and ch <= '9': \n                res = res*10 + ord(ch) - ord('0') \n                ch = Dont.jin.read() \n                temp_arr.append(res) \n        return res", "src": "public class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "index": 64, "complexity": "0"}
{"forwhile": "class GFG: \n\n    N = 1000 \n\n    prefixans = [0] * 1000 \n\n    @staticmethod \n    def countIndex(a, n): \n        i = 0 \n        while i < n: \n            if i + 1 < n and a[i] == a[i + 1]: \n                prefixans[i] = 1 \n            if i != 0: \n                prefixans[i] += prefixans[i - 1] \n            i += 1 \n\n    @staticmethod \n    def answer_query(l, r): \n        if l == 0: \n            return prefixans[r - 1] \n        else: \n            return prefixans[r - 1] - prefixans[l - 1] \n\n    @staticmethod \n    def main(args): \n        a = [1, 2, 2, 2, 3, 3, 4, 4, 4] \n        n = 9 \n\n        GFG.countIndex(a, n) \n\n        L, R = 1, 8 \n        print(GFG.answer_query(L, R)) \n\n        L, R = 0, 4 \n        print(GFG.answer_query(L, R)) \n", "src": "class\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n\n\n\nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n\npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n\n\npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n\n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n\n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n}", "index": 65, "complexity": "0"}
{"forwhile": "class mainA:\n    out = PrintWriter(System.out)\n    enter = FastScanner(System.in)\n\n    def main(self, args):\n        x = enter.nextInt()\n        if x % 4 == 0:\n            print(1, 'A')\n        elif x % 4 == 1:\n            print(0, 'A')\n        elif x % 4 == 2:\n            print(1, 'B')\n        elif x % 4 == 3:\n            print(2, 'A')\n\n    class FastScanner:\n        def __init__(self, is):\n            self.br = BufferedReader(InputStreamReader(is))\n            self.stok = None\n\n        def next(self):\n            while self.stok is None or not self.stok.hasMoreTokens():\n                s = self.br.readLine()\n                if s is None:\n                    return None\n                self.stok = StringTokenizer(s)\n            return self.stok.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextChar(self):\n            return chr(self.br.read())\n\n        def nextLine(self):\n            return self.br.readLine()", "src": "public class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "index": 67, "complexity": "0"}
{"forwhile": "class problem2:\n    class tile:\n        def __init__(self):\n            self.number = 0\n            self.suit = 0\n\n        def __lt__(self, b):\n            return self.number - b.number\n\n    def main(self):\n        line = input()\n        parts = line.split(' ')\n\n        tiles = [self.tile() for _ in range(3)]\n        i = 0\n        while i < 3:\n            tiles[i] = self.tile()\n            tiles[i].number = ord(parts[i][0]) - ord('0')\n            if(parts[i][1:2] == 's'):\n                tiles[i].suit = 1\n            if(parts[i][1:2] == 'm'):\n                tiles[i].suit = 2\n            if(parts[i][1:2] == 'p'):\n                tiles[i].suit = 3\n            i += 1\n\n\n        tiles.sort()\n\n        tilesObtained = [[0 for _ in range(4)] for _ in range(10)]\n        stairCases = [[0 for _ in range(4)] for _ in range(10)]\n        stairCases2 = [[0 for _ in range(4)] for _ in range(10)]\n        for i in range(3):\n            currNumber = tiles[i].number\n            currSuit = tiles[i].suit\n\n            tilesObtained[currNumber][currSuit] += 1\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber - 1][currSuit]\n            if(currNumber != 1):\n                if stairCases2[currNumber - 2][currSuit] != 0:\n                    stairCases2[currNumber][currSuit] = 2\n                else:\n                    stairCases2[currNumber][currSuit] = 1\n            else:\n                stairCases2[currNumber][currSuit] += 1\n\n        best = 3\n\n        for i in range(1, 10):\n            for j in range(1, 4):\n                best = min(best, 3 - tilesObtained[i][j])\n                best = min(best, 3 - stairCases[i][j])\n                best = min(best, 3 - stairCases2[i][j])\n                if best < 0:\n                    best = 0\n\n        print(best)", "src": "public class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            \n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "index": 69, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}", "index": 70, "complexity": "0"}
{"forwhile": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = InputReader(inputStream)\n        out = OutputWriter(outputStream)\n        solver = KingEscape()\n        solver.solve(1, in, out)\n        out.close()\n\n\nclass KingEscape:\n    def solve(testNumber, inData, outData):\n        n = inData.nextInt()\n        qx = inData.nextInt()\n        qy = inData.nextInt()\n        kx = inData.nextInt()\n        ky = inData.nextInt()\n        safex = inData.nextInt()\n        safey = inData.nextInt()\n        possible = False\n        if qx > max(kx, safex) or qx < min(kx, safex):\n            if qy > max(ky, safey) or qy < min(ky, safey):\n                possible = True\n        if possible:\n            outData.println(\"YES\")\n        else:\n            outData.println(\"NO\")\n\nclass OutputWriter:\n    def __init__(outputStream):\n        writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))\n\n    def print(*objects):\n        i = 0\n        for i in range(len(objects)):\n            if i != 0:\n                writer.print(' ')\n            writer.print(objects[i])\n\n    def println(*objects):\n        print(objects)\n        writer.println()\n\n    def close():\n        writer.close()\n\nclass InputReader:\n    def __init__(stream):\n        this.stream = stream\n        buf = byte[1024]\n        curChar = 0\n        numChars = 0\n        filter = SpaceCharFilter\n\n    def read():\n        if numChars == -1:\n            throw InputMismatchException()\n        if curChar >= numChars:\n            curChar = 0\n            numChars = stream.read(buf)\n            if numChars <= 0:\n                return -1\n        return buf[curChar++]\n\n    def nextInt():\n        c = read()\n        while isSpaceChar(c):\n            c = read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = read()\n        res = 0\n        do\n            if c < '0' or c > '9':\n                throw InputMismatchException()\n            res *= 10\n            res += c - '0'\n            c = read()\n        while not isSpaceChar(c)\n        return res * sgn\n\n    def isSpaceChar(c):\n        if filter != None:\n            return filter.isSpaceChar(c)\n        return isWhitespace(c)\n\n    def isWhitespace(c):\n        return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n\n    def interface SpaceCharFilter:\n        def isSpaceChar(ch)", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 71, "complexity": "0"}
{"forwhile": "class main:\n    @staticmethod\n    def main(args):\n        init()\n        x = nextInt()\n        y = nextInt()\n        z = nextInt()\n        t1 = nextInt()\n        t2 = nextInt()\n        t3 = nextInt()\n        lift = abs(z - x) * t2 + 2 * t3 + abs(x - y) * t2 + t3\n        stair = abs(x - y) * t1\n        if lift <= stair:\n            pw.print(\"YES\")\n        else:\n            pw.print(\"NO\")\n        pw.close()\n\n    @staticmethod\n    def next():\n        while st == None or not st.hasMoreElements():\n            st = StringTokenizer(sc.readLine())\n        return st.nextToken()\n\n    @staticmethod\n    def nextInt():\n        return Integer.parseInt(next())\n\n    @staticmethod\n    def nextLong():\n        return Long.parseLong(next())\n\n    @staticmethod\n    def init(in_, out):\n        sc = BufferedReader(FileReader(in_))\n        pw = PrintWriter(out)\n\n    @staticmethod\n    def init():\n        sc = BufferedReader(InputStreamReader(System.in))\n        pw = PrintWriter(System.out)\n\n\nclass DSU:\n    def __init__(self, n):\n        parent = [None] * n\n        i = 0\n        while i < n:\n            parent[i] = i\n            i += 1\n\n    def get(self, i):\n        while i != parent[i]:\n            p = self.get(parent[i])\n            parent[i] = p\n            return p\n\n    def union(self, a, b):\n        a = self.get(a)\n        b = self.get(b)\n        while a != b:\n            parent[a] = b\n            return True\n        return False", "src": "public class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "index": 73, "complexity": "0"}
{"forwhile": "from java.util import Scanner\n\ndef main(args):\n    scan = Scanner(System.in)\n    q = scan.nextInt()\n    i = 1\n    while i <= q:\n        a = scan.nextInt()\n        ans = a // 7 + 1\n        System.out.println(ans)\n        i += 1\n", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "index": 77, "complexity": "0"}
{"forwhile": "num = scan.nextInt()\ni = 0\nwhile i < num:\n    a = scan.nextInt()\n    b = scan.nextInt()\n    print(a + ' ' + 2 * a)\n    i += 1\n", "src": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}", "index": 78, "complexity": "0"}
{"forwhile": "from io import BufferedReader, PrintWriter, InputStreamReader\nfrom java.io import IOException, InputStream\nfrom java.util import StringTokenizer\nfrom java.util.Scanner\n\nclass b:\n\n    @staticmethod\n    def main(args):\n        zizo = Scanner(System.in)\n        wr = PrintWriter(System.out)\n\n        n1, n2, n3, n4 = 0, 0, 0, 0\n        n = 3\n        for _ in range(n):\n            x = zizo.nextInt()\n            {\n                1: n1 += 1,\n                4: n4 += 1,\n                2: n2 += 1,\n                3: n3 += 1,\n            }[x]\n        \n        n2 += n4 // 2\n        if n1 > 0 or n2 > 1 or n3 > 2:\n            System.out.println(\"YES\")\n        else:\n            System.out.println(\"NO\")\n        wr.close()\n\n\nclass pair:\n\n    def __init__(self, a, b):\n        self.l = a\n        self.r = b\n\n\nclass Scanner:\n    def __init__(self, s: InputStream):\n        self.st = StringTokenizer(None)\n        self.br = BufferedReader(InputStreamReader(s))\n\n    def next(self) -> str:\n        res = ''\n        while self.st is None or not self.st.hasMoreTokens():\n            self.st = StringTokenizer(self.br.readLine())\n            res = self.st.nextToken()\n        return res\n\n    def nextInt(self) -> int:\n        return int(self.next())\n\n    def nextLong(self) -> int:\n        return int(self.next())\n\n    def nextLine(self) -> str:\n        return self.br.readLine()\n\n    def nextDouble(self) -> float:\n        x = self.next()\n        sb = ['0']\n        res = 0\n        f = 1\n        dec = False\n        neg = False\n        start = 0\n        if x[0] == '-':\n            neg = True\n            start += 1\n        for i in range(start, len(x)):\n            if x[i] == '.':\n                res = float(''.join(sb))\n                sb = ['0']\n                dec = True\n            else:\n                sb.append(x[i])\n                if dec:\n                    f *= 10\n        res += float(''.join(sb)) / f\n        return res * (-1 if neg else 1)\n\n    def ready(self) -> bool:\n        return self.br.ready()\n", "src": "public class b {\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n1 = 0,n2 = 0,n3 = 0,n4 = 0;\n\t\tint n = 3;\n\t\twhile(n --> 0) {\n\t\t\tint x = zizo.nextInt();\n\t\t\tswitch(x) {\n\t\t\tcase 1:n1++;break;\n\t\t\tcase 4:n4++;break;\n\t\t\tcase 2:n2++;break;\n\t\t\tcase 3:n3++;break;\n\t\t\t}\n\t\t}\n\t\tn2 += n4/2;\n\t\tif(n1>0 || n2>1 || n3>2)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\twr.close();\n\t}\n}\nclass pair{\n\tint l,r;\n\tpair(int a,int b){l = a;r = b;}\n}\n\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n}", "index": 80, "complexity": "0"}
{"forwhile": "public class TrickyAlchemy:\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in))\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))\n    public static StringTokenizer st\n    \n    public static void main(String[] args) throws IOException:\n        long a = nextLong()\n        long b = nextLong()\n        long x = nextLong()\n        long y = nextLong()\n        long z = nextLong()\n        System.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0))\n    \n    public static String nextLine() throws IOException:\n        return in.readLine()\n\n    public static String nextString() throws IOException:\n        for(;st ==null || !st.hasMoreTokens();):\n            st = new StringTokenizer(in.readLine())\n        return st.nextToken()\n\n    public static int nextInt() throws IOException:\n        return Integer.parseInt(nextString())\n\n    public static long nextLong() throws IOException:\n        return Long.parseLong(nextString())\n\n    public static int[] intArray(int n) throws IOException:\n        int[] a = new int[n]\n        int i = 0\n        while i < n:\n            a[i] = nextInt()\n            i += 1\n        return a\n\n    public static int[][] intArray(int n, int m) throws IOException:\n        int[][] a = new int[n][m]\n        int i = 0\n        while i < n:\n            int j = 0\n            while j < m:\n                a[i][j] = nextInt()\n                j += 1\n            i += 1\n        return a\n\n    public static long[] longArray(int n) throws IOException:\n        long[] a = new long[n]\n        int i = 0\n        while i < n:\n            a[i] = nextLong()\n            i += 1\n        return a", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 81, "complexity": "0"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 117 column 65 (char 14152)", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 84, "complexity": "0"}
{"forwhile": "def intArray(n):\n    a = []\n    i = 0\n    while i < n:\n        a.append(nextInt())\n        i += 1\n    return a\n\ndef intArray(n, m):\n    a = []\n    i = 0\n    while i < n:\n        j = 0\n        while j < m:\n            a.append([])\n            a[i].append(nextInt())\n            j += 1\n        i += 1\n    return a\n\ndef longArray(n):\n    a = []\n    i = 0\n    while i < n:\n        a.append(nextLong())\n        i += 1\n    return a\n\nin = BufferedReader(InputStreamReader(System.in))\nout = PrintWriter(BufferedOutputStream(System.out))\nst = None\n\ndef main(args):\n    n = 0\n    try:\n        n = nextLong()\n    except Throwable as e:\n        printStackTrace(e)\n    if n == 0:\n        print('0')\n    elif n % 2 == 0:\n        print(n + 1)\n    else:\n        print((n + 1) / 2)\n\ndef nextLine():\n    try:\n        return in.readLine()\n    except Throwable as e:\n        printStackTrace(e)\n\ndef nextString():\n    while st is None or not st.hasMoreTokens():\n        try:\n            temp = in.readLine()\n            if temp is None:\n                return None\n            st = StringTokenizer(temp)\n        except Throwable as e:\n            printStackTrace(e)\n    return st.nextToken()\n\ndef nextInt():\n    try:\n        return Integer.parseInt(nextString())\n    except Throwable as e:\n        printStackTrace(e)\n\ndef nextLong():\n    try:\n        return Long.parseLong(nextString())    \n    except Throwable as e:\n        printStackTrace(e)", "src": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 85, "complexity": "0"}
{"forwhile": "import java.io.*;\nimport java.util.StringTokenizer;\n\nclass AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tdo {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t} while (st == null || !st.hasMoreTokens());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tint j = 0;\n\t\t\twhile (j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 87, "complexity": "0"}
{"forwhile": "class simple implements Runnable {\n    public void run()\n    {\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n        System.out.println((2*n*n)-(2*n)+1);\n    }\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            int i=0;\n            while(i<v){\n                adj.add(new LinkedList<>());\n                i++;\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            int i = 0;\n            while(i < f.length){\n                b[1+(f[i]&0xffff)]++;\n                i++;\n            }\n            i = 1;\n            while(i <= 65536){\n                b[i]+=b[i-1];\n                i++;\n            }\n            i = 0;\n            while(i < f.length){\n                to[b[f[i]&0xffff]++] = f[i];\n                i++;\n            }\n            int[] d = f; f = to; to = d;\n        }\n        {\n            int[] b = new int[65537];\n            int i = 0;\n            while(i < f.length){\n                b[1+(f[i]>>>16)]++;\n                i++;\n            }\n            i = 1;\n            while(i <= 65536){\n                b[i]+=b[i-1];\n                i++;\n            }\n            i = 0;\n            while(i < f.length){\n                to[b[f[i]>>>16]++] = f[i];\n                i++;\n            }\n            int[] d = f; f = to; to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            while(isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == \\'-\") {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if(c<\\'0\\'||c>\\'9\\')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - \\'0\\';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == \\'-\") {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < \\'0\\' || c > \\'9\\')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - \\'0\\';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public double nextDouble() {\n           int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == \\'-\") {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != \\'.\") {\n                if (c == \\'e\\' || c == \\'E\\')\n                    return res * Math.pow(10, nextInt());\n                if (c < \\'0\\' || c > \\'9\\')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - \\'0\\';\n                c = read();\n            }\n            if (c == \\'.\") {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == \\'e\\' || c == \\'E\\')\n                        return res * Math.pow(10, nextInt());\n                    if (c < \\'0\\' || c > \\'9\\')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - \\'0\\') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == \\' \\' || c == \\'\\n\\' || c == \\'\\r\\' || c == \\'\\t\\' || c == -1;\n        }\n        public String next() {\n            return readString();\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\\\"TaskA\\\",1<<26).start();\n    }\n}", "src": "public class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "index": 88, "complexity": "0"}
{"forwhile": "class Test:  static def binarySearch(arr, l, r, x):   if r>=l:     mid = l + (r - l)//2     if arr[mid] == x:       return mid     if arr[mid] > x:       return binarySearch(arr, l, mid-1, x)     return binarySearch(arr, mid+1, r, x)   return -1  static def findPos(arr, key):   l = 0   h = 1   val = arr[0]   for val in arr[h]:     l = h     h = 2*h if 2*h < len(arr)-1 else len(arr)-1     val = arr[h]   return binarySearch(arr, l, h, key)  def main(args):   arr = [3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170]   ans = findPos(arr, 10)   if ans==-1:     print('Element not found')   else:     print('Element found at index ' + str(ans))", "src": "class\nTest \n{ \n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r>=l) \n\n{ \n\nint\nmid = l + (r - l)/\n2\n; \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid-\n1\n, x); \n\nreturn\nbinarySearch(arr, mid+\n1\n, r, x); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindPos(\nint\narr[],\nint\nkey) \n\n{ \n\nint\nl = \n0\n, h = \n1\n; \n\nint\nval = arr[\n0\n]; \n\n\n\n\nwhile\n(val < key) \n\n{ \n\nl = h; \n\n\n\n\n\n\nif\n(\n2\n*h < arr.length-\n1\n) \n\nh = \n2\n*h; \n\nelse\n\nh = arr.length-\n1\n; \n\n\nval = arr[h]; \n\n\n} \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, l, h, key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n3\n, \n5\n, \n7\n, \n9\n, \n10\n, \n90\n, \n\n100\n, \n130\n, \n140\n, \n160\n, \n170\n}; \n\nint\nans = findPos(arr,\n10\n); \n\n\nif\n(ans==-\n1\n) \n\nSystem.out.println(\n\"Element not found\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ ans); \n\n} \n}", "index": 90, "complexity": "2"}
{"forwhile": "def binarySearch(a, n):\n    low, high = 0, len(a) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if n == a[mid]:\n            return mid\n        elif n < a[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\n\nprint(binarySearch([0, 2], 2))\nprint(binarySearch([0, 1, 2, 3], 2))\nprint(binarySearch([0, 1, 2, 3], 3))\nprint(binarySearch([0, 2], 0))\nprint(binarySearch([0, 1, 2, 2, 2, 3, 3], 2))\nprint('---------')\n\ndef binarySearchNonRecursive(a, n):\n    return binarySearch(a, n, 0, len(a))\n\n\ndef binarySearch(a, n, low, high):\n    if low <= high:\n        mid = (low + high) // 2\n        if n == a[mid]:\n            return mid\n        elif n < a[mid]:\n            return binarySearch(a, n, 0, mid - 1)\n        else:\n            return binarySearch(a, n, mid + 1, high)\n    else:\n        return -1\n\n\nprint(binarySearchNonRecursive([0, 2], 2))\nprint(binarySearchNonRecursive([0, 1, 2, 3], 2))\nprint(binarySearchNonRecursive([0, 1, 2, 3], 3))\nprint(binarySearchNonRecursive([0, 2], 0))\nprint(binarySearchNonRecursive([0, 1, 2, 2, 2, 3, 3], 2))", "src": "public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2; \n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "index": 93, "complexity": "2"}
{"forwhile": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        for (int partitionX = (low + high)/2; low <= high; partitionX = (low + high)/2) {\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            \n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "src": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high)/2;\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            \n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "index": 95, "complexity": "2"}
{"forwhile": "class FloorAndCeilingSortedArray:\n\n    def floor(self, input_list, x):\n        low = 0\n        high = len(input_list) - 1\n        for _ in range(len(input_list)):\n            middle = (low + high)//2\n            if input_list[middle] == x or (input_list[middle] < x and (middle == len(input_list) - 1 or input_list[middle + 1] > x)):\n                return middle\n            elif input_list[middle] < x:\n                low = middle + 1\n            else:\n                high = middle - 1\n        return -1\n\n    def ceiling(self, input_list, x):\n        low = 0\n        high = len(input_list) - 1\n        for _ in range(len(input_list)):\n            middle = (low + high)//2\n            if input_list[middle] == x or (input_list[middle] > x and (middle == 0 or input_list[middle - 1] < x)):\n                return middle\n            elif input_list[middle] < x:\n                low = middle + 1\n            else:\n                high = middle - 1\n        return -1\n\n\ninput_list = [1, 2, 5, 6, 11, 15]\nfoc = FloorAndCeilingSortedArray()\nprint(foc.floor(input_list, 15))\nprint(foc.ceiling(input_list, 2))", "src": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "index": 96, "complexity": "2"}
{"forwhile": "arr1 = [1, 2, 4, 5, 7, 8] \nlow, high = 0, len(arr1)-1 \nmid = 0 \ni = 0 \nwhile i <= high: \n    mid = low + ((high - low) // 2) \n    if arr1[mid] == -1: \n        print(mid) \n    elif arr1[mid] == 1: \n        print(mid) \n    elif arr1[mid] == 8: \n        print(mid) \n    elif arr1[mid] == 2: \n        print(mid) \n    i += 1", "src": "public class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "index": 99, "complexity": "2"}
{"forwhile": "class CircularBinarySearch:\n    def search(self, arr):\n        low = 0\n        high = len(arr) - 1\n        mid = 0\n        for _ in range(1000):\n            mid = (low + high) // 2\n            if (low >= high):\n                break\n            if (low == mid or arr[mid] < arr[mid-1]) and arr[mid] < arr[mid+1]:\n                return arr[mid]\n            if (arr[mid] >= arr[low] and arr[mid] >= arr[high]):\n                if arr[low] < arr[high]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if arr[mid-1] < arr[mid+1]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return arr[low]\n\n    def main(self):\n        cbs = CircularBinarySearch()\n        arr = [7, 10, 8, 5, 2, 3, 5]\n        print(cbs.search(arr))\n\n        arr1 = [5, 8, 10, 7, 5, 3, 2]\n        print(cbs.search(arr1))\n\n        arr2 = [3, 5, 7, 10, 8, 5, 2]\n        print(cbs.search(arr2))\n\n        arr3 = [8, 5, 2, 3, 5, 7, 10]\n        print(cbs.search(arr3))\n\n        arr4 = [5, 3, 2, 5, 8, 10, 7]\n        print(cbs.search(arr4))\n\n        arr5 = [100, 20, 10, 5, 2, 8, 11, 16, 19]\n        print(cbs.search(arr5))\n\n        arr6 = [200, 2, 10, 15, 20, 80, 110, 160, 190]\n        print(cbs.search(arr6))\n\n        arr7 = [5, 10, 20, 50, 200, 800, 1100, 1600, 1900, 2]\n        print(cbs.search(arr7))\n\n        arr8 = [2, 5, 10, 20, 50, 200, 800, 1100, 1600, 1900]\n        print(cbs.search(arr8))\n\n        arr9 = [3, 1, 8, 5, 4]\n        print(cbs.search(arr9))\n\nif __name__ == '__main__':\n    cbs = CircularBinarySearch()\n    cbs.main()", "src": "public class CircularBinarySearch {\n\n    \n    \n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            \n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "index": 100, "complexity": "2"}
{"forwhile": "def f(x):\n    return x*x - 10*x - 20\n\ndef findPoint():\n    i = 1\n    for i in range(1, i*2, i*2-1):\n        if f(i) > 0:\n            break\n    return binarySearch(i//2, i)\n\n\ndef binarySearch(start, end):\n    mid = (start + end) // 2\n    for start in range(start, end, end-start-1):\n        mid = (start + end) // 2\n        if f(mid) > 0 and f(mid-1) <= 0:\n            return mid\n        if f(mid) <= 0 and f(mid+1) > 0:\n            return mid + 1\n        if f(mid) <= 0:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return mid\n\nprint(findPoint())", "src": "public class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "index": 101, "complexity": "2"}
{"forwhile": "public class SortedAndRotatedArraySearch:\n\n    def search(self, arr, search):\n        low = 0\n        high = len(arr) - 1\n        for _ in range(low, high+1):\n            mid = (low + high) // 2\n            if arr[mid] == search:\n                return mid\n            if arr[mid] < arr[high]:\n                if arr[mid] < search and search <= arr[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if search >= arr[low] and search < arr[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return -1\n\n    def searchWithDuplicates(self, arr, search):\n        low = 0\n        high = len(arr) - 1\n        for _ in range(low, high+1):\n            mid = (low + high) // 2\n            if arr[mid] == search:\n                return True\n            if arr[mid] == arr[low]:\n                low += 1\n            elif arr[mid] == arr[high]:\n                high -= 1\n            elif arr[mid] < arr[high]:\n                if arr[mid] < search and search <= arr[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if search >= arr[low] and search < arr[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return False\n\n\nras = SortedAndRotatedArraySearch()\narr1 = [1, 2, 5, 6, 7, 8, 11, 21]\nprint(ras.search(arr1, 1), end='')\nprint(ras.search(arr1, 5), end='')\nprint(ras.search(arr1, 22))\n\narr2 = [18, 21, 1, 2, 5, 6, 7, 8, 10, 15]\nprint(ras.search(arr2, 1), end='')\nprint(ras.search(arr2, 5), end='')\nprint(ras.search(arr2, 10), end='')\nprint(ras.search(arr2, 14))\n\narr3 = [7, 8, 15, 17, 18, 21, 1, 2, 5, 6]\nprint(ras.search(arr3, 1), end='')\nprint(ras.search(arr3, 5), end='')\nprint(ras.search(arr3, 10), end='')\nprint(ras.search(arr3, 7), end='')\nprint(ras.search(arr3, 6), end='')\nprint(ras.search(arr3, 16))", "src": "public class SortedAndRotatedArraySearch {\n\n    \n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            \n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { \n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "index": 102, "complexity": "2"}
{"forwhile": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        for (int i = 0; i <= high; i++) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        for (int i = 0; i <= high; i++) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "src": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "index": 103, "complexity": "2"}
{"forwhile": "class PeakElement:\n\n    def findPeakElement(self, nums):\n        low = 0\n        high = len(nums) - 1\n        middle = 0\n        for _ in range(high - low + 1):\n            middle = (low + high)//2\n            before = float('-inf')\n            if middle > 0:\n                before = nums[middle - 1]\n            after = float('-inf')\n            if middle < len(nums) - 1:\n                after = nums[middle + 1]\n            if nums[middle] > before and nums[middle] > after:\n                return middle\n            elif before > after:\n                high = middle - 1\n            else:\n                low = middle + 1\n        return middle\n\n    def main(self):\n        arr = [10, 5, 15, 2, 23, 90, 67]\n        pe = PeakElement()\n        print(pe.findPeakElement(arr))\n        arr1 = [10, 20, 30, 40, 50]\n        print(pe.findPeakElement(arr1))\n        arr2 = [100, 90, 80, 70, 60]\n        print(pe.findPeakElement(arr2))\n\npe = PeakElement()\npe.main()", "src": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}", "index": 104, "complexity": "2"}
{"forwhile": "class FirstOccurrenceOfNumberInSortedArray:\n\n    def firstOccurrence(self, input, x):\n        low = 0\n        high = len(input)-1\n        \n        for _ in range(high+1):\n            middle = (low + high)//2\n            if input[middle] == x and (middle == 0 or input[middle-1] < x):\n                return middle\n            elif input[middle] < x:\n                low = middle+1\n            else:\n                high = middle-1\n        return -1\n    \n    def main(self, args):\n        fos = FirstOccurrenceOfNumberInSortedArray()\n        input = [1,2,2,2,2,2,5,7,7]\n        print(fos.firstOccurrence(input, 6))\n", "src": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "index": 105, "complexity": "2"}
{"forwhile": "class CountOne:\n\n    def main(self):\n        arr = [0, 0, 0, 0, 0, 0, 0]\n        countOne(arr)\n\n\ndef countOne(a):\n    l = 0\n    h = len(a) - 1\n    mid = -1\n    \n    for _ in range(len(a)):\n        while l <= h:\n            mid = (l + h) // 2\n            \n            if (mid == h or a[mid + 1] == 0) and a[mid] == 1:\n                print('Count ' + str(mid + 1))\n                return\n            \n            if a[mid] < 1:\n                h = mid - 1\n            else:\n                l = mid + 1\n    \n    print('No one\\'s found')", "src": "class CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    \n    \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       while(l<=h)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "index": 106, "complexity": "2"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nStack<Integer> st= \\nnew\\nStack<>(); \\n\\n\\n\\n\\nstatic\\nvoid\\npush_digits(\\nint\\nnumber) \\n\\n{ \\n\\nint\\ni = \\n0\\n; \\nfor( ; number != \\n0\\n ; ){ \\n\\nst.push(number % \\n10\\n); \\n\\nnumber = number / \\n10\\n; \\n\\n} \\n\\n} \\n\\n\\n\\n\\nstatic\\nint\\nreverse_number(\\nint\\nnumber) \\n\\n{ \\n\\n\\n\\n\\n\\n\\n\\npush_digits(number); \\n\\nint\\nreverse = \\n0\\n; \\n\\nint\\ni = \\n1\\n; \\n\\n\\n\\n\\n\\nfor(; !st.isEmpty(); ){ \\n\\nreverse = reverse + (st.peek() * i); \\n\\nst.pop(); \\n\\ni = i * \\n10\\n; \\n\\n\\n} \\n\\n\\n\\n\\n\\nreturn\\nreverse; \\n\\n} \\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\nnumber = \\n39997\\n; \\n\\nSystem.out.println(reverse_number(number)); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n\n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nwhile\n(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\n} \n\n} \n\n\n\n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n\n\n\n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n\n\n\n\nwhile\n(!st.isEmpty()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\nst.pop(); \n\ni = i * \n10\n; \n\n} \n\n\n\n\nreturn\nreverse; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n}", "index": 108, "complexity": "2"}
{"forwhile": "class BinarySearch { int binarySearch(int arr[], int x) { int l = 0, r = arr.length - 1; for (int i = l; i <= r; i++) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; } return -1; } public static void main(String args[]) { BinarySearch ob = new BinarySearch(); int arr[] = { 2, 3, 4, 10, 40 }; int n = arr.length; int x = 10; int result = ob.binarySearch(arr, x); if (result == -1) System.out.println(\"Element not present\"); else System.out.println(\"Element found at \" + \"index \" + result); } }", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n\n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n\n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n}", "index": 112, "complexity": "2"}
{"forwhile": "def f(x): \n    return (x*x - 10*x - 20) \n\ndef findFirstPositive(): \n    if f(0) > 0: \n        return 0 \n    i = 1 \n    for i in range(1, i*2, i*2): \n        if f(i) > 0 and (i == 1 or f(i-1) <= 0): \n            return i \n        elif f(i) <= 0: \n            low = i + 1 \n        else: \n            high = i - 1 \n    return -1 \n\ndef main(args): \n    print(\"The value n where f() becomes positive first is \" + str(findFirstPositive())) \n\nmain([])", "src": "class\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n\n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n\n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n\n\n\n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n\n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n\n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n}", "index": 113, "complexity": "2"}
{"forwhile": "class GfG { static int getMedian(int ar1[], int ar2[], int n) { if (n <= 0) return -1; if (n == 1) return (ar1[0] + ar2[0]) / 2; if (n == 2) return (Math.max(ar1[0], ar2[0]) + Math.min(ar1[1], ar2[1])) / 2; int m1, m2; if (n % 2 == 0) { m1 = getMedian(ar1,n); m2 = getMedian(ar2,n); return (m1 == m2) ? m1 : (m1 < m2) ? ((n % 2 == 0) ? getMedian(ar1 + n / 2 - 1, ar2, n - n / 2 + 1) : getMedian(ar1 + n / 2, ar2, n - n / 2)) : ((n % 2 == 0) ? getMedian(ar2 + n / 2 - 1, ar1, n - n / 2 + 1) : getMedian(ar2 + n / 2, ar1, n - n / 2)); } return m1; } static int median(int arr[], int n) { return (n % 2 == 0) ? (arr[n / 2] + arr[n / 2 - 1]) / 2 : arr[n / 2]; } public static void main(String[] args) { int ar1[] = {1, 2, 3, 6}; int ar2[] = {4, 6, 8, 10}; int n1 = ar1.length; int n2 = ar2.length; if (n1 == n2) System.out.println(\"Median is \" + getMedian(ar1, ar2, n1)); else System.out.println(\"Doesn't work for arrays of unequal size\"); } }", "src": "class\nGfG { \n\n\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n\n\nint\nm1 = median(ar1, n); \n\n\n\n\nint\nm2 = median(ar2, n); \n\n\n\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n}", "index": 115, "complexity": "2"}
{"forwhile": "class GFG { static int binarySearch(int[] arr, int l, int r, int x) { if (r < l) return -1; int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } static int countOccurrences(int[] arr, int n, int x) { int ind = binarySearch(arr, 0, n - 1, x); if (ind == -1) return 0; int count = 1; int left = ind - 1; for (; left >= 0 && arr[left] == x; count++, left--); int right = ind + 1; for (; right < n && arr[right] == x; count++, right++); return count; } public static void main(String[] args) { int arr[] = {1, 2, 2, 2, 2, 3, 4, 7, 8, 8}; int n = arr.length; int x = 2; System.out.print(countOccurrences(arr, n, x)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n\n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n\n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n\n\n\n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n}", "index": 117, "complexity": "2"}
{"forwhile": "n = 1\nlayers = n - 1\ncounter = 0\ni = 1\nwhile i < layers + 1:\n    counter += i\n    i += 1\n\nprint(1 + counter * 4)", "src": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tfor(int i =1 ;i < layers + 1 ; i ++) {\n\t\t\tcounter += i ;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "index": 126, "complexity": "1"}
{"forwhile": "n = int(input())\narr = list(map(int, input().split()))\n\ni = 0\nwhile i < n:\n    arr[i] = -1*arr[i]-1 if arr[i] >= 0 else arr[i]\n    i += 1\n\nif n % 2 == 0:\n    i = 0\n    while i < n:\n        if arr[i] >= 0:\n            arr[i] = -1*arr[i]-1\n        i += 1\nelse:\n    max = float('-inf')\n    maxIndex = 0\n    i = 0\n    while i < n:\n        elem = arr[i]\n        elem = -1*elem-1 if elem < 0 else elem\n        if elem > max:\n            max = elem\n            maxIndex = i\n        i += 1\n    i = 0\n    while i < n:\n        if i == maxIndex:\n            if arr[i] < 0:\n                arr[i] = -1*arr[i]-1\n        else:\n            arr[i] = -1*arr[i]-1 if arr[i] >= 0 else arr[i]\n        i += 1\n\ni = 0\nsb = ''\nwhile i < n:\n    sb += str(arr[i]) + ' '\n    i += 1\nprint(sb)", "src": "public class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 127, "complexity": "1"}
{"forwhile": "n = in.nextInt()\na = in.nextIntArray(n)\nif n % 2 == 0:\n    i = 0\n    while i < n:\n        if a[i] >= 0:\n            a[i] = -a[i] - 1\n        i += 1\nelse:\n    maxi = -1\n    max = -1\n    i = 0\n    while i < n:\n        x = -a[i] - 1 if a[i] >= 0 else a[i]\n        x = -x\n        if x > max:\n            max = x\n            maxi = i\n        i += 1\n    if max == 1:\n        a[0] = 0\n    else:\n        i = 0\n        while i < n:\n            if i == maxi:\n                if a[i] < 0:\n                    a[i] = -a[i] - 1\n            else:\n                if a[i] >= 0:\n                    a[i] = -a[i] - 1\n            i += 1\ni = 0\nwhile i < len(a):\n    out.print(a[i] + \" \")\n    i += 1\nout.close()", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 128, "complexity": "1"}
{"forwhile": "n=sc.nextInt()\na=[]\nk=0\nm=0\ni=0\nwhile i<n:\n    a.append(sc.nextInt())\n    if a[i]>=0:\n        a[i]=-a[i]-1\n    if a[i]<m:\n        m=a[i]\n        k=i\n    i+=1\nif n%2==1:\n    a[k]=-a[k]-1\ni=0\nwhile i<n:\n    print(a[i],end=' ')\n    i+=1", "src": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}", "index": 129, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 130, "complexity": "1"}
{"forwhile": "n=sc.nextInt()\nq=sc.nextInt()\nm=sc.nextInt()\nmax=sc.nextInt()\ni=0\nwhile i<(n-1):\n    inp=sc.nextInt()\n    a.append(max)\n    b.append(inp)\n    if inp>max:\n        c.append(max)\n        max=inp\n    else:\n        c.append(inp)\n    i+=1\ni=0\nwhile i<q:\n    in_q=sc.nextLong()\n    if in_q<n:\n        print(a[in_q-1],b[in_q-1])\n    else:\n        k=in_q%(n-1)-1\n        if k==-1:\n            k=n-2\n        print(max,c[k])", "src": "public class Kello\n{\n    public static void  main(String args[])\n    {\n        Scanner sc =new Scanner(System.in);\n        int n,q,m,max,inp,k,i;\n        long in_q;\n        n=sc.nextInt();\n        q=sc.nextInt();\n        int a[]=new int[n-1];\n        int b[]=new int[n-1];\n        int c[]=new int[n-1];\n        max=sc.nextInt();\n        for(i=0;i<n-1;i++)\n        {\n            inp=sc.nextInt();\n            a[i]=max;\n            b[i]=inp;\n            if(inp>max)\n            {\n                c[i]=max;\n             max=inp;\n        }\n        else\n        c[i]=inp;\n    }\n   \n        for(i=0;i<q;i++)\n        {\n            in_q=sc.nextLong();\n            if(in_q<n)\n            System.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n          else   {\n          k=(int)(in_q %(n-1))-1;\n          if(k==-1)\n          k=n-2;\n          System.out.println(max+\" \"+c[k]);\n            }\n        }\n    }\n    public static void display(int a[],int b[])\n    {\n        int i;\n        for(i=0;i<a.length;i++)\n        System.out.println(a[i]+\" \"+b[i]);\n}\n}", "index": 131, "complexity": "1"}
{"forwhile": "class\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n\n\ni = 0\n;\nwhile (i < n-\n1\n) \n\n{ \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\ni += 1\n; \n\n} \n\nif\n(i == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n\ne = n - \n1\n;\nwhile (e > \n0\n) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\ne -= 1\n; \n\n} \n\n\n\n\nmax = arr[s]; min = arr[s]; \n\ni = s + \n1\n;\nwhile (i <= e) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\ni += 1\n; \n\n} \n\n\n\n\ni = \n0\n;\nwhile (i < s) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\ni += 1\n; \n\n} \n\n\n\n\ni = n -\n1\n;\nwhile (i >= e+\n1\n) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\ni -= 1\n; \n\n} \n\n\n\n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n}", "src": "class\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n\n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n\n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n\n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n}", "index": 132, "complexity": "1"}
{"forwhile": "from collections import deque\nimport sys\nimport math\nfrom array import array\n\nclass FastWriter:\n    def __init__(self):\n        self.bw = sys.stdout\n\n    def print(self, object):\n        self.bw.write(str(object))\n\n    def println(self, object):\n        self.print(object)\n        self.bw.write('\\n')\n\n    def close(self):\n        self.bw.close()\n\nclass FastReader:\n    def __init__(self):\n        self.br = sys.stdin\n        self.st = None\n\n    def next(self):\n        while self.st is None or len(self.st) == 0:\n            self.st = self.br.readline().split()\n        return self.st.pop(0)\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n\n    def nextDouble(self):\n        return float(self.next())\n\n    def nextLine(self):\n        try:\n            return self.br.readline()\n        except:\n            return \"\"\n\n    def nextBigInteger(self):\n        try:\n            return int(self.nextLine())\n        except:\n            raise\n\nfr = FastReader()\nfw = FastWriter()\nn = fr.nextInt()\nq = fr.nextInt()\naa = array('i', [0] * (n - 1))\nab = array('i', [0] * (n - 1))\ndq = deque()\ni = 0\nwhile i < n:\n    dq.append(fr.nextInt())\n    i += 1\ni = 0\nwhile i < n - 1:\n    a = dq.popleft()\n    b = dq.popleft()\n    aa[i] = a\n    ab[i] = b\n    mi = min(a, b)\n    ma = max(a, b)\n    dq.appendleft(ma)\n    dq.append(mi)\n    i += 1\nfm = dq.popleft()\narr = array('i', [0] * (n - 1))\nfor i in range(len(arr)):\n    arr[i] = dq.popleft()\nwhile q > 0:\n    m = fr.nextLong() - 1\n    if m < n - 1:\n        fw.println(str(aa[m]) + ' ' + str(ab[m]))\n    else:\n        m = m % (n - 1)\n        fw.println(str(fm) + ' ' + str(arr[m]))\n    q -= 1\nfw.close()", "src": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}", "index": 133, "complexity": "1"}
{"forwhile": "T = scan.nextInt()\nwhile T > 0:\n    n = scan.nextInt()\n    arr = [0] * n\n    i = 0\n    while i < n:\n        arr[i] = scan.nextInt()\n        i += 1\n    m1 = 1\n    m2 = 1\n    i = 0\n    while i < n:\n        if arr[i] >= m1:\n            m2 = m1\n            m1 = arr[i]\n        elif arr[i] >= m2:\n            m2 = arr[i]\n        i += 1\n    print(min(min(m1, m2) - 1, n - 2))\n    T -= 1", "src": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "index": 134, "complexity": "1"}
{"forwhile": "class   CF111111:\n  in = None\n  as1 = None\n  nums = None\n  nums2 = None\n  nums1 = None\n  con = True\n  ar = []\n  fi = []\n  map = {}\n  @staticmethod\n  def main(args):\n    CF111111()\n  def GCD(self, a, b):\n    if b==0: return a\n    return self.GCD(b,a%b)\n  def LIS(self, arr):\n    n = len(arr)\n    sun = [0]*n\n    cur = 0\n    x = 0\n    while x<n:\n      temp = -1\n      temp = sun[:cur].index(arr[x]) if arr[x] in sun[:cur] else -temp -1\n      sun[temp] = arr[x]\n      if temp == cur: cur += 1\n      x += 1\n    return cur\n  def no(self):\n    print('NO')\n    exit(0)\n  def __init__(self):\n    in1 = None\n    try:\n      in1 = BufferedReader(InputStreamReader(System.in))\n      a = self.nextInt()\n      self.nums = [0]*a\n      max1 = -1\n      index = -1\n      x = 0\n      while x<a:\n        self.nums[x] = self.nextInt()\n        if self.nums[x] > max1:\n          max1 = self.nums[x]\n          index = x\n        x += 1\n      lindex = index-1\n      rindex = index+1\n      done = 1\n      top = max1\n      while True:\n        done += 1\n        if lindex < 0:\n          if self.nums[rindex] > top:\n            self.no()\n          else:\n            top = self.nums[rindex]\n            rindex += 1\n        elif rindex >= a:\n          if self.nums[lindex] > top:\n            self.no()\n          else:\n            top = self.nums[lindex]\n          lindex -= 1\n        else:\n          if self.nums[lindex] > top or self.nums[rindex] > top:\n            self.no()\n          else:\n            if self.nums[lindex] > self.nums[rindex]:\n              top = self.nums[lindex]\n              lindex -= 1\n            else:\n              top = self.nums[rindex]\n              rindex += 1\n        if done == a:\n          print('YES')\n          exit(0)\n    except IOError as e:\n      pass\n  def next(self):\n    while self.as1 == None or not self.as1.hasMoreTokens():\n      self.as1 = StringTokenizer(in1.readLine().strip())\n    return self.as1.nextToken()\n  def nextLong(self):\n    return int(self.next())\n  def nextInt(self):\n    return int(self.next())\n  def nextDouble(self):\n    return float(self.next())\n  def nextLine(self):\n    return in1.readLine().strip()\n", "src": "public class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  public void no()\n  {\n    System.out.println(\"NO\");\n    System.exit(0);\n  }\n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      nums = new int [a];\n      int max = -1;\n      int index = -1;\n     for(int x = 0;x<a;x++)\n     {\n       nums[x] = nextInt();\n       if(nums[x] > max)\n       {\n         max = nums[x];\n         index = x;\n       }\n     }\n      int lindex = index-1;\n      int rindex = index+1;\n      int done = 1;\n      int top = max;\n      for(;;)\n      {\n        done++;\n      \n        if(lindex < 0)\n        {\n           if(nums[rindex] > top)\n           {\n             no();\n           }\n           else\n             top = nums[rindex];\n           rindex++;\n        }\n        else if(rindex >= a)\n        {\n          if(nums[lindex] > top)\n            no();\n          else\n            top = nums[lindex];\n          lindex--;\n        }\n        else\n        {\n          if(nums[lindex] > top || nums[rindex] > top)\n            no();\n          else\n          {\n            if(nums[lindex] > nums[rindex])\n            {\n              top = nums[lindex];\n              lindex--;\n            }\n            else\n            {\n              top = nums[rindex];\n              rindex++;\n            }\n          }\n        }\n        if(done == a)\n        {\n          System.out.println(\"YES\");\n          System.exit(0);\n        }\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "index": 135, "complexity": "1"}
{"forwhile": "n = int(input())\nst = input().split()\na = [0] * n\ni = 0\nwhile i < n:\n    a[i] = int(st[i])\n    i += 1\nmax = 0\ni = 0\nwhile i < n:\n    if i != 0 and a[i] > a[max]:\n        max = i\n    i += 1\nmaxi = max\ni = max - 1\nfor i in range(max-1, -1, -1):\n    if a[i] > a[max]:\n        print(\"NO\")\n        break\n    max = i\nmax = maxi\ni = max + 1\nfor i in range(max+1, n):\n    if a[i] > a[max]:\n        print(\"NO\")\n        break\n    max = i\nelse:\n    print(\"YES\")", "src": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "index": 136, "complexity": "1"}
{"forwhile": "class PairSum { static void constructArr(int arr[], int pair[], int n) { arr[0] = (pair[0]+pair[1]-pair[n-1]) / 2; int i = 1; while (i < n) { arr[i] = pair[i-1]-arr[0]; i++; } } public static void main(String[] args) { int pair[] = {15, 13, 11, 10, 12, 10, 9, 8, 7, 5}; int n = 5; int [] arr = new int[n]; constructArr(arr, pair, n); int i = 0; for (; i < n; i++) System.out.print(arr[i]+\" \"); } }", "src": "class\nPairSum { \n\n\n\n\n\n\nstatic\nvoid\nconstructArr(\nint\narr[], \nint\npair[], \nint\nn) \n\n{ \n\narr[\n0\n] = (pair[\n0\n]+pair[\n1\n]-pair[n-\n1\n]) / \n2\n; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\narr[i] = pair[i-\n1\n]-arr[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\npair[] = {\n15\n, \n13\n, \n11\n, \n10\n, \n12\n, \n10\n, \n9\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = \n5\n; \n\nint\n[] arr = \nnew\nint\n[n]; \n\nconstructArr(arr, pair, n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 137, "complexity": "1"}
{"forwhile": "class GfG { public static int minMaxProduct(int arr1[], int arr2[], int n1, int n2) { int max = arr1[0]; int min = arr2[0]; int i = 1; while(i < n1 && i < n2) { if (arr1[i] > max) max = arr1[i]; if (arr2[i] < min) min = arr2[i]; i++; } for (; i < n1; ) { if (arr1[i] > max) max = arr1[i]; i++; } for (; i < n2; ) { if (arr2[i] < min) min = arr2[i]; i++; } return max * min; } public static void main(String argc[]) { int[] arr1 = new int[]{ 10, 2, 3, 6, 4, 1}; int[] arr2 = new int[]{ 5, 1, 4, 2, 6, 9}; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } }", "src": "class\nGfG \n{ \n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\nint\nmax = arr1[\n0\n]; \n\n\n\n\n\n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n\n\n\n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n\n\n\n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n\n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n}", "index": 138, "complexity": "1"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 801 (char 802)", "src": "class\nGFG { \n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\npublic\nstatic\nvoid\ncommonCharacters(String str[], \n\nint\nn) \n\n{ \n\n\n\n\n\n\nBoolean[] prim = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(prim, \nnew\nBoolean(\ntrue\n)); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nBoolean[] sec = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(sec, \nnew\nBoolean(\nfalse\n)); \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str[i].length(); j++) \n\n{ \n\n\n\n\n\n\nif\n(prim[str[i].charAt(j) - \n'a'\n]) \n\nsec[str[i].charAt(j) - \n'a'\n] = \ntrue\n; \n\n} \n\n\n\n\nSystem.arraycopy(sec, \n0\n, prim, \n0\n, MAX_CHAR); \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n26\n; i++) \n\nif\n(prim[i]){ \n\nSystem.out.print(Character.toChars(i \n\n+ \n97\n)); \n\nSystem.out.print(\n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str[] = { \n\"geeksforgeeks\"\n, \n\n\"gemkstones\"\n, \n\n\"acknowledges\"\n, \n\n\"aguelikes\"\n}; \n\n\nint\nn = str.length; \n\ncommonCharacters(str, n); \n\n} \n}", "index": 139, "complexity": "1"}
{"forwhile": "class GFG { static int MAX_CHAR = 26; static void findAndPrintUncommonChars(String str1, String str2) { int present[] = new int[MAX_CHAR]; int i = 0; while (i < MAX_CHAR) { present[i] = 0; i++; } int l1 = str1.length(); int l2 = str2.length(); i = 0; while (i < l1) { present[str1.charAt(i) - 'a'] = 1; i++; } i = 0;while (i < l2) { if (present[str2.charAt(i) - 'a'] == 1 || present[str2.charAt(i) - 'a'] == -1) {  present[str2.charAt(i) - 'a'] = -1; } else { present[str2.charAt(i) - 'a'] = 2;} i++; } i = 0; while (i < MAX_CHAR) { if (present[i] == 1 || present[i] == 2) { System.out.print((char) (i + 'a') + \" \"); } i++; } } public static void main(String[] args) { String str1 = \"characters\"; String str2 = \"alphabets\"; findAndPrintUncommonChars(str1, str2); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n\n\n\n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n\n\n\n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n\n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n}", "index": 140, "complexity": "1"}
{"forwhile": "class GFG:  def isVowel(ch):  if ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u': return True return False   def createAltStr(str1, str2, start, l): finalStr = '' i = 0 j = start while j < l: finalStr = finalStr + str1[i] + str2[j] i += 1 j += 1 return finalStr  def findAltStr(str): nv = 0 nc = 0 vstr = '' cstr = '' l = len(str) i = 0 while i < l: ch = str[i] if isVowel(ch): nv += 1  vstr = vstr + ch else: nc += 1  cstr = cstr + ch i += 1 if abs(nv - nc) >= 2: return 'no such string' if nv > nc: return vstr[0] + createAltStr(cstr, vstr, 1, nv) if nc > nv: return cstr[0] + createAltStr(vstr, cstr, 1, nc) if cstr[0] < vstr[0]: return createAltStr(cstr, vstr, 0, nv) return createAltStr(vstr, cstr, 0, nc)  def main(args): str = 'geeks' print(findAltStr(str)) main(None)", "src": "class\nGFG \n{ \n\n\nstatic\nboolean\nisVowel(\nchar\nch) \n{ \n\nif\n(ch == \n'a'\n|| ch == \n'e'\n|| ch == \n'i'\n|| \n\nch == \n'o'\n|| ch ==\n'u'\n) \n\nreturn\ntrue\n; \n\nreturn\nfalse\n; \n} \n\n\n\nstatic\nString createAltStr(String str1, String str2, \n\nint\nstart, \nint\nl) \n{ \n\nString finalStr = \n\"\"\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n, j = start; j < l; i++, j++) \n\nfinalStr = (finalStr + str1.charAt(i)) + \n\nstr2.charAt(j); \n\nreturn\nfinalStr; \n} \n\n\n\nstatic\nString findAltStr(String str) \n{ \n\nint\nnv = \n0\n, nc = \n0\n; \n\nString vstr = \n\"\"\n, cstr = \n\"\"\n; \n\nint\nl = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\n{ \n\nchar\nch = str.charAt(i); \n\n\n\n\nif\n(isVowel(ch)) \n\n{ \n\nnv++; \n\nvstr = vstr + ch; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nnc++; \n\ncstr = cstr + ch; \n\n} \n\n} \n\n\n\n\nif\n(Math.abs(nv - nc) >= \n2\n) \n\nreturn\n\"no such string\"\n; \n\n\n\n\n\n\n\n\nif\n(nv > nc) \n\nreturn\n(vstr.charAt(\n0\n) + createAltStr(cstr, vstr, \n1\n, nv)); \n\n\n\n\n\n\n\n\nif\n(nc > nv) \n\nreturn\n(cstr.charAt(\n0\n) + createAltStr(vstr, cstr, \n1\n, nc)); \n\n\n\n\n\n\n\n\nif\n(cstr.charAt(\n0\n) < vstr.charAt(\n0\n)) \n\nreturn\ncreateAltStr(cstr, vstr, \n0\n, nv); \n\n\n\n\nreturn\ncreateAltStr(vstr, cstr, \n0\n, nc); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nString str = \n\"geeks\"\n; \n\nSystem.out.println(findAltStr(str)); \n} \n}", "index": 141, "complexity": "1"}
{"forwhile": "class CountSubString { int countSubStr( char str[], int n) { int m = 0; int i = 0; while(i < n) { if(str[i] == '1') m++; i++; } return m * (m - 1) / 2; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n\n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n}", "index": 142, "complexity": "1"}
{"forwhile": "public class GFG { static final int M = 26; static int getIdx(char ch) { return (ch - 'a'); } static boolean allSame(int freq[], int N) { int same = 0; int i = 0; while (i < N) { if (freq[i] > 0) { same = freq[i]; break; } i++; } int j = i + 1; while (j < N) if (freq[j] > 0 && freq[j] != same) return false; return true; } static boolean possibleSameCharFreqByOneRemoval(String str) { int l = str.length(); int[] freq = new int[M]; int i = 0; while (i < l) { freq[getIdx(str.charAt(i))]++; i++; } if (allSame(freq, M)) return true; char c = 'a'; while (c <= 'z') { int k = getIdx(c); if (freq[k] > 0) { freq[k]--; if (allSame(freq, M)) return true; freq[k]++; } c++; } return false; } public static void main(String args[]) { String str = \"xyyzz\"; if (possibleSameCharFreqByOneRemoval(str)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n\n\n\n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n\n\n\n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n\n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 143, "complexity": "1"}
{"forwhile": "def printMinIndexChar(str, patt): \n    hm = {} \n    minIndex = float('inf') \n    m = len(str) \n    n = len(patt) \n    i = 0 \n    while i < m: \n        if str[i] not in hm: \n            hm[str[i]] = i \n        i += 1 \n    i = 0 \n    while i < n: \n        if patt[i] in hm and hm[patt[i]] < minIndex: \n            minIndex = hm[patt[i]] \n        i += 1 \n    if minIndex != float('inf'): \n        print(\\", "Minimum Index Character = %s": 285, "\\": 262, "     \\                                   ": "\\                                                                                                                                       '\" + str[minIndex]) \n    else: \n        print(\\", "No character present": 200, "                                                                  \\                                   ": "\\", "                     \\                                                                                                                        ": "\\", "                                                                           \\                                   ": "\") \n \nstr = \\", "geeksforgeeks": 268, "                                                                       \\                                   ": "\\", "\" \n \n \npatt = \\": 83, "set": 95, "\" \nprintMinIndexChar(str, patt)": " 314643('$028!%#44#43-433-$*4/72$/2-+/8$$-49/872", "  63$21 4!#$ 4,.!": "                                                     !%", "                                                \\                                   ": "\\", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\n\n\n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 144, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG\\n{ \\n\\nstatic\\nfinal\\nint\\nNO_OF_CHARS = \\n256\\n; \\n\\n\\nstatic\\nint\\n[] getCharCountArray(String str) \\n\\n{ \\n\\nint\\ncount[] = \\nnew\\nint\\n[NO_OF_CHARS]; \\n\\nint\\ni = \\n0\\n; \\nwhile (i < str.length()) \\n\\ncount[str.charAt(i++)]++; \\n\\n\\nreturn\\ncount; \\n\\n} \\n\\n\\n\\nstatic\\nString removeDirtyChars(String str, String mask_str) \\n\\n{ \\n\\nint\\ncount[] = getCharCountArray(mask_str); \\n\\nint\\nip_ind = \\n0\\n, res_ind = \\n0\\n; \\n\\n\\nchar\\narr[] = str.toCharArray(); \\n\\n\\nfor (int ip_ind = 0; ip_ind < arr.length; ip_ind++) \\n\\n{ \\n\\nchar\\ntemp = arr[ip_ind]; \\n\\nif\\n(count[temp] == \\n0\\n) \\n\\n{ \\n\\narr[res_ind++] = arr[ip_ind]; \\n\\n} \\n\\n} \\n\\n\\nstr = \\nnew\\nString(arr); \\n\\n\\n\\n\\nreturn\\nstr.substring(\\n0\\n, res_ind); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nString str = \\n\"geeksforgeeks\"\\n; \\n\\nString mask_str = \\n\"mask\"\\n; \\n\\nSystem.out.println(removeDirtyChars(str, mask_str)); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i<str.length(); i++) \n\ncount[str.charAt(i)]++; \n\n\nreturn\ncount; \n\n} \n\n\n\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nwhile\n(ip_ind != arr.length) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n}", "index": 145, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nclass\\nPair{ \\n\\nchar\\nfirst; \\n\\nint\\nsecond; \\n\\nPair(\\nchar\\nfirst, \\nint\\nsecond){ \\n\\nthis\\n.first = first; \\n\\nthis\\n.second = second; \\n\\n} \\n\\n} \\n\\n\\n\\nstatic\\nint\\nlongestNull(String str) \\n\\n{ \\n\\nArrayList<Pair> arr = \\nnew\\nArrayList<>(); \\n\\n\\n\\n\\narr.add(\\nnew\\nPair(\\n'@'\\n, -\\n1\\n)); \\n\\n\\nint\\nmaxlen = \\n0\\n; \\n\\n\\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile (i < str.length()) \\n\\n{ \\n\\n\\n\\n\\narr.add(\\nnew\\nPair(str.charAt(i), i)); \\n\\n\\n\\n\\nint\\narrSize = arr.size(); \\n\\nfor (int j = arrSize - \\n3\\n; j >= \\n0\\n; j--) \\n\\n{ \\n\\nif (arr.get(j).first == \\n'1'\\n && arr.get(j + \\n1\\n).first == \\n'0'\\n && arr.get(j + \\n2\\n).first == \\n'0'\\n) \\n\\n{ \\n\\nfor (int k = \\n0\\n; k < \\n3\\n; k++) \\n\\n{ \\n\\narr.remove(j); \\n\\n} \\n\\n} \\n\\n} \\n\\nint\\ntmp = arr.get(arr.size() - \\n1\\n).second; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmaxlen = Math.max(maxlen, i - tmp); \\n\\n\\ni++; \\n\\n} \\n\\n\\nreturn\\nmaxlen; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nSystem.out.println(longestNull(\\n\\\"1011100000100\\\"\\n)); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n\n\n\n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n\n\n\n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n\n\n\n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n\n\n\n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n\n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n}", "index": 146, "complexity": "1"}
{"forwhile": "class\\nTest { \\n\\nstatic\\nfinal\\nint\\nMAX_CHAR = \\n26\\n; \\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nint\\ncountPairs(String str) \\n\\n{ \\n\\nint\\nresult = \\n0\\n; \\n\\nint\\nn = str.length(); \\n\\n\\nint\\ni = \\n0\\n;\\nwhile i < n:\\n\\n\\n\\n\\nint\\nj = \\n1\\n;\\nwhile (i + j) < n and j <= MAX_CHAR:\\n\\nif\\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \\n\\nresult++; \\n\\nj += 1\\n\\n\\n\\n\\n\\ni += 1\\n\\n\\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString str = \\n\"geeksforgeeks\"\\n; \\n\\nSystem.out.println(countPairs(str)); \\n\\n} \\n}", "src": "class\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 147, "complexity": "1"}
{"forwhile": "class ReverseArray { static void rvereseArray(int arr[], int start, int end) { int temp; if (start >= end) return; temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; int i = 0; while (i < end-start) { rvereseArray(arr, start+1, end-1); break; } } static void printArray(int arr[], int size) { int i = 0; while (i < size) { System.out.print(arr[i] + \" \"); i += 1; } System.out.println(\"\"); } public static void main(String[] args) { int arr[] = {1, 2, 3, 4, 5, 6}; printArray(arr, 6); rvereseArray(arr, 0, 5); System.out.println(\"Reversed array is \"); printArray(arr, 6); } }", "src": "class\nReverseArray { \n\n\n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n}", "index": 148, "complexity": "1"}
{"forwhile": "class GFG: \n\n\n    MAX_CHARS = 26\n \n    @staticmethod \n    def longestSubseqWithK(str, k): \n\n        n = len(str) \n\n        freq = [0] * GFG.MAX_CHARS \n        i = 0 \n        while i < n: \n            freq[ord(str[i]) - ord('a')] += 1 \n            i += 1 \n\n        i = 0 \n        while i < n: \n            if freq[ord(str[i]) - ord('a')] >= k: \n                print(str[i], end='') \n            i += 1 \n\n    @staticmethod \n    def main(args): \n\n        str = 'geeksforgeeks' \n        k = 2 \n        GFG.longestSubseqWithK(str, k) \n", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n}", "index": 149, "complexity": "1"}
{"forwhile": "def countSubsequences(s): \n    aCount = 0 \n    bCount = 0 \n    cCount = 0 \n    i = 0 \n    while i < len(s): \n        if s[i] == 'a': \n            aCount = (1 + 2 * aCount) \n        elif s[i] == 'b': \n            bCount = (aCount + 2 * bCount) \n        elif s[i] == 'c': \n            cCount = (bCount + 2 * cCount) \n        i += 1 \n    return cCount \n \ndef main(args): \n    s = 'abbc' \n    print(countSubsequences(s)) \n \nmain([])", "src": "public\nclass\nNo_of_subsequence { \n\n\n\n\n\n\nstatic\nint\ncountSubsequences(String s) \n\n{ \n\n\n\n\n\nint\naCount = \n0\n; \n\n\n\n\n\n\n\n\nint\nbCount = \n0\n; \n\n\n\n\n\n\n\n\nint\ncCount = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i< s.length(); i++) \n\n{ \n\n\n\nif\n(s.charAt(i) == \n'a'\n) \n\naCount = (\n1\n+ \n2\n* aCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'b'\n) \n\nbCount = (aCount + \n2\n* bCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'c'\n) \n\ncCount = (bCount + \n2\n* cCount); \n\n} \n\n\nreturn\ncCount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abbc\"\n; \n\nSystem.out.println(countSubsequences(s)); \n\n} \n}", "index": 150, "complexity": "1"}
{"forwhile": "class GFG { \n\n\nstatic int countOccurrences(String s, int K) \n\n{ \n\nint n = s.length(); \n\nint C = 0, c1 = 0, c2 = 0; \n\nint i = 0;\nwhile (i < n) { \n\nif (s.charAt(i) == 'a') \n\nc1++; \n\n\nif (s.charAt(i) == 'b') { \n\nc2++; \n\n\n\n\n\n\n\nC += c1; \n\n} \n\ni++; \n\n} \n\n\n\n\n\n\n\n\nreturn C * K + (K * (K - 1) / 2) * c1 * c2; \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nString S = \"abcb\"; \n\nint k = 2; \n\nfor (int i = 0; i < 1; i++) { \n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n\n} \n}", "src": "class\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n\n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n\n\n\n\n\n\n\nC += c1; \n\n} \n\n} \n\n\n\n\n\n\n\n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n}", "index": 151, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\nstatic\\nint\\nmax = \\n100\\n; \\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\ncountSubsequence(String s, \\nint\\nn) \\n\\n{ \\n\\nint\\ncntG = \\n0\\n, cntF = \\n0\\n, result = \\n0\\n, C=\\n0\\n; \\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile i < n: \\n\\nswitch\\n(s.charAt(i)) { \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\ncase\\n'G'\\n: \\n\\n\\ncntG++; \\n\\nresult+=C; \\n\\nbreak\\n; \\n\\n\\n\\n\\n\\n\\n\\ncase\\n'F'\\n: \\n\\n\\ncntF++; \\n\\nC+=cntG; \\n\\nbreak\\n; \\n\\n\\n\\n\\ndefault\\n: \\n\\ncontinue\\n; \\n\\n} \\ni += 1\\n; \\n\\n} \\n\\n\\nSystem.out.println(result); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) { \\n\\nString s= \\n\"GFGFG\"\\n; \\n\\nint\\nn = s.length(); \\n\\nfor i in range(n): \\n\\n\\ncountSubsequence(s, n); \\n\\n} \\n}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n\n\n\n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nswitch\n(s.charAt(i)) { \n\n\n\n\n\n\n\n\n\n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n\n\n\n\n\n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n\n\ndefault\n: \n\ncontinue\n; \n\n} \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n}", "index": 152, "complexity": "1"}
{"forwhile": "public\\nclass\\nCount_Subsequences { \\n\\n\\nstatic\\nfinal\\nint\\nMAX_CHAR = \\n256\\n; \\n\\n\\n\\nstatic\\nint\\ncountSub(String str) \\n\\n{ \\n\\n\\n\\n\\nint\\n[] last = \\nnew\\nint\\n[MAX_CHAR]; \\n\\nArrays.fill(last, -\\n1\\); \\n\\n\\n\\nint\\nn = str.length(); \\n\\n\\n\\n\\n\\nint\\n[] dp = \\nnew\\nint\\n[n+\\n1\\]; \\n\\n\\n\\ndp[\\n0\\] = \\n1\\; \\n\\n\\n\\nint\\ni=\\n1\\; \\nwhile (i<=n) \\n\\n{ \\n\\n\\n\\n\\ndp[i] = \\n2\\*dp[i-\\n1\\]; \\n\\n\\n\\n\\n\\n\\nif\\n(last[(\\nint\\)str.charAt(i-\\n1\\)] != -\\n1\\) \\n\\ndp[i] = dp[i] - dp[last[(\\nint\\)str.charAt(i-\\n1\\)]]; \\n\\n\\n\\nlast[(\\nint\\)str.charAt(i-\\n1\\)] = (i-\\n1\\); \\n\\ni++; \\n} \\n\\n\\nreturn\\ndp[n]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nSystem.out.println(countSub(\\n\\\"gfg\\\"\\)); \\n\\n} \\n}", "src": "public\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n\n\nstatic\nint\ncountSub(String str) \n\n{ \n\n\n\n\n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n\n\nint\nn = str.length(); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\n\n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n\n\n\n\n\n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n\n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n}", "index": 153, "complexity": "1"}
{"forwhile": "class UglyNumber {\n\n\nint getNthUglyNo(int n) {\n\nint ugly[] = new int[n];\n\n\nint i2 = 0, i3 = 0, i5 = 0;\n\nint next_multiple_of_2 = 2;\n\nint next_multiple_of_3 = 3;\n\nint next_multiple_of_5 = 5;\n\nint next_ugly_no = 1;\n\n\nugly[0] = 1;\n\n\nint i = 1;\nwhile (i < n) {\n\nnext_ugly_no = Math.min(next_multiple_of_2, Math.min(next_multiple_of_3, next_multiple_of_5));\n\n\nugly[i] = next_ugly_no;\n\nif (next_ugly_no == next_multiple_of_2) {\n\ni2 = i2 + 1;\n\nnext_multiple_of_2 = ugly[i2] * 2;\n\n}\n\nif (next_ugly_no == next_multiple_of_3) {\n\ni3 = i3 + 1;\n\nnext_multiple_of_3 = ugly[i3] * 3;\n\n}\n\nif (next_ugly_no == next_multiple_of_5) {\n\ni5 = i5 + 1;\n\nnext_multiple_of_5 = ugly[i5] * 5;\n\n}\n\ni++;\n\n}\n\n\nreturn next_ugly_no;\n\n}\n\n\n\npublic static void main(String args[]) {\n\nint n = 150;\n\nUglyNumber obj = new UglyNumber();\n\nSystem.out.println(obj.getNthUglyNo(n));\n\n}\n}", "src": "class\nUglyNumber \n{ \n\n\n\nint\ngetNthUglyNo(\nint\nn) \n\n{ \n\nint\nugly[] = \nnew\nint\n[n]; \n\n\nint\ni2 = \n0\n, i3 = \n0\n, i5 = \n0\n; \n\nint\nnext_multiple_of_2 = \n2\n; \n\nint\nnext_multiple_of_3 = \n3\n; \n\nint\nnext_multiple_of_5 = \n5\n; \n\nint\nnext_ugly_no = \n1\n; \n\n\nugly[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nnext_ugly_no = Math.min(next_multiple_of_2, \n\nMath.min(next_multiple_of_3, \n\nnext_multiple_of_5)); \n\n\nugly[i] = next_ugly_no; \n\nif\n(next_ugly_no == next_multiple_of_2) \n\n{ \n\ni2 = i2+\n1\n; \n\nnext_multiple_of_2 = ugly[i2]*\n2\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_3) \n\n{ \n\ni3 = i3+\n1\n; \n\nnext_multiple_of_3 = ugly[i3]*\n3\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_5) \n\n{ \n\ni5 = i5+\n1\n; \n\nnext_multiple_of_5 = ugly[i5]*\n5\n; \n\n} \n\n} \n\n\nreturn\nnext_ugly_no; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n150\n; \n\nUglyNumber obj = \nnew\nUglyNumber(); \n\nSystem.out.println(obj.getNthUglyNo(n)); \n\n} \n}", "index": 154, "complexity": "1"}
{"forwhile": "def permutationCoeff(n, k):\n    fact = [0] * (n + 1)\n    fact[0] = 1\n    i = 1\n    while i <= n:\n        fact[i] = i * fact[i - 1]\n        i += 1\n    return fact[n] // fact[n - k]\n\ndef main():\n    n = 10\n    k = 2\n    print(\"Value of P( \", n, \", \", k, \") is \", permutationCoeff(n, k))\n\nmain()", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n\n\nfact[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n\n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 155, "complexity": "1"}
{"forwhile": "class GFG { int countFriendsPairings(int n) { int dp[] = new int[n + 1]; int i = 0; while (i <= n) { if (i <= 2) dp[i] = i; else dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]; i++; } return dp[n]; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 156, "complexity": "1"}
{"forwhile": "public\\nclass\\nTest \\n{ \\n\\nstatic\\nint\\narr[] = \\nnew\\nint\\n[]{\\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n}; \\n\\n\\n\\n\\nstatic\\nvoid\\nrotate() \\n\\n{ \\n\\nint\\nx = arr[arr.length-\\n1\\], i; \\n\\ni = arr.length-\\n1\\;\\nwhile i > \\n0\\n: \\n\\narr[i] = arr[i-\\n1\\]; \\n\\narr[\\n0\\n] = x; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nSystem.out.println(\\n\\\"Given Array is\\\"\\n); \\n\\nSystem.out.println(Arrays.toString(arr)); \\n\\n\\nrotate(); \\n\\n\\nSystem.out.println(\\n\\\"Rotated Array is\\\"\\n); \\n\\nSystem.out.println(Arrays.toString(arr)); \\n\\n} \\n}", "src": "public\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n\n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n}", "index": 157, "complexity": "1"}
{"forwhile": "class GFG { static int[] dp = new int[1000]; static int countFriendsPairings(int n) { if(dp[n] != -1) return dp[n]; if(n > 2) { int i = 0; while (i < 1000) { dp[i] = -1; i++; } i = 4; int total = 0; for (i in range(4, n+1): total += countFriendsPairings(i - 1) + (i - 1) * countFriendsPairings(i - 2); return dp[n] = total; } else return dp[n] = n; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 158, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\nstatic\\nint\\nsequence(\\nint\\nn) \\n\\n{ \\n\\n\\n\\nint\\nf[] = \\nnew\\nint\\n[n + \\n1\\]; \\n\\n    f[\\n0\\] = \\n0\\n; \\n\\n    f[\\n1\\] = \\n1\\n; \\n\\n    f[\\n2\\] = \\n1\\n; \\n\\n\\nint\\ni; \\n\\n\\ni = \\n3\\n; \\nwhile i <= n: \\n    f[i] = f[f[i - \\n1\\]] + \\n\\n        f[i - f[i - \\n1\\]]; \\n    i += 1\\n\\n\\nreturn\\nf[n]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\n    int\\nn = \\n10\\n; \\n\\n    System.out.println(sequence(n)); \\n\\n\\n} \\n}", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n\n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n}", "index": 160, "complexity": "1"}
{"forwhile": "class RearrangeArray { void rearrangeNaive(int arr[], int n) { int temp[] = new int[n]; int i = 0; while(i < n) temp[arr[i]] = i; i = 0; while(i < n) arr[i] = temp[i]; } void printArray(int arr[], int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i += 1; } System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = { 1 , 3 , 0 , 2 }; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrangeNaive(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "class\nRearrangeArray { \n\n\n\n\n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 161, "complexity": "1"}
{"forwhile": "class GFG: \n\n\n\n\nstatic int maxSumWO3Consec(int arr[], int n) \n\n{ \n\n\n\n\nint sum[] = new int[n]; \n\n\n\n\nif (n >= 1) \n\nsum[0] = arr[0]; \n\n\nif (n >= 2) \n\nsum[1] = arr[0] + arr[1]; \n\n\nif (n > 2) \n\nsum[2] = Math.max(sum[1], Math.max(arr[1] + arr[2], arr[0] + arr[2])); \n\n\n\n\n\n\n\n\n\n\n\nint i = 3; \nwhile i < n: \n\nsum[i] = Math.max(Math.max(sum[i - 1], sum[i - 2] + arr[i]), \n\narr[i] + arr[i - 1] + sum[i - 3]); \n\ni += 1 \n\n\nreturn sum[n - 1]; \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nint arr[] = { 100, 1000, 100, 1000, 1}; \n\nint n = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n\n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n}", "index": 162, "complexity": "1"}
{"forwhile": "class GFG { static int maximumSegments(int n, int a, int b, int c) { int dp[] = new int[n + 10]; Arrays.fill(dp, -1); dp[0] = 0; int i = 0; while (i < n) { if (dp[i] != -1) { if (i + a <= n) dp[i + a] = Math.max(dp[i] + 1, dp[i + a]); if (i + b <= n) dp[i + b] = Math.max(dp[i] + 1, dp[i + b]); if (i + c <= n) dp[i + c] = Math.max(dp[i] + 1, dp[i + c]); } i++; } return dp[n]; } public static void main(String arg[]) { int n = 7, a = 5, b = 2, c = 5; System.out.print(maximumSegments(n, a, b, c)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n\n\nArrays.fill(dp, -\n1\n); \n\n\n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n\n\nif\n(i + a <= n ) \n\n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n\n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n\n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n}", "index": 164, "complexity": "1"}
{"forwhile": "class\\nRearrangeArray { \\n\\n\\n\\n\\n\\nvoid\\nrearrangeUtil(\\nint\\narr[], \\nint\\nn, \\nint\\ni) \\n\\n{ \\n\\n\\n\\n\\nint\\nval = -(i + \\n1\\); \\n\\n\\n\\n\\ni = arr[i] - \\n1\\; \\n\\n\\n\\nint\\nlimit = 0; \\nwhile\\n(limit < n) { \\n\\n\\n\\nint\\nnew_i = arr[i] - \\n1\\; \\n\\n\\n\\narr[i] = val; \\n\\n\\n\\nval = -(i + \\n1\\); \\n\\ni = new_i; \\n\\nlimit++; \\n} \\n\\n} \\n\\n\\n\\n\\nvoid\\nrearrange(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\nint\\ni = 0; \\n\\nfor\\n(; i < n; ) \\n{ \\n\\narr[i]++; \\n i++; \\n} \\n\\n\\nlimit = 0; \\nfor\\n(; limit < n; ) { \\n\\n\\n\\nif\\n(arr[i] > \\n0\\) \\n\\nrearrangeUtil(arr, n, i); \\n\\n\\nlimit++; \\n} \\n\\n\\n\\n\\nfor\\n(i = \\n0\\; i < n; i++) \\n\\narr[i] = (-arr[i]) - \\n1\\; \\n\\n} \\n\\n\\n\\nvoid\\nprintArray(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\nint\\ni = 0; \\nfor\\n(; i < n; ) \\n{ \\nSystem.out.print(arr[i] + \\n \\); \\nSystem.out.println(\\n\\); \\n\\ni++; \\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nRearrangeArray arrange = \\nnew\\nRearrangeArray(); \\n\\nint\\narr[] = { \\n2\\, \\n0\\, \\n1\\, \\n4\\, \\n5\\, \\n3\\}; \\n\\nint\\nn = arr.length; \\n\\n\\nSystem.out.println(\\nGiven array is \\); \\narrange.printArray(arr, n); \\n\\n\\narrange.rearrange(arr, n); \\n\\n\\nSystem.out.println(\\nModified array is \\); \\n\\narrange.printArray(arr, n); \\n\\n} \\n}", "src": "class\nRearrangeArray { \n\n\n\n\n\n\n\n\n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n\n\n\n\n\nint\nval = -(i + \n1\n); \n\n\n\n\n\n\ni = arr[i] - \n1\n; \n\n\n\n\nwhile\n(arr[i] > \n0\n) { \n\n\n\n\n\nint\nnew_i = arr[i] - \n1\n; \n\n\n\n\narr[i] = val; \n\n\n\n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n\n\n\n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\n\n\n\n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 165, "complexity": "1"}
{"forwhile": "class GFG { final int MAX = 1000000; static int breakSum(int n) { int dp[] = new int[n+1]; dp[0] = 0; dp[1] = 1; int i = 2; while(i <= n) { dp[i] = Math.max(dp[i/2] + dp[i/3] + dp[i/4], i); i++; } return dp[n]; } public static void main (String[] args) { int n = 24; System.out.println(breakSum(n)); } }", "src": "class\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n\n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n}", "index": 166, "complexity": "1"}
{"forwhile": "class GFG { public static int maxSum( int grid[][], int n) { int incl = Math.max(grid[0][0], grid[1][0]); int excl = 0, excl_new; int i = 1; while( i < n ) { excl_new = Math.max(excl, incl); incl = excl + Math.max(grid[0][i], grid[1][i]); excl = excl_new; i++; } return Math.max(excl, incl); } public static void main(String[] args) { int grid[][] = {{ 1, 2, 3, 4, 5}, { 6, 7, 8, 9, 10}}; int n = 5; System.out.println(maxSum(grid, n)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n\n\n\n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n\n\nint\nexcl = \n0\n, excl_new; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n\n\n\n\nexcl_new = Math.max(excl, incl); \n\n\n\n\n\n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n\n\nexcl = excl_new; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n}", "index": 167, "complexity": "1"}
{"forwhile": "class GFG { public static int findLength(String str, int n) { int current_sum = 0; int max_sum = 0; int i = 0; while(i < n) { current_sum += (str.charAt(i) == '0' ? 1 : -1); if(current_sum < 0) current_sum = 0; max_sum = Math.max(current_sum, max_sum); i++; } return max_sum == 0 ? -1 : max_sum; } public static void main(String[] args) { String str = \"11000010001\"; int n = str.length(); System.out.println(findLength(str, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n\n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n\n\n\n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n}", "index": 168, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG{ \\npublic\\nstatic\\nint\\nminTimeForWritingChars(\\nint\\nN, \\n int\\ninsert, \\n\\nint\\nremove, \\nint\\ncopy) \\n\\n{ \\n\\n if(N == \\n 0\\n) \\n\\n return\\n0\\n; \\n\\n if(N == \\n 1\\n) \\n\\n return\\ninsert; \\n\\n int\\ndp[] = \\nnew\\nint\\n[N + \\n 1\\n]; \\n\\n int\\ni = \\n 1\\n; \\n while(i <= N)\\n { \\n\\n if(i % \\n 2\\n== \\n 0\\n) \\n\\ndp[i] = Math.min(dp[i-\\n 1\\n] + insert, dp[i/\\n 2\\n] + copy); \\n\\n else\\n\\n dp[i] = Math.min(dp[i-\\n 1\\n] + insert, \\n\\ndp[(i+\\n 1\\n)/\\n 2\\n] + copy + remove); \\n i++; \\n } \\n\\n return\\ndp[N]; \\n\\n} \\n\\n public\\nstatic\\nvoid\\nmain(String []args) \\n\\n{ \\n\\n int\\nN = \\n 9\\n; \\n\\n int\\ninsert = \\n 1\\n, remove = \\n 2\\n, copy = \\n 1\\n; \\n\\n System.out.println(minTimeForWritingChars(N, insert,remove, copy)); \\n\\n} \\n\\n}", "src": "public\nclass\nGFG{ \n\n\n\n\n\n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n\n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n\n}", "index": 169, "complexity": "1"}
{"forwhile": "class GFG{\n\n\n\npublic static int sumOfSubstrings(String num) \n\n{\n\nint n = num.length(); \n\nint sumofdigit[] = new int [n]; \n\nsumofdigit[0] = num.charAt(0)-'0'; \n\nint res = sumofdigit[0]; \n\nint i = 1; \n\nwhile (i < n) \n\n{\n\nint numi = num.charAt(i)-'0'; \n\nsumofdigit[i] = (i+1) * numi + 10* sumofdigit[i-1]; \n\nres += sumofdigit[i]; \n\ni++; \n\n} \n\nreturn res; \n\n} \n\npublic static void main(String[] args) \n\n{\n\nString num = \"1234\"; \n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n}", "src": "class\nGFG{ \n\n\n\n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n\n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n\n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n\n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n\n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n}", "index": 170, "complexity": "1"}
{"forwhile": "class GFG { static int maxLoot(int hval[], int n) { if (n == 0) return 0; if (n == 1) return hval[0]; if (n == 2) return Math.max(hval[0], hval[1]); int[] dp = new int[n]; dp[0] = hval[0]; dp[1] = Math.max(hval[0], hval[1]); int i = 2; while (i < n) { dp[i] = Math.max(hval[i] + dp[i - 2], dp[i - 1]); i++; } return dp[n - 1]; } public static void main(String[] args) { int hval[] = {6, 7, 1, 3, 8, 2, 4}; int n = hval.length; System.out.println(\"Maximum loot value : \" + maxLoot(hval, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 171, "complexity": "1"}
{"forwhile": "class GFG { static int maxLoot(int hval[], int n) { if (n == 0) return 0; int value1 = hval[0]; if (n == 1) return value1; int value2 = Math.max(hval[0], hval[1]); if (n == 2) return value2; int max_val = 0; int i=2; while (i<n) { max_val = Math.max(hval[i]+value1, value2); value1 = value2; value2 = max_val; i++; } return max_val; } public static void main (String[] args) { int hval[] = {6, 7, 1, 3, 8, 2, 4}; int n = hval.length; System.out.println(\"Maximum loot value : \"+ maxLoot(hval, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n\n\nint\nmax_val = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 172, "complexity": "1"}
{"forwhile": "class GFG { static int countWays(int n) { int DP[] = new int[n + 1]; DP[0] = DP[1] = DP[2] = 1; DP[3] = 2; int i = 4; while (i <= n) { DP[i] = DP[i - 1] + DP[i - 3] + DP[i - 4]; i++; } return DP[n]; } public static void main(String[] args) { int n = 10; System.out.println(countWays(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n\n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n}", "index": 173, "complexity": "1"}
{"forwhile": "dp = [[0]*(n+1) for _ in range(2)]; dp[0][1] = 1; dp[1][1] = 2; i = 2; while i <= n: dp[0][i] = dp[0][i - 1] + dp[1][i - 1]; dp[1][i] = dp[0][i - 1] * 2 + dp[1][i - 1]; i += 1; result = dp[0][n] + dp[1][n]; n = 5; print(\"Total no of ways with n = \", n, \" are: \", result);", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n\n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n\n\n\n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n\n\n\n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n}", "index": 174, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\nstatic\\nint\\ncountWays(\\nint\\nn, \\nint\\nm) \\n\\n{ \\n\\n\\n\\n\\nint\\ncount[] = \\nnew\\nint\\n[n + \\n1\\]; \\n\\n\\n\\n\\nint\\ni = \\n1\\n; \\n\\nwhile i <= n: \\n\\n\\n\\nif\\n(i > m) \\n\\n\\ncount[i] = count[i - \\n1\\] + count[i - m]; \\n\\n\\n\\nelse\\nif\\n(i < m) \\n\\n\\ncount[i] = \\n1\\n; \\n\\n\\n\\nelse\\n\\ncount[i] = \\n2\\n; \\n\\n\\ni += \\n1\\n; \\n\\n\\n\\n\\n\\nreturn\\ncount[n]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\nn = \\n7\\n; \\n\\nint\\nm = \\n4\\n; \\n\\nSystem.out.println(\\n\\", "src": "class\nGFG { \n\n\n\nstatic\nint\ncountWays(\nint\nn, \nint\nm) \n\n{ \n\n\n\n\n\nint\ncount[] = \nnew\nint\n[n + \n1\n]; \n\ncount[\n0\n] = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n1\n; i <= n; i++) { \n\n\n\nif\n(i > m) \n\ncount[i] = count[i - \n1\n] + count[i - m]; \n\n\n\n\nelse\nif\n(i < m) \n\ncount[i] = \n1\n; \n\n\n\n\nelse\n\ncount[i] = \n2\n; \n\n} \n\n\n\n\nreturn\ncount[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n7\n; \n\nint\nm = \n4\n; \n\nSystem.out.println(\n\"Number of ways = \"\n\n+ countWays(n, m)); \n\n} \n}", "index": 175, "complexity": "1"}
{"forwhile": "class Grid {\n\n\n\n\n\nstatic int count(int n) {\n\n\n\nint[] dp = new int[n+1]; \n\ndp[0] = 0; \n\n\n\nint i = 1; \n\nwhile (i <= n) {\n\n\n\nif (i >= 1 && i <= 3) \n\ndp[i] = 1;\n\nelse if (i == 4) \n\ndp[i] = 2;\n\n\nelse {\n\n\n\n\n\n\n\ndp[i] = dp[i-1] + dp[i - 4]; \n\n}\n\ni++;\n\n} \n\nreturn dp[n]; \n\n}\n\n\n\n\npublic static void main(String[] args) {\n\nint n = 5; \n\nSystem.out.println(\"Count of ways is: \" + count(n)); \n\n}\n}", "src": "class\nGrid \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n\n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n\n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n}", "index": 176, "complexity": "1"}
{"forwhile": "class GFG { static int nonDecNums(int n) { int[][] a = new int[n + 1][10]; int i = 0; while (i <= 9) { a[0][i] = 1; i++; } i = 1; while (i <= n) { a[i][9] = 1; i++; } i = 1; while (i <= n) { int j = 8; while (j >= 0) { a[i][j] = a[i - 1][j] + a[i][j + 1]; j--; } i++; } return a[n][0]; } public static void main(String[] args) { int n = 2; System.out.println(\"Non-decreasing digits = \" + nonDecNums(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n}", "index": 177, "complexity": "1"}
{"forwhile": "class GFG {  static int maxRevenue( int m, int[] x,  int[] revenue,  int n,  int t) {   int[] maxRev = new int[m + 1];   int i = 0;  while i < m + 1:  maxRev[i] = 0  i += 1    int nxtbb = 0;   i = 1;  while i <= m:    if nxtbb < n:     if x[nxtbb] != i:      maxRev[i] = maxRev[i - 1]     else:      if i <= t:       maxRev[i] = Math.max(maxRev[i - 1], revenue[nxtbb])      else:       maxRev[i] = Math.max(maxRev[i - t - 1] + revenue[nxtbb], maxRev[i - 1])       nxtbb += 1    else:     maxRev[i] = maxRev[i - 1]     i += 1   return maxRev[m];  }   public static void main(String []args) {  int m = 20;  int[] x = new int[]{ 6 , 7 , 12 , 13 , 14 };  int[] revenue = new int[]{ 5 , 6 , 5 , 3 , 1 };  int n = x.length;  int t = 5;  System.out.println(maxRevenue(m, x, revenue, n, t));  } }", "src": "class\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n\n\n\n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n\n\n\n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n\n\n\n\nif\n(nxtbb < n) \n\n{ \n\n\n\n\n\n\n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n\n\n\n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n\npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n}", "index": 178, "complexity": "1"}
{"forwhile": "public\\nclass\\nMain { \\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nrearrange(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\nint\\nmax_ele = arr[n - \\n1\\]; \\n\\nint\\nmin_ele = arr[\\n0\\]; \\n\\n\\nint\\ni = \\n0\\;\\nwhile\\ni < n:\\n{\\n\\n\\nif\\n(i % \\n2\\ == \\n0\\):\\n{\\n\\narr[i] = max_ele; \\n\\nmax_ele -= \\n1\\; \\n\\n}\\n\\n\\nelse:\\n{\\n\\narr[i] = min_ele; \\n\\nmin_ele += \\n1\\; \\n\\n}\\n\\ni += \\n1\\;\\n}\\n}\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\, \\n2\\, \\n3\\, \\n4\\, \\n5\\, \\n6\\, \\n7\\, \\n8\\, \\n9\\}; \\n\\nint\\nn = arr.length; \\n\\n\\nSystem.out.println(\\n\"Original Array\"\\n); \\n\\n\\nint\\ni = \\n0\\;\\nwhile\\ni < n:\\n{\\n\\nSystem.out.print(arr[i] + \\n\" \"\\); \\n\\ni += \\n1\\;\\n}\\n\\n\\nrearrange(arr, n); \\n\\n\\nSystem.out.print(\\n\"\\\\nModified Array\\\\n\"\\n); \\n\\n\\nint\\ni = \\n0\\;\\nwhile\\ni < n:\\n{\\n\\nSystem.out.print(arr[i] + \\n\" \"\\); \\n\\ni += \\n1\\;\\n}\\n\\n}\\n}", "src": "public\nclass\nMain { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n\n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 179, "complexity": "1"}
{"forwhile": "class GFG { static int max(int x, int y) { return (x > y ? x : y); } static int maxTasks(int[] high, int[] low, int n) { int[] task_dp = new int[n + 1]; task_dp[0] = 0; task_dp[1] = high[0]; int i = 2; while (i <= n) { task_dp[i] = Math.max(high[i - 1] + task_dp[i - 2], low[i - 1] + task_dp[i - 1]); i++; } return task_dp[n]; } public static void main(String[] args) { int n = 5; int[] high = {3, 6, 8, 7, 6}; int[] low = {1, 5, 4, 5, 3}; System.out.println(maxTasks(high, low, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n\n\nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n\n\n\n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n\n\ntask_dp[\n0\n] = \n0\n; \n\n\n\n\n\n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n}", "index": 181, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\n\\nstatic\\nvoid\\nsegregateElements(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\nint\\ntemp[] = \\nnew\\nint\\n[n]; \\n\\n\\n\\n\\nint\\nj = \\n0\\n; \\n\\n\\nint\\ni = \\n0\\n;\\nwhile\\ni < n:\\nif\\n(arr[i] >= \\n0\\n) \\n\\n\\ntemp[j++] = arr[i]; \\n\\n\\n\\n\\ni += \\n1\\n;\\nwhile\\ni < n:\\nif\\n(j == n or j == \\n0\\n) \\n\\n\\nreturn\\n; \\n\\n\\nint\\ni = \\n0\\n;\\nwhile\\ni < n:\\nif\\n(arr[i] < \\n0\\n) \\n\\n\\ntemp[j++] = arr[i]; \\n\\n\\n\\n\\nint\\ni = \\n0\\n;\\nwhile\\ni < n:\\narr[i] = temp[i]; \\n\\n\\n}\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String arg[]) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, -\\n1\\n, -\\n3\\n, -\\n2\\n, \\n7\\n, \\n5\\n, \\n11\\n, \\n6\\n}; \\n\\nint\\nn = arr.length; \\n\\n\\nsegregateElements(arr, n); \\n\\n\\nint\\ni = \\n0\\n;\\nwhile\\ni < n:\\nSystem.out.print(arr[i] + \\n\" \"); \\n\\ni += \\n1\\n;\\n} \\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n\n\n\n\nint\nj = \n0\n; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\n\n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 182, "complexity": "1"}
{"forwhile": "class GFG { static void rearrange(int arr[], int n) { int temp; int i = 0; while (i < n - 1) { if (i % 2 == 0 && arr[i] > arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } if (i % 2 != 0 && arr[i] < arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } i++; } } static void printArray(int arr[], int size) { int i = 0; for ( ; i < size; i++) System.out.print(arr[i] + \" \"); System.out.println(); } public static void main(String[] args) { int arr[] = { 6, 4, 2, 1, 8, 3 }; int n = arr.length; System.out.print(\"Before rearranging: \\n\"); printArray(arr, n); rearrange(arr, n); System.out.print(\"After rearranging: \\n\"); printArray(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 186, "complexity": "1"}
{"forwhile": "class Solution: \n\n    class Node: \n        \n        def __init__(self): \n            self.data = None \n            self.left = None \n            self.right = None \n           \n    temp = Node() \n    \n    def newNode(data): \n        temp = Node() \n        temp.data = data \n        temp.left = temp.right = None \n        return temp \n    \n    def leftMostNode(node): \n        while node is not None and node.left is not None: \n            node = node.left \n        return node \n    \n    def rightMostNode(node): \n        while node is not None and node.right is not None: \n            node = node.right \n        return node \n    \n    def findInorderRecursive(root, x): \n        if root is None: \n            return None \n        \n        if root == x or (temp := findInorderRecursive(root.left, x)) is not None or (temp := findInorderRecursive(root.right, x)) is not None: \n            if temp is not None: \n                if root.left == temp: \n                    print(\\", "Inorder Successor of \\": " + str(x.data), end='') \n            print(\",  ", " is ": " + str(inorderSucc.data)) \n        \n        if x.right is None: \n            f = 0 \n            rightMost = rightMostNode(root) \n            if rightMost == x: \n                print(\",  ", "No inorder successor! Right most node. ": ", end='\\n') \n            else: \n                findInorderRecursive(root, x) \n    \n    root = newNode(1) \n    root.left = newNode(2) \n    root.right = newNode(3) \n    root.left.left = newNode(4) \n    root.left.right = newNode(5) \n    root.right.right = newNode(6) \n    \n    inorderSuccesor(root, root.right) \n    inorderSuccesor(root, root.left.left) \n    inorderSuccesor(root, root.right.right) \n}", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode temp = \nnew\nNode(); \n\n\nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n\nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n\n\nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n\n\nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n\n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n\n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n\n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\n\n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n\n\ninorderSuccesor(root, root.right); \n\n\n\n\ninorderSuccesor(root, root.left.left); \n\n\n\n\ninorderSuccesor(root, root.right.right); \n\n} \n}", "index": 187, "complexity": "1"}
{"forwhile": "class Node: \n    def __init__(self, item): \n        self.data = item \n        self.left = None \n        self.right = None \n\n\nclass BinaryTree: \n    root = None \n\n    def printSpiral(self, node): \n        if node == None: \n            return \n        \n        s1 = [] \n        s2 = [] \n        \n        s1.append(node) \n\n        while s1 or s2: \n            while s1: \n                temp = s1[-1] \n                s1 = s1[:-1] \n                print(temp.data, end=' ') \n                \n                if temp.right != None: \n                    s2.append(temp.right) \n                if temp.left != None: \n                     s2.append(temp.left) \n            \n            while s2: \n                temp = s2[-1] \n                s2 = s2[:-1] \n                print(temp.data, end=' ') \n                \n                if temp.left != None: \n                    s1.append(temp.left) \n                if temp.right != None: \n                    s1.append(temp.right) \n    \n\nif __name__ == '__main__': \n    tree = BinaryTree() \n    tree.root = Node(1) \n    tree.root.left = Node(2) \n    tree.root.right = Node(3) \n    tree.root.left.left = Node(7) \n    tree.root.left.right = Node(6) \n    tree.root.right.left = Node(5) \n    tree.root.right.right = Node(4) \n    \n    print('Spiral Order traversal of Binary Tree is ') \n    tree.printSpiral(tree.root) ", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n\n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n\n\ns1.push(node); \n\n\n\n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n\n\n\n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n\n\n\n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n}", "index": 190, "complexity": "1"}
{"forwhile": "class GFG: \n\n    class Node: \n\n        def __init__(self, data): \n            self.data = data \n            self.left = None \n            self.right = None \n\n    def levelOrder(root): \n        if root is None: \n            return \n        \n        q = [] \n        q.append(root) \n        q.append(None) \n        \n        curr = q.pop(0) \n        while len(q) > 0: \n            if curr is None: \n                if len(q) > 0: \n                    q.append(None) \n                    print() \n            else: \n                if curr.left is not None: \n                    q.append(curr.left) \n                if curr.right is not None: \n                    q.append(curr.right) \n                print(curr.data, end=' ') \n            curr = q.pop(0) \n\n    def main(args): \n        root = GFG.Node(1) \n        root.left = GFG.Node(2) \n        root.right = GFG.Node(3) \n        root.left.left = GFG.Node(4) \n        root.left.right = GFG.Node(5) \n        root.right.right = GFG.Node(6) \n        levelOrder(root) \n\n    if __name__ == '__main__': \n        main(None)", "src": "public\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n\n\nq.add(root); \n\n\n\n\nq.add(\nnull\n); \n\n\n\n\n\n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n\n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n}", "index": 191, "complexity": "1"}
{"forwhile": "ERROR:Expecting ':' delimiter: line 2 column 1729 (char 1730)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n\n\n\n\n\n\n\n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n\n\nif\n(node.right != \nnull\n) \n\n\n\nQ.add(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n\n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n}", "index": 192, "complexity": "1"}
{"forwhile": "class Node: \n\n    def __init__(self, item): \n        self.data = item \n        self.left = None\n        self.right = None\n\n\nclass BinaryTree: \n\n    def printSpecificLevelOrder(self, node): \n        if node is None:\n            return\n\n        print(node.data, end='')\n        if node.left is not None:\n            print(' ' + str(node.left.data) + ' ' + str(node.right.data), end='')\n\n        if node.left.left is None:\n            return\n\n        q = []\n        q.append(node.left)\n        q.append(node.right)\n\n        while q: \n            first = q[0]\n            q.pop(0)\n            second = q[0]\n            q.pop(0)\n\n            print(' ' + str(first.left.data) + ' ' + str(second.right.data), end='')\n            print(' ' + str(first.right.data) + ' ' + str(second.left.data), end='')\n\n            if first.left.left is not None:\n                q.append(first.left)\n                q.append(second.right)\n                q.append(first.right)\n                q.append(second.left)\n\n    \nif __name__ == '__main__': \n    tree = BinaryTree()\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(5)\n    tree.root.right.left = Node(6)\n    tree.root.right.right = Node(7)\n    tree.root.left.left.left = Node(8)\n    tree.root.left.left.right = Node(9)\n    tree.root.left.right.left = Node(10)\n    tree.root.left.right.right = Node(11)\n    tree.root.right.left.left = Node(12)\n    tree.root.right.left.right = Node(13)\n    tree.root.right.right.left = Node(14)\n    tree.root.right.right.right = Node(15)\n    tree.root.left.left.left.left = Node(16)\n    tree.root.left.left.left.right = Node(17)\n    tree.root.left.left.right.left = Node(18)\n    tree.root.left.left.right.right = Node(19)\n    tree.root.left.right.left.left = Node(20)\n    tree.root.left.right.left.right = Node(21)\n    tree.root.left.right.right.left = Node(22)\n    tree.root.left.right.right.right = Node(23)\n    tree.root.right.left.left.left = Node(24)\n    tree.root.right.left.left.right = Node(25)\n    tree.root.right.left.right.left = Node(26)\n    tree.root.right.left.right.right = Node(27)\n    tree.root.right.right.left.left = Node(28)\n    tree.root.right.right.left.right = Node(29)\n    tree.root.right.right.right.left = Node(30)\n    tree.root.right.right.right.right = Node(31)\n\n    print('Specific Level Order traversal of binary tree is ', end='')\n    tree.printSpecificLevelOrder(tree.root)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.data); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n\n\n\n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n\n\n\n\nNode first = \nnull\n, second = \nnull\n; \n\n\n\n\nwhile\n(!q.isEmpty()) \n\n{ \n\n\n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n\n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n\n\n\n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n}", "index": 193, "complexity": "1"}
{"forwhile": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\ni = 1\n\nwhile i<n-\n1\n: \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\ni += 1\n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\ni=\n0\n\nwhile i<n: \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\ni += 1\n} \n}", "src": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 194, "complexity": "1"}
{"forwhile": "class Node: \n\n    def __init__(self, item): \n        self.data = item\n        self.left = None\n        self.right = None\n\n\nclass Index: \n\n    def __init__(self): \n        self.index = 0\n\n\nclass BinaryTree: \n\n    def __init__(self): \n        self.root = None\n        self.index_obj = Index()\n\n    def storeAlternate(self, node, arr, index, l): \n        if node is None: \n            return \n        self.storeAlternate(node.left, arr, index, l + 1)\n        if l % 2 != 0: \n            arr[index.index] = node.data\n            index.index += 1\n        self.storeAlternate(node.right, arr, index, l + 1)\n\n    def modifyTree(self, node, arr, index, l): \n        if node is None: \n            return \n        self.modifyTree(node.left, arr, index, l + 1)\n        if l % 2 != 0: \n            node.data = arr[index.index]\n            index.index += 1\n        self.modifyTree(node.right, arr, index, l + 1)\n\n    def reverse(self, arr, n): \n        l = 0\n        r = n - 1\n        while l < r: \n            temp = arr[l]\n            arr[l] = arr[r]\n            arr[r] = temp\n            l += 1\n            r -= 1\n\n    def reverseAlternate(self): \n        self.reverseAlternate(self.root)\n\n    def reverseAlternate(self, node): \n        arr = ['' for _ in range(100)]\n        self.storeAlternate(node, arr, self.index_obj, 0)\n        self.reverse(arr, self.index_obj.index)\n        self.index_obj.index = 0\n        self.modifyTree(node, arr, self.index_obj, 0)\n\n    def printInorder(self): \n        self.printInorder(self.root)\n\n    def printInorder(self, node): \n        if node is None: \n            return \n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\n\ndef main(): \n    tree = BinaryTree()\n    tree.root = Node('a')\n    tree.root.left = Node('b')\n    tree.root.right = Node('c')\n    tree.root.left.left = Node('d')\n    tree.root.left.right = Node('e')\n    tree.root.right.left = Node('f')\n    tree.root.right.right = Node('g')\n    tree.root.left.left.left = Node('h')\n    tree.root.left.left.right = Node('i')\n    tree.root.left.right.left = Node('j')\n    tree.root.left.right.right = Node('k')\n    tree.root.right.left.left = Node('l')\n    tree.root.right.left.right = Node('m')\n    tree.root.right.right.left = Node('n')\n    tree.root.right.right.right = Node('o')\n    print('Inorder Traversal of given tree')\n    tree.printInorder()\n    tree.reverseAlternate()\n    print('')\n    print('')\n    print('Inorder Traversal of modified tree')\n    tree.printInorder()\n\n\nmain()", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) { \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\nNode root; \n\nIndex index_obj = \nnew\nIndex(); \n\n\n\n\nvoid\nstoreAlternate(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\nstoreAlternate(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\narr[index.index] = node.data; \n\nindex.index++; \n\n} \n\n\nstoreAlternate(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nmodifyTree(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nmodifyTree(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\nnode.data = arr[index.index]; \n\n(index.index)++; \n\n} \n\n\n\n\nmodifyTree(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nreverse(\nchar\narr[], \nint\nn) { \n\nint\nl = \n0\n, r = n - \n1\n; \n\nwhile\n(l < r) { \n\nchar\ntemp = arr[l]; \n\narr[l] = arr[r]; \n\narr[r] = temp; \n\nl++; \n\nr--; \n\n} \n\n} \n\n\nvoid\nreverseAlternate() { \n\nreverseAlternate(root); \n\n} \n\n\n\n\nvoid\nreverseAlternate(Node node) { \n\n\n\n\nchar\n[] arr = \nnew\nchar\n[\n100\n]; \n\n\n\n\nstoreAlternate(node, arr, index_obj, \n0\n); \n\n\n\n\n\n\n\nreverse(arr, index_obj.index); \n\n\n\n\nindex_obj.index = \n0\n; \n\nmodifyTree(node, arr, index_obj, \n0\n); \n\n} \n\n\nvoid\nprintInorder() { \n\nprintInorder(root); \n\n} \n\n\n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n'a'\n); \n\ntree.root.left = \nnew\nNode(\n'b'\n); \n\ntree.root.right = \nnew\nNode(\n'c'\n); \n\ntree.root.left.left = \nnew\nNode(\n'd'\n); \n\ntree.root.left.right = \nnew\nNode(\n'e'\n); \n\ntree.root.right.left = \nnew\nNode(\n'f'\n); \n\ntree.root.right.right = \nnew\nNode(\n'g'\n); \n\ntree.root.left.left.left = \nnew\nNode(\n'h'\n); \n\ntree.root.left.left.right = \nnew\nNode(\n'i'\n); \n\ntree.root.left.right.left = \nnew\nNode(\n'j'\n); \n\ntree.root.left.right.right = \nnew\nNode(\n'k'\n); \n\ntree.root.right.left.left = \nnew\nNode(\n'l'\n); \n\ntree.root.right.left.right = \nnew\nNode(\n'm'\n); \n\ntree.root.right.right.left = \nnew\nNode(\n'n'\n); \n\ntree.root.right.right.right = \nnew\nNode(\n'o'\n); \n\nSystem.out.println(\n\"Inorder Traversal of given tree\"\n); \n\ntree.printInorder(); \n\n\ntree.reverseAlternate(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder Traversal of modified tree\"\n); \n\ntree.printInorder(); \n\n} \n}", "index": 195, "complexity": "1"}
{"forwhile": "class Node : \n\n    def __init__(self, item): \n        self.data = item \n        self.left = self.right = None \n\n\nclass BinaryTree : \n\n    def postOrderIterative(self, node): \n        S = [] \n        list = [] \n\n        if node is None: \n            return list \n\n        S.append(node) \n        prev = None \n\n        while S: \n            current = S[-1] \n\n            if prev is None or prev.left == current or prev.right == current: \n                if current.left is not None: \n                    S.append(current.left) \n                elif current.right is not None: \n                    S.append(current.right) \n                else: \n                    S.pop() \n                    list.append(current.data) \n\n            elif current.left == prev: \n                if current.right is not None: \n                    S.append(current.right) \n                else: \n                    S.pop() \n                    list.append(current.data) \n\n            elif current.right == prev: \n                S.pop() \n                list.append(current.data) \n\n            prev = current \n\n        return list \n\n\n    def main(self): \n        tree = BinaryTree() \n\n        tree.root = Node(1) \n        tree.root.left = Node(2) \n        tree.root.right = Node(3) \n        tree.root.left.left = Node(4) \n        tree.root.left.right = Node(5) \n        tree.root.right.left = Node(6) \n        tree.root.right.right = Node(7) \n\n        mylist = tree.postOrderIterative(tree.root) \n\n        print('Post order traversal of binary tree is :') \n        print(mylist) \n\n\nif __name__ == '__main__': \n    BinaryTree().main()", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n}", "index": 197, "complexity": "1"}
{"forwhile": "class ListNode : \n\n    def __init__(self, data) : \n        self.data = data \n        self.next = None \n\n\nclass BinaryTreeNode : \n\n    def __init__(self, data) : \n        self.data = data \n        self.left = self.right = None \n\n\nclass BinaryTree : \n\n    def __init__(self) : \n        self.head = None \n        self.root = None \n\n    def push(self, new_data) : \n        new_node = ListNode(new_data) \n        new_node.next = self.head \n        self.head = new_node \n\n    def convertList2Binary(self, node) : \n        q = [] \n        if self.head == None : \n            node = None \n            return None \n        node = BinaryTreeNode(self.head.data) \n        q.append(node) \n        self.head = self.head.next \n        while self.head != None : \n            parent = q[0] \n            pp = q.pop(0) \n            leftChild = None \n            rightChild = None \n            leftChild = BinaryTreeNode(self.head.data) \n            q.append(leftChild) \n            self.head = self.head.next \n            if self.head != None : \n                rightChild = BinaryTreeNode(self.head.data) \n                q.append(rightChild) \n                self.head = self.head.next \n            parent.left = leftChild \n            parent.right = rightChild \n        return node \n\n    def inorderTraversal(self, node) : \n        if node != None : \n            self.inorderTraversal(node.left) \n            print(node.data, end=' ') \n            self.inorderTraversal(node.right) \n\nif __name__ == '__main__' : \n    tree = BinaryTree() \n    tree.push(36) \n    tree.push(30) \n    tree.push(25) \n    tree.push(15) \n    tree.push(12) \n    tree.push(10) \n    node = tree.convertList2Binary(tree.root) \n    print(\"Inorder Traversal of the constructed Binary Tree is:\") \n    tree.inorderTraversal(node)", "src": "class\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\n\n\n\n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n\n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n\n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n\n\nhead = head.next; \n\n\n\n\n\n\nwhile\n(head != \nnull\n) \n\n{ \n\n\n\n\n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n\n\n\n\n\n\n\n\n\n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif\n(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n\n\n\n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n\n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\"\n); \n\ntree.inorderTraversal(node); \n\n} \n}", "index": 199, "complexity": "1"}
{"forwhile": "def pairInSortedRotated(arr, n, x): l = 0 i = 0 while i < n - 1: if arr[i] > arr[i+1]: break i += 1 l = (i + 1) % n r = i for _ in range(n): if l != r: if arr[l] + arr[r] == x: return True if arr[l] + arr[r] < x: l = (l + 1) % n else: r = (n + r - 1) % n return False arr = [11, 15, 6, 8, 9, 10] sum = 16 n = len(arr) if pairInSortedRotated(arr, n, sum): print(\"Array has two elements with sum 16\") else: print(\"Array doesn't have two elements with sum 16 \")", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 201, "complexity": "1"}
{"forwhile": "class BinaryTreeToDLL: \n    class node: \n        def __init__(self, data): \n            self.data = data \n            self.left = None \n            self.right = None \n\n    prev = None \n\n    def fixPrevptr(self, root): \n        if root is not None: \n            self.fixPrevptr(root.left) \n            root.left = self.prev \n            self.prev = root \n            self.fixPrevptr(root.right) \n\n    def fixNextptr(self, root): \n        while root.right is not None: \n            root = root.right \n        while root is not None and root.left is not None: \n            left = root.left \n            left.right = root \n            root = root.left \n        return root \n\n    def BTTtoDLL(self, root): \n        self.prev = None \n        self.fixPrevptr(root) \n        return self.fixNextptr(root) \n\n    def printlist(self, root): \n        while root is not None: \n            print(root.data, end=\" \") \n            root = root.right \n\n    def inorder(self, root): \n        if root is not None: \n            self.inorder(root.left) \n            print(root.data, end=\" \") \n            self.inorder(root.right) \n\n    def main(self): \n        root = self.node(10) \n        root.left = self.node(12) \n        root.right = self.node(15) \n        root.left.left = self.node(25) \n        root.left.right = self.node(30) \n        root.right.left = self.node(36) \n\n        print(\"Inorder Tree Traversal\") \n        self.inorder(root) \n\n        head = self.BTTtoDLL(root) \n\n        print(\"\\nDLL Traversal\") \n        self.printlist(head) \n\nobj = BinaryTreeToDLL() \nobj.main()", "src": "public\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n\n\n\n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n\n\n\n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n\n\n\n\n\n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n\n\nfixPrevptr(root); \n\n\n\n\nreturn\nfixNextptr(root); \n\n} \n\n\n\n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n}", "index": 203, "complexity": "1"}
{"forwhile": "class Node :   data = 0   left, right = None, None    def __init__(self, data):     self.data = data     self.left = self.right = None class BinaryTree :   root = None   head = None   prev = None     def BinaryTree2DoubleLinkedList(self, root):     if root is None:       return     current = root     stack = []     done = False     while not done:       if current is not None:         stack.append(current)         current = current.left       else:         if len(stack) > 0:           current = stack.pop()           if self.prev is None:             self.head = current           else:             current.left = self.prev             self.prev.right = current           self.prev = current           current = current.right         else:           done = True     def printList(self, node):     while node is not None:       print(node.data, end=' ')       node = node.right   if __name__ == '__main__':     tree = BinaryTree()     tree.root = Node(10)     tree.root.left = Node(12)     tree.root.right = Node(15)     tree.root.left.left = Node(25)     tree.root.left.right = Node(30)     tree.root.right.left = Node(36)     tree.BinaryTree2DoubleLinkedList(tree.root)     tree.printList(tree.head) ", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode head; \n\n\n\n\n\n\n\n\nstatic\nNode prev = \nnull\n; \n\n\n\n\n\n\n\n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n\n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n\n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n\n\ntree.printList(tree.head); \n\n\n} \n}", "index": 204, "complexity": "1"}
{"forwhile": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def BToDLL(self, root):\n        if root is None:\n            return\n        stack = []\n        current = root\n        done = False\n        while not done:\n            if current is not None:\n                stack.append(current)\n                current = current.right\n            else:\n                if len(stack) > 0:\n                    current = stack.pop()\n                    current.right = self.head\n                    if self.head is not None:\n                        self.head.left = current\n                    self.head = current\n                    current = current.left\n                else:\n                    done = True\n\n    def printList(self, head):\n        print('Extracted Double Linked List is : ')\n        current = head\n        while current is not None:\n            print(current.data, end=' ')\n            current = current.right\n\nif __name__ == '__main__':\n    tree = BinaryTree()\n    tree.root = Node(5)\n    tree.root.left = Node(3)\n    tree.root.right = Node(6)\n    tree.root.left.right = Node(4)\n    tree.root.left.left = Node(1)\n    tree.root.right.right = Node(8)\n    tree.root.left.left.right = Node(2)\n    tree.root.left.left.left = Node(0)\n    tree.root.right.right.left = Node(7)\n    tree.root.right.right.right = Node(9)\n\n    tree.BToDLL(tree.root)\n    tree.printList(tree.head)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\n\n\n\n\nNode head; \n\n\n\n\n\n\nvoid\nBToDLL(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBToDLL(root.right); \n\n\n\n\nroot.right = head; \n\n\n\n\nif\n(head != \nnull\n) \n\n(head).left = root; \n\n\n\n\nhead = root; \n\n\n\n\nBToDLL(root.left); \n\n} \n\n\n\n\nvoid\nprintList(Node head) \n\n{ \n\nSystem.out.println(\n\"Extracted Double Linked List is : \"\n); \n\nwhile\n(head != \nnull\n) \n\n{ \n\nSystem.out.print(head.data + \n\" \"\n); \n\nhead = head.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n3\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.right = \nnew\nNode(\n4\n); \n\ntree.root.left.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left.left = \nnew\nNode(\n0\n); \n\ntree.root.right.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right.right = \nnew\nNode(\n9\n); \n\n\ntree.BToDLL(tree.root); \n\ntree.printList(tree.head); \n\n} \n}", "index": 205, "complexity": "1"}
{"forwhile": "class GFG : \n\n    @staticmethod\n    def minEdge(n): \n        visit = [0] * (n+2)\n        ans = 0\n        ans = GFG.dfs(visit, 1)\n        return ans\n\n    @staticmethod\n    def dfs(visit, node): \n        num = 0\n        temp = 0\n        visit[node] = 1\n        i = 0\n        while i < len(tree[node]): \n            if visit[tree[node][i]] == 0: \n                temp = GFG.dfs(visit, tree[node][i]) \n                if temp % 2 != 0: \n                    num += temp \n                else: \n                    ans += 1 \n            i += 1\n        return num + 1\n\nn = 10\n\ni = 0\nwhile i < n + 2: \n    tree.append([])\n    i += 1\n\n\n\nfor i in range(len(tree)): \n    tree[1].append(3)\n    tree[3].append(1)\n    tree[1].append(6)\n    tree[6].append(1)\n    tree[1].append(2)\n    tree[2].append(1)\n    tree[3].append(4)\n    tree[4].append(3)\n    tree[6].append(8)\n    tree[8].append(6)\n    tree[2].append(7)\n    tree[7].append(2)\n    tree[2].append(5)\n    tree[5].append(2)\n    tree[4].append(9)\n    tree[9].append(4)\n    tree[4].append(10)\n    tree[10].append(4)\n\nprint(GFG.minEdge(n)) \n", "src": "class\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n\n\n\n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n\n\nvisit[node] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n\n\n\n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n\n\n\n\n\n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n}", "index": 209, "complexity": "1"}
{"forwhile": "public\\nclass\\nFlipTree { \\n\\n\\n\\n\\npublic\\nstatic\\nNode flipBinaryTree(Node root) \\n\\n{ \\n\\nif\\n(root == \\nnull\\n) \\n\\nreturn\\nroot; \\n\\nif\\n(root.left == \\nnull\\n&& root.right ==\\nnull\\n) \\n\\nreturn\\nroot; \\n\\n\\n\\n\\nNode flippedRoot=flipBinaryTree(root.left); \\n\\n\\n\\n\\n\\n\\n\\n\\nint i = 0; \\n\\nwhile\\ni < flippedRoot \\nleft = flippedRoot \\nleft.right = flippedRoot \\n\\nflippedRoot \\nleft = flippedRoot.right = \\nnull\\; \\n\nreturn flippedRoot; \\n\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nprintLevelOrder(Node root) \\n\\n{ \\n\\n\\n\\nif\\n(root==\\nnull\\n) \\n\\nreturn\\; \\n\\n\\n\\n\\n\\n\\nfor(Node node : LinkedList<>()) \\n\\n{ \\n\\nSystem.out.print(node.data+\\n\\ \\); \\n\\n\\nif\\n(node.left != \\nnull\\) \\n\\nLinkedList<>().add(node.left); \\n\nif\\ndata.isLeft \\nnull\\) \\n\\nLinkedList<>().add(data.left); \\n\\nnodeCount--; \\n\\n} \\n\\nSystem.out.println(); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) { \\n\\nNode root=\\nnew\\Node(\\n1\\); \\n\\nroot.left=\\nnew\\Node(\\n2\\); \\n\\nroot.right=\\nnew\\Node(\\n1\\); \\n\\nroot.right.left = \\nnew\\Node(\\n4\\); \\n\\nroot.right.right = \\nnew\\Node(\\n5\\); \\n\\nSystem.out.println(\\n\\Level order traversal of given tree\\n); \\n\\nprintLevelOrder(root); \\n\\n\\nroot = flipBinaryTree(root); \\n\\nSystem.out.println(\\n\\Level order traversal of flipped tree\\n); \\n\\nprintLevelOrder(root); \\n\\n} \\n} \\n\\n\\nclass\\nNode \\n{ \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\nNode(\\nint\\ndata) \\n\\n{ \\n\\nthis\\n.data=data; \\n\\n} \\n};", "src": "public\nclass\nFlipTree { \n\n\n\n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n\n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n\n\n\n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n\n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 211, "complexity": "1"}
{"forwhile": "class\nGFG \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode flipBinaryTree(Node root) \n{ \n\n\n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n\n\nfor(curr ; curr != \nnull\n;) \n\n{ \n\nnext = curr.left; \n\n\n\n\n\n\n\n\n\n\n\n\n\ncurr.left = temp; \n\n\n\n\ntemp = curr.right; \n\n\n\n\n\n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n\n\n\nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\nq.add(root); \n\n\nfor(\ntrue\n; ;) \n\n{ \n\n\n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\n\n\nfor(nodeCount ; nodeCount > \n0\n;) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n}", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode flipBinaryTree(Node root) \n{ \n\n\n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n\n\n\n\n\n\n\n\n\n\n\ncurr.left = temp; \n\n\n\n\ntemp = curr.right; \n\n\n\n\n\n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n\n\n\nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n\n\n\n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n}", "index": 212, "complexity": "1"}
{"forwhile": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n\n\nfor\n(; q.size() != \n0\n;) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n\n\nfor\n(; size > \n0\n;) { \n\nNode temp = q.remove(); \n\n\n\n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n\n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n\n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n\n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n\n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n\n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n\n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n\n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n}", "index": 217, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int key; Node left, right; } static int findADepth(Node node) { int d = 0; for ( ; node != null; ) { d++; node = node.left; } return d; } static boolean isPerfectRec(Node root, int d, int level) { if (root == null) return true; if (root.left == null && root.right == null) return (d == level+1); if (root.left == null || root.right == null) return false; return isPerfectRec(root.left, d, level+1) && isPerfectRec(root.right, d, level+1); } static boolean isPerfect(Node root) { int d = findADepth(root); return isPerfectRec(root, d, 0); } static Node newNode(int k) { Node node = new Node(); node.key = k; node.right = null; node.left = null; return node; } public static void main(String args[]) { Node root = null; root = newNode(10); while (root.left != null) { root = root.left; } System.out.println(\"Yes\"); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n\n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n\nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n}", "index": 219, "complexity": "1"}
{"forwhile": "public\\nclass\\nCompleteBTree \\n{ \\n\\n\\n\\nstatic\\nclass\\nNode \\n\\n{ \\n\\nint\\ndata; \\n\\nNode left; \\n\\nNode right; \\n\\n\\n\\n\\nNode(\\nint\\nd) \\n\n{ \\n\\ndata = d; \\n\\nleft = \\nnull\\; \\n\\nright = \\nnull\\; \\n\\n} \\n\\n} \\n\\n\\n\\nstatic\\nboolean\\nisCompleteBT(Node root) \\n\\n{ \\n\\n\\n\\nif\\n(root == \\nnull\\) \\n\\nreturn\\ntrue\\; \\n\\n\\n\\n\\nQueue<Node> queue =\\nnew\\nLinkedList<>(); \\n\\n\\n\\n\\n\\n\\n\\n\\nboolean\\nflag = \\nfalse\\; \\n\\n\\n\\nfor(Node temp_node : queue) \\n\\n{ \\n\\nNode temp_node = queue.remove(); \\n\\n\\n\\nif\\n(temp_node.left != \\nnull\\) \\n\n{ \\n\\n\\n\\n\\n\\nif\\n(flag == \\ntrue\\) \\n\nreturn\\nfalse\\; \\n\\n\\n\\nqueue.add(temp_node.left); \\n\\n} \\n\\n\\n\\nelse\\n\\nflag = \\ntrue\\; \\n\\n\\n\\nif\\n(temp_node.right != \\nnull\\) \\n\n{ \\n\\n\\n\\n\\n\\nif\\n(flag == \\ntrue\\) \\n\nreturn\\nfalse\\; \\n\\n\\n\\nqueue.add(temp_node.right); \\n\\n\\n} \\n\\n\\n\\nelse\\n\\nflag = \\ntrue\\; \\n\\n} \\n\\n\\nreturn\\ntrue\\; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\n\\n\\n\\nNode root = \\nnew\\nNode(\\n1\\); \\n\\nroot.left = \\nnew\\nNode(\\n2\\); \\n\\nroot.right = \\nnew\\nNode(\\n3\\); \\n\\nroot.left.left = \\nnew\\nNode(\\n4\\); \\n\\nroot.left.right = \\nnew\\nNode(\\n5\\); \\n\\nroot.right.right = \\nnew\\nNode(\\n6\\); \\n\\n\\nfor(Node temp_node : queue) \\n\\n{ \\n\\n\\nif\\nisCompleteBT(root) == \\ntrue\\ \\n\\nSystem.out.println(\\n\\\"Complete Binary Tree\\\"\\); \\n\\nelse\\n\\nSystem.out.println(\\n\\\"NOT Complete Binary Tree\\\"\\); \\n\\n} \\n\\n} \\n\\n}", "src": "public\nclass\nCompleteBTree \n{ \n\n\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n\n\n\n\nboolean\nflag = \nfalse\n; \n\n\n\n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.left); \n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n\n\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.right); \n\n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n} \n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n}", "index": 221, "complexity": "1"}
{"forwhile": "class Node { char data; Node left, right; Node(char item) { data = item; left = right = null; } } class Passing { int i; int m = 0; int n = 0; } class BinaryTree { static Node root; Passing p = new Passing(); String strstr(String haystack, String needle) { if(haystack == null || needle == null) { return null; } int hLength = haystack.length(); int nLength = needle.length(); if(hLength < nLength) { return null; } if(nLength == 0) { return haystack; } int i = 0; while(i <= hLength - nLength) { if(haystack.charAt(i) == needle.charAt(0)) { int j = 0; while(j < nLength) { if(haystack.charAt(i + j) != needle.charAt(j)) { break; } j++; } if(j == nLength) { return haystack.substring(i); } } i++; } return null; } void storeInorder(Node node, char arr[], Passing i) { if(node == null) { arr[i.i++] = '$'; return; } storeInorder(node.left, arr, i); arr[i.i++] = node.data; storeInorder(node.right, arr, i); } void storePreOrder(Node node, char arr[], Passing i) { if(node == null) { arr[i.i++] = '$'; return; } arr[i.i++] = node.data; storePreOrder(node.left, arr, i); storePreOrder(node.right, arr, i); } boolean isSubtree(Node T, Node S) { if(S == null) { return true; } if(T == null) { return false; } char inT[] = new char[100]; String op1 = String.valueOf(inT); char inS[] = new char[100]; String op2 = String.valueOf(inS); storeInorder(T, inT, p); storeInorder(S, inS, p); inT[p.m] = '\\0'; inS[p.m] = '\\0'; if(strstr(op1, op2) != null) { return false; } p.m = 0; p.n = 0; char preT[] = new char[100]; char preS[] = new char[100]; String op3 = String.valueOf(preT); String op4 = String.valueOf(preS); storePreOrder(T, preT, p); storePreOrder(S, preS, p); preT[p.m] = '\\0'; preS[p.n] = '\\0'; return (strstr(op3, op4) != null); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); Node T = new Node('a'); T.left = new Node('b'); T.right = new Node('d'); T.left.left = new Node('c'); T.right.right = new Node('e'); Node S = new Node('a'); S.left = new Node('b'); S.right = new Node('d'); S.left.left = new Node('c'); for(Node T_temp = T; tree.isSubtree(T_temp, S); T_temp = T_temp.right); String conditionalOutput = (tree.isSubtree(T, S)) ? \"Yes, S is a subtree of T\" : \"No, S is not a subtree of T\"; System.out.println(conditionalOutput); } }", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nPassing { \n\n\nint\ni; \n\nint\nm = \n0\n; \n\nint\nn = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nPassing p = \nnew\nPassing(); \n\n\nString strstr(String haystack, String needle) \n\n{ \n\nif\n(haystack == \nnull\n|| needle == \nnull\n) { \n\nreturn\nnull\n; \n\n} \n\nint\nhLength = haystack.length(); \n\nint\nnLength = needle.length(); \n\nif\n(hLength < nLength) { \n\nreturn\nnull\n; \n\n} \n\nif\n(nLength == \n0\n) { \n\nreturn\nhaystack; \n\n} \n\nfor\n(\nint\ni = \n0\n; i <= hLength - nLength; i++) { \n\nif\n(haystack.charAt(i) == needle.charAt(\n0\n)) { \n\nint\nj = \n0\n; \n\nfor\n(; j < nLength; j++) { \n\nif\n(haystack.charAt(i + j) != needle.charAt(j)) { \n\nbreak\n; \n\n} \n\n} \n\nif\n(j == nLength) { \n\nreturn\nhaystack.substring(i); \n\n} \n\n} \n\n} \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nvoid\nstoreInorder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\nstoreInorder(node.left, arr, i); \n\narr[i.i++] = node.data; \n\nstoreInorder(node.right, arr, i); \n\n} \n\n\n\n\n\n\nvoid\nstorePreOrder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\narr[i.i++] = node.data; \n\nstorePreOrder(node.left, arr, i); \n\nstorePreOrder(node.right, arr, i); \n\n} \n\n\n\n\nboolean\nisSubtree(Node T, Node S) \n\n{ \n\n\n\nif\n(S == \nnull\n) { \n\nreturn\ntrue\n; \n\n} \n\nif\n(T == \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\nchar\ninT[] = \nnew\nchar\n[\n100\n]; \n\nString op1 = String.valueOf(inT); \n\nchar\ninS[] = \nnew\nchar\n[\n100\n]; \n\nString op2 = String.valueOf(inS); \n\nstoreInorder(T, inT, p); \n\nstoreInorder(S, inS, p); \n\ninT[p.m] = \n'\\0'\n; \n\ninS[p.m] = \n'\\0'\n; \n\n\n\n\nif\n(strstr(op1, op2) != \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\np.m = \n0\n; \n\np.n = \n0\n; \n\nchar\npreT[] = \nnew\nchar\n[\n100\n]; \n\nchar\npreS[] = \nnew\nchar\n[\n100\n]; \n\nString op3 = String.valueOf(preT); \n\nString op4 = String.valueOf(preS); \n\nstorePreOrder(T, preT, p); \n\nstorePreOrder(S, preS, p); \n\npreT[p.m] = \n'\\0'\n; \n\npreS[p.n] = \n'\\0'\n; \n\n\n\n\n\n\nreturn\n(strstr(op3, op4) != \nnull\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode T = \nnew\nNode(\n'a'\n); \n\nT.left = \nnew\nNode(\n'b'\n); \n\nT.right = \nnew\nNode(\n'd'\n); \n\nT.left.left = \nnew\nNode(\n'c'\n); \n\nT.right.right = \nnew\nNode(\n'e'\n); \n\n\nNode S = \nnew\nNode(\n'a'\n); \n\nS.left = \nnew\nNode(\n'b'\n); \n\nS.right = \nnew\nNode(\n'd'\n); \n\nS.left.left = \nnew\nNode(\n'c'\n); \n\n\nif\n(tree.isSubtree(T, S)) { \n\nSystem.out.println(\n\"Yes, S is a subtree of T\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"No, S is not a subtree of T\"\n); \n\n} \n\n} \n}", "index": 222, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\n\\n\\nstatic\\nint\\nfindMedian(\\nint\\narr[], \\nint\\ni,\\nint\\nn) \\n{ \\n\\nif\\n(i <= n) \\n{\\nint\\nstart = i;\\nint\\nend = n;\\n} \\n\\nelse\\n{\\nint\\nstart = n;\\nint\\nend = i;\\n} \\n\\nArrays.sort(arr, start, end); \\n\\n\\nreturn\\narr[n/\\n2\\n]; \\n\\n} \\n\\n\\n\\n\\n\\nstatic\\nint\\nkthSmallest(\\nint\\narr[], \\nint\\nl, \\nint\\nr, \\nint\\nk) \\n{ \\n\\n\\n\\n\\nfor(\\nint\\ni = 0; k > \\n0\\n&& k <= r - l + \\n1\\n; i++) \\n\\n{ \\n\\nint\\nn = r - l + \\n1\\n; \\n\\n\\n\\n\\n\\n\\nint\\n[]median = \\nnew\\nint\\n[(n + \\n4\\n) / \\n5\\n]; \\n\\n\\nint\\nct = 0;\\nwhile( i < n/\\n5\\n) \\n{\\nmedian[i] = findMedian(arr,l + i * \\n5\\n, \\n5\\n); \\ni++; \\n}\\n\\n\\nif\\n(i*\\n5\\n< n) \\n{ \\n\\nmedian[i] = findMedian(arr,l + i * \\n5\\n, n % \\n5\\n); \\ni++; \\n\\n} \\n\\n\\n\\n\\n\\nint\\nmedOfMed = (i == \\n1\\n)? median[i - \\n1\\n]: \\nkthSmallest(median, \\n0\\n, i - \\n1\\n, i / \\n2\\n); \\n\\n\\n\\n\\nint\\npos = partition(arr, l, r, medOfMed); \\n\\n\\n\\nif\\n(pos-l == k - \\n1\\n) \\n\\nreturn\\narr[pos]; \\n\\nif\\n(pos-l > k - \\n1\\n) \\n\\n\\nreturn\\nkthSmallest(arr, l, pos - \\n1\\n, k); \\n\\n\\n\\nreturn\\nkthSmallest(arr, pos + \\n1\\n, r, k - pos + l - \\n1\\n); \\n\\n} \\n\\n\\nreturn\\nInteger.MAX_VALUE; \\n} \\n\\nstatic\\nint\\n[] swap(\\nint\\n[]arr, \\nint\\ni, \\nint\\nj) \\n{ \\n\\nint\\ntemp = arr[i]; \\n\\narr[i] = arr[j]; \\n\\narr[j] = temp; \\n\\nreturn\\narr; \\n} \\n\\n\\n\\nstatic\\nint\\npartition(\\nint\\narr[], \\nint\\nl, \\n\\nint\\nr, \\nint\\nx) \\n{ \\n\\n\\n\\nint\\ni; \\ni = l; \\n\\n\\nfor(\\nint\\nj = l; j <= r - \\n1\\n; j++) \\n\\n{ \\n\\nif\\n(arr[j] == x) \\n{\\nbreak; \\n}\\nswap(arr, i, r); \\n\\ni++; \\n\\n} \\n\\nswap(arr, i, r); \\n\\nreturn\\ni; \\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n{ \\n\\nint\\narr[] = {\\n12\\n, \\n3\\n, \\n5\\n, \\n7\\n, \\n4\\n, \\n19\\n, \\n26\\n}; \\n\\nint\\nn = arr.length, k = \\n3\\n; \\n\\nSystem.out.println(\\n\"K'th smallest element is \"\\n\\n+ kthSmallest(arr, \\n0\\n, n - \\n1\\n, k)); \\n} \\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n\n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n\n} \n\n\n\n\n\nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n\n\n\n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n\n\n\n\n\n\n\n\n\nint\ni; \n\n\n\n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n\n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n\n\n\n\n\n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n\n\n\n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n\n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n\n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n\n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n\n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n\n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n\n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n}", "index": 224, "complexity": "1"}
{"forwhile": "class GfG: \n    class Node: \n        def __init__(self): \n            self.data = None \n            self.left = None \n            self.right = None \n        @staticmethod \n        def newNode(data): \n            temp = GfG.Node() \n            temp.data = data \n            temp.left = None \n            temp.right = None \n            return temp \n        @staticmethod \n        def areMirrors(root1, root2): \n            st1 = [] \n            st2 = [] \n            while True: \n\n\n\n                while root1 is not None and root2 is not None: \n\n\n\n                    if root1.data != root2.data: \n                        return 'No' \n\n                    st1.append(root1) \n                    st2.append(root2) \n                    root1 = root1.left \n                    root2 = root2.right \n\n\n\n                if not (root1 is None and root2 is None): \n                    return 'No' \n\n                if st1 and st2: \n                    root1 = st1[-1] \n                    root2 = st2[-1] \n                    st1.pop() \n                    st2.pop() \n                    root1 = root1.right \n                    root2 = root2.left \n\n                else: \n                    break \n            return 'Yes' \n\n\n\n    root1 = GfG.Node.newNode(1) \n    root1.left = GfG.Node.newNode(3) \n    root1.right = GfG.Node.newNode(2) \n    root1.right.left = GfG.Node.newNode(5) \n    root1.right.right = GfG.Node.newNode(4) \n    root2 = GfG.Node.newNode(1) \n    root2.left = GfG.Node.newNode(2) \n    root2.right = GfG.Node.newNode(3) \n    root2.left.left = GfG.Node.newNode(4) \n    root2.left.right = GfG.Node.newNode(5) \n\n    print(GfG.areMirrors(root1, root2)", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\n\nstatic\nString areMirrors(Node root1, Node root2) \n{ \n\nStack<Node> st1 = \nnew\nStack<Node> (); \n\nStack<Node> st2 = \nnew\nStack<Node> (); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nwhile\n(root1 != \nnull\n&& root2 != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(root1.data != root2.data) \n\nreturn\n\"No\"\n; \n\n\nst1.push(root1); \n\nst2.push(root2); \n\nroot1 = root1.left; \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\n\n\n\n\nif\n(!(root1 == \nnull\n&& root2 == \nnull\n)) \n\nreturn\n\"No\"\n; \n\n\nif\n(!st1.isEmpty() && !st2.isEmpty()) \n\n{ \n\nroot1 = st1.peek(); \n\nroot2 = st2.peek(); \n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\nroot1 = root1.right; \n\n\n\n\nroot2 = root2.left; \n\n} \n\n\n\n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nreturn\n\"Yes\"\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root1 = newNode(\n1\n); \n\n\nroot1.left = newNode(\n3\n); \n\n\nroot1.right = newNode(\n2\n); \n\n\nroot1.right.left = newNode(\n5\n); \n\n\nroot1.right.right = newNode(\n4\n); \n\n\n\n\n\nNode root2 = newNode(\n1\n); \n\n\nroot2.left = newNode(\n2\n); \n\n\nroot2.right = newNode(\n3\n); \n\n\nroot2.left.left = newNode(\n4\n); \n\n\nroot2.left.right = newNode(\n5\n); \n\n\n\nSystem.out.println(areMirrors(root1, root2)); \n} \n}", "index": 225, "complexity": "1"}
{"forwhile": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef hasPath(root, arr, x):\n    if root is None:\n        return False\n\n    arr.append(root.data)\n\n    if root.data == x:\n        return True\n\n    if hasPath(root.left, arr, x) or hasPath(root.right, arr, x):\n        return True\n\n    arr.pop(-1)\n    return False\n\n\ndef printPath(root, x):\n    arr = []\n\n    if hasPath(root, arr, x):\n        i = 0\n        while i < len(arr) - 1:\n            print(arr[i], end='->')\n            i += 1\n        print(arr[-1])\n    else:\n        print('No Path')\n\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef main():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    x = 5\n    printPath(root, x)\n\n\nif __name__ == '__main__':\n    main()", "src": "public\nclass\nPrintPath { \n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\narr.add(root.data); \n\n\n\n\n\n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n\n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n\n\n\n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n\n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 229, "complexity": "1"}
{"forwhile": "class GfG: \n\n    class Node: \n\n        def __init__(self): \n            self.data = 0 \n            self.left = None \n            self.right = None \n\n    @staticmethod \n    def printOddNodes(root): \n        if root is None: \n            return \n        q = [] \n        q.append(root) \n        isOdd = True \n        while True: \n            nodeCount = len(q) \n            if nodeCount == 0: \n                break \n            while nodeCount > 0: \n                node = q[0] \n                if isOdd is True: \n                    print(node.data, end=' ') \n                q = q[1:] \n                if node.left is not None: \n                    q.append(node.left) \n                if node.right is not None: \n                    q.append(node.right) \n                nodeCount -= 1 \n            isOdd = not isOdd \n\n    @staticmethod \n    def newNode(data): \n        node = GfG.Node() \n        node.data = data \n        node.left = None \n        node.right = None \n        return node \n\n    @staticmethod \n    def main(args): \n        root = GfG.newNode(1) \n        root.left = GfG.newNode(2) \n        root.right = GfG.newNode(3) \n        root.left.left = GfG.newNode(4) \n        root.left.right = GfG.newNode(5) \n        GfG.printOddNodes(root) \n", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n\n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n}", "index": 231, "complexity": "1"}
{"forwhile": "class\nLinkedList { \n\n\n\n\nstatic\nLNode head; \n\n\n\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nNone\n; \n\n} \n\n} \n\n\n\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nNone\n; \n\n} \n\n} \n\n\n\n\nTNode sortedListToBST() \n\n{ \n\n\n\nint\nn = countNodes(head); \n\n\n\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\nNone\n; \n\n\n\n\nTNode left = sortedListToBSTRecur(n // \n2\n); \n\n\n\n\nTNode root = \nTNode(head.data); \n\n\n\n\nroot.left = left; \n\n\n\n\nhead = head.next; \n\n\n\n\nroot.right = sortedListToBSTRecur(n - n // \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nfor i in iter(lambda: temp != \nNone\n, False): \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nLNode new_node = \nLNode(new_data); \n\n\n\n\nnew_node.prev = \nNone\n; \n\n\n\n\nnew_node.next = head; \n\n\n\n\nif\n(head != \nNone\n) \n\nhead.prev = new_node; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(LNode node) \n\n{ \n\nfor i in iter(lambda: node != \nNone\n, False): \n\nprint(node.data, end=\n' '\n); \n\nnode = node.next; \n\n} \n\n\n\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nNone\n) \n\nreturn\n; \n\nprint(node.data, end=\n' '\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nLinkedList(); \n\n\n\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nprint(\n'Given Linked List '\n); \n\nllist.printList(head); \n\n\n\n\nTNode root = llist.sortedListToBST(); \n\nprint(\n''\n); \n\nprint(\n'Pre-Order Traversal of constructed BST '\n); \n\nllist.preOrder(root); \n\n} \n}", "src": "class\nLinkedList { \n\n\n\n\nstatic\nLNode head; \n\n\n\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n\n\nTNode sortedListToBST() \n\n{ \n\n\n\nint\nn = countNodes(head); \n\n\n\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n\n\nTNode root = \nnew\nTNode(head.data); \n\n\n\n\nroot.left = left; \n\n\n\n\nhead = head.next; \n\n\n\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n\n\nnew_node.prev = \nnull\n; \n\n\n\n\nnew_node.next = head; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n}", "index": 234, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = {10 , 324 , 45 , 90 , 9808}; static int largest() { int i; int max = arr[0]; i = 1; while (i < arr.length) { if (arr[i] > max) max = arr[i]; i++; } return max; } public static void main(String[] args) { System.out.println(\"Largest in given array is \"+ largest()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n\n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n\n\nint\nmax = arr[\n0\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n}", "index": 235, "complexity": "1"}
{"forwhile": "class\nNode: \n\n\n    def __init__(self, data): \n        self.data = data \n        self.left = None \n        self.right = None \n\nclass\nBinaryTree: \n    head = None \n\n    def insert(self, node, data): \n        if node == None: \n            return Node(data) \n        else: \n            while True: \n                if data <= node.data: \n                    if node.left == None: \n                        node.left = Node(data) \n                        break \n                    else: \n                        node = node.left \n                else: \n                    if node.right == None: \n                        node.right = Node(data) \n                        break \n                    else: \n                        node = node.right \n        return node \n\n    def minvalue(self, node): \n        current = node \n        for i in iter(lambda: 0, 1): \n            while current.left != None: \n                current = current.left \n        return current.data \n\n\n    def main(self): \n        tree = BinaryTree() \n        root = None \n        root = tree.insert(root, 4) \n        tree.insert(root, 2) \n        tree.insert(root, 1) \n        tree.insert(root, 3) \n        tree.insert(root, 6) \n        tree.insert(root, 5) \n        print('Minimum value of BST is ' + str(tree.minvalue(root))) \n\n\nif __name__ == '__main__': \n    BinaryTree().main() \n", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n\n\nNode insert(Node node, \nint\ndata) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n\n\nreturn\nnode; \n\n} \n\n} \n\n\n\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n}", "index": 238, "complexity": "1"}
{"forwhile": "class Solution { static class NodeDetails { int data; int min, max; }; static boolean levelOrderIsOfBST(int arr[], int n) { if (n == 0) return true; Queue<NodeDetails> q = new LinkedList<NodeDetails>(); int i = 0; NodeDetails newNode=new NodeDetails(); newNode.data = arr[i++]; newNode.min = Integer.MIN_VALUE; newNode.max = Integer.MAX_VALUE; q.add(newNode); for (int tempCounter = 0; tempCounter < n && q.size() > 0; tempCounter++) { NodeDetails temp = q.peek(); q.remove(); newNode = new NodeDetails(); if (i < n && (arr[i] < (int)temp.data && arr[i] > (int)temp.min)) { newNode.data = arr[i++]; newNode.min = temp.min; newNode.max = temp.data; q.add(newNode); } newNode=new NodeDetails(); if (i < n && (arr[i] > (int)temp.data && arr[i] < (int)temp.max)) { newNode.data = arr[i++]; newNode.min = temp.data; newNode.max = temp.max; q.add(newNode); } } if (i == n) return true; return false; } public static void main(String args[]) { int arr[] = {7, 4, 12, 3, 6, 8, 1, 5, 10}; int n = arr.length; if (levelOrderIsOfBST(arr, n)) System.out.print(\"Yes\"); else System.out.print(\"No\"); } }", "src": "class\nSolution \n{ \n\n\n\n\n\nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n\n\n\nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n\n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n\n\nint\ni = \n0\n; \n\n\n\n\n\n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n\n\n\n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n\n\n\n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n\n\n\n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nreturn\nfalse\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n}", "index": 239, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.right = null; temp.left = null; return temp; } static Node KthLargestUsingMorrisTraversal(Node root, int k) { Node curr = root; Node Klargest = null; int count = 0; for (; curr != null;) { if (curr.right == null) { if (++count == k) Klargest = curr; curr = curr.left; } else { Node succ = curr.right; for (; succ.left != null && succ.left != curr;) succ = succ.left; if (succ.left == null) { succ.left = curr; curr = curr.right; } else { succ.left = null; if (++count == k) Klargest = curr; curr = curr.left; } } } return Klargest; } public static void main(String[] args) { Node root = newNode(4); root.left = newNode(2); root.right = newNode(7); root.left.left = newNode(1); root.left.right = newNode(3); root.right.left = newNode(6); root.right.right = newNode(10); System.out.println(\"Finding K-th largest Node in BST : \" + KthLargestUsingMorrisTraversal(root, 2).data); } }", "src": "class\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n\n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n\n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n\n\n\n\nsucc.left = curr; \n\n\n\n\ncurr = curr.right; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n}", "index": 240, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int key; Node left, right; } static int KSmallestUsingMorris(Node root, int k) { int count = 0; int ksmall = Integer.MIN_VALUE; Node curr = root; for (; curr != null;) { if (curr.left == null) { count++; if (count==k) ksmall = curr.key; curr = curr.right; } else { Node pre = curr.left; for (; pre.right != null && pre.right != curr;) pre = pre.right; if (pre.right== null) { pre.right = curr; curr = curr.left; } else { pre.right = null; count++; if (count==k) ksmall = curr.key; curr = curr.right; } } } return ksmall; } static Node newNode(int item) { Node temp = new Node(); temp.key = item; temp.left = null; temp.right = null; return temp; } static Node insert(Node node, int key) { if (node == null) return newNode(key); if (key < node.key) node.left = insert(node.left, key); else if (key > node.key) node.right = insert(node.right, key); return node; } public static void main(String[] args) { Node root = null; root = insert(root, 50); insert(root, 30); insert(root, 20); insert(root, 40); insert(root, 70); insert(root, 60); insert(root, 80); int k=1; while (k<=7) { System.out.print(KSmallestUsingMorris(root, k) + \" \"); k++; } } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nKSmallestUsingMorris(Node root, \nint\nk) \n{ \n\n\n\n\n\nint\ncount = \n0\n; \n\n\nint\nksmall = Integer.MIN_VALUE; \n\n\nNode curr = root; \n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nif\n(curr.left == \nnull\n) \n\n{ \n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\n\n\ncurr = curr.right; \n\n} \n\nelse\n\n{ \n\n\n\n\n\nNode pre = curr.left; \n\nwhile\n(pre.right != \nnull\n&& pre.right != curr) \n\npre = pre.right; \n\n\n\n\nif\n(pre.right== \nnull\n) \n\n{ \n\n\n\npre.right = curr; \n\ncurr = curr.left; \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\n\n\npre.right = \nnull\n; \n\n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\ncurr = curr.right; \n\n} \n\n} \n\n} \n\nreturn\nksmall; \n\n} \n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node node, \nint\nkey) \n{ \n\n\n\nif\n(node == \nnull\n) \nreturn\nnewNode(key); \n\n\n\n\nif\n(key < node.key) \n\nnode.left = insert(node.left, key); \n\nelse\nif\n(key > node.key) \n\nnode.right = insert(node.right, key); \n\n\n\n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root = \nnull\n; \n\nroot = insert(root, \n50\n); \n\ninsert(root, \n30\n); \n\ninsert(root, \n20\n); \n\ninsert(root, \n40\n); \n\ninsert(root, \n70\n); \n\ninsert(root, \n60\n); \n\ninsert(root, \n80\n); \n\n\nfor\n(\nint\nk=\n1\n; k<=\n7\n; k++) \n\nSystem.out.print(KSmallestUsingMorris(root, k) + \n\" \"\n); \n\n} \n}", "index": 242, "complexity": "1"}
{"forwhile": "class GFG { static boolean isInorder( int[] arr, int n) { if (n == 0 || n == 1) { return true; } int i = 1; while (i < n){ if (arr[i - 1] > arr[i]) { return false; } i++; } return true; } public static void main(String[] args) { int arr[] = { 19, 23, 25, 30, 45 }; int n = arr.length; for (int i = 1; i < n; i++){ if (arr[i - 1] > arr[i]) { System.out.println( \"Non\" ); return; } } System.out.println( \"Yes\" ); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n\n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n}", "index": 243, "complexity": "1"}
{"forwhile": "class PrintLargest: \n    @staticmethod\n    def print3largest(arr, arr_size): \n        if arr_size < 3: \n            print(' Invalid Input ') \n            return \n        third = first = second = float('-inf') \n        i = 0\n        while i < arr_size: \n            if arr[i] > first: \n                third = second; \n                second = first; \n                first = arr[i]; \n            elif arr[i] > second: \n                third = second; \n                second = arr[i]; \n            elif arr[i] > third: \n                third = arr[i]; \n            i += 1\n        print('Three largest elements are ' + str(first) + ' ' + str(second) + ' ' + str(third)) \n\n    @staticmethod\n    def main(args): \n        arr = [12, 13, 1, 10, 34, 1] \n        n = len(arr) \n        PrintLargest.print3largest(arr, n) \n\nPrintLargest.main([])", "src": "class\nPrintLargest \n{ \n\n\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n}", "index": 244, "complexity": "1"}
{"forwhile": "public class GFG { static class Node { int data; Node left, right; public Node(int data) { this .data = data; left = null ; right = null ; } } static Node root1; static Node root2; static int countPairs(Node root1, Node root2, int x) { if (root1 == null || root2 == null ) return 0 ; List<Node> st1 = new ArrayList<>(); List<Node> st2 = new ArrayList<>(); Node top1, top2; int count = 0 ; for ( ; ; ) { for (Node current = root1; current != null ; current = current.left) st1.add(current); for (Node current = root2; current != null ; current = current.right) st2.add(current); if (st1.isEmpty() || st2.isEmpty()) break ; top1 = st1.get(st1.size() - 1 ); top2 = st2.get(st2.size() - 1 ); if ((top1.data + top2.data) == x) { count++; st1.remove(st1.size() - 1 ); st2.remove(st2.size() - 1 ); root1 = top1.right; root2 = top2.left; } else if ((top1.data + top2.data) < x) { st1.remove(st1.size() - 1 ); root1 = top1.right; } else { st2.remove(st2.size() - 1 ); root2 = top2.left; } } return count; } public static void main(String args[]) { root1 = new Node(5 ); root1.left = new Node(3 ); root1.right = new Node(7 ); root1.left.left = new Node(2 ); root1.left.right = new Node(4 ); root1.right.left = new Node(6 ); root1.right.right = new Node(8 ); root2 = new Node(10 ); root2.left = new Node(6 ); root2.right = new Node(15 ); root2.left.left = new Node(3 ); root2.left.right = new Node(8 ); root2.right.left = new Node(11 ); root2.right.right = new Node(18 ); int x = 16 ; System.out.println(\"Pairs = \" + countPairs(root1, root2, x)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n\n\n\n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n\n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nwhile\n(\ntrue\n) { \n\n\n\n\n\n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n\n\n\n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n\n\nif\n((top1.data + top2.data) == x) { \n\n\n\ncount++; \n\n\n\n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\n\n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n\n\n\n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n\n\n\n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nroot1 = \nnew\nNode(\n5\n); \n\n\nroot1.left = \nnew\nNode(\n3\n); \n\n\nroot1.right = \nnew\nNode(\n7\n); \n\n\nroot1.left.left = \nnew\nNode(\n2\n); \n\n\nroot1.left.right = \nnew\nNode(\n4\n); \n\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n\n\nroot2 = \nnew\nNode(\n10\n); \n\n\nroot2.left = \nnew\nNode(\n6\n); \n\n\nroot2.right = \nnew\nNode(\n15\n); \n\n\nroot2.left.left = \nnew\nNode(\n3\n); \n\n\nroot2.left.right = \nnew\nNode(\n8\n); \n\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n}", "index": 245, "complexity": "1"}
{"forwhile": "class Node:\n\n    def __init__(self, d):\n        self.data = d\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def inorder(self):\n        self.inorderUtil(self.root)\n\n    def inorderUtil(self, node):\n        if node is None:\n            return\n        self.inorderUtil(node.left)\n        print(node.data, end=' ')\n        self.inorderUtil(node.right)\n\n    def insert(self, key):\n        self.root = self.insertRec(self.root, key)\n\n    def insertRec(self, root, data):\n        if root is None:\n            root = Node(data)\n            return root\n        if data < root.data:\n            root.left = self.insertRec(root.left, data)\n        elif data > root.data:\n            root.right = self.insertRec(root.right, data)\n        return root\n\n    def treeToList(self, node, list):\n        if node is None:\n            return list\n        self.treeToList(node.left, list)\n        list.append(node.data)\n        self.treeToList(node.right, list)\n        return list\n\n    def isPairPresent(self, node, target):\n        a1 = []\n        a2 = self.treeToList(node, a1)\n        start = 0\n        end = len(a2) - 1\n        while start < end:\n            if a2[start] + a2[end] == target:\n                print('Pair Found:', a2[start], '+', a2[end], '=', target)\n                return True\n            if a2[start] + a2[end] > target:\n                end -= 1\n            if a2[start] + a2[end] < target:\n                start += 1\n        print('No such values are found!')\n        return False\n\n\nif __name__ == '__main__':\n    tree = BinarySearchTree()\n    tree.insert(15)\n    tree.insert(10)\n    tree.insert(20)\n    tree.insert(8)\n    tree.insert(12)\n    tree.insert(16)\n    tree.insert(25)\n    tree.isPairPresent(tree.root, 33)", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n\n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n\n\n\n\n\n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n\n\n\n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n\n\n\nint\nend = a2.size() - \n1\n; \n\n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n\n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n\n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n\n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n}", "index": 247, "complexity": "1"}
{"forwhile": "class Solution { static class Node { Node left, right; int data; } static Node createNode( int x) { Node p = new Node(); p.data = x; p.left = p.right = null; return p; } static void insertNode( Node root, int x) { Node p = root, q = null; for ( ; p != null; ) { q = p; if (p.data < x) p = p.right; else p = p.left; } if (q == null) p = createNode(x); else { if (q.data < x) q.right = createNode(x); else q.left = createNode(x); } } static int maxelpath(Node q, int x) { Node p = q; int mx = -1; for ( ; p.data != x; ) { if (p.data > x) { mx = Math.max(mx, p.data); p = p.left; } else { mx = Math.max(mx, p.data); p = p.right; } } return Math.max(mx, x); } static int maximumElement( Node root, int x, int y) { Node p = root; for ( ; (x < p.data && y < p.data) || (x > p.data && y > p.data); ) { if (x < p.data && y < p.data) p = p.left; else if (x > p.data && y > p.data) p = p.right; } return Math.max(maxelpath(p, x), maxelpath(p, y)); } public static void main(String args[]) { int arr[] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 }; int a = 1, b = 10; int n =arr.length; Node root = createNode(arr[0]); for (int i = 1; i < n; i++) insertNode(root, arr[i]); System.out.println( maximumElement(root, a, b) ); } }", "src": "class\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n\nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n\nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n\n\nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n\n\n\n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n\n\nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n\n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n\n\n\n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n\n\n\n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n\n\nNode root = createNode(arr[\n0\n]); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n}", "index": 248, "complexity": "1"}
{"forwhile": "class solution { static class Node { int data; Node left, right; } static Node newNode(int num) { Node temp = new Node(); temp.data = num; temp.left = temp.right = null; return temp; } static Node insert(Node root, int key) { if (root == null) return newNode(key); if (root.data > key) root.left = insert(root.left, key); else root.right = insert(root.right, key); return root; } static void storeInorder(Node ptr, Vector<Integer> vect) { if (ptr==null) return; storeInorder(ptr.left, vect); vect.add(ptr.data); storeInorder(ptr.right, vect); } static void pairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, int sum) { int left = 0; int right = vect2.size() - 1; for (left=0; (left < vect1.size()) && (right >= 0);) { if (vect1.get(left) + vect2.get(right) == sum) { System.out.print(\"(\"+vect1.get(left) + \", \"+ vect2.get(right) + \"), \"); left++; right--; } else if (vect1.get(left) + vect2.get(right) < sum) left++; else right--; } } static void pairSum(Node root1, Node root2, int sum) { Vector<Integer> vect1= new Vector<Integer>(), vect2= new Vector<Integer>(); storeInorder(root1, vect1); storeInorder(root2, vect2); pairSumUtil(vect1, vect2, sum); } public static void main(String args[]) { Node root1 = null; root1 = insert(root1, 8); root1 = insert(root1, 10); root1 = insert(root1, 3); root1 = insert(root1, 6); root1 = insert(root1, 1); root1 = insert(root1, 5); root1 = insert(root1, 7); root1 = insert(root1, 14); root1 = insert(root1, 13); Node root2 = null; root2 = insert(root2, 5); root2 = insert(root2, 18); root2 = insert(root2, 2); root2 = insert(root2, 1); root2 = insert(root2, 3); root2 = insert(root2, 4); int sum = 10; pairSum(root1, root2, sum); } }", "src": "class\nsolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n\nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n\n\n\nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n\n\n\n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n\n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n\n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n\n\n\n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n\n\n\n\nelse\n\nright--; \n\n} \n} \n\n\n\n\nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n\n\n\n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n\n\n\n\n\n\npairSumUtil(vect1, vect2, sum); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n\n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n}", "index": 249, "complexity": "1"}
{"forwhile": "class GFG: \n\n    @staticmethod \n    def dfs(w): \n        if cd[w] == 0: \n            return w \n        if wt[w] < ans: \n            ans = wt[w] \n        return dfs(cd[w]) \n\n    @staticmethod \n    def solve(arr): \n        i = 0 \n        while i < p: \n            q = arr[i][0] \n            h = arr[i][1] \n            t = arr[i][2] \n            cd[q] = h \n            wt[q] = t \n            rd[h] = q \n            i += 1 \n\n        a = [] \n        b = [] \n        c = [] \n        j = 1 \n        while j <= n: \n            if rd[j] == 0 and cd[j] > 0: \n                ans = 1000000000 \n                w = dfs(j) \n                a.append(j) \n                b.append(w) \n                c.append(ans) \n            j += 1 \n\n        print(len(a)) \n        j = 0 \n        for j in range(len(a)): \n            print(a[j], b[j], c[j]) \n\n    @staticmethod \n    def main(args): \n        n = 9 \n        p = 6 \n        for i in range(1100): \n            rd[i] = cd[i] = wt[i] = 0 \n\n        arr = [ \n                [7, 4, 98], \n                [5, 9, 72], \n                [4, 6, 10], \n                [2, 8, 22], \n                [9, 7, 17], \n                [3, 1, 66] \n              ] \n\n        solve(arr) \n", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nn, p; \n\n\n\n\n\n\nstatic\nint\nrd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\nwt[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\ncd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nList <Integer> a = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> b = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> c = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nint\nans; \n\n\nstatic\nint\ndfs(\nint\nw) \n\n{ \n\nif\n(cd[w] == \n0\n) \n\nreturn\nw; \n\nif\n(wt[w] < ans) \n\nans = wt[w]; \n\n\nreturn\ndfs(cd[w]); \n\n} \n\n\n\n\nstatic\nvoid\nsolve(\nint\narr[][]) \n\n{ \n\nint\ni = \n0\n; \n\n\nwhile\n(i < p) \n\n{ \n\n\nint\nq = arr[i][\n0\n]; \n\nint\nh = arr[i][\n1\n]; \n\nint\nt = arr[i][\n2\n]; \n\n\ncd[q] = h; \n\nwt[q] = t; \n\nrd[h] = q; \n\ni++; \n\n} \n\n\na=\nnew\nArrayList<Integer>(); \n\nb=\nnew\nArrayList<Integer>(); \n\nc=\nnew\nArrayList<Integer>(); \n\n\nfor\n(\nint\nj = \n1\n; j <= n; ++j) \n\n\n\n\nif\n(rd[j] == \n0\n&& cd[j]>\n0\n) { \n\nans = \n1000000000\n; \n\nint\nw = dfs(j); \n\n\n\n\n\n\n\n\na.add(j); \n\nb.add(w); \n\nc.add(ans); \n\n} \n\n\nSystem.out.println(a.size()); \n\n\nfor\n(\nint\nj = \n0\n; j < a.size(); ++j) \n\nSystem.out.println(a.get(j) + \n\" \"\n\n+ b.get(j) + \n\" \"\n+ c.get(j)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nn = \n9\n; \n\np = \n6\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n1100\n; i++) \n\nrd[i] = cd[i] = wt[i] = \n0\n; \n\n\nint\narr[][] = { { \n7\n, \n4\n, \n98\n}, \n\n{ \n5\n, \n9\n, \n72\n}, \n\n{ \n4\n, \n6\n, \n10\n}, \n\n{ \n2\n, \n8\n, \n22\n}, \n\n{ \n9\n, \n7\n, \n17\n}, \n\n{ \n3\n, \n1\n, \n66\n} }; \n\nsolve(arr); \n\n} \n}", "index": 251, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\npoliceThief(\\nchar\\narr[], \\nint\\nn, \\nint\\nk) \\n\\n{ \\n\\nint\\nres = \\n0\\n; \\n\\nArrayList<Integer> thi = \\nnew\\nArrayList<Integer>(); \\n\\nArrayList<Integer> pol = \\nnew\\nArrayList<Integer>(); \\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile\\ni < n: \\n\\nif\\narr[i] == \\n'P'\\n: \\n\\npol.add(i); \\nelif\\narr[i] == \\n'T'\\n: \\n\\nthi.add(i); \\n\\n\\ni += 1\\n; \\n\\n\\n\\n\\n\\nint\\nl = \\n0\\n, r = \\n0\\n; \\nfor\\nindex, value \\nin\\nrange(len(thi)): \\n\\nwhile\\nl < len(thi) and r < len(pol): \\n\\n\\n\\n\\n\\nif\\nMath.abs(thi[l] - pol[r]) <= k: \\n\\nres++; \\nl++; \\nr++; \\n\\n\\n\\nelif\\nthi[l] < pol[r]: \\n\\nl++; \\nelse\\n: \\nr++; \\n\\n\\nreturn\\nres; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\nk, n; \\n\\nchar\\narr1[] =\\nnew\\nchar\\n[] { \\n'P'\\n, \\n'T'\\n, \\n'T'\\n, \\n\\n'P'\\n, \\n'T'\\n}; \\n\\nk = \\n2\\n; \\nn = arr1.length; \\n\\nSystem.out.println(\\n\"Maximum thieves caught: \"\\n\\n+policeThief(arr1, n, k)); \\n\\n\\nchar\\narr2[] =\\nnew\\nchar\\n[] { \\n'T'\\n, \\n'T'\\n, \\n'P'\\n, \\n'P'\\n, \\n\\n'T'\\n, \\n'P'\\n}; \\n\\nk = \\n2\\n; \\nn = arr2.length; \\n\\nSystem.out.println(\\n\"Maximum thieves caught: \"\\n\\n+policeThief(arr2, n, k)); \\n\\n\\nchar\\narr3[] = \\nnew\\nchar\\n[]{ \\n'P'\\n, \\n'T'\\n, \\n'P'\\n, \\n'T'\\n, \\n\\n'T'\\n, \\n'P'\\n}; \\n\\nk = \\n3\\n; \\nn = arr3.length; \\n\\nSystem.out.println(\\n\"Maximum thieves caught: \"\\n\\n+policeThief(arr3, n, k)); \\n\\n} \\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n\n\n\n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n\n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n\n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n}", "index": 252, "complexity": "1"}
{"forwhile": "class GFG { static int minProductSubset(int a[], int n) { if (n == 1) return a[0]; int negmax = Integer.MIN_VALUE; int posmin = Integer.MAX_VALUE; int count_neg = 0, count_zero = 0; int product = 1; int i = 0; while (i < n) { if (a[i] == 0) { count_zero++; i++; continue; } if (a[i] < 0) { count_neg++; negmax = Math.max(negmax, a[i]); } if (a[i] > 0 && a[i] < posmin) posmin = a[i]; product *= a[i]; i++; } if (count_zero == n || (count_neg == 0 && count_zero > 0)) return 0; if (count_neg == 0) return posmin; if (count_neg % 2 == 0 && count_neg != 0) { product = product / negmax; } return product; } public static void main(String[] args) { int a[] = { -1, -1, -2, 4, 3}; int n = 5; System.out.println(minProductSubset(a, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nminProductSubset(\nint\na[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\na[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\n\nint\nnegmax = Integer.MIN_VALUE; \n\nint\nposmin = Integer.MAX_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nproduct = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(a[i] == \n0\n){ \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) \n\n{ \n\ncount_neg++; \n\nnegmax = Math.max(negmax, a[i]); \n\n} \n\n\n\n\nif\n(a[i] > \n0\n&& a[i] < posmin) \n\nposmin = a[i]; \n\n\nproduct *= a[i]; \n\n} \n\n\n\n\n\n\n\n\nif\n(count_zero == n || \n\n(count_neg == \n0\n&& count_zero > \n0\n)) \n\nreturn\n0\n; \n\n\n\n\nif\n(count_neg == \n0\n) \n\nreturn\nposmin; \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n0\n&& count_neg != \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nproduct = product / negmax; \n\n} \n\n\nreturn\nproduct; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\na[] = { -\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = \n5\n; \n\n\nSystem.out.println(minProductSubset(a, n)); \n\n} \n}", "index": 253, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\nstatic\\nint\\nmaxProductSubset(\\nint\\na[], \\nint\\nn) { \\n\\nif\\n(n == \\n1\\n) { \\n\\nreturn\\na[\\n0\\n]; \\n\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nint\\nmax_neg = Integer.MIN_VALUE; \\n\\nint\\ncount_neg = \\n0\\n, count_zero = \\n0\\n; \\n\\nint\\nprod = \\n1\\n; \\n\\nint\\ni = \\n0\\n; \\nwhile i < n: \\n\\n\\n\\n\\nif\\n(a[i] == \\n0\\n) { \\n\\n\\ncount_zero++; \\n\\ncontinue\\n; \\n\\n} \\n\\n\\n\\n\\nif\\n(a[i] < \\n0\\n) { \\n\\ncount_neg++; \\n\\nmax_neg = Math.max(max_neg, a[i]); \\n\\n} \\n\\n\\nprod = prod * a[i]; \\n\\ni += 1 \\n}\\n\\n\\nif\\n(count_zero == n) { \\n\\nreturn\\n0\\n; \\n\\n} \\n\\n\\n\\n\\nif\\n(count_neg % \\n2\\n== \\n1\\n) { \\n\\n\\n\\n\\nif\\n(count_neg == \\n1\\n\\n&& count_zero > \\n0\\n\\n&& count_zero + count_neg == n) { \\n\\nreturn\\n0\\n; \\n\\n} \\n\\n\\n\\n\\n\\n\\nprod = prod / max_neg; \\n\\n} \\n\\n\\nreturn\\nprod; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) { \\n\\nint\\na[] = {-\\n1\\n, -\\n1\\n, -\\n2\\n, \\n4\\n, \\n3\\n}; \\n\\nint\\nn = a.length; \\n\\nint\\ni = 0; \\nfor i in range(n): \\n\\nSystem.out.println(maxProductSubset(a, n)); \\n\\n\\n}", "src": "class\nGFG { \n\n\nstatic\nint\nmaxProductSubset(\nint\na[], \nint\nn) { \n\nif\n(n == \n1\n) { \n\nreturn\na[\n0\n]; \n\n} \n\n\n\n\n\n\n\n\nint\nmax_neg = Integer.MIN_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nprod = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(a[i] == \n0\n) { \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) { \n\ncount_neg++; \n\nmax_neg = Math.max(max_neg, a[i]); \n\n} \n\n\nprod = prod * a[i]; \n\n} \n\n\n\n\nif\n(count_zero == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n1\n) { \n\n\n\n\n\n\nif\n(count_neg == \n1\n\n&& count_zero > \n0\n\n&& count_zero + count_neg == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\n\n\nprod = prod / max_neg; \n\n} \n\n\nreturn\nprod; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\na[] = {-\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(maxProductSubset(a, n)); \n\n\n} \n}", "index": 254, "complexity": "1"}
{"forwhile": "class GFG { static int MinOperation(int a[], int n, int k) { int result = 0; int i = 0; while (i < n) { if (a[i] != 1 && a[i] > k) { result = result + Math.min(a[i] % k, k - a[i] % k); } else { result = result + k - a[i]; } i++; } return result; } public static void main (String[] args) { int arr[] = { 4, 5, 6}; int n = arr.length; int k = 5; System.out.println(MinOperation(arr, n, k)); } }", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nn, \nint\nk) \n{ \n\n\nint\nresult = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(a[i] != \n1\n&& a[i] > k) \n\n{ \n\nresult = result + \n\nMath.min(a[i] % k, \n\nk - a[i] % k); \n\n} \n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\nresult = result + k - a[i]; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr[] = {\n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n5\n; \n\nSystem.out.println(MinOperation(arr, n, k)); \n} \n}", "index": 256, "complexity": "1"}
{"forwhile": "class GFG { public static int maxSum(int stack1[], int stack2[], int stack3[], int n1, int n2, int n3) { int sum1 = 0, sum2 = 0, sum3 = 0; int i = 0; while (i < n1) { sum1 += stack1[i]; i++; } i = 0; while (i < n2) { sum2 += stack2[i]; i++; } i = 0; while (i < n3) { sum3 += stack3[i]; i++; } int top1 = 0, top2 = 0, top3 = 0; int ans = 0; for (;;) { if (top1 == n1 || top2 == n2 || top3 == n3) return 0; if (sum1 == sum2 && sum2 == sum3) return sum1; if (sum1 >= sum2 && sum1 >= sum3) sum1 -= stack1[top1++]; else if (sum2 >= sum3 && sum2 >= sum3) sum2 -= stack2[top2++]; else if (sum3 >= sum2 && sum3 >= sum1) sum3 -= stack3[top3++]; } } public static void main(String[] args) { int stack1[] = { 3, 2, 1, 1, 1}; int stack2[] = { 4, 3, 2}; int stack3[] = { 1, 1, 4, 1}; int n1 = stack1.length; int n2 = stack2.length; int n3 = stack3.length; System.out.println(maxSum(stack1, stack2, stack3, n1, n2, n3)); } }", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\nstack1[], \nint\nstack2[], \n\nint\nstack3[], \nint\nn1, \nint\nn2, \n\nint\nn3) \n\n{ \n\nint\nsum1 = \n0\n, sum2 = \n0\n, sum3 = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n1; i++) \n\nsum1 += stack1[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n2; i++) \n\nsum2 += stack2[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n3; i++) \n\nsum3 += stack3[i]; \n\n\n\n\n\n\nint\ntop1 =\n0\n, top2 = \n0\n, top3 = \n0\n; \n\nint\nans = \n0\n; \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\nif\n(top1 == n1 || top2 == n2 || top3 == n3) \n\nreturn\n0\n; \n\n\n\n\nif\n(sum1 == sum2 && sum2 == sum3) \n\nreturn\nsum1; \n\n\n\n\n\n\nif\n(sum1 >= sum2 && sum1 >= sum3) \n\nsum1 -= stack1[top1++]; \n\nelse\nif\n(sum2 >= sum3 && sum2 >= sum3) \n\nsum2 -= stack2[top2++]; \n\nelse\nif\n(sum3 >= sum2 && sum3 >= sum1) \n\nsum3 -= stack3[top3++]; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nstack1[] = { \n3\n, \n2\n, \n1\n, \n1\n, \n1\n}; \n\nint\nstack2[] = { \n4\n, \n3\n, \n2\n}; \n\nint\nstack3[] = { \n1\n, \n1\n, \n4\n, \n1\n}; \n\n\nint\nn1 = stack1.length; \n\nint\nn2 = stack2.length; \n\nint\nn3 = stack3.length; \n\n\nSystem.out.println(maxSum(stack1, stack2, \n\nstack3, n1, n2, n3)); \n\n} \n\n}", "index": 257, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintVector(Vector<Integer> v) \\n\\n{ \\n\\n\\n\\nSystem.out.println(v.size()); \\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile(i < v.size()) \\n{ \\nSystem.out.print(v.get(i) + \\n\\\" \\n\\\"\\n); \\ni++; \\n} \\n\\nSystem.out.println(); \\n\\n} \\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\nfindTwoGroup(\\nint\\nn) \\n\\n{ \\n\\n\\nint\\nsum = n * (n + \\n1\\n) / \\n2\\n; \\n\\n\\nint\\ngroup1Sum = sum / \\n2\\n; \\n\\n\\nVector<Integer> group1 = \\nnew\\nVector<Integer>(); \\n\\nVector<Integer> group2 = \\nnew\\nVector<Integer>(); \\n\\n\\nint\\ni = n; \\nwhile(i > \\n0\\n) { \\n\\n\\n\\n\\n\\n\\nif\\n(group1Sum - i >= \\n0\\n) { \\n\\n\\ngroup1.add(i); \\n\\n\\n\\ngroup1Sum -= i; \\n\\n} \\n\\nelse\\n{ \\n\\n group2.add(); \\n while(); \\n i = i - 1; \\n\\n} \\n\\n} \\n\\n\\n\\nprintVector(group1); \\n\\nprintVector(group2); \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain (String[] args) \\n\\n{ \\n\\nint\\nn = \\n5\\n; \\nfindTwoGroup(n); \\n} \\n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n\n\nSystem.out.println(v.size()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n\n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n\n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n\n\n\n\n\n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n\n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n\n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n}", "index": 258, "complexity": "1"}
{"forwhile": "def cost(a, n): \n    min = a[0] \n    i = 1 \n    while i < len(a): \n        if a[i] < min: \n            min = a[i] \n        i += 1 \n    return (n - 1) * min \n\n\n\n\n\n\n\n\n\n\ndef main(args): \n    a = [4, 3, 2] \n    n = len(a) \n    print(cost(a, n)) \n\n\n\n\n\nmain(None) ", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n\n\n\n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n}", "index": 259, "complexity": "1"}
{"forwhile": "class GFG : \n\nstatic void digitsNum( int N) : \n\n\n\nif (N == 0) : \n\nSystem.out.println('0') \n\n\n\n\n\n\n\nif (N % 9 != 0) : \n\nSystem.out.print((N % 9)) \n\n\n\n\ni = 1 \nwhile i <= (N / 9) : \n\nSystem.out.print('9') \n\ni += 1 \n\n\n\n\n\n\n\ni = 1 \nwhile i <= N : \n\nSystem.out.print('0') \n\nSystem.out.print('') \n\n\n\n\npublic static void main (String[]args) : \n\nN = 5 \n\nSystem.out.print('The number is : ') \n\n\ndigitsNum(N) ", "src": "class\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n\n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n\n\n\n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n}", "index": 260, "complexity": "1"}
{"forwhile": "class GFG { static void findSmallest(int m, int s) { if (s == 0) { System.out.print(m == 1 ? \"Smallest number is 0\" : \"Not possible\"); return; } if (s > 9 * m) { System.out.println(\"Not possible\"); return; } int[] res = new int[m]; s -= 1; int i = m - 1; while (i > 0) { if (s > 9) { res[i] = 9; s -= 9; } else { res[i] = s; s = 0; } i--; } res[0] = s + 1; System.out.print(\"Smallest number is \"); int i = 0; for (i = 0; i < m; i++) { System.out.print(res[i]); } } public static void main (String[] args) { int s = 9, m = 2; findSmallest(m, s); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n\n\n\n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n\n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nint\n[] res = \nnew\nint\n[m]; \n\n\n\n\n\n\n\n\ns -= \n1\n; \n\n\n\n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\nres[\n0\n] = s + \n1\n; \n\n\n\n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n}", "index": 261, "complexity": "1"}
{"forwhile": "class KeyComparator implements Comparator<Key> { public int compare(Key k1, Key k2) { if (k1.freq < k2.freq) return 1; else if (k1.freq > k2.freq) return - 1; return 0; } } class Key { int freq; char ch; Key(int val, char c) { freq = val; ch = c; } } class GFG { static int MAX_CHAR = 26; static void rearrangeString(String str) { int n = str.length(); int[] count = new int[MAX_CHAR]; int i = 0; while (i < n) { count[str.charAt(i) - 'a']++; i++; } PriorityQueue<Key> pq = new PriorityQueue<>(new KeyComparator()); char c = 'a'; while (c <= 'z') { int val = c - 'a'; if (count[val] > 0) pq.add(new Key(count[val], c)); c++; } str = \"\"; Key prev = new Key(-1, '#'); for (; !pq.isEmpty(); ) { Key k = pq.peek(); pq.poll(); str = str + k.ch; if (prev.freq > 0) pq.add(prev); k.freq--; prev = k; } if (n != str.length()) System.out.println(\" Not valid String \"); else System.out.println(str); } public static void main(String args[]) { String str = \"bbbaa\"; rearrangeString(str); } }", "src": "class\nKeyComparator \nimplements\nComparator<Key> { \n\n\n\n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n\n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n\n\n\n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n\n\nstr = \n\"\"\n; \n\n\n\n\n\n\n\n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n\n\nwhile\n(pq.size() != \n0\n) { \n\n\n\n\n\n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n\n\n\n\n\n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n\n\n\n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n\n\n\n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n}", "index": 262, "complexity": "1"}
{"forwhile": "public\\nclass\\nGfG{ \\n\\n\\n\\n\\npublic\\nstatic\\nString noAdjacentDup(String s1) \\n\\n{ \\n\\nint\\nn = s1.length(); \\n\\nchar\\n[] s = s1.toCharArray(); \\n\\nint\\ni = 1; \\n\\nwhile(i < n) \\n\\n{ \\n\\n\\n\\n\\nif\\n(s[i] == s[i - 1]) \\n\\n{ \\n\\n\\n\\ns[i] = 'a'; \\n\\n\\n\\n\\n\\n\\nint\\ntmp = 0; \\n\\nwhile(s[i] == s[i - 1] || \\n\\n(i + 1 < n && s[i] == s[i + 1])){ \\n\\n  s[i]++;\\n  tmp++;\\n} \\n\\ni += tmp; \\n\\n} \\n\\ni++; \\n\\n} \\n\\nreturn\\n(new\\nString(s)); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String argc[]){ \\n\\n\\nString s = \\\"geeksforgeeks\\\"; \\n\\nSystem.out.println(noAdjacentDup(s)); \\n\\n\\n} \\n\\n}", "src": "public\nclass\nGfG{ \n\n\n\n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n\n\ns[i] = \n'a'\n; \n\n\n\n\n\n\n\n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n}", "index": 263, "complexity": "1"}
{"forwhile": "class Main {    static int getMissingNo(int a[], int n) {    int i, total;    total = (n + 1) * (n + 2) / 2;    i = 0;    while (i < n) {    total -= a[i];    i++;    }    return total;    }    public static void main(String args[]) {    int a[] = { 1 , 2 , 4 , 5 , 6};    int miss = getMissingNo(a, 5);    System.out.println(miss);    }    }", "src": "class\nMain { \n\n\n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n}", "index": 265, "complexity": "1"}
{"forwhile": "class SecondSmallest { static void print2Smallest(int arr[]) { int first, second, arr_size = arr.length; if (arr_size < 2) { System.out.println(\" Invalid Input \"); return; } first = second = Integer.MAX_VALUE; int i = 0; while (i < arr_size) { if (arr[i] < first) { second = first; first = arr[i]; } else if (arr[i] < second && arr[i] != first) second = arr[i]; i++; } if (second == Integer.MAX_VALUE) System.out.println(\"There is no second\" + \"smallest element\"); else System.out.println(\"The smallest element is \" + first + \" and second Smallest\" + \" element is \" + second); } public static void main (String[] args) { int arr[] = {12, 13, 1, 10, 34, 1}; print2Smallest(arr); } }", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 266, "complexity": "1"}
{"forwhile": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int i; if (x <= arr[low]) return low; i = low; while (i < high) { if (arr[i] == x) return i; if (arr[i] < x && arr[i+1] >= x) return i+1; i++; } return -1; } public static void main (String[] args) { int arr[] = {1, 2, 8, 10, 10, 12, 19}; int n = arr.length; int x = 3; int index = ceilSearch(arr, 0, n-1, x); if (index == -1) System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\"); else System.out.println(\"ceiling of \" + x + \" is \" + arr[index]); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\ni; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nfor\n(i = low; i < high; i++) \n\n{ \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\n\n\n\nif\n(arr[i] < x && arr[i+\n1\n] >= x) \n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 267, "complexity": "1"}
{"forwhile": "class Main {\n\nstatic int countOccurrences(int arr[], int n, int x) {\n\nint res = 0;\n\nint i=0;\nwhile (i<n) {\nif (x == arr[i])\n\nres++;\ni++;\n}\n\nreturn res;\n}\n\n\npublic static void main(String args[]) {\n\nint arr[] = {1, 2, 2, 2, 2, 3, 4, 7, 8, 8};\n\nint n = arr.length;\n\nint x = 2;\n\nSystem.out.println(countOccurrences(arr, n, x));\n\n}\n}", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n}", "index": 268, "complexity": "1"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 211 (char 212)", "src": "class\nGFG { \n\n\nstatic\nvoid\nprintTwoElements(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nSystem.out.print(\n\"The repeating element is \"\n); \n\n\nfor\n(i = \n0\n; i < size; i++) { \n\nint\nabs_val = Math.abs(arr[i]); \n\nif\n(arr[abs_val - \n1\n] > \n0\n) \n\narr[abs_val - \n1\n] = -arr[abs_val - \n1\n]; \n\nelse\n\nSystem.out.println(abs_val); \n\n} \n\n\nSystem.out.print(\n\"And the missing element is \"\n); \n\nfor\n(i = \n0\n; i < size; i++) { \n\nif\n(arr[i] > \n0\n) \n\nSystem.out.println(i + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n7\n, \n3\n, \n4\n, \n5\n, \n5\n, \n6\n, \n2\n}; \n\nint\nn = arr.length; \n\nprintTwoElements(arr, n); \n\n} \n}", "index": 269, "complexity": "1"}
{"forwhile": "class GFG { static int x, y; static void getTwoElements(int arr[], int n) { int xor1; int set_bit_no; int i; x = 0; y = 0; xor1 = arr[0]; i = 1; while(i < n) { xor1 = xor1 ^ arr[i]; i++; } i = 1; while(i <= n) { xor1 = xor1 ^ i; i++; } set_bit_no = xor1 & ~(xor1 - 1); i = 0; while(i < n) { if((arr[i] & set_bit_no) != 0) x = x ^ arr[i]; else y = y ^ arr[i]; i++; } i = 1; while(i <= n) { if((i & set_bit_no) != 0) x = x ^ i; else y = y ^ i; i++; } } public static void main(String[] args) { int arr[] = { 1, 3, 4, 5, 1, 6, 2 }; int n = arr.length; getTwoElements(arr, n); System.out.println(\" The missing element is \" + x + \"and the \" + \"repeating number is \" + y); } }", "src": "class\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nxor1; \n\n\n\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n\n\nx = x ^ arr[i]; \n\n\nelse\n\n\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n\n\nx = x ^ i; \n\n\nelse\n\n\n\ny = y ^ i; \n\n} \n\n\n\n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n}", "index": 270, "complexity": "1"}
{"forwhile": "class Main: \n\n    @staticmethod \n    def linearSearch(arr, n): \n        i = 0 \n        while i < n: \n            if arr[i] == i: \n                return i \n            i += 1 \n        return -1 \n\n    @staticmethod \n    def main(args): \n        arr = [-10, -1, 0, 3, 10, 11, 30, 50, 100] \n        n = len(arr) \n        print('Fixed Point is ' + str(Main.linearSearch(arr, n)))", "src": "class\nMain \n{ \n\nstatic\nint\nlinearSearch(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == i) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ linearSearch(arr, n)); \n\n} \n}", "index": 271, "complexity": "1"}
{"forwhile": "class Main { static int findMaximum(int arr[], int low, int high) { int max = arr[low]; int i = low; while(i <= high) { if(arr[i] > max) max = arr[i]; i++; } return max; } public static void main (String[] args) { int arr[] = {1, 30, 40, 50, 60, 70, 23, 20}; int n = arr.length; System.out.println(\"The maximum element is \"+ findMaximum(arr, 0, n-1)); } }", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni; \n\nfor\n(i = low; i <= high; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n} \n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 272, "complexity": "1"}
{"forwhile": "class PairDifference:\n\n    @staticmethod\n    def findPair(arr, n):\n        size = len(arr)\n        i = 0\n        j = 1\n        for i in range(size):\n            for j in range(size):\n                if i != j and arr[j] - arr[i] == n:\n                    print('Pair Found: ( ' + str(arr[i]) + ', ' + str(arr[j]) + ' )')\n                    return True\n                elif arr[j] - arr[i] < n:\n                    j += 1\n                else:\n                    i += 1\n        print('No such pair')\n        return False\n\n    @staticmethod\n    def main(args):\n        arr = [1, 8, 30, 40, 100]\n        n = 60\n        PairDifference.findPair(arr, n)\n", "src": "class\nPairDifference \n{ \n\n\n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n\n\nint\ni = \n0\n, j = \n1\n; \n\n\n\n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n}", "index": 273, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nprint2largest(\\nint\\narr[], \\n\\nint\\narr_size) \\n\\n{ \\n\\nint\\ni, first, second; \\n\\n\\n\\nif\\n(arr_size < \\n2\\n) \\n\\n{ \\n\\nSystem.out.print(\\n\" Invalid Input \"\\n); \\n\\nreturn\\n; \\n\\n} \\n\\n\\ni = 0\\n; \\nwhile i < arr_size : \\n\\n{ \\n\\n\\n\\nif\\n(arr[i] > first) \\n\\n{ \\n\\nsecond = first; \\n\\nfirst = arr[i]; \\n\\n} \\n\\n\\n\\nelse\\nif\\n(arr[i] > second && arr[i] != first) \\n\\nsecond = arr[i]; \\n\\n\\ni += 1\\n; \\n} \\n\\n\\nif\\n(second == Integer.MIN_VALUE) \\n\\nSystem.out.print(\\n\"There is no second largest\"\\n+ \\n\\n\" element\\\\n\"\\n); \\n\\nelse\\n\\nSystem.out.print(\\n\"The second largest element\"\\n+ \\n\\n\" is \"\\n+ second); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\narr[] = {\\n12\\n, \\n35\\n, \\n1\\n, \\n10\\n, \\n34\\n, \\n1\\n}; \\n\\nint\\narr_size = arr.length; \\n\\ni = 0\\n; \\nfor i in range(arr_size): \\n\\n{ \\n\\nprint2largest(arr, arr_size); \\n\\n} \\n\\n} \\n}", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n}", "index": 274, "complexity": "1"}
{"forwhile": "class Main { static void printFirstRepeating(int arr[]) { int min = -1; HashSet<Integer> set = new HashSet<>(); int i = arr.length - 1; while (i >= 0) { if (set.contains(arr[i])) min = i; else set.add(arr[i]); i--; } if (min != -1) System.out.println(\"The first repeating element is \" + arr[min]); else System.out.println(\"There are no repeating elements\"); } public static void main (String[] args) throws java.lang.Exception { int arr[] = { 10, 5, 3, 4, 3, 5, 6 }; int i = arr.length - 1; for (; i >= 0; i--) { if (set.contains(arr[i])) min = i; else set.add(arr[i]); } if (min != -1) System.out.println(\"The first repeating element is \" + arr[min]); else System.out.println(\"There are no repeating elements\"); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nvoid\nprintFirstRepeating(\nint\narr[]) \n\n{ \n\n\n\nint\nmin = -\n1\n; \n\n\n\n\nHashSet<Integer> set = \nnew\nHashSet<>(); \n\n\n\n\nfor\n(\nint\ni=arr.length-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nif\n(set.contains(arr[i])) \n\nmin = i; \n\n\nelse\n\n\nset.add(arr[i]); \n\n} \n\n\n\n\nif\n(min != -\n1\n) \n\nSystem.out.println(\n\"The first repeating element is \"\n+ arr[min]); \n\nelse\n\nSystem.out.println(\n\"There are no repeating elements\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \nthrows\njava.lang.Exception \n\n{ \n\nint\narr[] = {\n10\n, \n5\n, \n3\n, \n4\n, \n3\n, \n5\n, \n6\n}; \n\nprintFirstRepeating(arr); \n\n} \n}", "index": 275, "complexity": "1"}
{"forwhile": "class FindCommon {\n\n\n\nvoid findCommon(int ar1[], int ar2[], int ar3[]) {\n\n\n\nint i = 0, j = 0, k = 0;\n\n\n\nfor (i = 0; i < ar1.length; i++) {\n\nfor (j = 0; j < ar2.length; j++) {\n\nfor (k = 0; k < ar3.length; k++) {\n\nif (ar1[i] == ar2[j] && ar2[j] == ar3[k]) {\nSystem.out.print(ar1[i]+ \" \");\n}\n}\n}\n}\n}\n\npublic static void main(String args[]) {\n\nFindCommon ob = new FindCommon();\n\nint ar1[] = {1, 5, 10, 20, 40, 80};\n\nint ar2[] = {6, 7, 20, 80, 100};\n\nint ar3[] = {3, 4, 15, 20, 30, 70, 80, 120};\n\nSystem.out.print(\"Common elements are \");\nob.findCommon(ar1, ar2, ar3);\n}\n}", "src": "class\nFindCommon \n{ \n\n\n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n\n\n\n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n\n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n\n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n\n\nelse\n\nk++; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n}", "index": 276, "complexity": "1"}
{"forwhile": "class CloseSum { static void printClosest(int arr[], int n, int x) { int res_l=0, res_r=0; int l = 0, r = n-1, diff = Integer.MAX_VALUE; for ( ; r > l; ) { if (Math.abs(arr[l] + arr[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(arr[l] + arr[r] - x); } if (arr[l] + arr[r] > x) r--; else l++; } System.out.println(\" The closest pair is \"+arr[res_l]+\" and \"+ arr[res_r]); } public static void main(String[] args) { int arr[] = { 10, 22, 28, 29, 30, 40}, x = 54; int n = arr.length; printClosest(arr, n, x); } }", "src": "class\nCloseSum { \n\n\n\n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n\n\n\n\n\n\n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n\n\nwhile\n(r > l) \n\n{ \n\n\n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n\n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n}", "index": 277, "complexity": "1"}
{"forwhile": "class ClosestPair:\n    def printClosest(self, ar1, ar2, m, n, x):\n        diff = float('inf')\n        res_l, res_r = 0, 0\n        l, r = 0, n - 1\n        for l in range(m):\n            for r in range(n - 1, -1, -1):\n                if abs(ar1[l] + ar2[r] - x) < diff:\n                    res_l = l\n                    res_r = r\n                    diff = abs(ar1[l] + ar2[r] - x)\n                if ar1[l] + ar2[r] > x:\n                    break\n        print(f'The closest pair is [{ar1[res_l]}, {ar2[res_r]}]')\n\n    @staticmethod\n    def main(args):\n        ob = ClosestPair()\n        ar1 = [1, 4, 5, 7]\n        ar2 = [10, 20, 30, 40]\n        m = len(ar1)\n        n = len(ar2)\n        x = 38\n        ob.printClosest(ar1, ar2, m, n, x)\n", "src": "class\nClosestPair \n{ \n\n\n\n\n\n\n\n\n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n\n\n\n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n\n\n\n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\n\n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n}", "index": 278, "complexity": "1"}
{"forwhile": "class PairInSortedRotated: def pairInSortedRotated(arr, n, x): i = 0 while i < n - 1: if arr[i] > arr[i + 1]: break l = (i + 1) % n r = i while l != r: if arr[l] + arr[r] == x: return True if arr[l] + arr[r] < x: l = (l + 1) % n else: r = (n + r - 1) % n return False def main(args): arr = [11, 15, 6, 8, 9, 10] sum = 16 n = len(arr) if pairInSortedRotated(arr, n, sum): print('Array has two elements with sum 16') else: print('Array doesn\\'t have two elements with sum 16') ", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 279, "complexity": "1"}
{"forwhile": "arr = [12, 34, 10, 6, 40] \n\n\ndef findLargestSumPair(): \n    first, second = (arr[0], arr[1]) if arr[0] > arr[1] else (arr[1], arr[0]) \n    i = 2 \n    while i < len(arr): \n        if arr[i] > first: \n            second = first \n            first = arr[i] \n        elif arr[i] > second and arr[i] != first: \n            second = arr[i] \n        i += 1 \n    return first + second \n\n\ndef main(args): \n    print('Max Pair Sum is ' + str(findLargestSumPair())) \n\n\nif __name__ == '__main__': \n    main([])", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n12\n, \n34\n, \n10\n, \n6\n, \n40\n}; \n\n\n\n\nstatic\nint\nfindLargestSumPair() \n\n{ \n\n\n\nint\nfirst, second; \n\nif\n(arr[\n0\n] > arr[\n1\n]) \n\n{ \n\nfirst = arr[\n0\n]; \n\nsecond = arr[\n1\n]; \n\n} \n\nelse\n\n{ \n\nfirst = arr[\n1\n]; \n\nsecond = arr[\n0\n]; \n\n} \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i<arr.length; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nreturn\n(first + second); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nSystem.out.println(\n\"Max Pair Sum is \"\n+ findLargestSumPair()); \n\n\n} \n}", "index": 280, "complexity": "1"}
{"forwhile": "class SecondSmallest { static void print2Smallest(int arr[]) { int first, second, arr_size = arr.length; if (arr_size < 2) { System.out.println(\" Invalid Input \"); return; } first = second = Integer.MAX_VALUE; int i = 0; while (i < arr_size) { if (arr[i] < first) { second = first; first = arr[i]; } else if (arr[i] < second && arr[i] != first) second = arr[i]; i += 1; } if (second == Integer.MAX_VALUE) System.out.println(\"There is no second\"+ \"smallest element\"); else System.out.println(\"The smallest element is \"+ first + \" and second Smallest\"+ \" element is \"+ second); } public static void main (String[] args) { int arr[] = {12, 13, 1, 10, 34, 1}; print2Smallest(arr); } }", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 281, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main (String[] args) throws java.lang.Exception {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 282, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tarr[i] = s.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti = 1;\n\t\twhile (i < n) {\n\t\t\tans = Math.min(ans, Math.min(arr[i], arr[0]) / i);\n\t\t\ti++;\n\t\t}\n\t\tint j = n - 2;\n\t\tfor (; j >= 0; j--) {\n\t\t\tans = Math.min(ans, Math.min(arr[n - 1], arr[j]) / (n - j - 1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 283, "complexity": "1"}
{"forwhile": "n=int(input())\nmin_val=float('inf')\ni=0\nwhile i<n:\n    tmp=int(input())\n    if i>n-1-i:\n        tmp=tmp//i\n    else:\n        tmp=tmp//(n-1-i)\n    if tmp<min_val:\n        min_val=tmp\n    i+=1\nprint(min_val)", "src": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 284, "complexity": "1"}
{"forwhile": "n = int(input())\nk = int(input())\nif n == k:\n\ts = ''\n\ti = 0\n\twhile i < k:\n\t\ts = s + '1'\n\t\ti += 1\n\tprint(s)\nelse:\n\ta = (n - k) // 2\n\ts = ''\n\ti = 0\n\twhile i < a and len(s) < n:\n\t\ts = s + '1'\n\t\ti += 1\n\tif len(s) < n:\n\t\ts = s + '0'\n\twhile len(s) < n:\n\t\ts = s + s\n\ts1 = ''\n\tfor _ in range(n):\n\t\ts1 = s1 + s[_]\n\tprint(s1)", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "index": 285, "complexity": "1"}
{"forwhile": "class MaximumSum {\n\n    int FindMaxSum(int arr[], int n) {\n\n        int incl = arr[0];\n        int excl = 0;\n        int excl_new;\n        int i = 1;\n\n        while (i < n) {\n            excl_new = (incl > excl) ? incl : excl;\n            incl = excl + arr[i];\n            excl = excl_new;\n            i++;\n        }\n\n        return ((incl > excl) ? incl : excl);\n    }\n\n    public static void main(String[] args) {\n        MaximumSum sum = new MaximumSum();\n        int arr[] = new int[]{5, 5, 10, 100, 10, 5};\n        System.out.println(sum.FindMaxSum(arr, arr.length));\n    }\n}", "src": "class\nMaximumSum \n{ \n\n\n\nint\nFindMaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nincl = arr[\n0\n]; \n\nint\nexcl = \n0\n; \n\nint\nexcl_new; \n\nint\ni; \n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\n\n\nexcl_new = (incl > excl) ? incl : excl; \n\n\n\n\nincl = excl + arr[i]; \n\nexcl = excl_new; \n\n} \n\n\n\n\nreturn\n((incl > excl) ? incl : excl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMaximumSum sum = \nnew\nMaximumSum(); \n\nint\narr[] = \nnew\nint\n[]{\n5\n, \n5\n, \n10\n, \n100\n, \n10\n, \n5\n}; \n\nSystem.out.println(sum.FindMaxSum(arr, arr.length)); \n\n} \n}", "index": 286, "complexity": "1"}
{"forwhile": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            int i=0;\n            while(i<k){\n                s=s+\"1\";\n                i++;\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            for(int j=0;j<k;j++){\n                if(s.length()<n){\n                    s=s+\"1\";\n                }\n            }\n            for(int i=0;i<k;i++){\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            while(s.length()<n){\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "index": 287, "complexity": "1"}
{"forwhile": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t\ti += 1;\n\t\t}\n\t\t\n\t\tint k = 2;\n\t\tfor(; k <= m; k++) {\n\t\t\tint j = 'a';\n\t\t\twhile(j <= 'z') {\n\t\t\t\tif(exist[j]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tint i = j + 2;\n\t\t\t\t\tfor(; i <= 'z'; i++) {\n\t\t\t\t\t\tif(dn[i][k-1] > 0 && (a == 0 || (a > dn[i][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[i][k-1];\n\t\t\t\t\t}\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[j][k] = a + j - 'a' + 1; \n\t\t\t\t}\n\t\t\t\tj += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tint i = 'a';\n\t\tfor(; i <= 'z'; i++) {\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 288, "complexity": "1"}
{"forwhile": "import java.util.Scanner\n\nclass helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tcnt += in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ti = 0;\n\t\twhile (i < n) {\n\t\t\tcnt -= in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif (cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 289, "complexity": "1"}
{"forwhile": "class Piles:\n    @staticmethod\n    def summation(arr):\n        k = 0\n        sum = 0\n        while k < len(arr):\n            sum = sum + arr[k]\n            k += 1\n        return sum\n    \n    @staticmethod\n    def main(args):\n        n = int(input())\n        if n >= 1 and n <= 50:\n            x = [0] * n\n            y = [0] * n\n            i = 0\n            while i < n:\n                x[i] = int(input())\n                i += 1\n            j = 0\n            while j < n:\n                y[j] = int(input())\n                j += 1\n            xsum = Piles.summation(x)\n            ysum = Piles.summation(y)\n            if xsum >= ysum:\n                print('Yes')\n            else:\n                print('No')\n        \nPiles.main(None)", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 290, "complexity": "1"}
{"forwhile": "class GFG { public static int findFrequency(int arr[], int n, int left, int right, int element) { int count = 0; int i = left - 1; while (i < right) { if (arr[i] == element) count++; i++; } return count; } public static void main(String[] args) { int arr[] = {2, 8, 6, 9, 8, 6, 8, 2, 11}; int n = arr.length; System.out.println(\"Frequency of 2 from 1 to 6 = \"+ findFrequency(arr, n, 1, 6, 2)); System.out.println(\"Frequency of 8 from 4 to 9 = \"+ findFrequency(arr, n, 4, 9, 8)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n\n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n\n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n}", "index": 291, "complexity": "1"}
{"forwhile": "from java.util import Scanner\n\ndef main(args):\n    input = Scanner(System['in'])\n    n = input.nextInt()\n    s1 = 0\n    s2 = 0\n    i = 0\n    while i < n:\n        s1 += input.nextInt()\n        i += 1\n    i = 0\n    while i < n:\n        s2 += input.nextInt()\n        i += 1\n    if s1 >= s2:\n        print('Yes')\n    else:\n        print('No')\n", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 292, "complexity": "1"}
{"forwhile": "from java.util import Scanner\n\npublic class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]\n\t\tint x = scan.nextInt()\n\t\ti = 0\n\t\twhile i < 2:\n\t\t\tj = 0\n\t\t\twhile j < x:\n\t\t\t\ta[i] += scan.nextInt()\n\t\t\t\tj += 1\n\t\t\ti += 1\n\t\t\tif a[1] <= a[0]:\n\t\t\t\tprint(\"Yes\")\n\t\t\telse:\n\t\t\t\tprint(\"No\")\n\n\t}\n\n}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 293, "complexity": "1"}
{"forwhile": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              int i = 0;\n              while(i < n){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n                     i++;\n              }\n              i = 0;\n              while(i < n){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     i++;\n              }\n              i = 0;\n              while(i < n){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n                     i++;\n              }\n              System.out.println(-1);\n      }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 294, "complexity": "1"}
{"forwhile": "import java.util.*;\nimport java.io.*;\n\npublic class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        int i = 1;\n        while (i <= n && ans == -1) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n            i++;\n        }\n\n        pw.println(ans);\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 295, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = new int[]{10, 1, 2, 3, 4, 5, 6, 7, 8, 9}; static int maxSum() { int arrSum = 0; int currVal = 0; int i = 0; while (i < arr.length) { arrSum = arrSum + arr[i]; currVal = currVal + (i * arr[i]); i++; } int maxVal = currVal; int j = 1; while (j < arr.length) { currVal = currVal + arrSum - arr.length * arr[arr.length - j]; if (currVal > maxVal) maxVal = currVal; j++; } return maxVal; } public static void main(String[] args) { System.out.println(\"Max sum is \" + maxSum()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n\n\nstatic\nint\nmaxSum() \n\n{ \n\n\n\nint\narrSum = \n0\n; \n\n\nint\ncurrVal = \n0\n; \n\n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n\n\nint\nmaxVal = currVal; \n\n\n\n\n\n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n\n\nreturn\nmaxVal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n}", "index": 296, "complexity": "1"}
{"forwhile": "public class TaskA:\n    def main(args):\n        sc = Scanner(System.in)\n        out = PrintWriter(System.out)\n        i = sc.nextInt()\n        goal = sc.nextLong()\n        if i > goal:\n            i = goal\n        count = 0\n        for goal in range(goal, -1, -1):\n            if goal - i >= 0:\n                goal = goal - i\n                count += 1\n            else:\n                i -= 1\n            if goal == 0:\n                break\n        out.print(count)\n        out.flush()\n\n    class Scanner:\n        def __init__(self, system):\n            self.st = None\n            if system == System.in:\n                self.br = BufferedReader(InputStreamReader(system))\n            else:\n                self.br = BufferedReader(FileReader(system))\n\n        def next(self):\n            while self.st is None or not self.st.hasMoreTokens():\n                self.st = StringTokenizer(self.br.readLine())\n            return self.st.nextToken()\n\n        def nextLine(self):\n            return self.br.readLine()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextChar(self):\n            return self.next()[0]\n\n        def nextLong(self):\n            return int(self.next())\n\n        def ready(self):\n            return self.br.ready()\n\n        def waitForInput(self):\n            time.sleep(3)", "src": "public class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 297, "complexity": "1"}
{"forwhile": "n = in.nextInt()\nS = in.nextInt()\nmCoins = 0\nfor _ in range(S//n):\n\tmCoins+=1\n\tS-=n\nmCoins = mCoins if S == 0 else mCoins+1\nSystem.out.print(mCoins)", "src": "public class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "index": 298, "complexity": "1"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 2227 (char 2228)", "src": "public class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "index": 299, "complexity": "1"}
{"forwhile": "input = Scanner(System.in)\na = input.nextLong()\ninput.nextLine()\ncoo = input.nextLine().split(\" \")\nxcoin = Long.parseLong(coo[0])\nycoin = Long.parseLong(coo[1])\nfirst = coordinates(1, 1, a)\nsecond = coordinates(a, a, a)\nx = (double)Math.sqrt(Math.abs((xcoin - 1) * (xcoin - 1) + (ycoin - 1) * (ycoin - 1)))\ny = (double)Math.sqrt(Math.abs((xcoin - a) * (xcoin - a) + (ycoin - a) * (ycoin - a))\nc = 0\nd = 0\nif x > y:\n    System.out.println(\"Black\")\nelif x < y:\n    System.out.println(\"White\")\nelse:\n    c = first.Distance(coordinates(xcoin, ycoin, a))\n    d = second.Distance(coordinates(xcoin, ycoin, a))\nif d != 0 and c != 0:\n    while not (first.xcoord == xcoin and first.ycoord == ycoin):\n        if xcoin > first.xcoord:\n            first.setCoordinates(first.xcoord + 1, first.ycoord)\n        elif xcoin < first.xcoord:\n            first.setCoordinates(first.xcoord - 1, first.ycoord)\n        elif ycoin > first.ycoord:\n            first.setCoordinates(first.xcoord, first.ycoord + 1)\n        elif ycoin < first.ycoord:\n            first.setCoordinates(first.xcoord, first.ycoord - 1)\n        elif xcoin >= first.xcoord and ycoin <= first.ycoord:\n            first.setCoordinates(first.xcoord + 1, first.ycoord - 1)\n        elif xcoin >= first.xcoord and ycoin >= first.ycoord:\n            first.setCoordinates(first.xcoord + 1, first.ycoord + 1)\n        elif xcoin <= first.xcoord and ycoin <= first.ycoord:\n            first.setCoordinates(first.xcoord - 1, first.ycoord - 1)\n        elif xcoin <= first.xcoord and ycoin >= first.ycoord:\n            first.setCoordinates(first.xcoord - 1, first.ycoord + 1)\n    distance = 0;\n    return distance\n    while not (second.xcoord == xcoin and second.ycoord == ycoin):\n        if xcoin > second.xcoord:\n            second.setCoordinates(second.xcoord + 1, second.ycoord)\n        elif xcoin < second.xcoord:\n            second.setCoordinates(second.xcoord - 1, second.ycoord)\n        elif ycoin > second.ycoord:\n            second.setCoordinates(second.xcoord, second.ycoord + 1)\n        elif ycoin < second.ycoord:\n            second.setCoordinates(second.xcoord, second.ycoord - 1)\n        elif xcoin >= second.xcoord and ycoin <= second.ycoord:\n            second.setCoordinates(second.xcoord + 1, second.ycoord - 1)\n        elif xcoin >= second.xcoord and ycoin >= second.ycoord:\n            second.setCoordinates(second.xcoord + 1, second.ycoord + 1)\n        elif xcoin <= second.xcoord and ycoin <= second.ycoord:\n            second.setCoordinates(second.xcoord - 1, second.ycoord - 1)\n        elif xcoin <= second.xcoord and ycoin >= second.ycoord:\n            second.setCoordinates(second.xcoord - 1, second.ycoord + 1)\n    distance = 0;\n    return distance", "src": "public class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  \n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}", "index": 300, "complexity": "1"}
{"forwhile": "class GFG { static int answer_query( int a[], int n, int l, int r) { int count = 0 ; int i = l; while(i < r) { if(a[i] == a[i + 1]) count += 1 ; i += 1 ; } return count; } public static void main(String[] args) { int a[] = {1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 }; int n = a.length; int L, R; L = 1 ; R = 8 ; System.out.println( answer_query(a, n, L, R)); L = 0 ; R = 4 ; System.out.println( answer_query(a, n, L, R)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n\n\n\n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n\n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n}", "index": 301, "complexity": "1"}
{"forwhile": "loca=[]\nres=[]\ni=0\nwhile i<m+n:\n\tloca.append(int(input()))\n\ti+=1\n\ny=0\ndriver=[]\ni=0\nwhile i<n+m:\n\tx=int(input())\n\tif x==1:\n\t\tdriver.append(i)\n\ti+=1\n\ni=0\nj=0\np=0\nq=0\nwhile i<m+n:\n\tif i==driver[0]:\n\t\ti+=1\n\t\tbreak\n\tif loca[i]<loca[driver[0]]:\n\t\tres.append(res[0]+1)\n\telse:\n\t\tbreak\n\ti+=1\n\nwhile i<n+m:\n\tcoor=loca[i]\n\tif j==m-1:\n\t\tbreak\n\tp=driver[j]\n\tq=driver[j+1]\n\tif i==j:\n\t\tcontinue\n\td1=coor-loca[p]\n\td2=loca[q]-coor\n\tif d2==0:\n\t\tj+=1\n\t\tcontinue\n\tif d1<=d2:\n\t\tres[j]+=1\n\telse:\n\t\tres[j+1]+=1\n\ti+=1\n\nwhile i<m+n:\n\tif i==driver[j]:\n\t\ti+=1\n\t\tbreak\n\tif loca[i]>loca[driver[j]]:\n\t\tres[j]+=1\n\telse:\n\t\tbreak\n\ti+=1\n\nfor i in range(m):\n\tprint(res[i],end=' ')", "src": "public class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "index": 302, "complexity": "1"}
{"forwhile": "class GFG { static int repeated_digit(int n) { LinkedHashSet<Integer> s = new LinkedHashSet<>(); for ( ; n != 0 ; ) { int d = n % 10; if (s.contains(d)) { return 0; } s.add(d); n = n / 10; } return 1; } static int calculate(int L, int R) { int answer = 0; int i = L; while (i < R + 1) { answer = answer + repeated_digit(i); i++; } return answer; } public static void main(String[] args) { int L = 1, R = 100; System.out.println(calculate(L, R)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n\n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n\n\n\n\n\n\nif\n(s.contains(d)) \n\n{ \n\n\n\n\n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n\n\n\n\nreturn\n1\n; \n} \n\n\n\n\nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n\n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n\n\n\n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n\n\nSystem.out.println(calculate(L, R)); \n} \n}", "index": 303, "complexity": "1"}
{"forwhile": "class GFG { static void initializeDiffArray(int A[], int D[]) { int n = A.length; D[0] = A[0]; D[n] = 0; int i = 1; while (i < n) { D[i] = A[i] - A[i - 1]; i++; } } static void update(int D[], int l, int r, int x) { D[l] += x; D[r + 1] -= x; } static int printArray(int A[], int D[]) { int i = 0; int len = A.length; while (i < len) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); i++; } System.out.println(); return 0; } public static void main(String[] args) { int A[] = { 10, 5, 20, 40 }; int n = A.length; int D[] = new int[n + 1]; initializeDiffArray(A, D); update(D, 0, 1, 10); printArray(A, D); update(D, 1, 3, 20); update(D, 2, 2, 30); printArray(A, D); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n\n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n\n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n\n\n\n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n\n\n\n\n\n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n\n\n\n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n\n\n\n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n}", "index": 304, "complexity": "1"}
{"forwhile": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\npublic class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        int i = 0;\n        while (i < n) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n            max = max < ++arr[tmp] ? arr[tmp] : max;\n            i++;\n        }\n        System.out.println(max);\n    }\n}", "src": "public class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "index": 305, "complexity": "1"}
{"forwhile": "from sys import stdin, stdout\n\n\nclass Contest1:\n    def solve(self, test_number, a, b, x):\n        s = \"\"\n        count = 0\n        copya = a\n        copyb = b\n        change = 0\n\n        if x == 1:\n            if copya > copyb:\n                a2 = a\n                s1 = \"\"\n                while a2 > 0:\n                    s1 += '0'\n                    a2 -= 1\n                b2 = b\n                while b2 > 0:\n                    s1 += '1'\n                    b2 -= 1\n                s = s1\n            else:\n                b2 = b\n                s1 = \"\"\n                while b2 > 0:\n                    s1 += '1'\n                    b2 -= 1\n                a2 = a\n                while a2 > 0:\n                    s1 += '0'\n                    a2 -= 1\n                s = s1\n\n        else:\n            if copya > copyb:\n                while change <= x - 1:\n                    if change % 2 == 0:\n                        s += '0'\n                        change += 1\n                        a -= 1\n                    else:\n                        s += '1'\n                        change += 1\n                        b -= 1\n            elif copyb >= copya:\n                while change <= x - 1:\n                    if change % 2 == 0:\n                        s += '1'\n                        change += 1\n                        b -= 1\n                    else:\n                        s += '0'\n                        change += 1\n                        a -= 1\n\n            z = s[-1]\n\n            if z == '0':\n                a2 = a\n                s1 = \"\"\n                while a2 > 0:\n                    s1 += '0'\n                    a2 -= 1\n                b2 = b\n                while b2 > 0:\n                    s1 += '1'\n                    b2 -= 1\n                s = s1\n            else:\n                b2 = b\n                s1 = \"\"\n                while b2 > 0:\n                    s1 += '1'\n                    b2 -= 1\n                a2 = a\n                while a2 > 0:\n                    s1 += '0'\n                    a2 -= 1\n                s = s1\n\n        stdout.write(s + '\\n')\n\n\na, b, x = map(int, stdin.readline().split())\nobj = Contest1()\nobj.solve(1, a, b, x)\n", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                \n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    \n                    while (change <= x - 1) {\n                        \n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                \n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 306, "complexity": "1"}
{"forwhile": "from java.util import *\\n class programA:\\n   def main(args: Array[String]):\\n\\t  br = BufferedReader(InputStreamReader(System.`in`))\\n\\t  st = StringTokenizer(br.readLine())\\n\\t  n = int(st.nextToken())\\n\\t  d = int(st.nextToken())\\n\\t  arr = [0] * n\\n\\t  st = StringTokenizer(br.readLine())\\n\\t  i = 0\\n\\t  while i < n:\\n\\t\t  arr[i] = int(st.nextToken())\\n\\t\t  i += 1\\n\\t  s = 2\\n\\t  i = 0\\n\\t  while i < n-1:\\n\\t\t  dis = 2 * d\\n\\t\t  dis2 = Math.abs(arr[i] - arr[i + 1])\\n\\t\t  if dis2 == dis:\\n\\t\t\t  s += 1\\n\\t\t  elif dis2 > dis:\\n\\t\t\t  s += 2\\n\\t\t  i += 1\\n\\t  System.out.println(s)\\n", "src": "public class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long)2*d;\n\t\t\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\n\t\t\tif(dis2 == dis)s++;\n\t\t\telse if (dis2 > dis)s+=2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "index": 307, "complexity": "1"}
{"forwhile": "n = int(br.readline())\nnumberOfStairs = 0\nresult = StringBuilder(\"\")\nstk = StringTokenizer(br.readline())\npreviousNum = 0\ntmp = 0\ni = 0\nwhile i < n:\n    tmp = int(stk.nextToken())\n    if tmp == 1:\n        numberOfStairs += 1\n        if previousNum != 0:\n            result.append(previousNum + ' ')\n    previousNum = tmp\n    i += 1\nresult.append(previousNum)\nprint(numberOfStairs)\nprint(result)\n", "src": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "index": 308, "complexity": "1"}
{"forwhile": "class Profit :\n    @staticmethod\n    def maxProfit(price,n) :\n        profit = [0]*n\n        i = n-2\n        max_price = price[n-1]\n        while i >= 0 :\n            if price[i] > max_price :\n                max_price = price[i]\n            profit[i] = max(profit[i+1], max_price-price[i])\n            i -= 1\n        min_price = price[0]\n        i = 1\n        while i < n :\n            if price[i] < min_price :\n                min_price = price[i]\n            profit[i] = max(profit[i-1], profit[i] + (price[i]-min_price) )\n            i += 1\n        result = profit[n-1]\n        return result\n\n    @staticmethod\n    def main(args) :\n        price = [2, 30, 15, 10, 8, 25, 80]\n        n = len(price)\n        print('Maximum Profit = '+ str(Profit.maxProfit(price, n)))", "src": "class\nProfit \n{ \n\n\n\n\n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n\n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n\n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n\n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}", "index": 309, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\npublic class CodeForce {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        String s=sc.next();\n        String t=sc.next();\n        int count=s.length()+t.length();\n        int i=0;\n        while (i<Math.min(s.length(), t.length())) {\n            if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n            else break;\n            i++;\n        }\n        System.out.println(count);\n    }\n}", "src": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "index": 310, "complexity": "1"}
{"forwhile": "arr = []\nwhile True:\n    try:\n        n = int(input())\n        break\n    except EOFError:\n        break\nfor _ in range(n):\n    arr.append(int(input()))\ni = 0\nwhile i < n:\n    if arr[i] % 2 == 0:\n        arr[i] -= 1\n    i += 1\ni = 0\nfor _ in range(n):\n    print(arr[i], end=' ')\n    i += 1", "src": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "index": 311, "complexity": "1"}
{"forwhile": "class Main:\n    def main(self):\n        inputStream = System.in\n        outputStream = System.out\n        in_ = FastScanner(inputStream)\n        out = FastPrinter(outputStream)\n        solver = TaskC()\n        solver.solve(1, in_, out)\n        out.close()\n\n\nclass TaskC:\n    def solve(self, testNumber, in_, out):\n        n = in_.nextInt()\n        a = [0] * n\n        b = [0] * n\n        i = 0\n        while i < n:\n            b[i] = a[i] = in_.nextInt()\n            if i > 0:\n                a[i] += a[i - 1]\n            i += 1\n\n        i = n - 2\n        while i >= 0:\n            b[i] += b[i + 1]\n            i -= 1\n\n        sum1 = 0\n        sum3 = 0\n        result = 0\n        i = 0\n        j = n - 1\n        while i < j:\n            sum1 = a[i]\n            sum3 = b[j]\n            if sum1 == sum3:\n                result = max(result, sum1)\n                i += 1\n                j -= 1\n            elif sum1 < sum3:\n                i += 1\n            else:\n                j -= 1\n        out.println(result)\n\n\nclass FastScanner:\n    def __init__(self, is_):\n        self.br = BufferedReader(InputStreamReader(is_))\n        self.st = None\n\n    def next(self):\n        while self.st == None or not self.st.hasMoreElements():\n            s = None\n            try:\n                s = self.br.readLine()\n            except IOException, e:\n                e.printStackTrace()\n            if s == None:\n                return None\n            self.st = StringTokenizer(s)\n        return self.st.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n\nclass FastPrinter(PrintWriter):\n    def __init__(self, out):\n        super().__init__(out)\n", "src": "public class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}", "index": 312, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n,ans=0;\n        String sa,sb;\n        char[] a,b;\n        n=sc.nextInt();\n        sa=sc.next();\n        sb=sc.next();\n        a=sa.toCharArray();\n        b=sb.toCharArray();\n        ans=0;\n        int i = 0;\n        while(i < n){\n            if(i==n/2){\n                if(a[i]!=b[i])\n                    ans++;\n                i++;\n                continue;\n            }\n            int[] vis=new int[28];\n            vis[a[i]-'a']++;\n            vis[b[i]-'a']++;\n            vis[a[n-1-i]-'a']++;\n            vis[b[n-1-i]-'a']++;\n            int num=0,ans1=0,ans2=0;\n            int j = 0;\n            for(j=0;j<26;j++){\n                if(vis[j]!=0){\n                    num++;\n                    if(num==1)\n                        ans1=vis[j];\n                    else\n                        ans2=vis[j];\n                }\n            }\n            if(num==2){\n                if(ans1==1||ans2==1)\n                    ans++;\n            }\n            else if(num==3){\n                if(a[i]==a[n-i-1])\n                    ans+=2;\n                else\n                    ans++;\n            }\n            else if(num==4)\n                ans+=2;\n            a[i]=b[i];\n            a[n-1-i]=b[n-1-i];\n            i++;\n        }\n        System.out.println(ans);\n    }\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 313, "complexity": "1"}
{"forwhile": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = FastScanner(inputStream)\n        out = PrintWriter(outputStream)\n        solver = EMilitaryProblem()\n        solver.solve(1, in, out)\n        out.close()\n\n\nclass EMilitaryProblem:\n    def solve(testNumber, br, pw):\n        n = br.nextInt()\n        q = br.nextInt()\n        preorder = [0] * n\n        sz = [0] * n\n        pos = [0] * n\n        curPos = 0\n        adj = [0] * n\n        i = 0\n        while i < n:\n            adj[i] = []\n            i += 1\n        i = 1\n        while i < n:\n            u = br.nextInt()\n            u -= 1\n            adj[u].append(i)\n            i += 1\n        dfs(0)\n        i = 0\n        while i < n:\n            pos[preorder[i]] = i\n            i += 1\n        i = 0\n        while i < q:\n            u = br.nextInt()\n            k = br.nextInt()\n            u -= 1\n            if sz[u] < k:\n                pw.println(\"-1\")\n            else:\n                pw.println(preorder[pos[u] + k - 1] + 1)\n            i += 1\n        pw.close()\n\n    def dfs(u):\n        preorder[curPos] = u\n        curPos += 1\n        sz[u] += 1\n        for e in adj[u]:\n            sz[u] += dfs(e)\n        return sz[u]\n\n\nclass FastScanner:\n    def FastScanner(stream):\n        this.stream = stream\n\n    def read():\n        if numChars == -1:\n            raise InputMismatchException()\n        if curChar >= numChars:\n            curChar = 0\n            try:\n                numChars = stream.read(buf)\n            except IOException as e:\n                raise InputMismatchException()\n            if numChars <= 0:\n                return -1\n        return buf[curChar++]\n\n    def nextInt():\n        c = read()\n        while isSpaceChar(c):\n            c = read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = read()\n        res = 0\n        do:\n            if c < '0' or c > '9':\n              raise InputMismatchException()\n\n            res *= 10\n            res += c - '0'\n            c = read()\n        while not isSpaceChar(c)\n        return res * sgn\n\n    def isSpaceChar(c):\n        if filter != None:\n            filter.isSpaceChar(c)\n        return isWhitespace(c)\n\n    def isWhitespace(c):\n        return c == ' ' or c == '\n' or c == '\r' or c == '\t' or c == -1\n\n    def interface SpaceCharFilter:\n      def isSpaceChar(ch):\n        return True", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 314, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = new int[] { 3 , 7 , 90 , 20 , 10 , 50 , 40}; static void findMinAvgSubarray( int n, int k) { if (n < k) return; int res_index = 0; int curr_sum = 0; int i = 0; while (i < k) curr_sum += arr[i]; int min_sum = curr_sum; i = k; while (i < n) { curr_sum += arr[i] - arr[i - k]; if (curr_sum < min_sum) { min_sum = curr_sum; res_index = (i - k + 1); } i++; } System.out.println( 'Subarray between [' + res_index + ', ' + (res_index + k - 1) + '] has minimum average'); } public static void main(String[] args) { int k = 3; findMinAvgSubarray(arr.length, k); } }", "src": "class\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n\n\n\n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n\n\nif\n(n < k) \n\nreturn\n; \n\n\n\n\nint\nres_index = \n0\n; \n\n\n\n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n\n\nint\nmin_sum = curr_sum; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n\n\n\n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n\n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n\n\nfindMinAvgSubarray(arr.length, k); \n\n} \n}", "index": 315, "complexity": "1"}
{"forwhile": "class helloWorld:\n    @staticmethod\n    def main(args):\n        in = Scanner(System.in)\n        n = in.nextInt()\n        m = in.nextInt()\n        str = in.next()\n        exist = [False] * 200\n        dn = [[0] * (m+1) for _ in range(200)]\n        i = 0\n        while i < n:\n            a = ord(str[i])\n            exist[a] = True\n            dn[a][1] = a - ord('a') + 1\n            i += 1\n        k = 2\n        while k <= m:\n            i = ord('a')\n            while i <= ord('z'):\n                if exist[i]:\n                    a = 0\n                    j = i + 2\n                    while j <= ord('z'):\n                        if dn[j][k-1] > 0 and (a == 0 or (a > dn[j][k-1])):\n                            a = dn[j][k-1]\n                        j += 1\n                    if a > 0:\n                        dn[i][k] = a + i - ord('a') + 1\n                i += 1\n            k += 1\n        ans = -1\n        i = ord('a')\n        while i <= ord('z'):\n            if dn[i][m] > 0 and (ans == -1 or ans > dn[i][m]):\n                ans = dn[i][m]\n            i += 1\n        print(ans)", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 316, "complexity": "1"}
{"forwhile": "class MinimumDistance :\n\n    def minDist(self, arr, n, x, y):\n        i = 0\n        min_dist = float('inf')\n        prev = 0\n\n        while i < n:\n            if arr[i] == x or arr[i] == y:\n                prev = i\n                break\n            i += 1\n\n        while i < n:\n            if arr[i] == x or arr[i] == y:\n                if arr[prev] != arr[i] and (i - prev) < min_dist:\n                    min_dist = i - prev\n                    prev = i\n                else:\n                    prev = i\n            i += 1\n\n        return min_dist\n\n\nif __name__ == \"__main__\":\n    min = MinimumDistance()\n    arr = [3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3]\n    n = len(arr)\n    x = 3\n    y = 6\n\n    print(\"Minimum distance between \", x, \" and \", y, \" is \", min.minDist(arr, n, x, y))", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 317, "complexity": "1"}
{"forwhile": "import java.util.*;\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\tint i = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt += in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt -= in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 318, "complexity": "1"}
{"forwhile": "def summation(arr):\n    k = 0\n    sum = 0\n    while k < len(arr):\n        sum = sum + arr[k]\n        k += 1\n    return sum\n\n\ndef main():\n    n = int(input())\n    if 1 <= n <= 50:\n        x = [0] * n\n        y = [0] * n\n        \n        i = 0\n        while i < n:\n            x[i] = int(input())\n            i += 1\n        \n        j = 0\n        while j < n:\n            y[j] = int(input())\n            j += 1\n        \n        xsum = summation(x)\n        ysum = summation(y)\n        if xsum >= ysum:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\n\nmain()", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 319, "complexity": "1"}
{"forwhile": "n = input()\ns1 = 0\ns2 = 0\ni = 0\nwhile i < n:\n\ts1 += input()\n\ti += 1\ni = 0\nwhile i < n:\n\ts2 += input()\n\ti += 1\nif s1 >= s2:\n\tprint('Yes')\nelse:\n\tprint('No')", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 320, "complexity": "1"}
{"forwhile": "a = [0, 0]\nscan = Scanner(System.in)\nx = scan.nextInt()\ni = 0\nwhile i < 2:\n    j = 0\n    while j < x:\n        a[i] += scan.nextInt()\n        j += 1\n    i += 1\nprint('Yes' if a[1] <= a[0] else 'No')", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 321, "complexity": "1"}
{"forwhile": "import java.util.*;\nimport java.io.*;\npublic class SolutionB {\n    \n    public static void main(String args[]) throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        int a[] = new int[n];\n        int i = 0;\n        while(i < n){\n            a[i] = sc.nextInt();\n            if(!set1.contains(a[i])){\n                set1.add(a[i]);\n            }else{\n                System.out.println(0);\n                return;\n            }\n            i++;\n        }\n        i = 0;\n        while(i < n){\n            int b = a[i] & k;\n            if(b != a[i] && set1.contains(b)){\n                System.out.println(1);\n                return;\n            }\n            i++;\n        }\n        i = 0;\n        while(i < n){\n            int b = a[i] & k;\n            if(b != a[i] && set2.contains(b)){\n                System.out.println(2);\n                return;\n            }else{\n                set2.add(b);\n            }\n            i++;\n        }\n        System.out.println(-1);\n    }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 322, "complexity": "1"}
{"forwhile": "import java.util.*;\nimport java.io.*;\n\npublic class B {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int) 2e5 + 50];\n        int g[] = new int[(int) 2e5 + 50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n + 1];\n        int i = 1;\n        while (i <= n && ans == -1) {\n            int a = in.nextInt();\n            if (f[a] > 0) {\n                ans = 0;\n                break;\n            }\n            f[a]++;\n            arr[i] = a;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if ((a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)) {\n                ans = 1;\n                break;\n            }\n\n            g[a]++;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if (g[a] > 1) {\n                ans = 2;\n                break;\n            }\n\n            i++;\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is) {\n            for (int i = '0'; i <= '9'; i++) ints[i] = i - '0';\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!(isSpaceChar(b))) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n\n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 323, "complexity": "1"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\tfor (long i = k; i > 0; i--) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = (cur - x > 0 ? cur - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "index": 324, "complexity": "1"}
{"forwhile": "tokens = ['token1', 'token2', 'token3']\nfor token in iter(tokens.pop, None):\n    print(token)", "src": "public class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 325, "complexity": "1"}
{"forwhile": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        int i = 1;\n        while (i < n*2) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n            i++;\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextInt();\n                i++;\n            }\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextInt() + delta;\n                i++;\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextLong();\n                i++;\n            }\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        int i = 0;\n        while (i < as.length) {\n            pw.println(as[i]);\n            i++;\n        }\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        int i = 0;\n        while (i < as.length) {\n            pw.println(as[i]);\n            i++;\n        }\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        int i = 0;\n        while (i < as.length) {\n            max = Math.max(as[i], max);\n            i++;\n        }\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        int i = 0;\n        while (i < as.length) {\n            min = Math.min(as[i], min);\n            i++;\n        }\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        int i = 0;\n        while (i < args.length) {\n            Object arg = args[i];\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n            i++;\n        }\n        System.err.println(j.toString());\n    }\n}", "src": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "index": 326, "complexity": "1"}
{"forwhile": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        int i = 1;\n        while (i<n) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n            i++;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "src": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "index": 327, "complexity": "1"}
{"forwhile": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        i=1;\n        while(i<n)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n            i++;\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        i=1;\n        while(i<m)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n            i++;\n        }\n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            for(;;)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                }\n                else\n                {\n                    s1+=arr1[i++];\n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        c = scan();\n        for (; c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        c = scan();\n        for (; c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         c = scan();\n         for (; c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        c = scan();\n        for (; c <= 32; c = scan());\n        boolean neg = c == \\'-\\';\n        if (c == \\'-\\' || c == \\'+\\') {\n            c = scan();\n        }\n        for (; c >= \\'0\\' && c <= \\'9\\'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        c = scan();\n        for (; c <= 32; c = scan());\n        boolean neg = c == \\'-\\';\n        if (c == \\'-\\' || c == \\'+\\') {\n            c = scan();\n        }\n        for (; c >= \\'0\\' && c <= \\'9\\'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "src": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        \n         \n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        \n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        \n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    \n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    \n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "index": 328, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 329, "complexity": "1"}
{"forwhile": "class SmallestSubArraySum : def smallestSubWithSum(arr, n, x): curr_sum = 0 min_len = n + 1 start = 0 end = 0 for i in range(n): while end < n and curr_sum <= x: curr_sum += arr[end] end += 1 while curr_sum > x and start < n: if end - start < min_len: min_len = end - start curr_sum -= arr[start] start += 1 return min_len def main(args): arr1 = [1, 4, 45, 6, 10, 19] x = 51 n1 = len(arr1) res1 = smallestSubWithSum(arr1, n1, x) if res1 == n1 + 1: print('Not Possible') else: print(res1) arr2 = [1, 10, 5, 2, 7] n2 = len(arr2) x = 9 res2 = smallestSubWithSum(arr2, n2, x) if res2 == n2 + 1: print('Not Possible') else: print(res2) arr3 = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250] n3 = len(arr3) x = 280 res3 = smallestSubWithSum(arr3, n3, x) if res3 == n3 + 1: print('Not Possible') else: print(res3) ", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\ncurr_sum += arr[end++]; \n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 330, "complexity": "1"}
{"forwhile": "N = int(input())\nL = int(input())\nA = int(input())\narr1 = []\narr2 = []\ni = 0\nwhile i < N:\n    x, y = map(int, input().split())\n    y += x\n    arr1.append(x)\n    arr2.append(y)\n    res = 0\ni = 1\nwhile i < N:\n    res += (arr1[i]-arr2[i-1])//A\n    i += 1\nif N > 0:\n    res += (L-arr2[N-1])//A + arr1[0]//A\nelse:\n    res += L//A\nprint(res)", "src": "public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n         }\n         int res = 0;\n         for(int i=1; i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "index": 331, "complexity": "1"}
{"forwhile": "n = input.nextInt()\ns = input.next()\ndone = False\ni = 0\nwhile i < len(s) - 1:\n    if s.charAt(i) != s.charAt(i + 1):\n        print(\"YES\")\n        print(s.charAt(i) + s.charAt(i + 1))\n        done = True\n        break\n    i += 1\nif not done:\n    print(\"NO\")", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "index": 332, "complexity": "1"}
{"forwhile": "class GFG: \n\n    @staticmethod \n    def findMaxAverage(arr, n, k): \n        if k > n: \n            return -1 \n        csum = [0] * n \n        csum[0] = arr[0] \n        i = 1 \n        while i < n: \n            csum[i] = csum[i - 1] + arr[i] \n            i += 1 \n        max_sum = csum[k - 1] \n        max_end = k - 1 \n        i = k \n        while i < n: \n            curr_sum = csum[i] - csum[i - k] \n            if curr_sum > max_sum: \n                max_sum = curr_sum \n                max_end = i \n            i += 1 \n        return max_end - k + 1 \n\n    @staticmethod \n    def main(args): \n        arr = [1, 12, -5, -6, 50, 3] \n        k = 4 \n        n = len(arr) \n        print(\"The maximum average subarray of length \" + str(k) + \" begins at index \" + str(GFG.findMaxAverage(arr, n, k)))", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nint\n[]csum = \nnew\nint\n[n]; \n\n\ncsum[\n0\n] = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ncsum[i] = csum[i - \n1\n] + arr[i]; \n\n\n\n\n\n\nint\nmax_sum = csum[k - \n1\n], \n\nmax_end = k - \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nint\ncurr_sum = csum[i] - \n\ncsum[i - k]; \n\nif\n(curr_sum > max_sum) \n\n{ \n\nmax_sum = curr_sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"The maximum \"\n\n+ \n\"average subarray of length \"\n\n+ k + \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 333, "complexity": "1"}
{"forwhile": "class GFG { static int findMaxAverage(int arr[], int n, int k) { if (k > n) return -1; int sum = arr[0]; int i = 1; while (i < k) { sum += arr[i]; i++; } int max_sum = sum, max_end = k - 1; i = k; while (i < n) { sum = sum + arr[i] - arr[i - k]; if (sum > max_sum) { max_sum = sum; max_end = i; } i++; } return max_end - k + 1; } public static void main (String[] args) { int arr[] = { 1, 12, -5, -6, 50, 3 }; int k = 4; int n = arr.length; System.out.println( \"The maximum average\" + \" subarray of length \" + k + \" begins at index \" + findMaxAverage(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 334, "complexity": "1"}
{"forwhile": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tint i = 0;\n\twhile ( i < n ) {\n\t    a[i] = in.nextInt();\n\t    i++;\n\t}\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "src": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "index": 335, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tint i=0;\n\t\twhile(i<num*2){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tfor(int i=0;i<num*2;i++){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}", "index": 336, "complexity": "1"}
{"forwhile": "class UniformString:\n    @staticmethod\n    def main(args):\n        t = UniformString.nextInt()\n        i = 0\n        while i < t:\n            n = UniformString.nextInt()\n            k = UniformString.nextInt()\n            s = \"\"\n            j = 0\n            while j < n:\n                s += chr(ord('a') + (j % k))\n                j += 1\n            print(s)\n            i += 1\n\n    @staticmethod\n    def nextLine():\n        return input()\n\n    @staticmethod\n    def nextString():\n        if not UniformString.st or not UniformString.st.hasMoreTokens():\n            UniformString.st = UniformString.input().split()\n        return UniformString.st.pop(0)\n\n    @staticmethod\n    def nextInt():\n        return int(UniformString.nextString())\n\n    @staticmethod\n    def nextLong():\n        return int(UniformString.nextString())\n\n    @staticmethod\n    def intArray(n):\n        a = []\n        i = 0\n        while i < n:\n            a.append(UniformString.nextInt())\n            i += 1\n        return a\n\n    @staticmethod\n    def intArray(n, m):\n        a = []\n        i = 0\n        while i < n:\n            j = 0\n            while j < m:\n                a[i].append(UniformString.nextInt())\n                j += 1\n            i += 1\n        return a\n\n    @staticmethod\n    def longArray(n):\n        a = []\n        i = 0\n        while i < n:\n            a.append(UniformString.nextLong())\n            i += 1\n        return a", "src": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 337, "complexity": "1"}
{"forwhile": "class\\narr_rot \\n{ \\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\nleftRotate(\\nint\\narr[], \\nint\\nn, \\n\\nint\\nk) \\n\\n{ \\n\\n\\n\\nint\\nmod = k % n; \\n\\n\\n\\n\\n\\n\\ni = \\n0\\n; \\n\\nwhile\\n\\(i < n) \\n\\nSystem.out.print(arr[(i + mod) % n] \\n\\n+ \\n\" \"\\); \\n\\n\\ni++; \\n\\n\\nSystem.out.println(); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain (String[] args) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, \\n3\\n, \\n5\\n, \\n7\\n, \\n9\\n}; \\n\\nint\\nn = arr.length; \\n\\n\\nint\\nk = \\n2\\n; \\n\\ni = \\n0\\n; \\n\\nfor\\ni in range(n): \\n\\nleftRotate(arr, n, k); \\n\\n\\n\\nk = \\n3\\n; \\n\\ni = \\n0\\n; \\n\\nfor\\ni in range(n): \\n\\nleftRotate(arr, n, k); \\n\\n\\n\\nk = \\n4\\n; \\n\\ni = \\n0\\n; \\n\\nfor\\ni in range(n): \\n\\nleftRotate(arr, n, k); \\n\\n} \\n}", "src": "class\narr_rot \n{ \n\n\n\n\n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n\n\nint\nmod = k % n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "index": 338, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\n\\n\\nstatic\\nint\\nfindMinOps(\\nint\\n[] arr, \\nint\\nn) \\n\\n{ \\n\\nint\\nans = \\n0\\n; \\n\\n\\n\\n\\n\\nint\\ni=\\n0\\n,j=n-\\n1\\n; \\nwhile i<=j: \\n\\n\\nif\\n(arr[i] == arr[j]) \\n\\n{ \\n\\n\\ni++; \\n\\nj--; \\n\\n} \\n\\n\\n\\n\\nelse\\nif\\n(arr[i] > arr[j]) \\n\\n{ \\n\\n\\nj--; \\n\\narr[j] += arr[j+\\n1\\n] ; \\nans++; \\n} \\n\\n\\n\\nelse\\n\\n{ \\n\\ni++; \\n\\narr[i] += arr[i-\\n1\\n]; \\nans++; \\n} \\n\\n} \\n\\n\\nreturn\\nans; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\narr[] =\\nnew\\nint\\n[]{\\n1\\n, \\n4\\n, \\n5\\n, \\n9\\n, \\n1\\n} ; \\nSystem.out.println(\\n\\\"Count of minimum operations is \\\"\\n+ \\n\\nfindMinOps(arr, arr.length)); \\n\\n\\n} \\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMinOps(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\nans = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n,j=n-\n1\n; i<=j;) \n\n{ \n\n\n\n\n\nif\n(arr[i] == arr[j]) \n\n{ \n\ni++; \n\nj--; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > arr[j]) \n\n{ \n\n\n\nj--; \n\narr[j] += arr[j+\n1\n] ; \n\nans++; \n\n} \n\n\n\n\nelse\n\n{ \n\ni++; \n\narr[i] += arr[i-\n1\n]; \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n4\n, \n5\n, \n9\n, \n1\n} ; \n\nSystem.out.println(\n\"Count of minimum operations is \"\n+ \n\nfindMinOps(arr, arr.length)); \n\n\n} \n}", "index": 339, "complexity": "1"}
{"forwhile": "tokens = []\ni = 0\nwhile i < 2:\n    tokens.append(bufr.readLine())\n    i += 1\ns = 'NO'\ni = 0\nfor _ in range(len(tokens)):\n    line = tokens[i]\n    i += 1\n    if 'over' == line:\n        break\n    n = bufr.readLine().split(' ')\n    j = 0\n    while j < len(n):\n        if n[j].find(line[0]) != -1 or n[j].find(line[1]) != -1:\n            s = 'YES'\n        j += 1\n    print(s)\n    s = 'NO'\n    bufw.flush()\nbufw.close()", "src": "public class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tn=bufr.readLine().split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();                          \n\t}\n}", "index": 340, "complexity": "1"}
{"forwhile": "class FindSmallestInteger : \n\n  def findSmallest(self, arr, n) : \n    res = 1 \n    i = 0 \n    while i < n and arr[i] <= res : \n      res = res + arr[i] \n      i = i + 1 \n    return res \n\n  @staticmethod \n  def main() : \n    small = FindSmallestInteger() \n\n    arr1 = [1, 3, 4, 5] \n    n1 = len(arr1) \n    print(small.findSmallest(arr1, n1)) \n\n    arr2 = [1, 2, 6, 10, 11, 15] \n    n2 = len(arr2) \n    print(small.findSmallest(arr2, n2)) \n\n    arr3 = [1, 1, 1, 1] \n    n3 = len(arr3) \n    print(small.findSmallest(arr3, n3)) \n\n    arr4 = [1, 1, 3, 4] \n    n4 = len(arr4) \n    print(small.findSmallest(arr4, n4))", "src": "class\nFindSmallestInteger \n{ \n\n\n\n\n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n}", "index": 341, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tint i = 0;\n\t\twhile (i < d) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\tfor (; sum != 0;) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "src": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "index": 342, "complexity": "1"}
{"forwhile": "n = in.nextInt()\nl = [0]*n\nd_min = 1000000\nmin_val = 1000000000\ni = 0\nwhile i < n:\n    l[i] = in.nextInt()\n    min_val = min(min_val, l[i])\n    i += 1\n\np = -1000000\ni = 0\nwhile i < n:\n    if l[i] == min_val:\n        d_min = min(d_min, i - p)\n        p = i\n    i += 1\nout.print(d_min)\nout.close()", "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 343, "complexity": "1"}
{"forwhile": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     int i=1;\n     while(i<n){\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     i++;\n     }\n     System.out.println(res);\n  }\n\n   }", "src": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }", "index": 344, "complexity": "1"}
{"forwhile": "class practise:\n    N = 31\n    sc = Scanner(System.in)\n    out = PrintWriter(System.out, True)\n    c = [0]*N\n    w = [0]*N\n    w[0] = 1\n    i = 1\n    while i < N:\n        w[i] = w[i-1]*2\n        i += 1\n    n = sc.nextInt()\n    l = sc.nextInt()\n    i = 0\n    while i < N:\n        c[i] = Long.MAX_VALUE\n        i += 1\n    i = 0\n    while i < n:\n        c[i] = sc.nextInt()\n        i += 1\n    i = 1\n    while i < N:\n        c[i] = min(c[i-1]*2,c[i])\n        i += 1\n    ans = 0\n    i = 0\n    while i < N:\n        if (l&w[i]) != 0:\n            ans += c[i]\n        i += 1\n    ans = 0\n    i = N - 1\n    while i >= 0:\n        if (l&w[i]) != 0:\n            m += c[i]\n        else:\n            ans = min(ans,m+c[i])\n        i -= 1\n    out.println(ans)\n    @staticmethod\n    def min(a,b):\n        return a if a < b else b", "src": "public class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}", "index": 345, "complexity": "1"}
{"forwhile": "n = scan.nextInt()\nc = ['o'] * n\nx, y = 1, 1\nfor _ in range(0, n):\n    if y > n:\n        break\nc[y - 1] = 'O'\nz = x + y\nx, y = y, z\nans = ''.join(c)\nprint(ans)", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "index": 346, "complexity": "1"}
{"forwhile": "from typing import List\n\ndef check_conditions(s: str) -> str:\n    f = True\n    f2 = True\n    f3 = True\n    f4 = True\n    v = 0\n    i = 0\n    while i < len(s) - 1:\n        if s[i] == s[i + 1] and (s[i] != '?' or s[i + 1] != '?'):\n            f = False\n            break\n        else:\n            f = True\n        i += 1\n    i = 0\n    while i < len(s):\n        if s[i] == '?':\n            if i == 0 or i == len(s) - 1:\n                f2 = True\n                v += 1\n            elif s[i] == s[i + 1]:\n                f2 = True\n                v += 1\n            elif s[i - 1] == s[i + 1] and i != 0 and i != len(s) - 1:\n                f2 = True\n                v += 1\n        else:\n            if v > 0:\n                f2 = True\n            else:\n                f2 = False\n        i += 1\n    if f and f2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ns = input()\nprint(check_conditions(s))", "src": "public class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}", "index": 347, "complexity": "1"}
{"forwhile": "class Test { static int arr1[] = new int[]{ 0, 1, 0, 1, 1, 1, 1}; static int arr2[] = new int[]{ 1, 1, 1, 1, 1, 0, 1}; static int longestCommonSum( int n) { int maxLen = 0; int preSum1 = 0, preSum2 = 0; int diff[] = new int[2*n+1]; int i = 0; while(i < diff.length) { diff[i] = -1; i++; } i = 0; while(i < n) { preSum1 += arr1[i]; preSum2 += arr2[i]; int curr_diff = preSum1 - preSum2; int diffIndex = n + curr_diff; if (curr_diff == 0) maxLen = i+1; else if ( diff[diffIndex] == -1) diff[diffIndex] = i; else { int len = i - diff[diffIndex]; if (len > maxLen) maxLen = len; } i++; } return maxLen; } public static void main(String[] args) { System.out.print(\"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n\n\n\n\n\n\n\n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n\n\n\n\n\n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n\n\n\n\n\n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n\n\n\n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n\n\nelse\n\n{ \n\n\n\nint\nlen = i - diff[diffIndex]; \n\n\n\n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 348, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\npublic class Codeforces {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, f[], c=0;\n        n = in.nextInt();\n        f = new int[n];\n        for (n--; n > 0;) {\n            f[in.nextInt() - 1] ++;\n            f[in.nextInt() - 1] ++;\n            in.nextLine();\n            n--;\n        }\n        int i = 0;\n        while (i < f.length) {\n            if (f[i] == 1) c++;\n            i++;\n        }\n        System.out.println(c);\n    }\n}", "src": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}", "index": 349, "complexity": "1"}
{"forwhile": "from java.util import *\\nclass loser:\\n    class InputReader:\\n        br=None\\n        token=None\\n        def __init__(self,stream):\\n            self.br=BufferedReader(InputStreamReader(stream),32768)\\n            self.token=None\\n        def next(self):\\n            while self.token==None or not self.token.hasMoreTokens():\\n                try:\\n                    self.token=StringTokenizer(self.br.readLine())\\n                except(IOException,e):\\n                    raise RuntimeException(e)\\n            return self.token.nextToken()\\n        def nextInt(self):\\n            return Integer.parseInt(self.next())\\n        def nextLong(self):\\n            return Long.parseLong(self.next())\\n    class card:\\n        a=None\\n        i=None\\n        def __init__(self,a,i):\\n            self.a=a\\n            self.i=i\\n    class sort(Comparator[pair]):\\n        def compare(self,o1,o2):\\n            if o1.a!=o2.a:\\n                return int(o1.a-o2.a)\\n            else:\\n                return int(o1.b-o2.b)\\n    def shuffle(self,a):\\n        l=ArrayList()\\n        i=0\\n        while i<len(a):\\n            l.add(a[i])\\n            i+=1\\n        Collections.shuffle(l)\\n        i=0\\n        while i<len(a):\\n            a[i]=l.get(i)\\n            i+=1\\n    class pair:\\n        a=None\\n        b=None\\n        def __init__(self,a,b):\\n            self.a=a\\n            self.b=b\\n    def main(args):\\n        sc=InputReader(System.in)\\n        c=sc.next().toCharArray()\\n        l=len(c)\\n        a=[0,0,0]\\n        i=0\\n        while i<l:\\n            a[c[i]-ord('a')]+=1\\n            if i>0 and c[i]<c[i-1]:\\n                print('NO')\\n                System.exit(0)\\n            i+=1\\n        if a[0]>0 and a[1]>0 and (a[2]==a[1] or a[2]==a[0]):\\n            print('YES')\\n        else:\\n            print('NO')\\n", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    \n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        for(int i=0;i<l;i++)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "index": 350, "complexity": "1"}
{"forwhile": "n = sc.nextInt()\na = sc.nextInt()\nb = sc.nextInt()\nc = sc.nextInt()\nans = 0\nt = sc.nextInt()\narr = [0]*n\ni = 0\nwhile i < n:\n    nn = sc.nextInt()\n    ans += a\n    if b < c:\n        ans += (t - nn) * (c - b)\n    i += 1\nprint(ans)", "src": "public class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "index": 351, "complexity": "1"}
{"forwhile": "n = sc.nextInt()\ncounts = [0] * 60\nnums = []\ni = 0\nwhile i < 60:\n\tnums.append(ArrayDeque())\n\ti += 1\ni = 0\nwhile i < n:\n\tnum = sc.nextLong()\n\tj = 1\n\twhile j <= 60:\n\t\tif num < (1<<j):\n\t\t\tnums[j-1].add(num)\n\t\t\tcounts[j-1] += 1\n\t\t\tbreak\n\t\tj += 1\ncurr = 0\nans = StringBuilder()\ni = 0\nwhile i < n:\n\tj = 0\n\twhile j <= 60:\n\t\tif j == 60:\n\t\t\tSystem.out.println('No')\n\t\t\treturn\n\t\tif counts[j] == 0 or (curr & (1<<j)) != 0:\n\t\t\tj += 1\n\t\t\tcontinue\n\t\tnum = nums[j].removeFirst()\n\t\tcounts[j] -= 1\n\t\tcurr ^= num\n\t\tif i > 0:\n\t\t\tans.append(' ')\n\t\tans.append(num)\n\t\tbreak\n\t\tj += 1\n\ti += 1\nSystem.out.println('Yes')\nSystem.out.println(ans)", "src": "public class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 352, "complexity": "1"}
{"forwhile": "n = sc.nextInt()\ns = sc.next()\nhm = {}\ni = 0\nwhile i < n - 1:\n    curr = s[i:i + 2]\n    if curr in hm:\n        hm[curr] += 1\n    else:\n        hm[curr] = 1\n    i += 1\nans = ''\ncurrMax = 0\nfor twoGram in hm.keys():\n    if hm[twoGram] > currMax:\n        ans = twoGram\n        currMax = hm[twoGram]\nprint(ans)", "src": "public class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "index": 353, "complexity": "1"}
{"forwhile": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(bf.readLine());\n        int[] f = new int[1001];\n        int[] a = new int[n];\n        StringTokenizer tk = new StringTokenizer(bf.readLine());\n        int i = 0;\n        while (i < n) {\n            int element = Integer.parseInt(tk.nextToken());\n            a[i] = element;\n            f[element]++;\n            i++;\n        }\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h = new ArrayList<>();\n        int counter = 0;\n        i = 0;\n        while (i < n) {\n            if (f[a[i]] == 1) {\n                counter++;\n                h.add(a[i]);\n            } else {\n                f[a[i]] -= 1;\n            }\n            i++;\n        }\n        pw.write(counter + \"\\n\");\n        i = 0;\n        for (i = 0; i < h.size(); i++) {\n            pw.write(h.get(i) + \" \");\n        }\n        pw.flush();\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "index": 354, "complexity": "1"}
{"forwhile": "class MergeArrays: def moveToEnd(mPlusN, size): i, j = size - 1 while i >= 0: if mPlusN[i] != -1: mPlusN[j] = mPlusN[i] j -= 1 i -= 1 def merge(mPlusN, N, m, n): i = n j = 0 k = 0 for k in range(m + n): if (i < (m + n) and mPlusN[i] <= N[j]) or (j == n): mPlusN[k] = mPlusN[i] k += 1 i += 1 else: mPlusN[k] = N[j] k += 1 j += 1 def printArray(arr, size): i = 0 while i < size: print(arr[i], end=' ') print('') if __name__ == '__main__': mergearray = MergeArrays() mPlusN = [2, 8, -1, -1, -1, 13, -1, 15, 20] N = [5, 7, 9, 25] n = len(N) m = len(mPlusN) - n mergearray.moveToEnd(mPlusN, m + n) mergearray.merge(mPlusN, N, m, n) mergearray.printArray(mPlusN, m + n)", "src": "class\nMergeArrays \n{ \n\n\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n\n\nint\nj = \n0\n; \n\n\n\n\nint\nk = \n0\n; \n\n\n\n\nwhile\n(k < (m + n)) \n\n{ \n\n\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n\n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n}", "index": 355, "complexity": "1"}
{"forwhile": "s = input()\nn = 0\nm = 0\ni = 0\nwhile i < len(s):\n    if s[i] == '-':\n        n += 1\n    else:\n        m += 1\n    i += 1\nif m == 0:\n    print('YES')\nelse:\n    if n % m == 0:\n        print('YES')\n    else:\n        print('NO')", "src": "public class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 356, "complexity": "1"}
{"forwhile": "class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\ni = 0\n\nwhile\n(i < end) { \n\nint\ntemp = arr[i]; \n\narr[i] = arr[end]; \n\narr[end] = temp; \n\ni++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\ni = 0\n\nwhile\n(i < size) { \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\ni++;\n} \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\ni = 0\n\nwhile\n(i < n) { \n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\nbreak;\n} \n} \n\n", "src": "class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n\n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n}", "index": 357, "complexity": "1"}
{"forwhile": "def sortit(arr, n): \n    i = 0 \n    while i < n: \n        arr[i] = i + 1 \n        i += 1 \n\n\ndef main(args): \n    arr = [10, 7, 9, 2, 8, 3, 5, 4, 6, 1] \n    n = len(arr) \n    sortit(arr, n) \n    i = 0 \n    for i in range(n): \n        print(arr[i], end=' ') \n", "src": "public\nclass\nGFG { \n\n\n\n\n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nsortit(arr, n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 358, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            int i = 0;\n            while (i < n) {\n                adj[i] = new ArrayList<>();\n                i++;\n            }\n\n            i = 1;\n            while (i < n) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n                i++;\n            }\n\n            int root = 0;\n            i = 1;\n            while (i < n) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n                i++;\n            }\n\n            dfs(root);\n            int cnt = 0;\n            i = 0;\n            while (i < n) {\n                if ((sizes[i] & 1) == 0) cnt++;\n                i++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "index": 360, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\n\\nstatic\\nboolean\\nsortedAfterSwap(\\nint\\nA[], \\n\\nboolean\\nB[], \\nint\\nn) \\n\\n{ \\n\\nint\\ni, j; \\n\\n\\n\\n\\nint\\n i = 0; \\nwhile (i < n - 1) { \\n\\nif\\n(B[i]) { \\n\\nj = i; \\n\\nwhile\\n(not (j >= n or not B[j])) { \\n\\nj++; \\n\\n} \\n\\n\\n\\nArrays.sort(A, i, 1 + j); \\n\\ni = j; \\n\\n} \\n\\ni++; \\n\\n} \\n\\n\\n\\nint\\n i = 0; \\nwhile (i < n) { \\n\\nif\\n(A[i] != i + 1) { \\n\\nreturn\\nfalse\\n; \\n\\n} \\n\\ni++; \\n\\n} \\n\\n\\n\\nreturn\\ntrue\\n; \\n\\n} \\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\nA[] = { \\n1\\n, \\n2\\n, \\n5\\n, \\n3\\n, \\n4\\n, \\n6\\n}; \\n\\nboolean\\nB[] = { \\nfalse\\n, \\ntrue\\n, \\ntrue\\n, \\ntrue\\n, \\nfalse\\n}; \\n\\nint\\nn = A.length; \\n\\n\\nif\\n(sortedAfterSwap(A, B, n)) { \\n\\nSystem.out.println(\\n\\", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n\n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n}", "index": 361, "complexity": "1"}
{"forwhile": "data = StringBuilder()\n\nansw = 0\ni = 0\nn = in.nextInt()\nk = in.nextInt()\na = [0] * 101\nwhile i < n:\n    t = in.nextInt()\n    a[t] += 1\n    if a[t] < 2:\n        if answ < k:\n            data.append(i + 1).append(' ')\n            answ += 1\n    i += 1\n\nif answ == k:\n    print('YES')\n    print(data)\nelse:\n    print('NO')", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 362, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            int i=2;\n            while (i<s.length()){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n                i++;\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "index": 363, "complexity": "1"}
{"forwhile": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        int i=0;\n        while(i < n)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n            i++;\n        }\n        if(flag)\n        {\n            int z=0;\n            while(z < stringBuilder.length())\n            {\n                if(stringBuilder.charAt(z) == '.')\n                {\n                    stringBuilder.setCharAt(z, '0');\n                }\n                z++;\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        int k = 1;\n        while(k < input.length) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                int k1 = k - left;\n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n            k++;\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n        for(i=0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        int i=0;\n        while(i < A.length)\n        {\n            min = Math.min(min, A[i]);\n            i++;\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        i=0;\n        while(i < A.length)\n        {\n            max = Math.max(max, A[i]);\n            i++;\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    void merge(int arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0;\n        int j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            int m = (l + r) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass MergeSortLong\n{\n    void merge(long arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0;\n        int j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            int m = (l + r) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64];\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n        if (neg)\n            return -ret;\n        return ret;\n    }\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n        int i;\n        for(i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "src": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for(int i=0;i<n;i++)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag)\n        {\n            for(int i=0;i<stringBuilder.length();i++)\n            {\n                if(stringBuilder.charAt(i) == '.')\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                \n                int k1 = k - left;\n                \n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    \n    \n    \n    void merge(int arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    \n    \n    \n    void merge(long arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; \n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "index": 364, "complexity": "1"}
{"forwhile": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tint i = 0;\n\t\twhile (i < m) {\n\t\t\tset.add(nextInt());\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tString s = \"\";\n\t\ti = 0;\n\t\twhile (i < n) {\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tint j = 0;\n\t\t\twhile (j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 365, "complexity": "1"}
{"forwhile": "n = int(input())\na = list(map(int, input().split()))\ni = 0\nwhile i < len(a):\n\ta[i] = int(input())\n\ti += 1\nprint(solve(a))\ndef solve(a):\n\tif len(a) == 1 or (len(a) == 2 and a[0] == a[1]):\n\t\treturn '-1'\n\tsum = sum(a)\n\tfor i in range(len(a)):\n\t\tif a[i] * 2 != sum:\n\t\t\treturn '1\\n%d' % (i + 1)", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0;; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 366, "complexity": "1"}
{"forwhile": "n = in.nextInt()\nm = in.nextInt()\na = [0]*n\ni = 0\nwhile i < n:\n    a[i] = in.nextInt()\n    i += 1\nh = 0\nt = n-1\nansw = 0\nfor _ in range(n):\n    if h >= n or t < 0:\n        break\n    elif a[h] <= m:\n        answ += 1\n        h += 1\n    elif a[t] <= m:\n        t -= 1\n        answ += 1\nprint(answ)", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 367, "complexity": "1"}
{"forwhile": "public class Solution{\n    public static void main(String sp[]){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        String st = sc.next();\n        \n        char arr[] = st.toCharArray();\n        \n        boolean b=false;\n        char j='a';\n        while (j<='z'){\n            int i=0;\n            while (i<arr.length){\n                if(arr[i]==j){\n                    arr[i]='*';\n                    k--;\n                }\n                if(k==0){\n                    b=true;\n                    prin(arr);\n                    return;\n                }\n                i++;\n            }\n            j++;\n        }\n\n    }\n    \n    public static void prin(char arr[]){\n        StringBuilder sb = new StringBuilder();\n        int i=0;\n        while (i<arr.length){\n            if(arr[i]!='*'){\n                sb.append(arr[i]);\n            }\n            i++;\n        }\n        if(sb.length()!=0){\n            System.out.println(sb.toString());\n        }\n    }\n}", "src": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "index": 368, "complexity": "1"}
{"forwhile": "class loser:\n    class InputReader:\n        def __init__(self, stream):\n            self.br = BufferedReader(InputStreamReader(stream, 32768))\n            self.token = None\n\n        def next(self):\n            while self.token is None or not self.token.hasMoreTokens():\n                try:\n                    self.token = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    raise RuntimeError(e)\n            return self.token.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n    class card:\n        def __init__(self, s, i):\n            self.s = s\n            self.l = i\n\n    class sort(Comparator[card]):\n        def compare(self, o1, o2):\n            if o1.l != o2.l:\n                return o1.l - o2.l\n            else:\n                return ord(o1.s) - ord(o2.s)\n\n    def shuffle(a):\n        l = ArrayList()\n        i = 0\n        while i < len(a):\n            l.add(a[i])\n            i += 1\n        Collections.shuffle(l)\n        i = 0\n        while i < len(a):\n            a[i] = l.get(i)\n            i += 1\n\n    class Pair:\n        def __init__(self, a, b):\n            self.a = a\n            self.b = b\n\n    def main(args):\n        sc = InputReader(System.in)\n        n = sc.nextInt()\n        m = HashMap()\n        i = 0\n        while i < n:\n            t = sc.next()\n            if m.containsKey(t):\n                m.put(t, m.get(t) + 1)\n            else:\n                m.put(t, 1)\n            i += 1\n        ans = 0\n        i = 0\n        while i < n:\n            t = sc.next()\n            if m.containsKey(t) and m.get(t) > 0:\n                m.put(t, m.get(t) - 1)\n                ans += 1\n            i += 1\n        println(n - ans)", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 369, "complexity": "1"}
{"forwhile": "from sys import stdin, stdout\n\nn, m = map(int, stdin.readline().split())\n\ndef solve(n, m):\n    grid = [0] * (m + 1)\n    i = 0\n    while i < n:\n        start, end = map(int, stdin.readline().split())\n        grid[start] += 1\n        grid[end] -= 1\n        i += 1\n\n    sum = 0\n    for i in range(m):\n        sum += grid[i]\n        if sum == 0:\n            return 'NO'\n\n    return 'YES'\n\nstdout.write(solve(n, m))\nstdout.flush()\nstdout.close()", "src": "public class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "index": 370, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}", "index": 371, "complexity": "1"}
{"forwhile": "import sys\nimport math\n\nMAX = 1000000007\n\n\n\nclass InputReader:\n    def __init__(self, stream=sys.stdin):\n        self.stream = stream\n        self.buf = bytearray()\n        self.curChar = 0\n        self.numChars = 0\n        self.br = None\n\n    \n    def read(self):\n        if self.numChars == -1 : raise InputMismatchException()\n\n        if self.curChar >= self.numChars:\n            self.curChar = 0\n            self.buf = self.stream.readline()\n           \n            if not self.buf:\n                return -1\n            self.numChars = len(self.buf)\n        \n        return self.buf[self.curChar]\n    \n    def nextLine(self):\n        return sys.stdin.readline()\n\n    \n    def nextInt(self):\n        return int(self.nextLine())\n    \n    def nextLong(self):\n        return int(self.nextLine())\n    \n    def nextDouble(self):\n        return float(self.nextLine())\n\n    \n    def readString(self):\n        return self.nextLine()\n\n        \n    def isSpaceChar(self, c):\n        return c in [' ', '\\n', '\\r', '\\t', -1]\n\n\n\n\ndef main(args):\n    t=Solution1()\n    t.run()\n\n\nclass Solution1:\n    def run(self):\n        sc = InputReader()\n        w = sys.stdout\n\n        n = sc.nextInt()\n        ch = list(sc.nextLine().strip())\n        ch2 = list(sc.nextLine().strip())\n        hset = [set() for _ in range(26)]\n        count = 0\n\n        i = 0\n        while i < n:\n            if ch[i] != ch2[i]:\n                hset[ord(ch[i]) - 97].add(ord(ch2[i]) - 97)\n                count += 1\n            i += 1\n\n        flag = False\n        swap1 = -1\n        swap2 = -1\n        rem = -1\n\n        i = 0\n        while i < n:\n            if ch[i] != ch2[i]:\n                if len(hset[ord(ch2[i]) - 97]) != 0:\n                    swap1 = i\n                    flag = True\n                    if ord(ch[i]) - 97 in hset[ord(ch2[i]) - 97]:\n                        rem = i\n                        count -= 2\n                        flag=False\n                        break\n\n            i += 1\n\n        if flag:\n            count-=1\n            w.write('{}\\n'.format((count)))\n            i = 0\n            while i < n:\n                if i != swap1 and ch[i] == ch2[swap1] and ch[i] != ch2[i]:\n                    w.write('{} {}\\n'.format((swap1+1), (i+1)))\n                    w.close()\n                    sys.exit(0)\n                i += 1\n        \n        else:\n            if rem==-1:\n                w.write('{}\\n'.format(count))\n                w.write('-1 -1')\n            else:\n                w.write('{}\\n'.format(count))\n                for i in range(n):\n                    if i!=rem and ch[i]==ch2[rem] and ch[rem]==ch2[i] and ch[i]!=ch2[i]:\n                        w.write('{} {}\\n'.format((rem+1),(i+1)))\n                        w.close()\n                        sys.exit(0)\n        w.close()\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "src": "public class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "index": 372, "complexity": "1"}
{"forwhile": "class Main:\n    class Reader:\n        def __init__(self, mIs):\n            self.mIs = mIs\n            self.buf = bytearray(1024)\n            self.curChar = 0\n            self.numChars = 0\n\n        def read(self):\n            if self.numChars == -1:\n                raise ValueError('InputMismatchException')\n            if self.curChar >= self.numChars:\n                self.curChar = 0\n                try:\n                    self.numChars = self.mIs.readinto(self.buf)\n                except IOError as e:\n                    raise ValueError('InputMismatchException')\n                if self.numChars <= 0:\n                    return -1\n            res = self.buf[self.curChar]\n            self.curChar += 1\n            return res\n\n        def nextLine(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = bytearray()\n            while not self.isEndOfLine(c):\n                res.append(c)\n                c = self.read()\n            return res.decode()\n\n        def s(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = bytearray()\n            while not self.isSpaceChar(c):\n                res.append(c)\n                c = self.read()\n            return res.decode()\n\n        def l(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == 45:\n                sgn = -1\n                c = self.read()\n            res = 0\n            while not self.isSpaceChar(c):\n                if c < 48 or c > 57:\n                    raise ValueError('InputMismatchException')\n                res *= 10\n                res += c - 48\n                c = self.read()\n            return res * sgn\n\n        def i(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == 45:\n                sgn = -1\n                c = self.read()\n            res = 0\n            while not self.isSpaceChar(c):\n                if c < 48 or c > 57:\n                    raise ValueError('InputMismatchException')\n                res *= 10\n                res += c - 48\n                c = self.read()\n            return res * sgn\n\n        def d(self):\n            return float(self.s())\n\n        def isSpaceChar(self, c):\n            return c == 32 or c == 10 or c == 13 or c == 9 or c == -1\n\n        def isEndOfLine(self, c):\n            return c == 10 or c == 13 or c == -1\n\n    sc = Reader(bytearray(b''))\n    n = sc.i()\n    s1 = sc.s()\n    s2 = sc.s()\n    pos1 = -1\n    pos2 = -1\n    arr = [[[0 for _ in range(2)] for _ in range(100)] for _ in range(100)]\n    i = 0\n    while i < n:\n        if s1[i] != s2[i]:\n            if arr[ord(s2[i]) - 97][ord(s1[i]) - 97][0] == 1:\n                pos2 = i\n                pos1 = arr[ord(s2[i]) - 97][ord(s1[i]) - 97][1]\n                break\n            arr[ord(s1[i]) - 97][ord(s2[i]) - 97][0] = 1\n            arr[ord(s1[i]) - 97][ord(s2[i]) - 97][1] = i\n        i += 1\n    ham = 0\n    i = 0\n    while i < n:\n        if s1[i] != s2[i]:\n            ham += 1\n        i += 1\n    if pos1 != -1 and pos2 != -1:\n        print(ham - 2)\n        print(pos1 + 1, pos2 + 1)\n    \n        arr1 = [[0 for _ in range(2)] for _ in range(100)]\n        arr2 = [[0 for _ in range(2)] for _ in range(100)]\n        i = 0\n        while i < n:\n            if s1[i] != s2[i]:\n                if arr1[ord(s1[i]) - 97][0] == 1:\n                    pos2 = i\n                    pos1 = arr1[ord(s1[i]) - 97][1]\n                    break\n                if arr2[ord(s2[i]) - 97][0] == 1:\n                    pos2 = i\n                    pos1 = arr2[ord(s2[i]) - 97][1]\n                    break\n                arr1[ord(s2[i]) - 97][0] = 1\n                arr1[ord(s2[i]) - 97][1] = i\n                arr2[ord(s1[i]) - 97][0] = 1\n                arr2[ord(s1[i]) - 97][1] = i\n            i += 1\n        if pos1 != -1 and pos2 != -1:\n            print(ham - 1)\n            print(pos1 + 1, pos2 + 1)\n    print(ham)\n    print(pos1, pos2)\n", "src": "public class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    \n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                    break;\n                }\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n            }\n        }\n        int ham=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        \n        int arr1[][]=new int[100][2];\n        int arr2[][]=new int[100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr1[s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr1[s1.charAt(i)-97][1];\n                    break;\n                }\n                if(arr2[s2.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr2[s2.charAt(i)-97][1];\n                    break;\n                }\n                arr1[s2.charAt(i)-97][0]=1;\n                arr1[s2.charAt(i)-97][1]=i;\n                arr2[s1.charAt(i)-97][0]=1;\n                arr2[s1.charAt(i)-97][1]=i;\n            }\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-1);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        System.out.println(ham);\n        System.out.println(pos1+\" \"+pos2);\n    }\n}", "index": 373, "complexity": "1"}
{"forwhile": "n = sc.nextInt()\ns = sc.nextInt()\nf = [0] * n\nt = [0] * n\ni = 0\nwhile i < n:\n    f[i] = sc.nextInt()\n    t[i] = sc.nextInt()\n    i += 1\n\nmaxTimes = [0] * (s + 1)\ni = 0\nwhile i < len(f):\n    maxTimes[f[i]] = max(maxTimes[f[i]], t[i])\n    i += 1\n\ntime = 0\nfor i in range(s, 0, -1):\n    time = max(time, maxTimes[i])\n    time += 1\n\nprint(time)", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "index": 374, "complexity": "1"}
{"forwhile": "def reverse(a):\n    b = [0] * len(a)\n    j = 0\n    i = len(a)-1\n    while i >= 0:\n        b[i] = a[j]\n        j += 1\n        i -= 1\n    return b\n\npas = int(input())\ntop = int(input())\na = [0] * pas\nb = [0] * pas\ni = 0\nwhile i < pas:\n    a[i] = int(input())\n    b[i] = int(input())\n    i += 1\na = reverse(a)\nb = reverse(b)\nftime = 0\nt = 0\ntop = top\ni = 0\nwhile i < pas:\n    ftime += (top - a[i])\n    t = max(b[i] - ftime, 0)\n    ftime += t\n    top = a[i]\n    i += 1\nif top != 0:\n    ftime += top\nprint(ftime)", "src": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "index": 375, "complexity": "1"}
{"forwhile": "class FindUnion : \n\n\n\n@staticmethod \ndef printUnion(arr1, arr2, m, n) : \n\ni = 0 \nj = 0 \nfor i in range(m): \n\nif arr1[i] < arr2[j] : \nprint(arr1[i], end=' ') \n\nelif arr2[j] < arr1[i] : \nprint(arr2[j], end=' ') \n\nelse : \nprint(arr2[j], end=' ') \nj += 1 \ni += 1 \n\nwhile i < m: \nprint(arr1[i], end=' ') \n\nwhile j < n: \nprint(arr2[j], end=' ') \n\nreturn 0 \n\n\n\n@staticmethod \ndef main(args) : \n\narr1 = [1, 2, 4, 5, 6] \narr2 = [2, 3, 5, 7] \nm = len(arr1) \nn = len(arr2) \nFindUnion.printUnion(arr1, arr2, m, n) \n", "src": "class\nFindUnion \n{ \n\n\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n}", "index": 376, "complexity": "1"}
{"forwhile": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        int i = 1;\n        while (i < n) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n            i++;\n        }\n\n        long ans = 0;\n        int i = 0;\n        while (i < m) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n            i++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = scanner.nextInt();\n                i++;\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "src": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 377, "complexity": "1"}
{"forwhile": "import java.util.Scanner;\npublic class codef8 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int num = sc.nextInt();\n        int beacon[] = new int[1000001];\n        int i = 0;\n        while (i < num) {\n            beacon[sc.nextInt()] = sc.nextInt();\n            i++;\n        }\n        int dp[] = new int[1000001];\n        int max = 1;\n        if (beacon[0] > 0) {\n            dp[0] = 1;\n        }\n        for (int j = 1; j <= 1000000; j++) {\n            int i = j;\n            if (beacon[i] == 0) {\n                dp[i] = dp[i-1];\n            } else {\n                int b = beacon[i];\n                if (i <= b) {\n                    dp[i] = 1;\n                } else {\n                    dp[i] = dp[i-b-1] + 1;\n                }\n            }\n            max = Math.max(max, dp[i]);\n        }\n        System.out.println(num-max);\n        sc.close();\n    }\n}", "src": "public class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}", "index": 378, "complexity": "1"}
{"forwhile": "class FindUnion { static void UnionArray(int arr1[], int arr2[]) { int m = arr1[arr1.length - 1]; int n = arr2[arr2.length - 1]; int ans = 0; if (m > n) { ans = m; } else ans = n; int newtable[] = new int[ans + 1]; System.out.print(arr1[0] + \" \"); ++newtable[arr1[0]]; int i = 1; while (i < arr1.length) { if (arr1[i] != arr1[i - 1]) { System.out.print(arr1[i] + \" \"); ++newtable[arr1[i]]; } i++; } int j = 0; for (; j < arr2.length; j++) { if (newtable[arr2[j]] == 0) { System.out.print(arr2[j] + \" \"); ++newtable[arr2[j]]; } } } public static void main(String args[]) { int arr1[] = {1, 2, 2, 2, 3}; int arr2[] = {2, 3, 4, 5}; UnionArray(arr1, arr2); } }", "src": "class\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n\n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n\n\n\n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n\n\n\n\n++newtable[arr1[\n0\n]]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n\n\n\n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n\n\n\n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n}", "index": 379, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 380, "complexity": "1"}
{"forwhile": "public class Main {\n    \n    static InputReader in = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static long oo = 1000000000000L;\n    static int[][] memo;\n    \n    public static void main(String[] args) throws IOException {\n \n        int[] cnt = new int[101];\n        cnt[1] = 1;\n        int i = 2;\n        while (i <= 100) {\n            cnt[i] = cnt[i-1] + 4 * (i - 1);\n            i++;\n        }\n        int n = in.nextInt();\n        System.out.println( cnt[n] );\n        \n        out.close();\n    }\n    \n    static int maxHit(ArrayList<Integer> a, int p, int i) {\n        if(i == a.size())\n            return 0;\n        if(memo[p][i] != -1)\n            return memo[p][i];\n        int ret = maxHit(a, p, i + 1);\n        if(p == -1 || a.get(p) < a.get(i)) {\n            ret = Math.max(ret, maxHit(a, i, i + 1) );\n        }\n        return memo[p][i] = ret;\n    }\n    \n    \n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n    \n    static boolean nextPermutation(int[] a) {\n        int i = a.length - 2;\n        while (i >= 0) {\n            if(a[i] < a[i+1]) {\n                int j = a.length - 1;\n                while (true) {\n                    if(a[i] < a[j]) {\n                        int t = a[i];\n                        a[i] = a[j];\n                        a[j] = t;\n                        for(i++, j = a.length - 1; i < j; i++, j--) {\n                            t = a[i];\n                            a[i] = a[j];\n                            a[j] = t;\n                        }\n                        break;\n                    }\n                    j--;\n                }\n            }\n            i--;\n        }\n        return false;\n    }\n    \n    \n    static void shuffle(int[] a) {\n        Random r = new Random();\n        int i = a.length - 1;\n        while (i > 0) {\n            int si = r.nextInt(i);\n            int t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n            i--;\n        }\n    }\n    \n    static void shuffle(long[] a) {\n        Random r = new Random();\n        int i = a.length - 1;\n        while (i > 0) {\n            int si = r.nextInt(i);\n            long t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n            i--;\n        }\n    }\n    \n    static int lower_bound(int[] a, int n, int k) {\n        int s = 0;\n        int e = n;\n        int m;\n        for(; e - s > 0;) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n    static int lower_bound(long[] a, int n, long k) {\n        int s = 0;\n        int e = n;\n        int m;\n        for(; e - s > 0;) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n    \n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    \n    static class Pair implements Comparable<Pair> {\n        int first, second;\n \n        public Pair(int first, int second) {\n            super();\n            this.first = first;\n            this.second = second;\n        }\n \n        @Override\n        public int compareTo(Pair o) {\n            return this.first != o.first ? this.first - o.first : this.second - o.second;\n        }\n \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + first;\n            result = prime * result + second;\n            return result;\n        }\n \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Pair other = (Pair) obj;\n            if (first != other.first)\n                return false;\n            if (second != other.second)\n                return false;\n            return true;\n        }\n    }\n    \n    \n}\n \n \n \nclass InputReader {\n \n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n \n    public InputReader(InputStream st) {\n        this.stream = st;\n    }\n \n    public int read() {\n        if (snumChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n \n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n \n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n \n}", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 381, "complexity": "1"}
{"forwhile": "n = int(input())\nnum = 1\ni = 1\nwhile i < n:\n    add = 4 * i\n    num += add\n    i += 1\nprint(num)", "src": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "index": 382, "complexity": "1"}
{"forwhile": "class GFG { static int findRepeating(int arr[], int n) { int res = 0; int i = 0; while (i < n - 1) { res = res ^ (i + 1) ^ arr[i]; i++; } res = res ^ arr[n - 1]; return res; } public static void main(String[] args) { int arr[] = { 9, 8, 2, 6, 1, 8, 5, 3, 4, 7 }; int n = arr.length; System.out.println(findRepeating(arr, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n}", "index": 383, "complexity": "1"}
{"forwhile": "from collections import defaultdict\n\ndef findMajority(arr):\n    map = defaultdict(int)\n    i = 0\n    while i < len(arr):\n        if arr[i] in map:\n            count = map[arr[i]] + 1\n            if count > len(arr) / 2:\n                print(\"Majority found :- \" + str(arr[i]))\n                return\n            else:\n                map[arr[i]] = count\n        else:\n            map[arr[i]] = 1\n        i += 1\n\n    print(\" No Majority element\")\n\n\na = [2, 2, 2, 2, 5, 5, 2, 3, 3]\nfindMajority(a)", "src": "class\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n}", "index": 384, "complexity": "1"}
{"forwhile": "class GFG { static int maxTripletSum(int arr[], int n) { int maxA = -100000000, maxB = -100000000; int maxC = -100000000; int i = 0; while (i < n) { if (arr[i] > maxA) { maxC = maxB; maxB = maxA; maxA = arr[i]; } else if (arr[i] > maxB) { maxC = maxB; maxB = arr[i]; } else if (arr[i] > maxC) maxC = arr[i]; i++; } return (maxA + maxB + maxC); } public static void main(String args[]) { int arr[] = { 1, 0, 8, 6, 4, 2 }; int n = arr.length; System.out.println(maxTripletSum(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmaxA = -\n100000000\n, maxB = -\n100000000\n; \n\nint\nmaxC = -\n100000000\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(arr[i] > maxA) \n\n{ \n\nmaxC = maxB; \n\nmaxB = maxA; \n\nmaxA = arr[i]; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > maxB) \n\n{ \n\nmaxC = maxB; \n\nmaxB = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > maxC) \n\nmaxC = arr[i]; \n\n} \n\n\nreturn\n(maxA + maxB + maxC); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 385, "complexity": "1"}
{"forwhile": "class\\nLinkedList { \\n\\nNode head; \\n\\n\\nNode left; \\n\\n\\n\\n\\n\\nclass\\nNode { \\n\\nchar\\ndata; \\n\\nNode next; \\n\\n\\nNode(\\nchar\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nnext = \\nnull\\; \\n\\n} \\n\\n} \\n\\n\\n\\nboolean\\nisPalindromeUtil(Node right) \\n\\n{ \\n\\nleft = head; \\n\\n\\n\\nif\\n(right == \\nnull\\) \\n\\nreturn\\ntrue\\; \\n\\n\\n\\nboolean\\nisp = isPalindromeUtil(right.next); \\n\\nif\\n(isp == \\nfalse\\) \\n\\nreturn\\nfalse\\; \\n\\n\\n\\nboolean\\nisp1 = (right.data == (left).data); \\n\\n\\n\\n\\n\\nleft = left.next; \\n\\n\\nreturn\\nisp1; \\n\\n} \\n\\n\\n\\nboolean\\nisPalindrome(Node head) \\n\\n{ \\n\\nboolean\\nresult = isPalindromeUtil(head); \\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\n\\n\\npublic\\nvoid\\npush(\\nchar\\nnew_data) \\n\\n{ \\n\\n\\n\\nNode new_node = \\nnew\\nNode(new_data); \\n\\n\\n\\nnew_node.next = head; \\n\\n\\n\\nhead = new_node; \\n\\n} \\n\\n\\n\\nvoid\\nprintList(Node ptr) \\n\\n{ \\n\\nfor\\n(; ptr != \\nnull\\;) { \\n\\nSystem.out.print(ptr.data + \\n\"->\"\\); \\n\\nptr = ptr.next; \\n\\n} \\n\\nSystem.out.println(\\n\"NULL\"\\); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\n\\n\\nLinkedList llist = \\nnew\\nLinkedList(); \\n\\n\\nchar\\nstr[] = { \\n\\'a\\'\\, \\n\\'b\\'\\, \\n\\'a\\'\\, \\n\\'c\\'\\, \\n\\'a\\'\\, \\n\\'b\\'\\, \\n\\'a\\'\\}; \\n\\nString string = \\nnew\\nString(str); \\n\\n\\nint\\ni = \\n0\\; \\nwhile(i < \\n7\\) { \\n\\nllist.push(str[i]); \\n\\nllist.printList(llist.head); \\n\\nif\\n(llist.isPalindrome(llist.head) != \\nfalse\\) { \\n\\nSystem.out.println(\\n\"Is Palindrome\"\\); \\n\\nSystem.out.println(\\n\"\"\\); \\n\\n} \\n\\nelse { \\n\\nSystem.out.println(\\n\"Not Palindrome\"\\); \\n\\nSystem.out.println(\\n\"\"\\); \\n\\n} \\n\\ni += \\n1\\; \\n} \\n\\n} \\n}", "src": "class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n}", "index": 386, "complexity": "1"}
{"forwhile": "class GFG { static int maxSum(int arr[], int n) { int sum = 0; int i; int pivot = findPivot(arr, n); int diff = n - 1 - pivot; i = 0; while (i < n) { sum = sum + ((i + diff) % n) * arr[i]; i++; } return sum; } static int findPivot(int arr[], int n) { int i; i = 0; while (i < n) { if (arr[i] > arr[(i + 1) % n]) return i; i++; } return 0; } public static void main(String args[]) { int arr[] = { 8, 3, 1, 2 }; int n = arr.length; int max = maxSum(arr, n); System.out.println(max); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n\n\n\n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n}", "index": 387, "complexity": "1"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 593 (char 594)", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 388, "complexity": "1"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\nstatic\\nlong\\nbinomialCoeff(\\nint\\nn, \\nint\\nk) { \\n\\nlong\\nres = \\n1\\; \\n\\n\\n\\nif\\n(k > n - k) { \\n\\nk = n - k; \\n\\n} \\n\\n\\n\\nint\\ni = \\n0\\; \\ni < k; { \\nwhile \\ni < k: \\n\\nres *= (n - i); \\n\\nres /= (i + \\n1\\); \\n\\ni += 1; \\n} \\n\\n\\nreturn\\nres; \\n\\n} \\n\\n\\n\\nstatic\\nlong\\ncatalan(\\nint\\nn) { \\n\\n\\n\\nlong\\nc = binomialCoeff(\\n2\\* n, n); \\n\\n\\n\\nreturn\\nc / (n + \\n1\\); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) { \\n\\nint\\ni = \\n0\\; \\ni < \\n10\\; { \\nwhile \\ni < \\n10\\: \\n\\nSystem.out.print(catalan(i) + \\n\" \"\\); \\n\\ni += 1; \\n} \\n\\n\\n} \\n}", "src": "class\nGFG { \n\n\n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n\n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\nstatic\nlong\ncatalan(\nint\nn) { \n\n\n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n\n\nreturn\nc / (n + \n1\n); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n}", "index": 389, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\nstatic\\nint\\nPermutationCoeff(\\nint\\nn, \\n\\nint\\nk) \\n\\n{ \\n\\nint\\nFn = \\n1\\, Fk = \\n1\\; \\n\\n\\n\\nint\\ni = \\n1\\; \\nwhile i <= n: \\n\\n{ \\n\\nFn *= i; \\n\\nif\\n(i == n - k) \\n\\nFk = Fn; \\n\n    i += 1; \\n}\\n\\nint\\ncoeff = Fn / Fk; \\n\\nreturn\\ncoeff; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\nn = \\n10\\, k = \\n2\\; \\n\\nSystem.out.println(\\n\"Value of P( \"\\n+ n + \\n\",\"\\n+ \\n\\nk +\\n\") is \"\\n+ \\n\\nPermutationCoeff(n, k) ); \\n\\n} \\n}", "src": "class\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n}", "index": 390, "complexity": "1"}
{"forwhile": "class GFG { static int countFriendsPairings(int n) { int a = 1, b = 2, c = 0; if (n <= 2) { return n; } int i = 3; while (i <= n) { c = b + (i - 1) * a; a = b; b = c; i++; } return c; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 391, "complexity": "1"}
{"forwhile": "class GFG { static int countSeq(int n) { int nCr = 1, res = 1; int r = 1; while (r <= n) { nCr = (nCr * (n + 1 - r)) / r; res += nCr * nCr; r++; } return res; } public static void main(String args[]) { int n = 2; System.out.print(\"Count of sequences is \"); System.out.println(countSeq(n)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n\n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n\n\n\n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n}", "index": 392, "complexity": "1"}
{"forwhile": "class GFG { static void rearrange(int arr[], int n) { int i = 0; while (i < n) { arr[arr[i] % n] += i * n; i++; } i = 0; while (i < n) { arr[i] /= n; i++; } } static void printArray(int arr[], int n) { int i = 0; while (i < n) { System.out.print(arr[i] + \" \"); i++; } System.out.println(); } public static void main(String[] args) { int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is : \"); printArray(arr, n); rearrange(arr, n); System.out.println(\"Modified array is :\"); printArray(arr, n); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\narr[i] /= n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 393, "complexity": "1"}
{"forwhile": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nint\ni = \n0\n; \nwhile i < n:\n\n{ \n\n\n\n\n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\ni += 1\n}\n\n\nint\ni = \n0\n; \nwhile i < n:\n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n\ni += 1\n} \n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n}", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n}", "index": 394, "complexity": "1"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nsmallestSubWithSum(\\nint\\narr[], \\n\\nint\\nn, \\nint\\nx) \\n{ \\n\\n\\n\\n\\nint\\ncurr_sum = \\n0\\n, min_len = n + \\n1\\n; \\n\\n\\n\\n\\nint\\nstart = \\n0\\n, end = \\n0\\n; \\n\\nfor\\nend \\nin\\nrange(n): \\n\\n\\n{ \\n\\n\\n\\n\\n\\nfor\\ncurr_sum \\nin\\nrange(x + 1): \\n\\n\\n{ \\n\\n\\n\\n\\n\\nif\\ncurr_sum <= \\n0\\n\\nand x > \\n0\\n: \\n\\n\\n{ \\n\\nstart = end; \\n\\n\\n\\ncurr_sum = \\n0\\n; \\n\\n\\n} \\n\\n\\n\\ncurr_sum += arr[end]; \\n\\nend += \\n1\\n; \\n\\n} \\n\\n\\n\\n\\nfor\\ncurr_sum \\nin\\nrange(x): \\n\\n\\n{ \\n\\n\\n\\n\\n\\nif\\nend - start < min_len: \\n\\n\\nmin_len = end - start; \\n\\n\\n\\n\\ncurr_sum -= arr[start]; \\n\\nstart += \\n1\\n; \\n\\n} \\n\\n} \\n\\nreturn\\nmin_len; \\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain (String[] args) \\n{ \\n\\nint\\narr1[] = {- \\n8\\n, \\n1\\n, \\n4\\n, \\n2\\n, -\\n6\\n}; \\n\\nint\\nx = \\n6\\n; \\n\\nint\\nn1 = arr1.length; \\n\\nfor\\narr1 \\nin\\nrange(n1): \\n\\n{ \\n\\nint\\nres1 = smallestSubWithSum(arr1, \\n\\nn1, x); \\n\\nif\\nres1 == n1 + \\n1\\n: \\n\\nSystem.out.println(\\n\\\"Not possible\\\"\\n); \\n\\nelse\\n\\nSystem.out.println (res1); \\n\\n} \\n} \\n}", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n\n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n\n\n\n\n\n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n}", "index": 395, "complexity": "1"}
{"forwhile": "arr1 = [1, 2, 4, 5, 6]\narr2 = [2, 3, 5, 7]\nm = len(arr1)\nn = len(arr2)\ni = 0\nj = 0\nfor i in range(m):\n    while j < n:\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr2[j] < arr1[i]:\n            j += 1\n        else:\n            print(arr2[j], end=' ')\n            j += 1\n            i += 1", "src": "class\nFindIntersection \n{ \n\n\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n}", "index": 396, "complexity": "1"}
{"forwhile": "class RotateArray { void leftRotate( int arr[], int d, int n) { int i = 0; while (i < d) leftRotatebyOne(arr, n); } void leftRotatebyOne( int arr[], int n) { int i, temp; i = 0; while (i < n - 1) { arr[i] = arr[i + 1]; i++; } arr[i] = temp; } void printArray( int arr[], int n) { int i = 0; while (i < n) { System.out.print(arr[i] + \" \"); i++; } } public static void main(String[] args) { RotateArray rotate = new RotateArray(); int arr[] = { 1, 2, 3, 4, 5, 6, 7 }; rotate.leftRotate(arr, 2, 7); rotate.printArray(arr, 7); } }", "src": "class\nRotateArray { \n\n\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n}", "index": 397, "complexity": "3"}
{"forwhile": "class CountTriangles { static int findNumberOfTriangles( int arr[]) { int n = arr.length; Arrays.sort(arr); int count = 0; int i = 0; while (i < n-2) { int k = i + 2; int j = i+1; while (j < n) { while (k < n && arr[i] + arr[j] > arr[k]) k++; if (k>j) count += k - j - 1; j++; } i++; } return count; } public static void main (String[] args) { int arr[] = { 10, 21, 22, 100, 101, 200, 300 }; System.out.println( \"Total number of triangles is \"+ findNumberOfTriangles(arr)); } }", "src": "class\nCountTriangles \n{ \n\n\n\n\n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n\n\nint\nk = i + \n2\n; \n\n\n\n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n}", "index": 398, "complexity": "3"}
{"forwhile": "class\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n\n\ni = 0\n\nwhile i < n: \n\n{ \n\n\n\n\n\nj = i + \n1\n\nwhile j < n: \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k): \n\ncount++ \n\nj++ \n\n} \n\ni++ \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n}", "src": "class\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k) \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n}", "index": 399, "complexity": "3"}
{"forwhile": "class Test { static int arr1[] = new int[]{ 1, 5, 9, 10, 15, 20}; static int arr2[] = new int[]{ 2, 3, 8, 13}; static void merge( int m, int n) { int i=n-1; while(i>=0) { int j, last = arr1[m-1]; j=m-2; while(j >= 0 && arr1[j] > arr2[i]){ arr1[j+1] = arr1[j]; j--; } if(j != m-2 || last > arr2[i]) { arr1[j+1] = arr2[i]; arr2[i] = last; } i--; } } public static void main(String[] args) { merge(arr1.length,arr2.length); System.out.print(", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n\n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n}", "index": 400, "complexity": "3"}
{"forwhile": "class GFG { static boolean isPresent(int B[], int m, int x) { int i = 0; while (i < m) { if (B[i] == x) return true; i++; } return false; } static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = -2147483648, curr_max = 0; int i = 0; while (i < n) { if (!isPresent(B, m, A[i])) { curr_max = 0; i++; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); i++; } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if (maxSubarraySum == -2147483648) { System.out.println(\"Maximum Subarray Sum \" + \"can't be found\"); } else { System.out.println(\"The Maximum Subarray Sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = { 3, 4, 5, -4, 6 }; int B[] = { 1, 8, 5 }; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 401, "complexity": "3"}
{"forwhile": "class GFG { static int findMaxSum(int[] arr, int n) { int res = Integer.MIN_VALUE; int i = 0; while (i < n) { int prefix_sum = arr[i]; int j = 0; while (j < i) { prefix_sum += arr[j]; j++; } int suffix_sum = arr[i]; j = n - 1; while (j > i) { suffix_sum += arr[j]; j--; } if (prefix_sum == suffix_sum) res = Math.max(res, prefix_sum); i++; } return res; } public static void main (String[] args) { int arr[] = {-2, 5, 3, 1, 2, 6, -4, 2}; int n = arr.length; System.out.println(findMaxSum(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n}", "index": 402, "complexity": "3"}
{"forwhile": "class EquilibriumIndex { int equilibrium(int arr[], int n) { int i, j; int leftsum, rightsum; i = 0; while (i < n) { leftsum = 0; j = 0; while (j < i) leftsum += arr[j++]; rightsum = 0; j = i + 1; while (j < n) rightsum += arr[j++]; if (leftsum == rightsum) return i; i++; } return -1; } public static void main(String[] args) { EquilibriumIndex equi = new EquilibriumIndex(); int arr[] = { -7, 1, 5, 2, -4, 3, 0 }; int arr_size = arr.length; System.out.println(equi.equilibrium(arr, arr_size)); } }", "src": "class\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n}", "index": 403, "complexity": "3"}
{"forwhile": "class LeadersInArray { void printLeaders( int arr[], int size) { int i = 0; while(i < size) { int j; j = i + 1; while(j < size) { if(arr[i] <= arr[j]) break; j++; } if(j == size) System.out.print(arr[i] + \" \"); i++; } } public static void main(String[] args) { LeadersInArray lead = new LeadersInArray(); int arr[] = new int[]{ 16, 17, 4, 3, 5, 2}; int n = arr.length; lead.printLeaders(arr, n); } }", "src": "class\nLeadersInArray \n{ \n\n\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n\n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n}", "index": 404, "complexity": "3"}
{"forwhile": "class GFG { static void findMajority(int arr[], int n) { int maxCount = 0; int index = -1; int i = 0; while (i < n) { int count = 0; int j = 0; while (j < n) { if (arr[i] == arr[j]) count++; j++; } if (count > maxCount) { maxCount = count; index = i; } i++; } if (maxCount > n/2) System.out.println(arr[index]); else System.out.println(\"No Majority Element\"); } public static void main (String[] args) { int arr[] = {1, 1, 2, 1, 3, 5, 1}; int n = arr.length; findMajority(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n\n\n\n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n\n\n\n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nfindMajority(arr, n); \n\n} \n\n}", "index": 405, "complexity": "3"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 454 (char 455)", "src": "class\nSubarraySum \n{ \n\n\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n\n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n}", "index": 406, "complexity": "3"}
{"forwhile": "class FindTriplet { boolean find3Numbers(int A[], int arr_size, int sum) { int l, r; quickSort(A, 0, arr_size - 1); int i = 0; while (i < arr_size - 2) { l = i + 1; r = arr_size - 1; while (l < r) { if (A[i] + A[l] + A[r] == sum) { System.out.print(\"Triplet is \" + A[i] + \", \" + A[l] + \", \" + A[r]); return true; } else if (A[i] + A[l] + A[r] < sum) l++; else r--; } i++; } return false; } int partition(int A[], int si, int ei) { int x = A[ei]; int i = (si - 1); for (int j = si; j <= ei - 1; j++) { if (A[j] <= x) { i++; int temp = A[i]; A[i] = A[j]; A[j] = temp; } } int temp = A[i + 1]; A[i + 1] = A[ei]; A[ei] = temp; return (i + 1); } void quickSort(int A[], int si, int ei) { int pi; for (int i = si; i < ei; i++) { if (si < ei) { pi = partition(A, si, ei); quickSort(A, si, pi - 1); quickSort(A, pi + 1, ei); } } } public static void main(String[] args) { FindTriplet triplet = new FindTriplet(); int A[] = { 1, 4, 45, 6, 10, 8 }; int sum = 22; int arr_size = A.length; triplet.find3Numbers(A, arr_size, sum); } }", "src": "class\nFindTriplet { \n\n\n\n\n\n\nboolean\nfind3Numbers(\nint\nA[], \nint\narr_size, \nint\nsum) \n\n{ \n\nint\nl, r; \n\n\n\n\nquickSort(A, \n0\n, arr_size - \n1\n); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < arr_size - \n2\n; i++) { \n\n\n\n\n\n\n\n\nl = i + \n1\n; \n\n\nr = arr_size - \n1\n; \n\n\nwhile\n(l < r) { \n\nif\n(A[i] + A[l] + A[r] == sum) { \n\nSystem.out.print(\n\"Triplet is \"\n+ A[i] + \n\", \"\n+ A[l] + \n\", \"\n+ A[r]); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(A[i] + A[l] + A[r] < sum) \n\nl++; \n\n\nelse\n\n\nr--; \n\n} \n\n} \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\nint\npartition(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\nx = A[ei]; \n\nint\ni = (si - \n1\n); \n\nint\nj; \n\n\nfor\n(j = si; j <= ei - \n1\n; j++) { \n\nif\n(A[j] <= x) { \n\ni++; \n\nint\ntemp = A[i]; \n\nA[i] = A[j]; \n\nA[j] = temp; \n\n} \n\n} \n\nint\ntemp = A[i + \n1\n]; \n\nA[i + \n1\n] = A[ei]; \n\nA[ei] = temp; \n\nreturn\n(i + \n1\n); \n\n} \n\n\n\n\nvoid\nquickSort(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\npi; \n\n\n\n\nif\n(si < ei) { \n\npi = partition(A, si, ei); \n\nquickSort(A, si, pi - \n1\n); \n\nquickSort(A, pi + \n1\n, ei); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindTriplet triplet = \nnew\nFindTriplet(); \n\nint\nA[] = { \n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n8\n}; \n\nint\nsum = \n22\n; \n\nint\narr_size = A.length; \n\n\ntriplet.find3Numbers(A, arr_size, sum); \n\n} \n}", "index": 407, "complexity": "3"}
{"forwhile": "class GFG { static void findTriplets(int arr[], int n) { boolean found = false; int i = 0; while (i < n - 1) { HashSet<Integer> s = new HashSet<Integer>(); int j = i + 1; while (j < n) { int x = -(arr[i] + arr[j]); if (s.contains(x)) { System.out.printf(\"%d %d %d\\n\", x, arr[i], arr[j]); found = true; } else { s.add(arr[j]); } j++; } i++; } if (found == false) { System.out.printf(\" No Triplet Found\\n\"); } } public static void main(String[] args) { int arr[] = { 0, -1, 2, -3, 1 }; int n = arr.length; findTriplets(arr, n); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n\n\n\n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n}", "index": 408, "complexity": "3"}
{"forwhile": "class GFG: \n\n\n\nstatic void spiralPrint(int m, int n, int a[][]) \n\n{ \n\nint i, k = 0, l = 0; \n\n\n\nwhile k < m and l < n: \n\n\ni = l \nwhile i < n: \n\nSystem.out.print(a[k][i] + \" \"); \n\ni++ \n\nk++; \n\n\n\ni = k \nwhile i < m: \n\nSystem.out.print(a[i][n - 1] + \" \"); \n\ni++ \n\nn--; \n\n\n\nif k < m: \n\ni = n - 1 \nwhile i >= l: \n\nSystem.out.print(a[m - 1][i] + \" \"); \n\ni-- \n\nm--; \n\n\n\nif l < n: \n\ni = m - 1 \nwhile i >= k: \n\nSystem.out.print(a[i][l] + \" \"); \n\ni-- \n\nl++; \n\n\n\n} \n\n} \n\n\n\npublic static void main(String[] args) \n\n{ \n\nint R = 3; \n\nint C = 6; \n\nint a[][] = { { 1, 2, 3, 4, 5, 6}, \n\n{ 7, 8, 9, 10, 11, 12}, \n\n{ 13, 14, 15, 16, 17, 18} }; \n\nspiralPrint(R, C, a); \n\n} ", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\nwhile\n(k < m && l < n) { \n\n\n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n\n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n\n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n\n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n}", "index": 409, "complexity": "3"}
{"forwhile": "class GFG : \n\n    @classmethod\n    def counterClockspiralPrint(cls, m, n, arr): \n\n        i = 0\n        k = 0\n        l = 0\n        cnt = 0\n        total = m * n\n\n        while k < m and l < n: \n\n            if cnt == total: \n                break\n\n            i = k\n            while i < m: \n                print(arr[i][l], end=\" \")\n                cnt += 1\n                i += 1\n            l += 1\n\n            if cnt == total: \n                break\n\n            i = l\n            while i < n: \n                print(arr[m - 1][i], end=\" \")\n                cnt += 1\n                i += 1\n            m -= 1\n\n            if cnt == total: \n                break\n\n            if k < m: \n                i = m - 1\n                while i >= k: \n                    print(arr[i][n - 1], end=\" \")\n                    cnt += 1\n                    i -= 1\n                n -= 1\n\n            if cnt == total: \n                break\n\n            if l < n: \n                i = n - 1\n                while i >= l: \n                    print(arr[k][i], end=\" \")\n                    cnt += 1\n                    i -= 1\n                k += 1\n\n    @classmethod\n    def main(cls, args): \n        arr = [ [1, 2, 3, 4], \n                [5, 6, 7, 8], \n                [9, 10, 11, 12], \n                [13, 14, 15, 16] ]\n\n        cls.counterClockspiralPrint(cls.R, cls.C, arr)\n\n\nGFG.R = 4\nGFG.C = 4\nGFG.main([])", "src": "class\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n\n\n\n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\n\n\n\nint\ncnt = \n0\n; \n\n\n\n\n\n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n\n\ncounterClockspiralPrint(R, C, arr); \n} \n}", "index": 410, "complexity": "3"}
{"forwhile": "N = 4\nM = 6\n\ndef findMaxPath(mat):\n    res = -1\n    i = 0\n    while i < M:\n        res = max(res, mat[0][i])\n        i += 1\n    i = 1\n    while i < N:\n        res = -1\n        j = 0\n        while j < M:\n            if j > 0 and j < M - 1:\n                mat[i][j] += max(mat[i - 1][j], max(mat[i - 1][j - 1], mat[i - 1][j + 1]))\n            elif j > 0:\n                mat[i][j] += max(mat[i - 1][j], mat[i - 1][j - 1])\n            elif j < M - 1:\n                mat[i][j] += max(mat[i - 1][j], mat[i - 1][j + 1])\n            res = max(mat[i][j], res)\n            j += 1\n        i += 1\n    return res\n\nmat = [[10, 10, 2, 0, 20, 4],\n       [1, 0, 0, 30, 2, 5],\n       [0, 10, 4, 0, 2, 0],\n       [1, 0, 2, 20, 0, 4]]\n\nprint(findMaxPath(mat)", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n\n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n\n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n\n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n\n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n\n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n\n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n}", "index": 411, "complexity": "3"}
{"forwhile": "class LinkedList { static Node head; static class Node { int data; Node next; Node(int d) { data = d; next = null; } } void remove_duplicates() { Node ptr1 = null, ptr2 = null, dup = null; ptr1 = head; for ( ; ptr1 != null && ptr1.next != null ; ) { ptr2 = ptr1; for ( ; ptr2.next != null ; ) { if (ptr1.data == ptr2.next.data) { dup = ptr2.next; ptr2.next = ptr2.next.next; System.gc(); } else { ptr2 = ptr2.next; } } ptr1 = ptr1.next; } } void printList(Node node) { for ( ; node != null ; ) { System.out.print(node.data + \" \"); node = node.next; } } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(12); list.head.next.next = new Node(11); list.head.next.next.next = new Node(11); list.head.next.next.next.next = new Node(12); list.head.next.next.next.next.next = new Node(11); list.head.next.next.next.next.next.next = new Node(10); System.out.println(\"Linked List before removing duplicates : \\n \"); list.printList(head); list.remove_duplicates(); System.out.println(\"\"); System.out.println(\"Linked List after removing duplicates : \\n \"); list.printList(head); } }", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nvoid\nremove_duplicates() { \n\nNode ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n; \n\nptr1 = head; \n\n\n\n\nwhile\n(ptr1 != \nnull\n&& ptr1.next != \nnull\n) { \n\nptr2 = ptr1; \n\n\n\n\nwhile\n(ptr2.next != \nnull\n) { \n\n\n\n\nif\n(ptr1.data == ptr2.next.data) { \n\n\n\n\ndup = ptr2.next; \n\nptr2.next = ptr2.next.next; \n\nSystem.gc(); \n\n} \nelse\n\n{ \n\nptr2 = ptr2.next; \n\n} \n\n} \n\nptr1 = ptr1.next; \n\n} \n\n} \n\n\nvoid\nprintList(Node node) { \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next.next.next = \nnew\nNode(\n10\n); \n\n\nSystem.out.println(\n\"Linked List before removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n\nlist.remove_duplicates(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Linked List after removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n} \n}", "index": 412, "complexity": "3"}
{"forwhile": "class Node: \n\n    def __init__(self, data): \n        self.data = data \n        self.next = None \n\n    @staticmethod \n    def getJosephusPosition(m, n): \n        head = Node(1) \n        prev = head \n        i = 2 \n        while i <= n: \n            prev.next = Node(i) \n            prev = prev.next \n            i += 1 \n        prev.next = head \n        ptr1 = head \n        ptr2 = head \n        while ptr1.next != ptr1: \n            count = 1 \n            m_count = m \n            while m_count != count: \n                ptr2 = ptr1 \n                ptr1 = ptr1.next \n                count += 1 \n            ptr2.next = ptr1.next \n            ptr1 = ptr2.next \n        print('Last person left standing (Josephus Position) is', ptr1.data) \n\n    @staticmethod \n    def main(args): \n        n = 14 \n        m = 2 \n        Node.getJosephusPosition(m, n)", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode next; \n\npublic\nNode( \nint\ndata ) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ngetJosephusPosition(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nNode head = \nnew\nNode(\n1\n); \n\nNode prev = head; \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\n{ \n\nprev.next = \nnew\nNode(i); \n\nprev = prev.next; \n\n} \n\n\n\n\nprev.next = head; \n\n\n\n\nNode ptr1 = head, ptr2 = head; \n\n\nwhile\n(ptr1.next != ptr1) \n\n{ \n\n\n\n\nint\ncount = \n1\n; \n\nwhile\n(count != m) \n\n{ \n\nptr2 = ptr1; \n\nptr1 = ptr1.next; \n\ncount++; \n\n} \n\n\n\n\nptr2.next = ptr1.next; \n\nptr1 = ptr2.next; \n\n} \n\nSystem.out.println (\n\"Last person left standing \"\n+ \n\n\"(Josephus Position) is \"\n+ ptr1.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n14\n, m = \n2\n; \n\ngetJosephusPosition(m, n); \n\n} \n}", "index": 413, "complexity": "3"}
{"forwhile": "class GFG: \n\n\n    @staticmethod\n    def maxSum(arr, n): \n\n        res = float('-inf') \n\n\n\n        i = 0\n        while i < n: \n\n\n\n            curr_sum = 0 \n\n\n\n\n\n\n\n\n\n\n            j = 0\n            while j < n: \n\n                index = (i + j) % n \n                curr_sum += j * arr[index] \n                j += 1\n\n            \n\n\n\n            res = max(res, curr_sum) \n            i += 1\n\n        return res \n\n\n    @staticmethod\n    def main(args): \n\n        arr = [8, 3, 1, 2] \n\n        n = len(arr) \n\n        print(GFG.maxSum(arr, n)) \n\n\n", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 414, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def calculateSpan(price, n, S): \n        S[0] = 1\n\n        i = 1\n        while i < n:\n            S[i] = 1\n\n            j = i - 1\n            while j >= 0 and price[i] >= price[j]:\n                S[i] += 1\n                j -= 1\n\n            i += 1\n\n    @staticmethod\n    def printArray(arr): \n        print(Arrays.toString(arr))\n\n    @staticmethod\n    def main(args): \n        price = [10, 4, 5, 90, 120, 80]\n        n = len(price)\n        S = [0] * n\n\n        GFG.calculateSpan(price, n, S)\n\n        GFG.printArray(S)\n", "src": "class\nGFG { \n\n\n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n\n\nS[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n\n\ncalculateSpan(price, n, S); \n\n\n\n\nprintArray(S); \n\n} \n}", "index": 415, "complexity": "3"}
{"forwhile": "class GFG { static Stack<Integer> sortStack(Stack<Integer> input) { Stack<Integer> tmpStack = new Stack<Integer>(); while (!input.empty()) { int tmp = input.peek(); input.pop(); while (!tmpStack.empty() && tmpStack.peek() < tmp) { input.push(tmpStack.peek()); tmpStack.pop(); } tmpStack.push(tmp); } return tmpStack; } static void sortArrayUsingStacks(int []arr, int n) { Stack<Integer> input = new Stack<Integer>(); int i = 0; while (i < n) { input.push(arr[i]); i++; } Stack<Integer> tmpStack = sortStack(input); i = 0; while (i < n) { arr[i] = tmpStack.peek(); tmpStack.pop(); i++; } } public static void main(String args[]) { int []arr = { 10 , 5 , 15 , 45 }; int n = arr.length; sortArrayUsingStacks(arr, n); int i = 0; while (i < n) { System.out.print(arr[i] + \" \"); i++; } } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n\n\n\n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n\n\n\n\n\n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n\n\n\n\n\n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n\n\n\n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n\n\n\n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n\n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 416, "complexity": "3"}
{"forwhile": "class GFG: \n    @staticmethod \n    def minIndex(list, sortIndex): \n        min_index = -1 \n        min_value = float('inf') \n        s = len(list) \n        i = 0 \n        while i < s: \n            current = list[0] \n            list.pop(0) \n            if current <= min_value and i <= sortIndex: \n                min_index = i \n                min_value = current \n            list.append(current) \n            i += 1 \n        return min_index \n\n    @staticmethod \n    def insertMinToRear(list, min_index): \n        min_value = 0 \n        s = len(list) \n        i = 0 \n        while i < s: \n            current = list[0] \n            list.pop(0) \n            if i != min_index: \n                list.append(current) \n            else: \n                min_value = current \n            i += 1 \n        list.append(min_value) \n\n    @staticmethod \n    def sortQueue(list): \n        i = 1 \n        while i <= len(list): \n            min_index = GFG.minIndex(list, len(list) - i) \n            GFG.insertMinToRear(list, min_index) \n            i += 1 \n\n    @staticmethod \n    def main(args): \n        list = [] \n        list.append(30) \n        list.append(11) \n        list.append(15) \n        list.append(4) \n        GFG.sortQueue(list) \n        while list: \n            print(list[0], end=' ') \n            list.pop(0) \n", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n\n\nlist.poll(); \n\n\n\n\n\n\n\n\n\n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n\n\n\n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n\n\nsortQueue(list); \n\n\n\n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n}", "index": 417, "complexity": "3"}
{"forwhile": "class Node: \n\n    def __init__(self, d): \n        self.data = d \n        self.left = None \n        self.right = None \n\n\nclass BinaryTree: \n\n    def printSpiral(self, node): \n        h = self.height(node) \n        i = 1 \n        ltr = False \n\n        while i <= h: \n            self.printGivenLevel(node, i, ltr) \n            ltr = not ltr \n            i += 1 \n\n    def height(self, node): \n        if node is None: \n            return 0 \n        else: \n            lheight = self.height(node.left) \n            rheight = self.height(node.right) \n\n            return (lheight + 1) if lheight > rheight else (rheight + 1) \n\n    def printGivenLevel(self, node, level, ltr): \n        if node is None: \n            return \n\n        if level == 1: \n            print(node.data, end=' ') \n        elif level > 1: \n            if ltr: \n                self.printGivenLevel(node.left, level - 1, ltr) \n                self.printGivenLevel(node.right, level - 1, ltr) \n            else: \n                self.printGivenLevel(node.right, level - 1, ltr) \n                self.printGivenLevel(node.left, level - 1, ltr) \n\n\nif __name__ == '__main__': \n    tree = BinaryTree() \n\n    tree.root = Node(1) \n    tree.root.left = Node(2) \n    tree.root.right = Node(3) \n    tree.root.left.left = Node(7) \n    tree.root.left.right = Node(6) \n    tree.root.right.left = Node(5) \n    tree.root.right.right = Node(4) \n\n    print('Spiral order traversal of Binary Tree is') \n    tree.printSpiral(tree.root)", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 418, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\n\\nstatic\\nvoid\\nprintKMax(\\nint\\narr[], \\nint\\nn, \\nint\\nk) \\n\\n{ \\n\\nint\\nj, max; \\n\\n\\ni = 0;\\nwhile i <= n - k:\\n\\n\\nmax = arr[i]; \\n\\n\\nj = 1;\\nwhile j < k:\\n\\nif arr[i + j] > max:\\n\\nmax = arr[i + j]; \\n\\nj += 1;\\n\\nprint(max + \\n' ' ); \\n\\ni += 1;\\n\\n} \\n\\n} \\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n6\\n, \\n7\\n, \\n8\\n, \\n9\\n, \\n10\\n}; \\n\\nint\\nk = \\n3\\n; \\n\\nprintKMax(arr, arr.length, k); \\n\\n} \\n}", "src": "public\nclass\nGFG { \n\n\n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n}", "index": 419, "complexity": "3"}
{"forwhile": "class\nsolution \n{ \n\n\n\nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n\n\n\n\nboolean\nflag; \n\ni = 0\n\nwhile i < (n-k+1): \n\n{ \n\nflag = \nfalse\n; \n\nj = 0\n\nwhile j < k: \n\n\n\n\n\n\n\n\n\nif\n(arr[i+j] < \n0\n): \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\nj += 1\n\n} \n\n\n\n\n\n\nif\n(not flag): \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\ni += 1\n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n}", "src": "class\nsolution \n{ \n\n\n\nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n\n\n\n\nboolean\nflag; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n\n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n}", "index": 420, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def maxSubarrayXOR(arr, n): \n        ans = float('-inf') \n\n        i = 0 \n        while i < n: \n\n            curr_xor = 0 \n\n            j = i \n            while j < n: \n\n                curr_xor = curr_xor ^ arr[j] \n                ans = max(ans, curr_xor) \n\n                j += 1 \n\n            i += 1 \n\n        return ans \n\n    @staticmethod\n    def main(args): \n        arr = [8, 1, 2, 12] \n        n = len(arr) \n        print(\"Max subarray XOR is \", GFG.maxSubarrayXOR(arr, n)) \n", "src": "class\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\ncurr_xor = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n}", "index": 421, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod \n    def splitArr(arr, n, k): \n        i = 0 \n        while i < k: \n            x = arr[0] \n            j = 0 \n            while j < n - 1: \n                arr[j] = arr[j + 1] \n                j += 1 \n            arr[n - 1] = x \n            i += 1 \n\n    @staticmethod \n    def main(args): \n        arr = [12, 10, 5, 6, 52, 36] \n        n = len(arr) \n        position = 2 \n        GFG.splitArr(arr, 6, position) \n        i = 0 \n        for i in range(n): \n            print(arr[i], end=' ') \n", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n\n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 422, "complexity": "3"}
{"forwhile": "public\\nclass\\nCountKSubStr \\n{ \\n\\n\\n\\n\\n\\nint\\ncountkDist(String str, \\nint\\nk) \\n\\n{ \\n\\n\\n\\nint\\nres = \\n0\\n; \\n\\n\\nint\\nn = str.length(); \\n\\n\\n\\nint\\ncnt[] = \\nnew\\nint\\n[\\n26\\n]; \\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile i < n: \\n\\n{ \\n\\n\\nint\\ndist_count = \\n0\\n; \\n\\n\\n\\nArrays.fill(cnt, \\n0\\n); \\n\\n\\n\\n\\n\\nint\\nj=i; while j<n: \\n\\n{ \\n\\n\\n\\n\\nif\\n(cnt[str.charAt(j) - \\n'a'\\n] == \\n0\\n) \\n\\ndist_count++; \\n\\n\\n\\ncnt[str.charAt(j) - \\n'a'\\n]++; \\n\\n\\n\\n\\n\\nif\\n(dist_count == k) \\n\\nres++; \\n\\n\\n} \\n\\ni++; \\n} \\n\\n\\n\\nreturn\\nres; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nCountKSubStr ob = \\nnew\\nCountKSubStr(); \\n\\nString ch = \\n\\\"abcbaa\\\"\\n; \\n\\nint\\nk = \\n3\\n; \\n\\nSystem.out.println(\\n\\\"Total substrings with exactly \\\"\\n+ \\n\\nk + \\n\\\" distinct characters : \\\"\\n\\n+ ob.countkDist(ch, k)); \\n\\n} \\n}", "src": "public\nclass\nCountKSubStr \n{ \n\n\n\n\n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n\n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n\n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n\n\nArrays.fill(cnt, \n0\n); \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\n\n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n\n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n\n\n\n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n}", "index": 423, "complexity": "3"}
{"forwhile": "class\\nGFG \\n{ \\n\\nstatic\\nint\\nMAX_CHAR = \\n26\\n; \\n\\n\\n\\nstatic\\nboolean\\ncheck(\\nint\\nfreq[], \\nint\\nk) \\n{ \\n\\nint\\ni = \\n0\\n; \\nwhile(i < MAX_CHAR) \\n{ \\n\\nif\\n(freq[i] !=\\n0\\n&& freq[i] != k) \\n{ \\nreturn\\nfalse\\n; \\n} \\ni++; \\n} \\n\\nreturn\\ntrue\\n; \\n} \\n\\n\\n\\nstatic\\nint\\nsubstrings(String s, \\nint\\nk) \\n{ \\n\\nint\\nres = \\n0\\n; \\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile(i < s.length()) \\n{ \\n\\n\\n\\n\\n\\nint\\nfreq[] = \\nnew\\nint\\n[MAX_CHAR]; \\n\\n\\n\\nint\\nj = i; \\nwhile(j<s.length()) \\n{ \\n\\n\\n\\n\\nint\\nindex = s.charAt(j) - \\n'a'\\n; \\n\\nfreq[index]++; \\n\\n\\n\\n\\n\\n\\nif\\n(freq[index] > k) \\n{ \\nbreak\\n; \\n} \\n\\n\\n\\n\\nelse\\nif\\n(freq[index] == k && \\n\\ncheck(freq, k) == \\ntrue\\n) \\n{ \\nres++; \\n} \\nj++; \\n} \\n\\n} \\n\\nreturn\\nres; \\n} \\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n{ \\n\\nString s = \\n\"aabbcc\"\\n; \\n\\nint\\nk = \\n2\\n; \\n\\nSystem.out.println(substrings(s, k)); \\n\\n\\ns = \\n\"aabbc\"\\n; \\n\\nk = \\n2\\n; \\n\\nSystem.out.println(substrings(s, k)); \\n} \\n}", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n\n\nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n\n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n\n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n\n\n\n\n\n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n\n\n\n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n}", "index": 424, "complexity": "3"}
{"forwhile": "def checkEquality(s): \n    return (s[0] == s[len(s) - 1]) \n\ndef countSubstringWithEqualEnds(s): \n    result = 0 \n    n = len(s) \n    i = 0 \n    while i < n: \n        len = 1 \n        while len <= n-i: \n            if checkEquality(s[i:i + len]): \n                result += 1 \n            len += 1 \n        i += 1 \n    return result \n\n\ns = \"abcab\" \nprint(countSubstringWithEqualEnds(s)) ", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckEquality(String s) \n\n{ \n\nreturn\n(s.charAt(\n0\n) == s.charAt(s.length() - \n1\n)); \n\n} \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nlen = \n1\n; len <= n-i; len++) \n\n\n\n\n\n\nif\n(checkEquality(s.substring(i, i + len))) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 426, "complexity": "3"}
{"forwhile": "def countSubstringWithEqualEnds(s):\n    result = 0\n    n = len(s)\n    i = 0\n    while i < n:\n        j = i\n        while j < n:\n            if s[i] == s[j]:\n                result += 1\n            j += 1\n        i += 1\n    return result\n\n\ndef main(args):\n    s = 'abcab'\n    print(countSubstringWithEqualEnds(s))\n\nmain([])", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i; j < n; j++) \n\nif\n(s.charAt(i) == s.charAt(j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 427, "complexity": "3"}
{"forwhile": "class\nGFG { \n\n\n\n\n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n\n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n\n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nint\ni = rotation; \nwhile (i < rotation+length){ \n\nA[i-rotation]=tmp[i]; \n\ni++; \n} \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nint\ni = \n0\n; \nwhile ( i < n){ \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\ni++; \n} \n\n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n\n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n\n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 428, "complexity": "3"}
{"forwhile": "public class GFG { static final int MAX_CHAR = 26; static String getKey(String str) { boolean[] visited = new boolean[MAX_CHAR]; int j = 0; while (j < str.length()) { visited[str.charAt(j) - 'a'] = true; j++; } String key = \"\"; j = 0; while (j < MAX_CHAR) { if (visited[j]) key = key + (char)('a' + j); j++; } return key; } static void wordsWithSameCharSet(String words[], int n) { HashMap<String, ArrayList<Integer>> Hash = new HashMap<>(); int i = 0; while (i < n) { String key = getKey(words[i]); if (Hash.containsKey(key)) { ArrayList<Integer> get_al = Hash.get(key); get_al.add(i); Hash.put(key, get_al); } else { ArrayList<Integer> new_al = new ArrayList<>(); new_al.add(i); Hash.put(key, new_al); } i++; } for (Entry<String, ArrayList<Integer>> it : Hash.entrySet()) { ArrayList<Integer> get = it.getValue(); for (Integer v : get) System.out.print(words[v] + \", \"); System.out.println(); } } public static void main(String args[]) { String words[] = { \"may\", \"student\", \"students\", \"dog\", \"studentssess\", \"god\", \"cat\", \"act\", \"tab\", \"bat\", \"flow\", \"wolf\", \"lambs\", \"amy\", \"yam\", \"balms\",\"looped\",\"poodle\"}; int n = words.length; wordsWithSameCharSet(words, n); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\n\n\nstatic\nString getKey(String str) \n\n{ \n\nboolean\n[] visited = \nnew\nboolean\n[MAX_CHAR]; \n\nArrays.fill(visited, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str.length(); j++) \n\nvisited[str.charAt(j) - \n'a'\n] = \ntrue\n; \n\nString key = \n\"\"\n; \n\nfor\n(\nint\nj=\n0\n; j < MAX_CHAR; j++) \n\nif\n(visited[j]) \n\nkey = key + (\nchar\n)(\n'a'\n+j); \n\nreturn\nkey; \n\n} \n\n\n\n\nstatic\nvoid\nwordsWithSameCharSet(String words[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nHashMap<String, ArrayList<Integer>> Hash = \nnew\nHashMap<>(); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\nString key = getKey(words[i]); \n\n\n\n\n\n\n\n\nif\n(Hash.containsKey(key)) \n\n{ \n\nArrayList<Integer> get_al = Hash.get(key); \n\nget_al.add(i); \n\nHash.put(key, get_al); \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\nArrayList<Integer> new_al = \nnew\nArrayList<>(); \n\nnew_al.add(i); \n\nHash.put(key, new_al); \n\n} \n\n} \n\n\n\n\nfor\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \n\n{ \n\nArrayList<Integer> get =it.getValue(); \n\nfor\n(Integer v:get) \n\nSystem.out.print( words[v] + \n\", \"\n); \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString words[] = { \n\"may\"\n, \n\"student\"\n, \n\"students\"\n, \n\"dog\"\n, \n\n\"studentssess\"\n, \n\"god\"\n, \n\"cat\"\n, \n\"act\"\n, \n\"tab\"\n, \n\n\"bat\"\n, \n\"flow\"\n, \n\"wolf\"\n, \n\"lambs\"\n, \n\"amy\"\n, \n\"yam\"\n, \n\n\"balms\"\n, \n\"looped\"\n, \n\"poodle\"\n}; \n\nint\nn = words.length; \n\nwordsWithSameCharSet(words, n); \n\n} \n}", "index": 429, "complexity": "3"}
{"forwhile": "class CountSubString { int countSubStr( char str[], int n) { int res = 0; int i = 0; while(i<n) { if (str[i] == '1') { int j = i + 1; while (j < n) { if (str[j] == '1') res++; j++; } } i++; } return res; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str,n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n\n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n}", "index": 430, "complexity": "3"}
{"forwhile": "def printMinIndexChar(str, patt): \n    minIndex = float('inf') \n    m = len(str) \n    n = len(patt) \n    i = 0 \n    while i < n: \n        j = 0 \n        while j < m: \n            if patt[i] == str[j] and j < minIndex: \n                minIndex = j \n                break \n            j += 1 \n        i += 1 \n    if minIndex != float('inf'): \n        print('Minimum Index Character =', str[minIndex]) \n    else: \n        print('No character present') \n\n\n\n\nstr = 'geeksforgeeks' \n\npatt = 'set' \n\nprintMinIndexChar(str, patt)", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) { \n\n\n\n\n\n\n\n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\n} \n\n} \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 431, "complexity": "3"}
{"forwhile": "class Test { static int countPairs(String str) { int result = 0; int n = str.length(); int i = 0; while (i < n) { int j = i + 1; while (j < n) { if (Math.abs(str.charAt(i) - str.charAt(j)) == Math.abs(i - j)) result++; j++; } i++; } return result; } public static void main(String args[]) { String str = \"geeksforgeeks\"; System.out.println(countPairs(str)); } }", "src": "class\nTest { \n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n\n\n\n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 432, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def findSubsequenceCount(S, T): \n\n        m = len(T)\n        n = len(S)\n\n        if m > n: \n            return 0\n\n        mat = [[0 for x in range(n + 1)] for y in range(m + 1)]\n\n        i = 1\n        while i <= m: \n            mat[i][0] = 0\n            i += 1\n\n        j = 0\n        while j <= n: \n            mat[0][j] = 1\n            j += 1\n\n        i = 1\n        while i <= m: \n            j = 1\n            while j <= n: \n                if T[i - 1] != S[j - 1]: \n                    mat[i][j] = mat[i][j - 1]\n                else: \n                    mat[i][j] = mat[i][j - 1] + mat[i - 1][j - 1]\n                j += 1\n            i += 1\n\n        return mat[m][n]\n\n    @staticmethod\n    def main(args): \n\n        T = 'ge'\n        S = 'geeksforgeeks'\n        print(GFG.findSubsequenceCount(S, T))\n\nGFG.main([])", "src": "class\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n\n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n\n\n\n\n\n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n\n\n\n\n\n\n\n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\nmat[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n}", "index": 433, "complexity": "3"}
{"forwhile": "class\nGFG\n{\n\n\n\nstatic\nint\nbellNumber(\nint\nn)\n\n{\n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n];\n\nbell[\n0\n][\n0\n] = \n1\n;\n\n\nint\ni=\n1\n;\nwhile i<=n:\n\n{\n\n\n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n];\n\n\n\n\nint\nj=\n1\n;\nwhile j<=i:\n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n];\n\nj++;\n\n\ni++;\n\n}\n\n\nreturn\nbell[n][\n0\n];\n\n}\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args)\n\n{\n\nint\nn=\n0\n;\nwhile n<=\n5:\n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n));\n\nn++;\n\n}\n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n\n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n}", "index": 434, "complexity": "3"}
{"forwhile": "class GFG{\n\n\n\n\nstatic int catalanDP(\nint n) { \n\n\n\nint catalan[] = new int [n + 2]; \n\n\n\ncatalan[0] = 1; \n\ncatalan[1] = 1; \n\n\n\nint i = 2; \nwhile (i <= n) { \n\ncatalan[i] = 0; \n\nint j = 0; \nwhile (j < i) { \n\ncatalan[i] += catalan[j] * catalan[i - j - 1]; \n\nj++; \n} \n\ni++; \n} \n\n\n\nreturn catalan[n]; \n\n} \n\n\n\npublic static void main(String[] args) { \n\nint i = 0; \nwhile (i < 10) { \n\nSystem.out.print(catalanDP(i) + \" \"); \n\ni++; \n} \n\n} }", "src": "class\nGFG{ \n\n\n\n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n\n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n\n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ncatalan[n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n}", "index": 435, "complexity": "3"}
{"forwhile": "class BinomialCoefficient: \n\n\n\n@staticmethod \ndef binomialCoeff(n, k): \n\nC = [[0 for _ in range(k + 1)] for _ in range(n + 1)] \n\ni, j = 0, 0 \n\n\nwhile i <= n: \n\nj = 0 \n\nwhile j <= min(i, k): \n\nif j == 0 or j == i: \n\nC[i][j] = 1 \n\nelse: \n\nC[i][j] = C[i - 1][j - 1] + C[i - 1][j] \n\nj += 1 \n\ni += 1 \n\n\nreturn C[n][k] \n\n\n@staticmethod \ndef min(a, b): \n\nreturn a if a < b else b \n\n\n\n\n@staticmethod \ndef main(args): \n\nn, k = 5, 2 \n\nprint(\"Value of C({}, {}) is \".format(n, k) + str(binomialCoeff(n, k)))", "src": "class\nBinomialCoefficient \n{ \n\n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n\n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n\n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n\n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n}", "index": 436, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def permutationCoeff(n, k): \n        P = [[0 for i in range(k + 2)] for j in range(n + 2)] \n        i = 0 \n        while i <= n: \n            j = 0 \n            while j <= min(i, k): \n                if j == 0: \n                    P[i][j] = 1 \n                else: \n                    P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1]); \n                P[i][j + 1] = 0 \n                j += 1 \n            i += 1 \n        return P[n][k] \n\n    def main(): \n        n = 10 \n        k = 2 \n        print('Value of P(', n, ',', k, ') is ', GFG.permutationCoeff(n, k)) \n\nGFG.main() \n", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n\n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n\n\n\n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n\n\n\n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 437, "complexity": "3"}
{"forwhile": "class GFG: \n\n    MAX = 100 \n\n    @staticmethod \n    def getMaxGold(gold, m, n): \n\n        goldTable = [[0 for _ in range(n)] for _ in range(m)] \n\n        col = n-1 \n        while col >= 0: \n            row = 0 \n            while row < m: \n                right = 0 if col == n-1 else goldTable[row][col+1] \n                right_up = 0 if row == 0 or col == n-1 else goldTable[row-1][col+1] \n                right_down = 0 if row == m-1 or col == n-1 else goldTable[row+1][col+1] \n                goldTable[row][col] = gold[row][col] + max(right, max(right_up, right_down)) \n                row += 1 \n            col -= 1 \n\n        res = goldTable[0][0] \n        for i in range(1, m): \n            res = max(res, goldTable[i][0]) \n\n        return res \n\n    @staticmethod \n    def main(): \n        gold = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]] \n        m, n = 4, 4 \n        print(GFG.getMaxGold(gold, m, n)) \n\n\nGFG.main()", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n\n\n\n\n\n\n\n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n\n\n\n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n\n\n\n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n\n\n\n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n\n\n\n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n\n\n\n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n}", "index": 438, "complexity": "3"}
{"forwhile": "class GFG: \n\n\n    @staticmethod\n    def printArray(A, size): \n        i = 0\n        while i < size: \n            print(A[i], end= ' ')\n            i += 1\n        print()\n\n    @staticmethod\n    def merge(arr, l, m, r): \n        n1 = m - l + 1\n        n2 = r - m\n        \n        L = [0] * n1\n        R = [0] * n2\n        \n        i = 0\n        while i < n1: \n            L[i] = arr[l + i]\n            i += 1\n        \n        j = 0\n        while j < n2: \n            R[j] = arr[m + 1 + j]\n            j += 1\n        \n        i = 0\n        j = 0\n        k = l\n        \n        while i < n1 and L[i] < 0: \n            arr[k] = L[i]\n            k += 1\n            i += 1\n        \n        while j < n2 and R[j] < 0: \n            arr[k] = R[j]\n            k += 1\n            j += 1\n        \n        while i < n1: \n            arr[k] = L[i]\n            k += 1\n            i += 1\n        \n        while j < n2: \n            arr[k] = R[j]\n            k += 1\n            j += 1\n    \n    @staticmethod\n    def RearrangePosNeg(arr, l, r): \n        if l < r: \n            m = l + (r - l) // 2\n            GFG.RearrangePosNeg(arr, l, m)\n            GFG.RearrangePosNeg(arr, m + 1, r)\n            GFG.merge(arr, l, m, r)\n\n    @staticmethod\n    def main(args): \n        arr = [-12, 11, -13, -5, 6, -7, 5, -3, -6]\n        arr_size = len(arr)\n        GFG.RearrangePosNeg(arr, 0, arr_size - 1)\n        GFG.printArray(arr, arr_size)\n", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni, j, k; \n\nint\nn1 = m - l + \n1\n; \n\nint\nn2 = r - m; \n\n\n\n\nint\nL[] = \nnew\nint\n[n1]; \n\nint\nR[] = \nnew\nint\n[n2]; \n\n\n\n\nfor\n(i = \n0\n; i < n1; i++) \n\nL[i] = arr[l + i]; \n\nfor\n(j = \n0\n; j < n2; j++) \n\nR[j] = arr[m + \n1\n+ j]; \n\n\n\n\n\n\ni = \n0\n; \n\n\n\n\nj = \n0\n; \n\n\n\n\nk = l; \n\n\n\n\n\n\n\n\n\n\n\nwhile\n(i < n1 && L[i] < \n0\n) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2 && R[j] < \n0\n) \n\narr[k++] = R[j++]; \n\n\n\n\nwhile\n(i < n1) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2) \n\narr[k++] = R[j++]; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\nprintArray(arr, arr_size); \n\n} \n}", "index": 439, "complexity": "3"}
{"forwhile": "class GFG: \n    @staticmethod \n    def isSubsetSum(set, n, sum): \n        subset = [[False for _ in range(n+1)] for _ in range(sum+1)] \n        i = 0 \n        while i <= n: \n            subset[0][i] = True \n            i += 1 \n        i = 1 \n        while i <= sum: \n            subset[i][0] = False \n            i += 1 \n        i = 1 \n        while i <= sum: \n            j = 1 \n            while j <= n: \n                subset[i][j] = subset[i][j-1] \n                if i >= set[j-1]: \n                    subset[i][j] = subset[i][j] or subset[i - set[j-1]][j-1] \n                j += 1 \n            i += 1 \n        return subset[sum][n] \n    @staticmethod \n    def main(args): \n        set = [3, 34, 4, 12, 5, 2] \n        sum = 9 \n        n = len(set) \n        if GFG.isSubsetSum(set, n, sum) == True: \n            print(\"Found a subset with given sum\") \n        else: \n            print(\"No subset with given sum\")", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n\n\n\n\n\n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n}", "index": 440, "complexity": "3"}
{"forwhile": "class GFG: \n\n\t@staticmethod \n\tdef modularSum(arr, n, m): \n\t\tif n > m: \n\t\t\treturn True \n\t\tDP = [False] * m \n\t\ti = 0 \n\t\twhile i < n: \n\t\t\tif DP[0]: \n\t\t\t\treturn True \n\t\t\ttemp = [False] * m \n\t\t\tj = 0 \n\t\t\twhile j < m: \n\t\t\t\tif DP[j]: \n\t\t\t\t\tif not DP[(j + arr[i]) % m]: \n\t\t\t\t\t\ttemp[(j + arr[i]) % m] = True \n\t\t\t\tj += 1 \n\t\t\tj = 0 \n\t\t\twhile j < m: \n\t\t\t\tif temp[j]: \n\t\t\t\t\tDP[j] = True \n\t\t\t\tj += 1 \n\t\t\tDP[arr[i] % m] = True \n\t\t\ti += 1 \n\t\treturn DP[0] \n\n\t@staticmethod \n\tdef main(arr): \n\t\tn = len(arr) \n\t\tm = 5 \n\t\tif GFG.modularSum(arr, n, m): \n\t\t\tprint(\\", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nmodularSum(\nint\narr[], \n\nint\nn, \nint\nm) \n\n{ \n\nif\n(n > m) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\nboolean\nDP[]=\nnew\nboolean\n[m]; \n\n\nArrays.fill(DP, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(DP[\n0\n]) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\nboolean\ntemp[] = \nnew\nboolean\n[m]; \n\nArrays.fill(temp, \nfalse\n); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\n{ \n\n\n\n\n\n\nif\n(DP[j] == \ntrue\n) \n\n{ \n\nif\n(DP[(j + arr[i]) % m] == \nfalse\n) \n\n\n\n\n\n\ntemp[(j + arr[i]) % m] = \ntrue\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\nif\n(temp[j]) \n\nDP[j] = \ntrue\n; \n\n\n\n\n\n\n\n\n\nDP[arr[i] % m] = \ntrue\n; \n\n} \n\n\nreturn\nDP[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {\n1\n, \n7\n}; \n\nint\nn = arr.length; \n\nint\nm = \n5\n; \n\n\nif\n(modularSum(arr, n, m)) \n\nSystem.out.print(\n\"YES\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"NO\\n\"\n); \n\n} \n}", "index": 441, "complexity": "3"}
{"forwhile": "class GFG { static int largestSubset(int[] a, int n) { Arrays.sort(a); int[] dp = new int[n]; dp[n - 1] = 1; int i = n - 2; while (i >= 0) { int mxm = 0; int j = i + 1; while (j < n) { if (a[j] % a[i] == 0) { mxm = Math.max(mxm, dp[j]); } j++; } dp[i] = 1 + mxm; i--; } return Arrays.stream(dp).max().getAsInt(); } public static void main(String[] args) { int[] a = { 1, 3, 6, 13, 17, 18 }; int n = a.length; System.out.println(largestSubset(a, n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nlargestSubset(\nint\n[] a, \nint\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[n - \n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) { \n\n\n\n\n\n\n\n\nint\nmxm = \n0\n; \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) { \n\nif\n(a[j] % a[i] == \n0\n) { \n\nmxm = Math.max(mxm, dp[j]); \n\n} \n\n} \n\n\ndp[i] = \n1\n+ mxm; \n\n} \n\n\n\n\nreturn\nArrays.stream(dp).max().getAsInt(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] a = { \n1\n, \n3\n, \n6\n, \n13\n, \n17\n, \n18\n}; \n\nint\nn = a.length; \n\nSystem.out.println(largestSubset(a, n)); \n\n} \n}", "index": 442, "complexity": "3"}
{"forwhile": "class RodCutting { static int cutRod(int price[], int n) { int val[] = new int[n+1]; val[0] = 0; int i = 1; while (i <= n) { int max_val = Integer.MIN_VALUE; int j = 0; while (j < i) { max_val = Math.max(max_val, price[j] + val[i-j-1]); j++; } val[i] = max_val; i++; } return val[n]; } public static void main(String args[]) { int arr[] = new int[] {1, 5, 8, 9, 10, 17, 17, 20}; int size = arr.length; System.out.println(\"Maximum Obtainable Value is \" + cutRod(arr, size)); } }", "src": "class\nRodCutting \n{ \n\n\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i<=n; i++) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n}", "index": 443, "complexity": "3"}
{"forwhile": "class GFG: \n\nlookup = [[-1 for j in range(1000)] for k in range(1000)] \n\n@staticmethod \ndef countSeqUtil(n, dif): \n\nif abs(dif) > n: \nreturn 0 \n\nif n == 1 and dif == 0: \nreturn 2 \n\nif n == 1 and abs(dif) == 1: \nreturn 1 \n\nif lookup[n][n+dif] != -1: \nreturn lookup[n][n+dif] \n\nres = countSeqUtil(n-1, dif+1) + 2*countSeqUtil(n-1, dif) + countSeqUtil(n-1, dif-1) \nlookup[n][n+dif] = res \nreturn res \n\n@staticmethod \ndef countSeq(n): \n\nk = 0 \nwhile k < len(lookup): \nj = 0 \nwhile j < len(lookup): \nlookup[k][j] = -1 \nj += 1 \nk += 1 \n\nreturn countSeqUtil(n, 0) \n\n@staticmethod \ndef main(args): \n\nn = 2 \nprint('Count of sequences is ' + str(countSeq(2)))", "src": "class\nGFG { \n\n\n\nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n\n\n\nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n\n\n\n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n\n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n\n\n\n\n\n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n\n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n\n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n\n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n\n\n\n\nreturn\nlookup[n][n+dif] = res; \n} \n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n\n\n\n\n\n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n\n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n}", "index": 444, "complexity": "3"}
{"forwhile": "class Sequences {\n    static int getTotalNumberOfSequences(int m, int n) {\n        int[][] T = new int[m + 1][n + 1];\n        int i = 0;\n        while (i < m + 1) {\n            int j = 0;\n            while (j < n + 1) {\n                if (i == 0 || j == 0)\n                    T[i][j] = 0;\n                else if (i < j)\n                    T[i][j] = 0;\n                else if (j == 1)\n                    T[i][j] = i;\n                else\n                    T[i][j] = T[i - 1][j] + T[i / 2][j - 1];\n                j++;\n            }\n            i++;\n        }\n        return T[m][n];\n    }\n\n    public static void main(String[] args) {\n        int m = 10;\n        int n = 4;\n        System.out.println(\"Total number of possible sequences \" + getTotalNumberOfSequences(m, n));\n    }\n}", "src": "class\nSequences \n{ \n\n\n\n\n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n\n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n}", "index": 445, "complexity": "3"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nMaxSumBS(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\nint\\nmax_sum = Integer.MIN_VALUE; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\nint\\nMSIBS[] = \\nnew\\nint\\n[n]; \\n\\nint\\nMSDBS[] = \\nnew\\nint\\n[n]; \\n\\nint\\ni = 0; \\nwhile (i < n) { \\n\\nMSDBS[i] = arr[i]; \\n\\nMSIBS[i] = arr[i]; \\n\\ni++; \\n} \\n\\n\\n\\nint\\ni = 1; \\nwhile (i < n) \\n{ \\n\\nint\\nj = 0; \\nwhile (j < i) \\n{ \\n\\nif\\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \\n\\nMSIBS[i] = MSIBS[j] + arr[i]; \\n\\nj++; \\n} \\n\\ni++; \\n} \\n\\n\\n\\nint\\ni = n - 2; \\nwhile (i >= 0) \\n{ \\n\\nint\\nj = n - 1; \\nwhile (j > i) \\n{ \\n\\nif\\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \\n\\nMSDBS[i] = MSDBS[j] + arr[i]; \\n\\nj--; \\n} \\n\\ni--; \\n} \\n\\n\\n\\n\\nint\\ni = 0; \\nwhile (i < n) \\n{ \\n\\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \\n\\ni++; \\n} \\n\\n\\n\\n\\nreturn\\nmax_sum; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, \\n15\\n, \\n51\\n, \\n45\\n, \\n33\\n, \\n100\\n, \\n12\\n, \\n18\\n, \\n9\\n}; \\n\\nint\\nn = arr.length; \\n\\nSystem.out.println(\\n\\\"Maximum Sum : \\\"\\n+ MaxSumBS(arr, n)); \\n\\n} \\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n\n\n\n\nreturn\nmax_sum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n}", "index": 446, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod \n    def maxSumIS(arr, n): \n        i = 0 \n        j = 0 \n        max = 0 \n        msis = [0] * n \n\n        while i < n: \n            msis[i] = arr[i] \n            i += 1 \n\n        i = 1 \n        while i < n: \n            j = 0 \n            while j < i: \n                if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]: \n                    msis[i] = msis[j] + arr[i] \n                j += 1 \n            i += 1 \n\n        i = 0 \n        while i < n: \n            if max < msis[i]: \n                max = msis[i] \n            i += 1 \n\n        return max \n\n    @staticmethod \n    def main(args): \n        arr = [1, 101, 2, 3, 100, 4, 5] \n        n = len(arr) \n        print(\"Sum of maximum sum increasing subsequence is \" + str(GFG.maxSumIS(arr, n)))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 447, "complexity": "3"}
{"forwhile": "class GFG { static int lis(int[] arr, int n) { int[] mpis = new int[n]; int max = Integer.MIN_VALUE; int i = 0; while (i < n) { mpis[i] = arr[i]; i++; } i = 1; while (i < n) { int j = 0; while (j < i) { if (arr[i] > arr[j] && mpis[i] < (mpis[j] * arr[i])) { mpis[i] = mpis[j] * arr[i]; } j++; } i++; } int k = 0; for (; k < mpis.length; k++) { if (mpis[k] > max) { max = mpis[k]; } } return max; } static public void main(String[] args) { int[] arr = { 3, 100, 4, 5, 150, 6 }; int n = arr.length; System.out.println(lis(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n}", "index": 448, "complexity": "3"}
{"forwhile": "class GFG { static int longestSubseqWithDiffOne(int arr[], int n) { int dp[] = new int[n]; int i = 0; while (i < n) { dp[i] = 1; i++; } i = 1; while (i < n) { int j = 0; while (j < i) { if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) dp[i] = Math.max(dp[i], dp[j]+1); j++; } i++; } int result = 1; i = 0; while (i < n) { if (result < dp[i]) result = dp[i]; i++; } return result; } public static void main(String[] args) { int arr[] = {1, 2, 3, 4, 5, 3, 2}; int n = arr.length; System.out.println(longestSubseqWithDiffOne(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n\n\n\n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n}", "index": 449, "complexity": "3"}
{"forwhile": "class GFG { public static int maxLenSub(int arr[], int n) { int mls[] = new int[n], max = 0; int i = 0; while(i < n) { mls[i] = 1; i++; } i = 1; while(i < n) { int j = 0; while(j < i) { if(Math.abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) { mls[i] = mls[j] + 1; } j++; } i++; } i = 0; while(i < n) { if(max < mls[i]) { max = mls[i]; } i++; } return max; } public static void main(String[] args) { int arr[] = {2, 5, 6, 3, 7, 6, 5, 8}; int n = arr.length; System.out.println(\"Maximum length subsequence = \" + maxLenSub(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n}", "index": 450, "complexity": "3"}
{"forwhile": "class GFG { static int pre_compute( int a[], int n, int index, int k) { int dp[][] = new int[n][n]; int i = 0; while (i < n) { if (a[i] > a[0]) dp[0][i] = a[i] + a[0]; else dp[0][i] = a[i]; i++; } i = 1; while (i < n) { int j = 0; while (j < n) { if (a[j] > a[i] && j > i) { if (dp[i - 1][i] + a[j] > dp[i - 1][j]) dp[i][j] = dp[i - 1][i] + a[j]; else dp[i][j] = dp[i - 1][j]; } else dp[i][j] = dp[i - 1][j]; j++; } i++; } return dp[index][k]; } public static void main(String[] args) { int a[] = { 1, 101, 2, 3, 100, 4, 5}; int n = a.length; int index = 4, k = 6; System.out.println( pre_compute(a, n, index, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\npre_compute(\nint\na[], \nint\nn, \n\nint\nindex, \nint\nk) \n\n{ \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(a[i] > a[\n0\n]) \n\ndp[\n0\n][i] = a[i] + a[\n0\n]; \n\nelse\n\ndp[\n0\n][i] = a[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(a[j] > a[i] && j > i) \n\n{ \n\nif\n(dp[i - \n1\n][i] + a[j] > \n\ndp[i - \n1\n][j]) \n\ndp[i][j] = dp[i - \n1\n][i] \n\n+ a[j]; \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[index][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = a.length; \n\nint\nindex = \n4\n, k = \n6\n; \n\nSystem.out.println( \n\npre_compute(a, n, index, k)); \n\n} \n}", "index": 451, "complexity": "3"}
{"forwhile": "class Pair: \n\n    def __init__(self, a, b): \n        self.a = a \n        self.b = b \n\n    @staticmethod \n    def maxChainLength(arr, n): \n        i = 0 \n        j = 0 \n        max = 0 \n        mcl = [0] * n \n\n        i = 0 \n        while i < n: \n            mcl[i] = 1 \n            i += 1 \n\n        i = 1 \n        while i < n: \n            j = 0 \n            while j < i: \n                if arr[i].a > arr[j].b and mcl[i] < mcl[j] + 1: \n                    mcl[i] = mcl[j] + 1 \n                j += 1 \n            i += 1 \n\n        i = 0 \n        while i < n: \n            if max < mcl[i]: \n                max = mcl[i] \n            i += 1 \n\n        return max \n\n    @staticmethod \n    def main(args): \n        arr = [Pair(5, 24), Pair(15, 25), Pair(27, 40), Pair(50, 60)] \n        print(\"Length of maximum size chain is \" + str(Pair.maxChainLength(arr, len(arr))))", "src": "class\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n\n\n\n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n\n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n}", "index": 452, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintMaxSubSquare(\\nint\\nM[][]) \\n\\n{ \\n\\nint\\ni,j; \\n\\nint\\nR = M.length; \\n\\n\\nint\\nC = M[\\n0\\n].length; \\n\\n\\n\\nint\\nS[][] = \\nnew\\nint\\n[R][C]; \\n\\n\\n\\nint\\nmax_of_s, max_i, max_j; \\n\\n\\n\\n\\nint\\nindex1 = 0; \\n\\nwhile index1 < R: \\n\\nS[index1][\\n0\\n] = M[index1][\\n0\\n]; \\n\\nindex1 += 1; \\n\\n\\n\\n\\nint\\nindex2 = 0; \\n\\nwhile index2 < C: \\n\\nS[\\n0\\n][index2] = M[\\n0\\n][index2]; \\n\\nindex2 += 1; \\n\\n\\n\\n\\nint\\ni = \\n1\\n; \\n\\nwhile i < R: \\n\\n{ \\n\\nint\\nj = \\n1\\n; \\nwhile j < C: \\n\\n{ \\n\\nif\\n(M[i][j] == \\n1\\n): \\n\\nS[i][j] = Math.min(S[i][j-\\n1\\n], \\n\\nMath.min(S[i-\\n1\\n][j], S[i-\\n1\\n][j-\\n1\\n])) + \\n1\\n; \\n\\nelse\\n\\nS[i][j] = \\n0\\n; \\n\\n\\n\\n+j; \\n\\n} \\n\\n+i; \\n\\n} \\n\\n\\n\\n\\nmax_of_s = S[\\n0\\n][\\n0\\n]; max_i = \\n0\\n; max_j = \\n0\\n; \\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile i < R: \\n\\n{ \\n\\nint\\nj = \\n0\\n; \\nwhile j < C: \\n\\n{ \\n\\nif\\n(max_of_s < S[i][j]): \\n\\n{ \\n\\nmax_of_s = S[i][j]; \\n\\nmax_i = i; \\n\\nmax_j = j; \\n\\n} \\n\\n\\n\\n+j; \\n\\n} \\n\\n+i; \\n\\n} \\n\\n\\n\\n\\nSystem.out.println(\\n\\", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMaxSubSquare(\nint\nM[][]) \n\n{ \n\nint\ni,j; \n\nint\nR = M.length; \n\n\nint\nC = M[\n0\n].length; \n\n\nint\nS[][] = \nnew\nint\n[R][C]; \n\n\nint\nmax_of_s, max_i, max_j; \n\n\n\n\nfor\n(i = \n0\n; i < R; i++) \n\nS[i][\n0\n] = M[i][\n0\n]; \n\n\n\n\nfor\n(j = \n0\n; j < C; j++) \n\nS[\n0\n][j] = M[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i < R; i++) \n\n{ \n\nfor\n(j = \n1\n; j < C; j++) \n\n{ \n\nif\n(M[i][j] == \n1\n) \n\nS[i][j] = Math.min(S[i][j-\n1\n], \n\nMath.min(S[i-\n1\n][j], S[i-\n1\n][j-\n1\n])) + \n1\n; \n\nelse\n\nS[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nmax_of_s = S[\n0\n][\n0\n]; max_i = \n0\n; max_j = \n0\n; \n\nfor\n(i = \n0\n; i < R; i++) \n\n{ \n\nfor\n(j = \n0\n; j < C; j++) \n\n{ \n\nif\n(max_of_s < S[i][j]) \n\n{ \n\nmax_of_s = S[i][j]; \n\nmax_i = i; \n\nmax_j = j; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\"Maximum size sub-matrix is: \"\n); \n\nfor\n(i = max_i; i > max_i - max_of_s; i--) \n\n{ \n\nfor\n(j = max_j; j > max_j - max_of_s; j--) \n\n{ \n\nSystem.out.print(M[i][j] + \n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nM[][] = {{\n0\n, \n1\n, \n1\n, \n0\n, \n1\n}, \n\n{\n1\n, \n1\n, \n0\n, \n1\n, \n0\n}, \n\n{\n0\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n}}; \n\n\nprintMaxSubSquare(M); \n\n} \n\n}", "index": 453, "complexity": "3"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def maxCost(mat, N): \n\n        dp = [[0]*N for _ in range(N)] \n\n        dp[0][0] = mat[0][0] \n\n        i = 1 \n        while i < N: \n            dp[i][0] = mat[i][0] + dp[i-1][0] \n            i += 1 \n\n        i = 1 \n        while i < N: \n            j = 1 \n            while j < i+1 and j < N: \n                dp[i][j] = mat[i][j] + max(dp[i-1][j-1], dp[i-1][j]) \n                j += 1 \n            i += 1 \n\n        result = 0 \n        i = 0 \n        while i < N: \n            if result < dp[N-1][i]: \n                result = dp[N-1][i] \n            i += 1 \n\n        return result \n\n    @staticmethod\n    def main(args): \n\n        mat = [ [4, 1, 5, 6, 1], \n                [2, 9, 2, 11, 10], \n                [15, 1, 3, 15, 2], \n                [16, 92, 41, 4, 3], \n                [8, 142, 6, 4, 8] ] \n\n        N = 5 \n\n        print('Maximum Path Sum : ' + str(GFG.maxCost(mat, N)))", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n\n\n\n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n}", "index": 454, "complexity": "3"}
{"forwhile": "class GFG: \n    N = 4 \n    @staticmethod \n    def MaximumPath(Mat): \n        result = 0 \n        dp = [[0 for j in range(N + 2)] for i in range(N)] \n        i = 0 \n        while i < N: \n            dp[0][i + 1] = Mat[0][i] \n            i += 1 \n        i = 1 \n        while i < N: \n            j = 1 \n            while j <= N: \n                dp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i - 1][j + 1])) + Mat[i][j - 1] \n                j += 1 \n            i += 1 \n        i = 0 \n        while i <= N: \n            result = max(result, dp[N - 1][i]) \n            i += 1 \n        return result \n    @staticmethod \n    def main(arg): \n        Mat = [[4, 2, 3, 4], [2, 9, 1, 10], [15, 1, 3, 0], [16, 92, 41, 44]] \n        print(GFG.MaximumPath(Mat)) \n", "src": "class\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n\n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n\n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n}", "index": 455, "complexity": "3"}
{"forwhile": "class MinimumCostPath :\n\n    private static int min(int x, int y, int z) :\n\n        return (x if (x < y) else y if (y < z) else z)\n\n    private static int minCost(int[][] cost, int m, int n) :\n\n        int i = 0\n        int j = 0\n        int[][] tc = new int[m+1][n+1]\n\n        tc[0][0] = cost[0][0]\n\n        while i <= m :\n            i += 1\n            tc[i][0] = tc[i-1][0] + cost[i][0]\n\n        j = 1\n        while j <= n :\n            j += 1\n            tc[0][j] = tc[0][j-1] + cost[0][j]\n\n        i = 1\n        while i <= m :\n            i += 1\n            j = 1\n            while j <= n :\n                j += 1\n                tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\n\n        return tc[m][n]\n\n    public static void main(String args[]) :\n\n        int cost[][]= {{1, 2, 3}, {4, 8, 2}, {1, 5, 3}}\n\n        System.out.println(minCost(cost, 2, 2))\n", "src": "class\nMinimumCostPath \n{ \n\n\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n}", "index": 456, "complexity": "3"}
{"forwhile": "class GFG{ private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if (n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; i = 1; while (i < n) { jumps[i] = Integer.MAX_VALUE; j = 0; while (j < i) { if (i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } j++; } i++; } return jumps[n-1]; } public static void main(String[] args) { int arr[] = {1, 3, 6, 1, 0, 9}; System.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr,arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 457, "complexity": "3"}
{"forwhile": "class GFG : \n\n    MAX = 100\n    dp = [[-1 for _ in range(MAX)] for _ in range(MAX)] \n\n    @staticmethod\n    def countRemovals(a, i, j, k) : \n        if i >= j : \n            return 0\n        elif a[j] - a[i] <= k : \n            return 0\n        elif GFG.dp[i][j] != -1 : \n            return GFG.dp[i][j] \n        elif a[j] - a[i] > k : \n            GFG.dp[i][j] = 1 + min(GFG.countRemovals(a, i + 1, j, k), GFG.countRemovals(a, i, j - 1, k))\n        return GFG.dp[i][j] \n\n    @staticmethod\n    def removals(a, n, k) : \n        a.sort()\n        for rows in GFG.dp : \n            rows.fill(-1) \n        if n == 1 : \n            return 0\n        else : \n            return GFG.countRemovals(a, 0, n - 1, k) \n\n    @staticmethod\n    def main(args) : \n        a = [1, 3, 4, 9, 10, 11, 12, 17, 20] \n        n = len(a)\n        k = 4 \n        print(GFG.removals(a, n, k)) ", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX=\n100\n; \n\nstatic\nint\ndp[][]=\nnew\nint\n[MAX][MAX]; \n\n\n\n\n\n\nstatic\nint\ncountRemovals(\nint\na[], \nint\ni, \nint\nj, \nint\nk) \n\n{ \n\n\n\nif\n(i >= j) \n\nreturn\n0\n; \n\n\n\n\n\n\nelse\nif\n((a[j] - a[i]) <= k) \n\nreturn\n0\n; \n\n\n\n\nelse\nif\n(dp[i][j] != -\n1\n) \n\nreturn\ndp[i][j]; \n\n\n\n\nelse\nif\n((a[j] - a[i]) > k) { \n\n\n\n\n\n\n\n\ndp[i][j] = \n1\n+ Math.min(countRemovals(a, i + \n1\n, j, k), \n\ncountRemovals(a, i, j - \n1\n, k)); \n\n} \n\nreturn\ndp[i][j]; \n\n} \n\n\n\n\nstatic\nint\nremovals(\nint\na[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nfor\n(\nint\n[] rows:dp) \n\nArrays.fill(rows,-\n1\n); \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\nelse\n\nreturn\ncountRemovals(a, \n0\n, n - \n1\n, k); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n3\n, \n4\n, \n9\n, \n10\n, \n11\n, \n12\n, \n17\n, \n20\n}; \n\nint\nn = a.length; \n\nint\nk = \n4\n; \n\nSystem.out.print(removals(a, n, k)); \n\n} \n}", "index": 458, "complexity": "3"}
{"forwhile": "class\nEDIST \n{\n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n{\n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n}\n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n{\n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nint\ni=\n0\n; \nwhile i<=m \n{\n\nint\nj=\n0\n; \nwhile j<=n \n{\n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\n\nj++;\n} \n\ni++;\n} \n\n\nreturn\ndp[m][n]; \n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{\n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n} \n}", "src": "class\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}", "index": 459, "complexity": "3"}
{"forwhile": "public\\nclass\\nLongestCommonSubSequence \\n{ \\n\\n\\n\\nstatic\\nint\\nLCSubStr(\\nchar\\nX[], \\nchar\\nY[], \\nint\\nm, \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\n\\nint\\nLCStuff[][] = \\nnew\\nint\\n[m + \\n1\\n][n + \\n1\\n]; \\n\\nint\\nresult = \\n0\\n; \\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile (i <= m) \\n\\n{ \\n\\n\\n\\n\\n\\nint\\nj = \\n0\\n; \\nwhile (j <= n) \\n\\n{ \\n\\n\\n\\n\\n\\nif\\n(i == \\n0\\n|| j == \\n0\\n) \\n\\nLCStuff[i][j] = \\n0\\n; \\n\\nelse\\nif\\n(X[i - \\n1\\n] == Y[j - \\n1\\n]) \\n\\n{ \\n\\nLCStuff[i][j] = LCStuff[i - \\n1\\n][j - \\n1\\n] + \\n1\\n; \\n\\nresult = Integer.max(result, LCStuff[i][j]); \\n\\n} \\n\\nelse\\n\\nLCStuff[i][j] = \\n0\\n; \\n\\nj++; \\n\\n} \\n\\ni++; \\n\\n} \\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nString X = \\n\\\"OldSite:GeeksforGeeks.org\\\"\\n; \\n\\nString Y = \\n\\\"NewSite:GeeksQuiz.com\\\"\\n; \\n\\n\\nint\\nm = X.length(); \\n\\nint\\nn = Y.length(); \\n\\n\\nSystem.out.println(\\n\\\"Length of Longest Common Substring is \\\"\\n\\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \\n\\n} \\n}", "src": "public\nclass\nLongestCommonSubSequence \n{ \n\n\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n}", "index": 460, "complexity": "3"}
{"forwhile": "def LCSubStr(X, Y): \n    m = len(X) \n    n = len(Y) \n    result = 0 \n    len = [[0 for _ in range(n)] for _ in range(2)] \n    currRow = 0 \n    i = 0 \n    while i < m: \n        j = 0 \n        while j < n: \n            if i == 0 or j == 0: \n                len[currRow][j] = 0 \n            elif X[i - 1] == Y[j - 1]: \n                len[currRow][j] = len[1 - currRow][j - 1] + 1 \n                result = max(result, len[currRow][j]) \n            else: \n                len[currRow][j] = 0 \n            j += 1 \n        currRow = 1 - currRow \n        i += 1 \n    return result \ndef main(args): \n    X = 'GeeksforGeeks' \n    Y = 'GeeksQuiz' \n    print(LCSubStr(X, Y)) \nmain([]) \n", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n\n\n\n\nint\ncurrRow = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n}", "index": 461, "complexity": "3"}
{"forwhile": "class\nGFG \n{ \n\n\n\nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n\n\n\n\n\n\n\ni = 0\n\nwhile i < n: \n\n{ \n\n\n\n\n\nint\nleft = \n0\n, right = \n0\n; \n\nj = i - \n1\n\nwhile j >= \n0\n: \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]): \n\n++left; \n\nelse\n\nbreak\n; \n\nj -= 1\n\n} \n\n\n\nj = i + \n1\n\nwhile j < n: \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]): \n\n++right; \n\nelse\n\nbreak\n; \n\nj += 1\n\n} \n\n\n\n\n\n\n\n\nsum += Math.max(right, left) + \n1\n; \n\ni += 1\n\n} \n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\n\n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n}", "index": 462, "complexity": "3"}
{"forwhile": "class GFG :\\n\\n\\n\\n\\ndef printEqualSumSets(arr, n) :\\n\\n    i = 0\\n    currSum = 0\\n    sum = 0\\n\\n    while i < len(arr):\\n        sum += arr[i]\\n        i += 1\\n\\n    if sum & 1 == 1:\\n        print('-1')\\n        return\\n\\n    k = sum >> 1\\n\\n    dp = [[False for _ in range(k + 1)] for _ in range(n + 1)]\\n\\n    i = 1\\n    while i <= k:\\n        dp[0][i] = False\\n        i += 1\\n\\n    i = 0\\n    while i <= n:\\n        dp[i][0] = True\\n        i += 1\\n\\n    i = 1\\n    while i <= n:\\n        currSum = 1\\n        while currSum <= k:\\n            dp[i][currSum] = dp[i - 1][currSum]\\n            if arr[i - 1] <= currSum:\\n                dp[i][currSum] = dp[i][currSum] or dp[i - 1][currSum - arr[i - 1]]\\n            currSum += 1\\n        i += 1\\n\\n    set1 = []\\n    set2 = []\\n\\n    if not dp[n][k]:\\n        print('-1\\n')\\n        return\\n\\n    i = n\\n    currSum = k\\n    while i > 0 and currSum >= 0:\\n        if dp[i - 1][currSum]:\\n            i -= 1\\n            set2.append(arr[i])\\n        elif dp[i - 1][currSum - arr[i - 1]]:\\n            i -= 1\\n            currSum -= arr[i]\\n            set1.append(arr[i])\\n\\n    print('Set 1 elements: ', end='')\\n    i = 0\\n    while i < len(set1):\\n        print(set1[i], end=' ')\\n        i += 1\\n\\n    print('\\nSet 2 elements: ', end='')\\n    i = 0\\n    while i < len(set2):\\n        print(set2[i], end=' ')\\n        i += 1\\n\\n\\ndef main():\\n    arr = [5, 5, 1, 11]\\n    n = len(arr)\\n    printEqualSumSets(arr, n)\\n\\n\\nif __name__ == '__main__':\\n    main()", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n\n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n\n\n\n\n\n\n\n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\nint\nk = sum >> \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n\n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n\n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n\n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n\n\n\n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n\n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n}", "index": 463, "complexity": "3"}
{"forwhile": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\ni = \n0\n; \nwhile i < n: \n  lis[i] = \n1\n; \n  i += 1\n\n\n\n\ni = \n1\n; \nwhile i < n: \n  j = \n0\n; \n  while j < i: \n    \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n): \n      lis[i] = lis[j] + \n1\n; \n    j += 1\n  i += 1\n    \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\ni = \n0\n; \nwhile i < n: \n  lds[i] = \n1\n; \n  i += 1\n\n\n\ni = n-\n2\n; \nwhile i >= \n0\n: \n  j = n-\n1\n; \n  while j > i: \n    \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n): \n      lds[i] = lds[j] + \n1\n; \n    j -= 1\n  i -= 1\n    \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\ni = \n1\n; \nwhile i < n: \n  \n\nif\n(lis[i] + lds[i] - \n1\n> max): \n    max = lis[i] + lds[i] - \n1\n; \n  i += 1\n    \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "src": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "index": 464, "complexity": "3"}
{"forwhile": "class GFG { static int lps(String s) { int n = s.length(); int a[] = new int[n]; int i = n - 1; while (i >= 0) { int back_up = 0; int j = i; while (j < n) { if (j == i) a[j] = 1; else if (s.charAt(i) == s.charAt(j)) { int temp = a[j]; a[j] = back_up + 2; back_up = temp; } else { back_up = a[j]; a[j] = Math.max(a[j - 1], a[j]); } j++; } i--; } return a[n - 1]; } public static void main(String[] args) { String str = \"GEEKSFORGEEKS\"; System.out.println(lps(str)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nint\na[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n\n\n\n\n\n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n\n\n\n\n\n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n}", "index": 465, "complexity": "3"}
{"forwhile": "public class GFG { static int countPS(String str) { int N = str.length(); int[][] cps = new int[N+1][N+1]; int i = 0; while (i < N) { cps[i][i] = 1; i += 1; } int L = 2; while (L <= N) { i = 0; while (i < N) { int k = L + i - 1; if (k < N) { if (str.charAt(i) == str.charAt(k)) { cps[i][k] = cps[i][k-1] + cps[i+1][k] + 1; } else { cps[i][k] = cps[i][k-1] + cps[i+1][k] - cps[i+1][k-1]; } } i += 1; } L += 1; } return cps[0][N-1]; } public static void main(String args[]) { String str = \"abcb\"; System.out.println(\"Total palindromic \" + \"subsequence are : \" + countPS(str)); } }", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n\n\n\n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n\n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n}", "index": 466, "complexity": "3"}
{"forwhile": "public\\nclass\\nLongestPalinSubstring \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintSubStr(String str, \\nint\\nlow, \\nint\\nhigh) { \\n\\nSystem.out.println(str.substring(low, high + \\n1\\)); \\n\\n} \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nlongestPalSubstr(String str) { \\n\\nint\\nn = str.length(); \\n\\n\\n\\n\\n\\n\\nboolean\\ntable[][] = \\nnew\\nboolean\\n[n][n]; \\n\\n\\n\\nint\\nmaxLength = \\n1\\; \\n\\nint\\ni = \\n0\\; \\n\nwhile i < n:\\n\\ntable[i][i] = \\ntrue\\; \\n\\ni += 1\\; \\n\\nint\\nstart = \\n0\\; \\n\\nint\\ni = \\n0\\; \\n\nwhile i < n - \\n1\\:\\n\\nif\\n(str.charAt(i) == str.charAt(i + \\n1\\)) { \\n\\n\\ntable[i][i + \\n1\\] = \\ntrue\\; \\n\\nstart = i; \\n\\nmaxLength = \\n2\\; \\n\\n} \\n\ni += 1\\; \\n\\n\\n\\nk = \\n3\\; \\n\nwhile k <= n:\\n\\n\\n\\ni = \\n0\\; \\n\nwhile i < n - k + \\n1\\:\\n\\n\\n\\nj = i + k - \\n1\\; \\n\\n\\n\\n\\n\\n\\nif\\ntable[i + \\n1\\][j - \\n1\\] && str.charAt(i) == str.charAt(j) { \\n\\ntable[i][j] = \\ntrue\\; \\n\\nif\\nk > maxLength: \\n\\nstart = i; \\n\\nmaxLength = k; \\n} \\n\\n\\n\\n\\n} \\n\\n\\nk += 1\\; \\n\\n} \\n\\nSystem.out.print(\\n\"Longest palindrome substring is; \"\\); \\n\\nprintSubStr(str, start, start + maxLength - \\n1\\); \\n\\n\\nreturn\\nmaxLength; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) { \\n\\n\\nString str = \\n\"forgeeksskeegfor\"\\; \\n\\nSystem.out.println(\\n\"Length is: \"\\+ \\n\\nlongestPalSubstr(str)); \\n\\n} \\n}", "src": "public\nclass\nLongestPalinSubstring \n{ \n\n\n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n\n\n\n\n\n\n\n\n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n\n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n\n\n\n\nint\nj = i + k - \n1\n; \n\n\n\n\n\n\n\n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n}", "index": 467, "complexity": "3"}
{"forwhile": "class GFG {\n    static int CountPS(char str[], int n) {\n        int dp[][] = new int[n][n];\n        boolean P[][] = new boolean[n][n];\n        int i = 0;\n        while (i < n) {\n            P[i][i] = true;\n            i++;\n        }\n        i = 0;\n        while (i < n - 1) {\n            if (str[i] == str[i + 1]) {\n                P[i][i + 1] = true;\n                dp[i][i + 1] = 1;\n            }\n            i++;\n        }\n        int gap = 2;\n        while (gap < n) {\n            int i = 0;\n            while (i < n - gap) {\n                int j = gap + i;\n                if (str[i] == str[j] && P[i + 1][j - 1])\n                    P[i][j] = true;\n                if (P[i][j])\n                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j] + 1 - dp[i + 1][j - 1];\n                else\n                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];\n                i++;\n            }\n            gap++;\n        }\n        return dp[0][n - 1];\n    }\n    public static void main(String[] args) {\n        String str = \"abaab\";\n        System.out.println(CountPS(str.toCharArray(), str.length()));\n    }\n}", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n\n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n\n\nint\nj = gap + i; \n\n\n\n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n\n\n\n\n\n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n}", "index": 468, "complexity": "3"}
{"forwhile": "class GFG:  static void constructDp(int dp[][], String str) { int l = str.length(); int[][] isPalin = new int[l + 1][l + 1]; int i = 0; while (i <= l) { int j = 0; while (j <= l) { isPalin[i][j] = dp[i][j] = 0; j++; } i++; } i = l - 1; while (i >= 0) { isPalin[i][i] = 1; dp[i][i] = 1; int j = i + 1; while (j < l) { isPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + 1 > j - 1 || (isPalin[i + 1][j - 1]) != 0)) ? 1 : 0; dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + isPalin[i][j]; j++; } i--; } } static int countOfPalindromeInRange(int dp[][], int l, int r) { return dp[l][r]; } public static void main(String args[]) { int MAX = 50; String str = \"xyaabax\"; int dp[][] = new int[MAX][MAX]; constructDp(dp, str); int l = 3; int r = 5; System.out.println(countOfPalindromeInRange(dp, l, r)); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\n\n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n\n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n}", "index": 469, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nint\\nmaxAlternateSum(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\nif\\n(n == \\n1\\n) \\n\\nreturn\\narr[\\n0\\n]; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nint\\ndec[] = \\nnew\\nint\\n[n]; \\n\\n\\n\\n\\nint\\ninc[] = \\nnew\\nint\\n[n]; \\n\\n\\n\\n\\ndec[\\n0\\n] = inc[\\n0\\n] = arr[\\n0\\n]; \\n\\n\\nint\\nflag = \\n0\\n; \\n\\n\\nint\\ni=\\n1\\n;\\n while\\ni<n:\\n { \\n\\n\\n\\n\\nint\\nj=\\n0\\n;\\n while\\nj<i:\\n { \\n\\n\\n\\n\\n\\n\\n\\n\\nif\\n(arr[j] > arr[i]) \\n\\n{ \\n\\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \\n\\n\\n\\n\\nflag = \\n1\\n; \\n\\n} \\n\\n\\n\\n\\n\\nelse\\nif\\n(arr[j] < arr[i] && flag == \\n1\\n) \\n\\n\\n\\n\\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \\n\\n\\n} \\n\\ni += \\n1\\n; \\n} \\n\\n\\n\\nint\\nresult = Integer.MIN_VALUE; \\n\\n\\nint\\ni = \\n0\\n;\\n while\\ni < n:\\n { \\n\\nif\\n(result < inc[i]) \\n\\nresult = inc[i]; \\n\\nif\\n(result < dec[i]) \\n\\nresult = dec[i]; \\n\\ni += \\n1\\n; \\n} \\n\\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\narr[]= {\\n8\\n, \\n2\\n, \\n3\\n, \\n5\\n, \\n7\\n, \\n9\\n, \\n10\\n}; \\n\\nSystem.out.println(\\n\"Maximum sum = \"\\n+ \\n\\nmaxAlternateSum(arr , arr.length)); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n\n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n\n\n\n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n\n\n\n\nflag = \n1\n; \n\n} \n\n\n\n\n\n\n\n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n\n\n\n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n\n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n}", "index": 470, "complexity": "3"}
{"forwhile": "class GFG { static int zzis(int arr[], int n) { int las[][] = new int[n][2]; int i = 0; while (i < n) { las[i][0] = las[i][1] = 1; i++; } int res = 1; i = 1; while (i < n) { int j = 0; while (j < i) { if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) las[i][0] = las[j][1] + 1; if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) las[i][1] = las[j][0] + 1; j++; } if (res < Math.max(las[i][0], las[i][1])) res = Math.max(las[i][0], las[i][1]); i++; } return res; } public static void main(String[] args) { int arr[] = { 10, 22, 9, 33, 49, 50, 31, 60 }; int n = arr.length; System.out.println(\"Length of Longest \" + \"alternating subsequence is \" + zzis(arr, n)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n\n\n\n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n}", "index": 471, "complexity": "3"}
{"forwhile": "class GFG { static int search(int arr[], int x, int n) { int i = 0; while (i < n) { if (arr[i] == x) return i; i++; } return -1; } static void printPostOrder(int in1[], int pre[], int n) { int root = search(in1, pre[0], n); if (root != 0) { int i = 1; while (i < n) { i++; } printPostOrder(in1, Arrays.copyOfRange(pre, 1, n), root); } if (root != n - 1) { int i = 1; while (i + root < n) { i++; } printPostOrder(Arrays.copyOfRange(in1, root + 1, n), Arrays.copyOfRange(pre, 1 + root, n), n - root - 1); } System.out.print( pre[0] + \" \"); } public static void main(String args[]) { int in1[] = { 4, 2, 5, 1, 3, 6 }; int pre[] = { 1, 2, 4, 5, 3, 6 }; int n = in1.length; System.out.println(\"Postorder traversal \"); printPostOrder(in1, pre, n); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nx, \nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\nreturn\n-\n1\n; \n} \n\n\n\nstatic\nvoid\nprintPostOrder(\nint\nin1[], \n\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\nint\nroot = search(in1, pre[\n0\n], n); \n\n\n\n\n\n\nif\n(root != \n0\n) \n\nprintPostOrder(in1, Arrays.copyOfRange(pre, \n1\n, n), root); \n\n\n\n\n\n\nif\n(root != n - \n1\n) \n\nprintPostOrder(Arrays.copyOfRange(in1, root+\n1\n, n), \n\nArrays.copyOfRange(pre, \n1\n+root, n), n - root - \n1\n); \n\n\n\n\nSystem.out.print( pre[\n0\n] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nin1[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nn = in1.length; \n\nSystem.out.println(\n\"Postorder traversal \"\n); \n\nprintPostOrder(in1, pre, n); \n} \n}", "index": 472, "complexity": "3"}
{"forwhile": "class PrintPost:\n    preIndex = 0\n    \n    def printPost(self, inOrder, preOrder, inStrt, inEnd):\n        if inStrt > inEnd:\n            return\n        \n        inIndex = self.search(inOrder, inStrt, inEnd, preOrder[self.preIndex])\n        self.preIndex += 1\n        \n        self.printPost(inOrder, preOrder, inStrt, inIndex - 1)\n        self.printPost(inOrder, preOrder, inIndex + 1, inEnd)\n        print(inOrder[inIndex], end=' ')\n\n    def search(self, inOrder, startIn, endIn, data):\n        i = startIn\n        while i < endIn:\n            if inOrder[i] == data:\n                return i\n            i += 1\n        return i\n\ninOrder = [4, 2, 5, 1, 3, 6]\npreOrder = [1, 2, 4, 5, 3, 6]\nlenArr = len(inOrder)\n\ntree = PrintPost()\ntree.printPost(inOrder, preOrder, 0, lenArr - 1)", "src": "public\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n\n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n\n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n\n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n}", "index": 473, "complexity": "3"}
{"forwhile": "class Node:\n    def __init__(self, d):\n        self.data = d\n        self.left = self.right = None\n\nclass BinaryTree:\n    def printSpiral(self, node):\n        h = self.height(node)\n        i = 1\n        ltr = False\n        while i <= h:\n            self.printGivenLevel(node, i, ltr)\n            ltr = not ltr\n            i += 1\n\n    def height(self, node):\n        if node is None:\n            return 0\n        else:\n            lheight = self.height(node.left)\n            rheight = self.height(node.right)\n            if lheight > rheight:\n                return lheight + 1\n            else:\n                return rheight + 1\n\n    def printGivenLevel(self, node, level, ltr):\n        if node is None:\n            return\n        if level == 1:\n            print(node.data, end=' ')\n        elif level > 1:\n            if ltr is not False:\n                self.printGivenLevel(node.left, level - 1, ltr)\n                self.printGivenLevel(node.right, level - 1, ltr)\n            else:\n                self.printGivenLevel(node.right, level - 1, ltr)\n                self.printGivenLevel(node.left, level - 1, ltr)\n\nif __name__ == '__main__':\n    tree = BinaryTree()\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(7)\n    tree.root.left.right = Node(6)\n    tree.root.right.left = Node(5)\n    tree.root.right.right = Node(4)\n    print('Spiral order traversal of Binary Tree is')\n    tree.printSpiral(tree.root)", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 474, "complexity": "3"}
{"forwhile": "class Node: \n\n    def __init__(self, item): \n        self.data = item \n        self.left = None \n        self.right = None \n\n\nclass BinaryTree: \n\n    def reverseLevelOrder(self, node): \n        h = self.height(node) \n        i = h \n        while i >= 1: \n            self.printGivenLevel(node, i) \n            i -= 1 \n\n    def printGivenLevel(self, node, level): \n        if node is None: \n            return \n        if level == 1: \n            print(node.data, end=' ') \n        elif level > 1: \n            self.printGivenLevel(node.left, level - 1) \n            self.printGivenLevel(node.right, level - 1) \n\n    def height(self, node): \n        if node is None: \n            return 0 \n        else: \n            lheight = self.height(node.left) \n            rheight = self.height(node.right) \n            if lheight > rheight: \n                return lheight + 1 \n            else: \n                return rheight + 1 \n\n\ndef main(): \n    tree = BinaryTree() \n    tree.root = Node(1) \n    tree.root.left = Node(2) \n    tree.root.right = Node(3) \n    tree.root.left.left = Node(4) \n    tree.root.left.right = Node(5) \n    print(\"Level Order traversal of binary tree is : \") \n    tree.reverseLevelOrder(tree.root) \n\n\nif __name__ == '__main__': \n    main()", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n\n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n}", "index": 475, "complexity": "3"}
{"forwhile": "class Node: \n\n    def __init__(self, item): \n        self.data = item \n        self.left = None \n        self.right = None \n\n\nclass BinaryTree: \n    def __init__(self): \n        self.root = None \n        self.preIndex = 0 \n\n    def buildTree(self, in_order, pre_order, inStrt, inEnd): \n        if inStrt > inEnd: \n            return None \n\n        tNode = Node(pre_order[self.preIndex]) \n        self.preIndex += 1 \n\n        if inStrt == inEnd: \n            return tNode \n\n        inIndex = self.search(in_order, inStrt, inEnd, tNode.data) \n\n        tNode.left = self.buildTree(in_order, pre_order, inStrt, inIndex - 1) \n        tNode.right = self.buildTree(in_order, pre_order, inIndex + 1, inEnd) \n\n        return tNode \n\n    def search(self, arr, strt, end, value): \n        for i in range(strt, end + 1): \n            if arr[i] == value: \n                return i \n        return i \n\n    def printInorder(self, node): \n        if node is None: \n            return \n\n        self.printInorder(node.left) \n        print(node.data, end=' ') \n        self.printInorder(node.right) \n\n\ndef main(args): \n    tree = BinaryTree() \n    in_order = ['D', 'B', 'E', 'A', 'F', 'C'] \n    pre_order = ['A', 'B', 'D', 'E', 'C', 'F'] \n    length = len(in_order) \n    root = tree.buildTree(in_order, pre_order, 0, length - 1) \n\n    print('Inorder traversal of constructed tree is : ') \n    tree.printInorder(root) \n\nmain(None) \n", "src": "class\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex - \n1\n); \n\ntNode.right = buildTree(in, pre, inIndex + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n\n\n\n\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\ntree.printInorder(root); \n\n} \n}", "index": 476, "complexity": "3"}
{"forwhile": "class GFG { public static void ancestorMatrix(Node root , int matrix[][], int size) { if(root==null) return;ancestorMatrix(root.left, matrix, size);ancestorMatrix(root.right, matrix, size);if(root.left != null) { matrix[root.data][root.left.data] = 1;int i = 0;while(i < size) { if(matrix[root.left.data][i] == 1) matrix[root.data][i] = 1;i++; } }if(root.right != null) { matrix[root.data][root.right.data] = 1;int i = 0;while(i < size) { if(matrix[root.right.data][i] == 1) matrix[root.data][i] = 1;i++; } }}public static void main(String[] args) { Node tree_root = new Node(5);tree_root.left = new Node (1);tree_root.right = new Node(2);tree_root.left.left = new Node(0);tree_root.left.right = new Node(4);tree_root.right.left = new Node(3);int size = 6;int matrix [][] = new int[size][size];ancestorMatrix(tree_root, matrix, size);int i = 0;while(i < size) { int j = 0;while(j < size) { System.out.print(matrix[i][j]+\" \");j++; } System.out.println(); i++; }}static class Node { public int data ; public Node left ,right; public Node (int data) { this.data = data; this.left = this.right = null; }}} ", "src": "class\nGFG \n{ \n\n\n\npublic\nstatic\nvoid\nancestorMatrix(Node root , \n\nint\nmatrix[][],\nint\nsize) \n\n{ \n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nancestorMatrix(root.left, matrix, size); \n\n\n\n\nancestorMatrix(root.right, matrix, size); \n\n\n\n\n\n\n\nif\n(root.left != \nnull\n) \n\n{ \n\n\n\nmatrix[root.data][root.left.data] = \n1\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(matrix[root.left.data][i] == \n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n\nif\n(root.right != \nnull\n) \n\n{ \n\nmatrix[root.data][root.right.data] = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nif\n(matrix[root.right.data][i]==\n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nNode tree_root = \nnew\nNode(\n5\n); \n\ntree_root.left = \nnew\nNode (\n1\n); \n\ntree_root.right = \nnew\nNode(\n2\n); \n\ntree_root.left.left = \nnew\nNode(\n0\n); \n\ntree_root.left.right = \nnew\nNode(\n4\n); \n\ntree_root.right.left = \nnew\nNode(\n3\n); \n\n\n\n\nint\nsize = \n6\n; \n\nint\nmatrix [][] = \nnew\nint\n[size][size]; \n\n\nancestorMatrix(tree_root, matrix, size); \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < size; j++) \n\n{ \n\nSystem.out.print(matrix[i][j]+\n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode left ,right; \n\npublic\nNode (\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nthis\n.right = \nnull\n; \n\n} \n\n} \n}", "index": 477, "complexity": "3"}
{"forwhile": "class Node: \n    def __init__(self, item): \n        self.data = item \n        self.left = None \n        self.right = None \n\n\nclass BinaryTree: \n    def buildTree(self, inorder, start, end, node): \n        if start > end: \n            return None \n\n        i = self.max(inorder, start, end) \n\n        node = Node(inorder[i]) \n\n        if start == end: \n            return node \n\n        node.left = self.buildTree(inorder, start, i - 1, node.left) \n        node.right = self.buildTree(inorder, i + 1, end, node.right) \n\n        return node \n\n    def max(self, arr, strt, end): \n        maxval = arr[strt] \n        maxind = strt \n        i = strt + 1 \n        while i <= end: \n            if arr[i] > maxval: \n                maxval = arr[i] \n                maxind = i \n            i += 1 \n        return maxind \n\n    def printInorder(self, node): \n        if node is None: \n            return \n\n        self.printInorder(node.left) \n        print(node.data, end=' ') \n        self.printInorder(node.right) \n\n\nif __name__ == '__main__': \n    tree = BinaryTree() \n    inorder = [5, 10, 40, 30, 28] \n    len_inorder = len(inorder) \n    mynode = tree.buildTree(inorder, 0, len_inorder - 1, tree.root) \n    print('Inorder traversal of the constructed tree is ') \n    tree.printInorder(mynode) ", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n\n\nint\ni = max(inorder, start, end); \n\n\n\n\nnode = \nnew\nNode(inorder[i]); \n\n\n\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 478, "complexity": "3"}
{"forwhile": "class Node: \n\n    def __init__(self, data): \n        self.data = data \n        self.left = None \n        self.right = None \n\n\nclass Index: \n    def __init__(self): \n        self.index = 0 \n\n\nclass BinaryTree: \n\n    def buildUtil(self, _in, post, inStrt, inEnd, pIndex): \n        if inStrt > inEnd: \n            return None \n\n        node = Node(post[pIndex.index]) \n        pIndex.index -= 1 \n\n        if inStrt == inEnd: \n            return node \n\n        iIndex = self.search(_in, inStrt, inEnd, node.data) \n\n        node.right = self.buildUtil(_in, post, iIndex + 1, inEnd, pIndex) \n        node.left = self.buildUtil(_in, post, inStrt, iIndex - 1, pIndex) \n\n        return node \n\n    def buildTree(self, _in, post, n): \n        pIndex = Index() \n        pIndex.index = n - 1 \n        return self.buildUtil(_in, post, 0, n - 1, pIndex) \n\n    def search(self, arr, strt, end, value): \n        i = 0 \n        while i <= end: \n            if arr[i] == value: \n                break \n            i += 1 \n        return i \n\n    def preOrder(self, node): \n        if node is None: \n            return \n        print(node.data, end=' ') \n        self.preOrder(node.left) \n        self.preOrder(node.right) \n\n\ndef main(): \n    tree = BinaryTree() \n    _in = [4, 8, 2, 5, 1, 6, 3, 7] \n    post = [8, 4, 5, 2, 6, 7, 3, 1] \n    n = len(_in) \n    root = tree.buildTree(_in, post, n) \n    print('Preorder of the constructed tree : ', end='') \n    tree.preOrder(root) \n\n\nif __name__ == '__main__': \n    main() \n", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 479, "complexity": "3"}
{"forwhile": "class GfG: \n\n    preIndex = 0 \n\n    class Node: \n\n        def __init__(self): \n            self.data = None \n            self.left = None \n            self.right = None \n\n    @staticmethod \n    def newNode(data): \n        temp = GfG.Node() \n        temp.data = data \n        temp.left = None \n        temp.right = None \n        return temp \n\n    @staticmethod \n    def search(arr, strt, end, value): \n        i = strt \n        while i <= end: \n            if arr[i] == value: \n                return i \n            i += 1 \n        return -1 \n\n    @staticmethod \n    def buildTree(_in, pre, inStrt, inEnd): \n        if inStrt > inEnd: \n            return None \n\n        tNode = GfG.newNode(pre[GfG.preIndex]) \n\n        if inStrt == inEnd: \n            return tNode \n\n        inIndex = GfG.search(_in, inStrt, inEnd, tNode.data) \n\n        tNode.left = GfG.buildTree(_in, pre, inStrt, inIndex - 1) \n        tNode.right = GfG.buildTree(_in, pre, inIndex + 1, inEnd) \n\n        return tNode \n\n    @staticmethod \n    def checkPostorder(node, postOrder, index): \n        if node is None: \n            return index \n\n        index = GfG.checkPostorder(node.left,postOrder,index) \n        index = GfG.checkPostorder(node.right,postOrder,index) \n\n        if node.data == postOrder[index]: \n            index += 1 \n        else: \n            return -1 \n\n        return index \n\n    def main(self): \n\n        inOrder = [4, 2, 5, 1, 3] \n        preOrder = [1, 2, 4, 5, 3] \n        postOrder = [4, 5, 2, 3, 1] \n\n        _len = len(inOrder) \n\n        root = GfG.buildTree(inOrder, preOrder, 0, _len - 1) \n\n        _index = GfG.checkPostorder(root,postOrder, 0) \n\n        if _index == _len: \n            print('Yes') \n        else: \n            print('No') \n\nobj = GfG() \nobj.main()", "src": "class\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n\n\n\n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n\n\n\n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n\n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 483, "complexity": "3"}
{"forwhile": "class\nMST { \n\n\n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n\n\n\n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\ni = \n0\n\nwhile(i < V)\n\n{\n\nif\n(mstSet[i] == \nfalse\n&& key[i] < min) { \n\nmin = key[i]; \n\nmin_index = i; \n\n} \n\ni++ \n\n}\n\n\nreturn\nmin_index; \n\n} \n\n\n\n\n\n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n", "src": "class\nMST { \n\n\n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n\n\n\n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\n\n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n\n\n\n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n\n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n\n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n\n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n\n\nkey[\n0\n] = \n0\n; \n\n\n\n\nparent[\n0\n] = -\n1\n; \n\n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n\n\n\n\nint\nu = minKey(key, mstSet); \n\n\n\n\nmstSet[u] = \ntrue\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n\n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n\n\nt.primMST(graph); \n\n} \n}", "index": 484, "complexity": "3"}
{"forwhile": "class ShortestPath: \n    V = 9 \n\n    def minDistance(self, dist, sptSet): \n        min_val = float('inf') \n        min_index = -1 \n        v = 0 \n        while v < self.V: \n            if sptSet[v] == False and dist[v] <= min_val: \n                min_val = dist[v] \n                min_index = v \n            v += 1 \n        return min_index \n\n    def printSolution(self, dist, n): \n        print('Vertex Distance ') \n        i = 0 \n        while i < self.V: \n            print(str(i) + ' tt ' + str(dist[i])) \n            i += 1 \n\n    def dijkstra(self, graph, src): \n        dist = [float('inf')] * self.V \n        sptSet = [False] * self.V \n        i = 0 \n        while i < self.V: \n            dist[i] = float('inf') \n            sptSet[i] = False \n            i += 1 \n\n        dist[src] = 0 \n        count = 0 \n        while count < self.V - 1: \n            u = self.minDistance(dist, sptSet) \n            sptSet[u] = True \n            v = 0 \n            while v < self.V: \n                if not sptSet[v] and graph[u][v] != 0 and dist[u] != float('inf') and dist[u] + graph[u][v] < dist[v]: \n                    dist[v] = dist[u] + graph[u][v] \n                v += 1 \n            count += 1 \n\n        self.printSolution(dist, self.V) \n\n\ngraph = [ \n    [0, 4, 0, 0, 0, 0, 0, 8, 0], \n    [4, 0, 8, 0, 0, 0, 0, 11, 0], \n    [0, 8, 0, 7, 0, 4, 0, 0, 2], \n    [0, 0, 7, 0, 9, 14, 0, 0, 0], \n    [0, 0, 0, 9, 0, 10, 0, 0, 0], \n    [0, 0, 4, 14, 10, 0, 2, 0, 0], \n    [0, 0, 0, 0, 0, 2, 0, 1, 6], \n    [8, 11, 0, 0, 0, 0, 1, 0, 7], \n    [0, 0, 2, 0, 0, 0, 6, 7, 0] \n] \n\nsp = ShortestPath() \nsp.dijkstra(graph, 0)", "src": "class\nShortestPath \n{ \n\n\n\n\n\nstatic\nfinal\nint\nV=\n9\n; \n\nint\nminDistance(\nint\ndist[], Boolean sptSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index=-\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(sptSet[v] == \nfalse\n&& dist[v] <= min) \n\n{ \n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\nvoid\nprintSolution(\nint\ndist[], \nint\nn) \n\n{ \n\nSystem.out.println(\n\"Vertex Distance \"\n); \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\nSystem.out.println(i+\n\" tt \"\n+dist[i]); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndijkstra(\nint\ngraph[][], \nint\nsrc) \n\n{ \n\nint\ndist[] = \nnew\nint\n[V]; \n\n\n\n\n\n\n\n\n\nBoolean sptSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\n{ \n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = \nfalse\n; \n\n} \n\n\n\n\ndist[src] = \n0\n; \n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V-\n1\n; count++) \n\n{ \n\n\n\n\n\n\n\nint\nu = minDistance(dist, sptSet); \n\n\n\n\nsptSet[u] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(!sptSet[v] && graph[u][v]!=\n0\n&& \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\n} \n\n\n\n\nprintSolution(dist, V); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\nint\ngraph[][] = \nnew\nint\n[][]{{\n0\n, \n4\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n8\n, \n0\n}, \n\n{\n4\n, \n0\n, \n8\n, \n0\n, \n0\n, \n0\n, \n0\n, \n11\n, \n0\n}, \n\n{\n0\n, \n8\n, \n0\n, \n7\n, \n0\n, \n4\n, \n0\n, \n0\n, \n2\n}, \n\n{\n0\n, \n0\n, \n7\n, \n0\n, \n9\n, \n14\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n9\n, \n0\n, \n10\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n4\n, \n14\n, \n10\n, \n0\n, \n2\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n2\n, \n0\n, \n1\n, \n6\n}, \n\n{\n8\n, \n11\n, \n0\n, \n0\n, \n0\n, \n0\n, \n1\n, \n0\n, \n7\n}, \n\n{\n0\n, \n0\n, \n2\n, \n0\n, \n0\n, \n0\n, \n6\n, \n7\n, \n0\n} \n\n}; \n\nShortestPath t = \nnew\nShortestPath(); \n\nt.dijkstra(graph, \n0\n); \n\n} \n}", "index": 485, "complexity": "3"}
{"forwhile": "class GFG { static int maximumSum(int arr[], int n, int k) { int i = 1; while (i <= k) { int min = +2147483647; int index = -1; int j = 0; while (j < n) { if (arr[j] < min) { min = arr[j]; index = j; } j++; } if (min == 0) break; arr[index] = -arr[index]; i++; } int sum = 0; int i = 0; for (; i < n; i++) sum += arr[i]; return sum; } public static void main(String arg[]) { int arr[] = {-2, 0, 5, -1, 2}; int k = 4; int n = arr.length; System.out.print(maximumSum(arr, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nmaximumSum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nfor\n(\nint\ni = \n1\n; i <= k; i++) \n\n{ \n\nint\nmin = +\n2147483647\n; \n\nint\nindex = -\n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj=\n0\n; j<n; j++) \n\n{ \n\nif\n(arr[j] < min) \n\n{ \n\nmin = arr[j]; \n\nindex = j; \n\n} \n\n} \n\n\n\n\n\n\n\n\nif\n(min == \n0\n) \n\nbreak\n; \n\n\n\n\narr[index] = -arr[index]; \n\n} \n\n\n\n\nint\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\nreturn\nsum; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {-\n2\n, \n0\n, \n5\n, -\n1\n, \n2\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.print(maximumSum(arr, n, k)); \n\n} \n}", "index": 486, "complexity": "3"}
{"forwhile": "class GFG { \n\n\n\n\n\n\nstatic void minimizeWithKSwaps( int arr[], int n, int k) \n\n{ \n\nint i = 0; \nwhile(i < n-1 && k > 0) \n\n{ \n\n\n\n\n\n\nint pos = i; \n\nint j = i+1; \nwhile(j < n) \n\n{ \n\n\n\n\n\n\nif(j - i > k) \n\nbreak; \n\n\n\n\n\n\nif(arr[j] < arr[pos]) \n\npos = j; \n\nj++; \n} \n\n\n\n\n\n\nint temp; \n\nj = pos; \nwhile(j > i) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-1]; \n\narr[j-1]=temp; \n\nj--; \n} \n\n\n\n\n\n\nk -= pos-i; \n\ni++; \n} \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nint arr[] = { 7, 6, 9, 2, 1}; \n\nint n = arr.length; \n\nint k = 3; \n\n\nminimizeWithKSwaps(arr, n, k); \n\nint i=0; \nfor(; i<n; ++i) \n\nSystem.out.print(arr[i] + \" \"); \n\n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n\n\n\n\nif\n(j - i > k) \n\nbreak\n; \n\n\n\n\n\n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n\n\n\n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n\n\n\n\nk -= pos-i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n}", "index": 487, "complexity": "3"}
{"forwhile": "class GFG { static void SwapInts(int array[], int position1, int position2) { int temp = array[position1]; array[position1] = array[position2]; array[position2] = temp; } static void KSwapMaximum(int []arr, int n, int k) { int i = 0; while (i < n - 1 && k > 0) { int indexPosition = i; int j = i + 1; while (j < n) { if (k <= j - i) break; if (arr[j] > arr[indexPosition]) indexPosition = j; j++; } while (j > i) { SwapInts(arr, j, j - 1); j--; } k -= indexPosition - i; i++; } } public static void main(String args[]) { int []arr = { 3, 5, 4, 1, 2 }; int n = arr.length; int k = 3; KSwapMaximum(arr, n, k); int i = 0; while (i < n) { System.out.print(arr[i] + \" \"); i++; } } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\ntemp = array[position1]; \n\n\n\n\n\n\narray[position1] = array[position2]; \n\n\n\n\n\n\narray[position2] = temp; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n\n\n\n\n\n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n\n\n\n\n\n\n\n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n\n\n\n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 488, "complexity": "3"}
{"forwhile": "class Graph {\n\nprivate int V;\nprivate LinkedList<Integer> adj[];\n\nGraph(int v) {\nV = v;\nadj = new LinkedList[v];\nint i = 0;\nwhile (i < v) {\nadj[i] = new LinkedList();\ni++;\n}\n}\n\nvoid addEdge(int v, int w) {\nadj[v].add(w);\nadj[w].add(v);\n}\n\nvoid greedyColoring() {\nint result[] = new int[V];\nArrays.fill(result, -1);\nresult[0] = 0;\n\nboolean available[] = new boolean[V];\nArrays.fill(available, true);\nint u = 1;\nfor (; u < V; u++) {\nIterator<Integer> it = adj[u].iterator();\nwhile (it.hasNext()) {\nint i = it.next();\nif (result[i] != -1)\navailable[result[i]] = false;\n}\nint cr;\nint V = this.V;\nfor (cr = 0; cr < V; cr++) {\nif (available[cr])\nbreak;\n}\nresult[u] = cr;\nArrays.fill(available, true);\n} \n\nu = 0;\nfor (; u < V; u++)\nSystem.out.println(\"Vertex \" + u + \" ---> Color \" + result[u]);\n}\n\npublic static void main(String args[]) {\nGraph g1 = new Graph(5);\ng1.addEdge(0, 1);\ng1.addEdge(0, 2);\ng1.addEdge(1, 2);\ng1.addEdge(1, 3);\ng1.addEdge(2, 3);\ng1.addEdge(3, 4);\nSystem.out.println(\"Coloring of graph 1\");\ng1.greedyColoring();\n\nSystem.out.println();\nGraph g2 = new Graph(5);\ng2.addEdge(0, 1);\ng2.addEdge(0, 2);\ng2.addEdge(1, 2);\ng2.addEdge(1, 4);\ng2.addEdge(2, 4);\ng2.addEdge(4, 3);\nSystem.out.println(\"Coloring of graph 2 \");\ng2.greedyColoring();\n}\n}", "src": "class\nGraph \n{ \n\nprivate\nint\nV; \n\n\nprivate\nLinkedList<Integer> adj[]; \n\n\n\n\n\nGraph(\nint\nv) \n\n{ \n\nV = v; \n\nadj = \nnew\nLinkedList[v]; \n\nfor\n(\nint\ni=\n0\n; i<v; ++i) \n\nadj[i] = \nnew\nLinkedList(); \n\n} \n\n\n\n\nvoid\naddEdge(\nint\nv,\nint\nw) \n\n{ \n\nadj[v].add(w); \n\nadj[w].add(v); \n\n\n} \n\n\n\n\n\n\nvoid\ngreedyColoring() \n\n{ \n\nint\nresult[] = \nnew\nint\n[V]; \n\n\n\n\nArrays.fill(result, -\n1\n); \n\n\n\n\nresult[\n0\n] = \n0\n; \n\n\n\n\n\n\n\n\nboolean\navailable[] = \nnew\nboolean\n[V]; \n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n\n\n\nfor\n(\nint\nu = \n1\n; u < V; u++) \n\n{ \n\n\n\n\n\nIterator<Integer> it = adj[u].iterator() ; \n\nwhile\n(it.hasNext()) \n\n{ \n\nint\ni = it.next(); \n\nif\n(result[i] != -\n1\n) \n\navailable[result[i]] = \nfalse\n; \n\n} \n\n\n\n\nint\ncr; \n\nfor\n(cr = \n0\n; cr < V; cr++){ \n\nif\n(available[cr]) \n\nbreak\n; \n\n} \n\n\nresult[u] = cr; \n\n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n} \n\n\n\n\nfor\n(\nint\nu = \n0\n; u < V; u++) \n\nSystem.out.println(\n\"Vertex \"\n+ u + \n\" ---> Color \"\n\n+ result[u]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGraph g1 = \nnew\nGraph(\n5\n); \n\ng1.addEdge(\n0\n, \n1\n); \n\ng1.addEdge(\n0\n, \n2\n); \n\ng1.addEdge(\n1\n, \n2\n); \n\ng1.addEdge(\n1\n, \n3\n); \n\ng1.addEdge(\n2\n, \n3\n); \n\ng1.addEdge(\n3\n, \n4\n); \n\nSystem.out.println(\n\"Coloring of graph 1\"\n); \n\ng1.greedyColoring(); \n\n\nSystem.out.println(); \n\nGraph g2 = \nnew\nGraph(\n5\n); \n\ng2.addEdge(\n0\n, \n1\n); \n\ng2.addEdge(\n0\n, \n2\n); \n\ng2.addEdge(\n1\n, \n2\n); \n\ng2.addEdge(\n1\n, \n4\n); \n\ng2.addEdge(\n2\n, \n4\n); \n\ng2.addEdge(\n4\n, \n3\n); \n\nSystem.out.println(\n\"Coloring of graph 2 \"\n); \n\ng2.greedyColoring(); \n\n} \n}", "index": 489, "complexity": "3"}
{"forwhile": "class GFG {\nstatic final int N = 3;\nstatic int getMin(int arr[]) {\nint minInd = 0;\nint i = 1;\nwhile (i < N) {\nif (arr[i] < arr[minInd])\nminInd = i;\ni += 1;\n}\nreturn minInd;\n}\nstatic int getMax(int arr[]) {\nint maxInd = 0;\nint i = 1;\nwhile (i < N) {\nif (arr[i] > arr[maxInd])\nmaxInd = i;\ni += 1;\n}\nreturn maxInd;\n}\nstatic int minOf2(int x, int y) {\nreturn (x < y) ? x: y;\n}\nstatic void minCashFlowRec(int amount[]) {\nint mxCredit = getMax(amount), mxDebit = getMin(amount);\nif (amount[mxCredit] == 0 && amount[mxDebit] == 0)\nreturn;\nint min = minOf2(-amount[mxDebit], amount[mxCredit]);\namount[mxCredit] -= min;\namount[mxDebit] += min;\nSystem.out.println(\"Person \" + mxDebit + \" pays \" + min + \" to \" + \"Person \" + mxCredit);\nminCashFlowRec(amount);\n}\nstatic void minCashFlow(int graph[][]) {\nint amount[]=new int[N];\nint p = 0;\nwhile (p < N) {\nint i = 0;\nwhile (i < N) {\namount[p] += (graph[i][p] - graph[p][i]);\ni += 1;\n}\np += 1;\n}\nminCashFlowRec(amount);\n}\npublic static void main (String[] args) {\nint graph[][] = { {0, 1000, 2000}, {0, 0, 5000}, {0, 0, 0},};\nminCashFlow(graph);\n}\n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n\n\n\n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n\n\n\n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n\n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n\n\n\n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n\n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n\n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n\n\n\n\n\n\n\n\n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n\n\n\n\nint\namount[]=\nnew\nint\n[N]; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n\n\nminCashFlow(graph); \n\n} \n}", "index": 490, "complexity": "3"}
{"forwhile": "class Main :\n\nstatic void minAbsSumPair(int arr[], int arr_size) \n\n{\n\nint inv_count = 0;\n\nint l, r, min_sum, sum, min_l, min_r;\n\n\n\nif (arr_size < 2) \n\n{\n\nSystem.out.println(\"Invalid Input\");\n\nreturn;\n\n}\n\n\n\nmin_l = 0;\n\nmin_r = 1;\n\nmin_sum = arr[0] + arr[1];\n\n\nl = 0;\n\nwhile (l < arr_size - 1) \n\n{\n\nr = l+1;\n\nwhile (r < arr_size) \n\n{\n\nsum = arr[l] + arr[r];\n\nif (Math.abs(min_sum) > Math.abs(sum)) \n\n{\n\nmin_sum = sum;\n\nmin_l = l;\n\nmin_r = r;\n\n}\n\nr++;\n\n}\n\nl++;\n\n}\n\n\nSystem.out.println(\" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l]+ \" and \"+arr[min_r]);\n\n}\n\n\n\npublic static void main (String[] args) \n\n{\n\nint arr[] = {1, 60, -10, 70, -80, 85};\n\nminAbsSumPair(arr, 6);\n\n}", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 491, "complexity": "3"}
{"forwhile": "class GFG { static void printPrevSmaller(int[]arr, int n) { System.out.print( \", \"); int i = 1; while (i < n) { int j; j = i - 1; for (j = i - 1; j >= 0; j--) { if (arr[j] < arr[i]) { System.out.print(arr[j] + \", \"); break; } } if (j == -1) System.out.print( \", \") ; i += 1; } } public static void main (String[] args) { int[]arr = {1, 3, 0, 2, 5}; int n = arr.length; printPrevSmaller(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n\n\n\n\nSystem.out.print( \n\"_, \"\n); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n}", "index": 492, "complexity": "3"}
{"forwhile": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        int maxindex = 0;\n        int minindex = 0;\n        int max;\n        int min;\n        int i = 0;\n        while (i < arr.length) {\n            arr[i] = sc.nextInt();\n            i++;\n        }\n        int k = Integer.MAX_VALUE;\n        i = 0;\n        while (i < arr.length) {\n            int j = i;\n            while (j < arr.length) {\n                if (i != j) {\n                    int k1 = Math.min(arr[i], arr[j]) / Math.abs(i - j);\n                    if (k1 < k) {\n                        k = k1;\n                    }\n                }\n                j++;\n            }\n            i++;\n        }\n        System.out.println(k);\n    }\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "index": 493, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }", "index": 494, "complexity": "3"}
{"forwhile": "n = nextInt()\nm = nextInt()\nb = [0] * n\ng = [0] * m\ni = 0\nwhile i < n:\n    b[i] = nextInt()\n    i += 1\ni = 0\nwhile i < m:\n    g[i] = nextInt()\n    i += 1\ntotal = 0\nmax = 0\nmax2 = 0\ni = 0\nwhile i < n:\n    if b[i] > b[max]:\n        max2 = max\n        max = i\n    elif b[max2] < b[i]:\n        max2 = i\n    i += 1\ntotal += b[max] - b[max2]\ni = 0\nwhile i < n:\n    j = 0\n    while j < m:\n        if b[i] > g[j]:\n            System.out.println(-1)\n            return\n        if i != max:\n            total += b[i]\n        else:\n            total += g[j]\n        j += 1\n    i += 1\nSystem.out.println(total)", "src": "public class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "index": 495, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 496, "complexity": "3"}
{"forwhile": "n = int(input())\nk = int(input())\ns = input()\nwtArray = [0]*n\ni = 0\nwhile i < len(s):\n    wtArray[i] = ord(s[i]) - 96\n    i += 1\ni = 1\nwhile i < n:\n    j = 0\n    while j < n - i:\n        if wtArray[j] > wtArray[j+1]:\n            temp = wtArray[j+1]\n            wtArray[j+1] = wtArray[j]\n            wtArray[j] = temp\n        j += 1\nsum = wtArray[0]\nk -= 1\ntemp = sum\ni = 1\nfor token in range(n):\n    if k != 0 and wtArray[token] - temp > 1:\n        sum += wtArray[token]\n        k -= 1\n        temp = wtArray[token]\nif k != 0:\n    sum = -1\nprint(sum)", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 497, "complexity": "3"}
{"forwhile": "n = sc.nextInt()\nm = sc.nextInt()\nans = 0\na = [0]*101\ni = 0\nwhile i < m:\n    a[sc.nextInt()] += 1\n    i += 1\ni = 1\nwhile i <= 100:\n    y = 0\n    for x in a:\n        y += x // i\n    if y >= n:\n        ans = i\n    i += 1\npw.println(ans)\npw.close()", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 498, "complexity": "3"}
{"forwhile": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        int i = 0;\n        while (i < m) {\n            a[i] = in.nextInt();\n            i++;\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int j = 0; j < a.length; j++) {\n            Integer t = map.get(a[j]);\n            if (t == null) {\n                map.put(a[j], 1);\n            } else {\n                map.put(a[j], t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        for (Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator(); it.hasNext(); ) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int k = min; k <= max; k++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / k;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, k);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 499, "complexity": "3"}
{"forwhile": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tint i = 0;\n\t\twhile(i < b.length) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < b.length) {\n\t\t\tb[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia = 0;\n\t\tint ib = 0;\n\t\tfor(; ia < LEN && a[ia] == 0; ia++);\n\t\tfor(; ib < LEN && b[ib] == 0; ib++);\n\t\tif(ib == LEN){\n\t\t\tSystem.out.println(\\", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 500, "complexity": "3"}
{"forwhile": "from typing import List, Set\n\n\ndef set_size(a: List[int], N: int) -> int:\n    newset: Set[int] = set()\n    i = 0\n    for _ in range(N):\n        newset.add(a[i])\n        i += 1\n    v = len(newset)\n    return v\n\ndef main(args: List[str]):\n    N, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [0] * N\n    if set_size(a, N) < N:\n        print('0')\n        exit(0)\n    num = 0\n    for _ in range(4):\n        i = 0\n        while i < N:\n            if (a[i] & x) == a[i]:\n                i += 1\n                continue\n            else:\n                j = 0\n                while j < N:\n                    if i == j:\n                        b[i] = a[i] & x\n                    else:\n                        b[j] = a[j]\n                    j += 1\n                s = set_size(b, N)\n                if s < N:\n                    print(num)\n                    exit(0)\n            i += 1\n        i = 0\n        while i < N:\n            a[i] = b[i]\n            i += 1\n    print('-1')\n    exit(0)\n", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 501, "complexity": "3"}
{"forwhile": "n = int(input())\nx = int(input())\nstatus = -1\na = set()\nbitA = set()\nal = []\nbl = []\ni = 0\nwhile i < n:\n    v = int(input())\n    if v in a:\n        print(0)\n        break\n    a.add(v)\n    if v & x in bitA:\n        status = 2\n    al.append(v)\n    bl.append(v & x)\n    i += 1\n\nif any(v1 == v2 for v1 in al for v2 in bl if v1 == v2):\n    print(1)\nelse:\n    print(status)", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 502, "complexity": "3"}
{"forwhile": "class B:\n    @staticmethod\n    def main(args):\n        scanner = Scanner(System.in)\n        n = scanner.nextInt()\n        x = scanner.nextInt()\n        a = [0] * n\n        i = 0\n        while i < n:\n            a[i] = scanner.nextInt()\n            i += 1\n        Arrays.sort(a)\n        list = []\n        i = 0\n        while i < n:\n            list.append(a[i])\n            i += 1\n        i = 0\n        while i < n - 1:\n            if a[i] == a[i + 1]:\n                print(0)\n                return\n            i += 1\n        i = n - 1\n        for i in range(n - 1, 0, -1):\n            if (a[i] & x) == (a[i - 1] & x) and x not in list:\n                print(2)\n                return\n            elif x in list and a[i] > x and (a[i] & x) == x:\n                print(1)\n                return\n        print(-1)", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 503, "complexity": "3"}
{"forwhile": "n = int(in.nextLine())\nm = int(in.nextLine())\nv = [0]*n\nans = [0]*n\ns = 0\nt = 0\ni = 0\nwhile i < n:\n    v[i] = int(in.nextLine())\n    s += v[i]\n    i += 1\ni = 0\nwhile i < n-1:\n    j = i + 1\n    while j < n:\n        if v[j] > v[i]:\n            t = v[i]\n            v[i] = v[j]\n            v[j] = t\n        j += 1\n    i += 1\ni = 0\nwhile i < n-1:\n    if v[i] > v[i+1]:\n        ans[i] = v[i]-v[i+1]\n    if v[i] == v[i+1] and v[i] != 1:\n        ans[i] = 1\n        v[i+1] -= 1\n    if v[i] < v[i+1]:\n        ans[i] = 1\n        v[i+1] = v[i]-1\n        if v[i+1] == 0:\n            v[i+1] = 1\n    if v[i] == 0 or v[i] == 1:\n        ans[i] = 1\n        v[i] = 1\n    i += 1\nif v[n-1] > 1:\n    ans[n-1] = v[n-1]\nelse:\n    ans[n-1] = 1\ni = 0\nwhile i < n:\n    s -= ans[i]\n    i += 1\nSystem.out.print(s)", "src": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "index": 504, "complexity": "3"}
{"forwhile": "expon = [0]*n\ni = 0\nwhile i < n:\n    expon[i] = s.nextInt()\n    m = max(expon[i], m)\n    sum += expon[i]\n    i += 1\nlevels = set()\namount = 0\ni = 0\nwhile i < n:\n    currentHigh = expon[i]\n    for j in range(currentHigh, 0, -1):\n        if j not in levels:\n            levels.add(j)\n            amount += 1\n            break\n        if j == 1:\n            amount += 1\n    i += 1\nprint(sum - amount - (m - len(levels)))\n", "src": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "index": 505, "complexity": "3"}
{"forwhile": "class GFG { static int answerQuery( int a[], int n, int l, int r) { int count = 0; l = l - 1; int i = l; while (i < r) { int element = a[i]; int divisors = 0; int j = l; while (j < r) { if (a[j] % a[i] == 0) divisors++; else break; j++; } if(divisors == (r - l)) count++; i++; } return count; } public static void main (String[] args) { int a[] = { 1, 2, 3, 5 }; int n = a.length; int l = 1, r = 4; System.out.println( answerQuery(a, n, l, r)); l = 2; r = 4; System.out.println( answerQuery(a, n, l, r)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nanswerQuery(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n{ \n\n\n\nint\ncount = \n0\n; \n\n\n\n\nl = l - \n1\n; \n\n\n\n\nfor\n(\nint\ni = l; i < r; i++) \n\n{ \n\nint\nelement = a[i]; \n\nint\ndivisors = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = l; j < r; j++) \n\n{ \n\n\n\nif\n(a[j] % a[i] == \n0\n) \n\ndivisors++; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nif\n(divisors == (r - l)) \n\ncount++; \n\n} \n\n\n\n\nreturn\ncount; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = { \n1\n, \n2\n, \n3\n, \n5\n}; \n\nint\nn = a.length; \n\n\nint\nl = \n1\n, r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n\n\nl = \n2\n; r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n} \n}", "index": 506, "complexity": "3"}
{"forwhile": "from java.io import BufferedReader, InputStreamReader\nfrom java.util import StringTokenizer\nfrom java.io import IOException\nimport Arrays\n\nclass Interval:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nclass FastReader:\n    def __init__(self):\n        self.br = BufferedReader(InputStreamReader(System.in))\n        self.st = None\n    \n    def next(self):\n        while self.st == None or not self.st.hasMoreElements():\n            try:\n                self.st = StringTokenizer(self.br.readLine())\n            except IOException as e:\n                e.printStackTrace()\n        return self.st.nextToken()\n        \n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return Long.parseLong(self.next())\n\n    def nextDouble(self):\n        return Double.parseDouble(self.next())\n\n    def nextLine(self):\n        str = ''\n        try:\n            str = self.br.readLine()\n        except IOException as e:\n            e.printStackTrace()\n        return str\n\nmod = 1000000007\n\nif __name__=='__main__':\n    in_ = FastReader()\n    intervals = in_.nextInt()\n    x = in_.nextInt()\n    y = in_.nextInt()\n    ints = [None]*int(intervals)\n    i = 0\n    while i < intervals:\n        ints[i] = Interval(in_.nextInt(), in_.nextInt())\n        i+=1\n    Arrays.sort(ints, lambda a, b: a.start - b.start)\n    count = 0\n    i = 0\n    while i < len(ints):\n        if i >= 0 and ints[i] != None:\n            cur1 = ints[i]\n            j = i + 1\n            while j < len(ints):\n                if ints[j] != None:\n                    cur2 = ints[j]\n                    if y * (cur2.start - cur1.end) < x:\n                        if cur1.start != cur2.start and cur1.end < cur2.start:\n                            cur1.end = cur2.end\n                            ints[j] = None\n                    else:\n                        break\n                j+=1\n            count = (count + x) % mod\n            count += (y * (cur1.end - cur1.start) % mod)\n            count %= mod\n        i+=1\n    print(count)", "src": "public class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\n\n\n\n\n\n\n\t\tSystem.out.println(count);\n\t}\n\n}", "index": 507, "complexity": "3"}
{"forwhile": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft {\n    static class Resident{\n        Integer index;\n        Integer type;\n        Integer requests;\n\n        public Resident(int index, int type) {\n            this.index = index;\n            this.type = type;\n            this.requests = 0;\n        }\n\n        @Override\n        public String toString() {\n            if(type == 0) {\n                return \"Rider at index : \" + index;\n            }\n            else {\n                return \"Driver at index : \" + index + \", Requests: \" + requests;\n            }\n        }\n    }\n\n    static ArrayList<Resident> residents;\n    static ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner reader = new Scanner(System.in);\n        int n = reader.nextInt();\n        int m = reader.nextInt();\n        int length = n + m;\n\n        int [] coordinates = new int[length];\n        int [] types = new int[length];\n        residents = new ArrayList<>();\n        drivers_indexes = new ArrayList<>();\n\n        int i = 0;\n        while (i < length) {\n            coordinates[i] = reader.nextInt();\n            i++;\n        }\n\n        i = 0;\n        while (i < length) {\n            types[i] = reader.nextInt();\n            if(types[i] == 1)\n                drivers_indexes.add(i);\n            residents.add(new Resident(i, types[i]));\n            i++;\n        }\n        reader.close();\n\n        i = 0;\n        while (i < length) {\n            Resident current = residents.get(i);\n            if(current.type == 0) {\n                int left = i-1, right = i+1;\n                \n                for (; left >= 0 || right < length;) {\n                    if(left >= 0 && residents.get(left).type == 1) {\n                        residents.get(left).requests++;\n                        break;\n                    }\n                    else if(right < length && residents.get(right).type == 1) {\n                        residents.get(right).requests++;\n                        break;\n                    }\n\n                    left--;\n                    right++;\n                }\n            }\n            i++;\n        }\n\n        for (int index : drivers_indexes) {\n            System.out.print(residents.get(index).requests + \" \");\n        }\n    }\n}", "src": "public class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t\n\t\tInteger type;\t\t\t\n\t\tInteger requests;\t\t\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}", "index": 508, "complexity": "3"}
{"forwhile": "class Lyft: \n    scan = FastScanner(System.in) \n    pr = PrintWriter(System.out) \n    n, m, taxistNumber, noTaxistNumber = 0 \n    peoples = [] \n    taxist = [] \n    noTaxist = [] \n    def main(args): \n        n = scan.nextInt() \n        m = scan.nextInt() \n        peoples = [people(scan.nextInt()) for i in range(n + m)] \n        noTaxist = [people(0) for i in range(n)] \n        taxist = [people(0) for i in range(m)] \n        i = 0 \n        while i < len(peoples): \n            peoples[i] = people(scan.nextInt()) \n            i += 1 \n        for i in range(len(peoples)): \n            person = peoples[i] \n            if scan.nextInt() == 1: \n                person.taxi = True \n                person.passangers = 0 \n                taxist[taxistNumber] = person \n                taxistNumber += 1 \n            else: \n                noTaxist[noTaxistNumber] = person \n                noTaxistNumber += 1 \n        i = 0 \n        while i < len(noTaxist): \n            person = noTaxist[i] \n            for j in range(len(taxist)): \n                ii = taxist[j] \n                if ii.taxi: \n                    if person.nearestTaxist is None: \n                        person.nearestTaxist = ii \n                        ii.passangers += 1 \n                    elif person.coord - person.nearestTaxist.coord > ii.coord - person.coord: \n                        person.nearestTaxist.passangers -= 1 \n                        person.nearestTaxist = ii \n                        person.nearestTaxist.passangers += 1 \n            i += 1 \n        for i in range(len(taxist)): \n            pr.print(taxist[i].passangers + ' ') \n        pr.close() \n\n\nclass FastScanner: \n    bufferSize = 64 * 1024 \n    reader = None \n    tokenizer = None \n    def __init__(self, inputStream): \n        self.reader = BufferedReader(InputStreamReader(inputStream), self.bufferSize) \n    def nextToken(): \n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens(): \n            line = self.reader.readLine() \n            if line is None: \n                self.tokenizer = None \n                return None \n            self.tokenizer = StringTokenizer(line) \n        return self.tokenizer.nextToken() \n    def readIntArray(self, n): \n        a = [] \n        i = 0 \n        while i < n: \n            a.append(self.nextInt()) \n            i += 1 \n        return a \n    def readLongArray(self, n): \n        a = [] \n        i = 0 \n        while i < n: \n            a.append(self.nextLong()) \n            i += 1 \n        return a \n    def nextInt(): \n        return int(self.nextToken()) \n    def nextLong(): \n        return int(self.nextToken()) \n    def nextDouble(): \n        return float(self.nextToken()) \n    def nextLine(): \n        self.tokenizer = None \n        return self.reader.readLine() \n\nclass people: \n    coord = 0 \n    taxi = False \n    nearestTaxist = None \n    passangers = -1 \n    def __init__(self, coord): \n        self.coord = coord", "src": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for(int i = 0; i < peoples.length; i++){\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples){\n            if(scan.nextInt() == 1){\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist){\n                for (people ii: taxist){\n                    if(ii.taxi){\n                       if(i.nearestTaxist == null){\n                           i.nearestTaxist = ii;\n                           ii.passangers++;\n                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){\n                           i.nearestTaxist.passangers--;\n                           i.nearestTaxist = ii;\n                           i.nearestTaxist.passangers++;\n                       }\n                    }\n                }\n        }\n        for (people i : taxist){\n                pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}", "index": 509, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}", "index": 510, "complexity": "3"}
{"forwhile": "import java.io.BufferedInputStream;\nimport java.util.Scanner;\n\nclass RookHome {\n    static long MAX = 1_000_000_000;\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(new BufferedInputStream(System.in));\n        int n = s.nextInt();\n        int m = s.nextInt();\n        long[] vert = new long[n + 2];\n        vert[0] = 1;\n        int i = 1;\n        while (i <= n) {\n            vert[i] = s.nextLong();\n            i++;\n        }\n        vert[n + 1] = MAX;\n        long[][] hor = new long[m][2];\n        int i = 0;\n        while (i < m) {\n            hor[i][0] = s.nextLong();\n            hor[i][1] = s.nextLong();\n            s.nextLong();\n            i++;\n        }\n        long min = Long.MAX_VALUE;\n        int count;\n        for (int i = 0; i < vert.length - 1; i++) {\n            count = 0;\n            for (int j = 0; j < m; j++) {\n                if (hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n                    count++;\n                }\n            }\n            min = Math.min(min, i + count);\n        }\n        System.out.println(min);\n    }\n}", "src": "public class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 511, "complexity": "3"}
{"forwhile": "class Main: \n    n, m = 0, 0\n    vert, group = [], []\n    horiz = []\n    @staticmethod\n    def ok(a, b, g): \n        start, end = 0, 0\n        if g == 0: \n            start = 1\n            end = vert.__len__() > 0 and vert[0] or 10 ** 9\n        elif g == len(group) - 1: \n            start = vert[g - 1]\n            end = 10 ** 9\n        else: \n            start = vert[g - 1]\n            end = vert[g]\n        return a <= start and b >= end \n    @staticmethod\n    def main(args): \n        global n, m, vert, group, horiz\n        n = int(input())\n        m = int(input())\n        vert = []\n        i = 0\n        while i < n: \n            vert.append(int(input())) \n            i += 1\n        horiz = []\n        i = 0\n        while i < m: \n            horiz.append([int(input()), int(input()), int(input())]) \n            i += 1\n        group = [0] * (n + 1)\n        i = 0\n        while i < m: \n            a = horiz[i][0]\n            b = horiz[i][1]\n            j = 0\n            while j < len(group): \n                if Main.ok(a, b, j): \n                    group[j] += 1 \n                j += 1\n            i += 1\n        min_val = 2147483647\n        i = 0\n        while i < len(group): \n            min_val = min(min_val, group[i] + i) \n            i += 1\n        print(min_val)", "src": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "index": 512, "complexity": "3"}
{"forwhile": "m = sc.nextInt()\nk = sc.nextLong()\np=[0]*m\ni = 0\nwhile i < m:\n    p[i]=sc.nextDouble()\n    i += 1\n\nc=0\nused=0\ni = 0\nwhile i < m:\n    low=(long)((Math.floor(p[i]/k)*k)-i)+1\n    high=low+k\n    j=i\n    while j < m:\n        if p[j]>=low and p[i]<=high:\n            i += 1\n        j += 1\n    c += 1\n\nprint(c)", "src": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "index": 513, "complexity": "3"}
{"forwhile": "public final class CF_573_D1_A {\n\n\n    static boolean verb=true;\n    static void log(Object X){if (verb) System.err.println(X);}\n    static void log(Object[] X){if (verb) {Object U; while((U = X[i]) != null) System.err.print(U+\" \");System.err.println(\"\");}}\n    static void log(int[] X){if (verb) {int U; while((U = X[i]) != null) System.err.print(U+\" \");System.err.println(\"\");}}\n    static void log(int[] X,int L){if (verb) {int i=0; while(i < L) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n    static void log(long[] X){if (verb) {long U; while((U = X[i]) != null) System.err.print(U+\" \");System.err.println(\"\");}}\n\n    static void logWln(Object X){if (verb) System.err.print(X);}\n    static void info(Object o){    System.out.println(o);}\n    static void output(Object o){outputWln(\"\"+o+\"\\n\");    }\n    static void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n    \n    static long mod=998244353 ; \n    static int CX=64;\n\n\n    \n    static BufferedWriter out;\n    static InputReader reader;\n\n\n    \n\n    static void process() throws Exception {\n\n        Locale.setDefault(Locale.US);\n        out = new BufferedWriter(new OutputStreamWriter(System.out));\n        reader = new InputReader(System.in);\n\n        long n=reader.readLong();\n        int m=reader.readInt();\n        \n        long k=reader.readLong();\n        long[] p=new long[m];\n        int i=0; while(i < m){\n            p[i]=reader.readLong()-1;\ni++;}\n        \n        int pid=-1;\n        int rem=m;\n        int win=0; \n        long mx=k-1; \n        int res=0;\n        int idx=0;\n        \n        while (rem>0) {\n            \n            int i=idx; while (p[i]>mx) {\n                mx+=k;\n                if (mx>=n-1)\n                    mx=n-1;\n                \n            }\n        \n            int nxt=idx;\n            while(nxt+1<m && p[nxt+1]<=mx){\n                nxt++;}\n            \n            int nb=nxt-idx+1;\n            rem-=nb;\n            mx+=nb;\n            idx=nxt+1;\n            res++;\n        }\n        output(res);\n\n    \n        try {\n            out.close();\n        } catch (Exception E) {\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        process();\n\n    }\n\n    static final class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() throws IOException {\n            if (curChar >= numChars) {\n            curChar = 0;\n            numChars = stream.read(buf);\n            if (numChars <= 0) {\n                return -1;\n            }\n            }\n            return buf[curChar++];\n        }\n\n        public final String readString() throws IOException {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n            res.append((char) c);\n            c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public final int readInt() throws IOException {\n            int c = read();\n            boolean neg = false;\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            char d = (char) c;\n            \n            if (d == \\'-\\') {\n            neg = true;\n            c = read();\n            }\n            int res = 0;\n            do {\n            res *= 10;\n            res += c - \\'0\\';\n            c = read();\n            } while (!isSpaceChar(c));\n            \n            if (neg)\n            return -res;\n            return res;\n\n        }\n\n        public final long readLong() throws IOException {\n            int c = read();\n            boolean neg = false;\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            char d = (char) c;\n            \n            if (d == \\'-\\') {\n            neg = true;\n            c = read();\n            }\n            long res = 0;\n            do {\n            res *= 10;\n            res += c - \\'0\\';\n            c = read();\n            } while (!isSpaceChar(c));\n            \n            if (neg)\n            return -res;\n            return res;\n\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == \\' \\' || c == \\'\\n\\' || c == \\'\\r\\' || c == \\'\\t\\' || c == -1;\n        }\n    }\n\n}", "src": "public final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; \n\t\tlong mx=k-1; \n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "index": 514, "complexity": "3"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 80 column 61 (char 20259)", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 515, "complexity": "3"}
{"forwhile": "n = len(str)\nk = int(st.nextToken())\narr = [0]*n\nadjlist = [None]*n\ni = 0\nwhile i < n:\n    x = ord(str[i]) - ord('a') + 1\n    arr[i] = x\n    adjlist[i] = LinkedList()\n    i += 1\narr.sort()\ni = 0\nwhile i < n:\n    j = i + 1\n    while j < n:\n        a = arr[i]\n        b = arr[j]\n        if (b - a) >= 2:\n            adjlist[i].add(Pair(j, arr[j], 1))\n        j += 1\nlist = LinkedList()\ntmpList = LinkedList()\nans = float('inf')\ni = 0\nwhile i < n:\n    list.clear()\n    list.add(Pair(i, arr[i], 0))\n    j = 0\n    while j < k:\n        tmpList.clear()\n        while list:\n            cur = list.pop(0)\n            if j == k - 1:\n                ans = min(cur.val, ans)\n            for adj in adjlist[cur.idx]:\n                tmpList.add(Pair(adj.idx, adj.val + cur.val, cur.val + 1))\n        if not tmpList:\n            break\n        else:\n            list.extend(tmpList)\n        j += 1\n    i += 1\nif ans == float('inf'):\n    out.println(-1)\nelse:\n    out.println(ans)\n", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 516, "complexity": "3"}
{"forwhile": "n = input()\nk = input()\ns = input()\nwtArray = [0] * n\ni = 0\nwhile i < len(s):\n    wtArray[i] = ord(s[i]) - 96\n    i += 1\n\ni = 0\nwhile i < n:\n    j = 0\n    while j < n-i-1:\n        if wtArray[j] > wtArray[j+1]:\n            temp = wtArray[j+1]\n            wtArray[j+1] = wtArray[j]\n            wtArray[j] = temp\n        j += 1\n    i += 1\n\nsum = wtArray[0]\nk -= 1\ntemp = sum\ni = 1\nwhile k != 0 and i < n:\n    if wtArray[i] - temp > 1:\n        sum += wtArray[i]\n        k -= 1\n        temp = wtArray[i]\n    i += 1\n\nif k != 0:\n    sum = -1\n\nprint(sum)", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 517, "complexity": "3"}
{"forwhile": "class Main:\n\n\tclass FastScanner:\n        def __init__(self):\n            self.br = sys.stdin\n            self.st = []\n\n        def next(self):\n            if self.st:\n                return self.st.pop(0)\n            self.st = list(input().split())\n            return self.st.pop(0)\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            line = ''\n            if self.st:\n                line = self.st.pop(0)\n            else:\n                line = input()\n            while self.st:\n                line += ' ' + self.st.pop(0)\n            return line\n\n    def main(args):\n        sc = Main.FastScanner()\n\n        n = int(sc.nextInt())\n        m = int(sc.nextInt())\n        ans = 0\n\n        a = [0]*101\n        i = 0\n        mtemp = m\n        while i < mtemp:\n            a[int(sc.nextInt())] += 1\n            i += 1\n\n        i = 1\n        while i <= 100:\n            y = 0\n            for x in a:\n                y += x // i\n\n            if y >= n:\n                ans = i\n            i += 1\n\n        print(ans)\n\nif __name__ == \"__main__\":\n    Main.main(sys.argv[1:])\n", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 518, "complexity": "3"}
{"forwhile": "from java.util import Arrays, HashMap, ArrayList, Iterator\n\nclass G:\n\n    def main(self, args):\n        in = Scanner(System.in)\n        n = 0\n        m = 0\n        n = in.nextInt()\n        m = in.nextInt()\n        a = [0]*m\n        i = 0\n        while i < m:\n            a[i] = in.nextInt()\n            i += 1\n        Arrays.sort(a)\n        map = HashMap(200)\n        for i in a:\n            t = map.get(i)\n            if t == None:\n                map.put(i, 1)\n            else:\n                map.put(i, t + 1)\n        list = ArrayList(100)\n        it = map.entrySet().iterator()\n        for en in it:\n            list.add(Food(en.getKey(), en.getValue()))\n        list.sort((o) -> o.num)\n        min = 1\n        max = list.get(list.size() - 1).num\n        res = 0\n        i = min\n        while i <= max:\n            t = 0\n            for food in list:\n                gaven = food.num // i\n                if gaven >= 1:\n                    t += gaven\n                    if t >= n:\n                        res = max(res, i)\n                        break\n            i += 1\n        System.out.println(res)\n\n\nclass Food:\n\n    id = 0\n    num = 0\n\n    def __init__(self, id, num):\n        self.id = id\n        self.num = num\n\n    def toString(self):\n        return \"Food{\" + \"id=\" + str(self.id) + \", num=\" + str(self.num) + '}'", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 519, "complexity": "3"}
{"forwhile": "import java.util.*;\n\nclass Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc) {\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tint i = 0;\n\t\twhile (i < b.length) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint j = 0;\n\t\twhile (j < b.length) {\n\t\t\tb[j] = sc.nextInt();\n\t\t\tj++;\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia = 0, ib = 0;\n\t\tfor (; ia < LEN && a[ia] == 0; ia++);\n\t\tfor (; ib < LEN && b[ib] == 0; ib++);\n\t\tif (ib == LEN) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif (ia == LEN) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean out = true;\n\t\tfor (; ia < LEN && ib < LEN;) {\n\t\t\tif (a[ia] == b[ib]) {\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t} else {\n\t\t\t\tif (a[ia] > b[ib]) {\n\t\t\t\t\tfor (; ib < LEN && b[ib] != a[ia]; ib++);\n\t\t\t\t\tif (ib == LEN) {\n\t\t\t\t\t\tout = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (out) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t} else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 520, "complexity": "3"}
{"forwhile": "class GFG { static int maxSum( int arr[], int n) { int res = Integer.MIN_VALUE; int i = 0; while(i < n) { int curr_sum = 0; int j = 0; while(j < n) { int index = (i + j) % n; curr_sum += j * arr[index]; j++; } res = Math.max(res, curr_sum); i++; } return res; } public static void main(String args[]) { int arr[] = { 8 , 3 , 1 , 2 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 521, "complexity": "3"}
{"forwhile": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        for(i=0; i<N; i++){\n            newset.add(a[i]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            int i=0;\n            while(i<N){\n                a[i] = Integer.parseInt(tb.nextToken());\n                i++;\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        for(num=0; num<4; num++){\n            i=0;\n            while(i<N){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    int j=0;\n                    while(j<N){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                        j++;\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n                i++;\n            }\n            i=0;\n            while(i<N){\n                a[i] = b[i];\n                i++;\n            }\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 522, "complexity": "3"}
{"forwhile": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        int i = 0;\n        while (i < n) {\n            int v = 0;\n            if (!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if (!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n            i++;\n        }\n\n        boolean flag = false;\n        for (int i = 0; i < al.size(); i++) {\n            int v1 = al.get(i);\n            for (int j = 0; j < bl.size(); j++) {\n                int v2 = bl.get(j);\n                if (i != j && v1 == v2) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                break;\n            }\n        }\n\n        if (flag) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for (int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            int j = 0;\n            while (j < b.size()) {\n                int v2 = b.get(j);\n                if (i != j && v1 == v2) {\n                    return true;\n                }\n                j++;\n            }\n        }\n        return false;\n    }\n}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 523, "complexity": "3"}
{"forwhile": "Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();int x = scanner.nextInt();int[] a = new int[n];int i = 0;while(i < n){a[i] = scanner.nextInt();i++;}Arrays.sort(a);List<Integer> list = new ArrayList<>();i = 0;while(i < n){list.add(a[i]);i++;}for (int i = 0; i < n - 1; i++) {if (a[i] == a[i + 1]) {System.out.println(0);return;}}for (int i = n - 1; i > 0; i--) {if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {System.out.println(2);return;}else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {System.out.println(1);return;}}System.out.println(-1);", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 524, "complexity": "3"}
{"forwhile": "n = scan.nextInt()\nm = scan.nextInt()\na = [0] * (m + 1)\nc = 0\ni = 0\nwhile i < n:\n    l = scan.nextInt()\n    r = scan.nextInt()\n    j = l\n    while j <= r:\n        if a[j] != 1:\n            a[j] = 1\n            c += 1\n        j += 1\n    i += 1\nprint(m - c)\ni = 1\nwhile i <= m:\n    if a[i] == 0:\n        print(i, end=' ')\n    i += 1\n", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "index": 525, "complexity": "3"}
{"forwhile": "class GFG{\n\nprivate static int minJumps(int[] arr, int n) {\n\nint jumps[] = new int[n];\n\nint i, j;\n\nif(n == 0 || arr[0] == 0)\nreturn Integer.MAX_VALUE;\n\njumps[0] = 0;\n\ni = 1;\nwhile(i < n)\n{\njumps[i] = Integer.MAX_VALUE;\nj = 0;\nwhile(j < i)\n{\nif(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE)\n{\njumps[i] = Math.min(jumps[i], jumps[j] + 1);\nbreak;\n}\nj += 1;\n}\ni += 1;\n}\nreturn jumps[n-1];\n}\n\npublic static void main(String[] args) {\nint arr[] = {1, 3, 6, 1, 0, 9};\nSystem.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr,arr.length));\n}\n}", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 526, "complexity": "3"}
{"forwhile": "import java.io.BufferedReader;\nimport java.io.BufferedOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse {\n\t\t\tint i = 0;\n\t\t\twhile (i < n) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < n) {\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\tb = true;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tint j = 0;\n\t\t\twhile (j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse \n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\t b = true;\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 527, "complexity": "3"}
{"forwhile": "class GFG { static int maxSumIS( int arr[], int n) { int i, j, max = 0; int msis[] = new int[n]; i = 0; while (i < n) { msis[i] = arr[i]; i++; } i = 1; while (i < n) { j = 0; while (j < i) { if (arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) msis[i] = msis[j] + arr[i]; j++; } i++; } i = 0; while (i < n) { if (max < msis[i]) max = msis[i]; i++; } return max; } public static void main(String args[]) { int arr[] = new int[]{ 1, 101, 2, 3, 100, 4, 5}; int n = arr.length; System.out.println(\"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 528, "complexity": "3"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 1259 (char 1260)", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\nmin_len = n + \n1\n; \n\n\n\n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n\n\nint\ncurr_sum = arr[start]; \n\n\n\n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n\n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n\n\ncurr_sum += arr[end]; \n\n\n\n\n\n\n\n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 529, "complexity": "3"}
{"forwhile": "n = input.nextLong()\nm = input.nextInt()\na = [0]*m\ni = 0\nwhile i < m:\n    if i <= (n % m) and i != 0:\n        a[i] = n//m + 1\n    else:\n        a[i] = n//m\n    i += 1\nresult = 0\ni = 0\nwhile i < m:\n    j = 0\n    while j < m:\n        if (i * i + j * j) % m == 0:\n            result += a[i] * a[j]\n        j += 1\n    i += 1\nprint(result)", "src": "public class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "index": 530, "complexity": "3"}
{"forwhile": "n= sc.nextInt()\nli=[]\ni=0\nwhile i<n:\n    li.append(sc.nextInt())\n    i+=1\nmax=0\nc=0\ni=0\nwhile i<n:\n    c=0\n    j=i\n    while j<n:\n        if j!=n-1 and j!=0 and li[j]-li[j-1]==1 and li[j+1]-li[j]==1:\n            c+=1\n            i+=1\n        elif j!=n-1 and j==0 and li[j+1]-li[j]==1 and li[j]==1:\n            c+=1\n            i+=1\n        elif j==n-1 and j!=0 and li[j]-li[j-1]==1 and li[j]==1000:\n            c+=1\n            i+=1\n        else:\n            break\n        j+=1\n    if c>max:\n        max=c\n    i+=1\nif c>max:\n    max=c\nprint(max)", "src": ";\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}", "index": 531, "complexity": "3"}
{"forwhile": "n = sc.nextInt()\nk = sc.nextInt()\n\ni = 1\nwhile i <= n:\n\ta[i] = sc.nextInt()\n\tif a[i] == 1:\n\t\te += 1\n\telse:\n\t\ts += 1\n\ti += 1\n\ni = 1\nfor i in range(1, k+1):\n\te1 = 0\n\ts1 = 0\n\tj = i\n\twhile j <= n:\n\t\tif a[j] == 1:\n\t\t\te1 += 1\n\t\telse:\n\t\t\ts1 += 1\n\t\tj += k\n\n\tans = abs((s-s1) - (e-e1))\n\tmaxx = max(maxx, ans)\n\nprint(maxx)", "src": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t}\n\t    \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        \n\t        \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\t}\n       System.out.print(maxx);\n\t}\n\n}", "index": 532, "complexity": "3"}
{"forwhile": "n=cin.nextInt();ww=cin.nextInt();hh=cin.nextInt();num=0;que=[];i=1;while i<=n:temp=cin.nextInt();tempb=cin.nextInt();if temp>ww and tempb>hh:que.append([temp,tempb,i]);num+=1;i+=1;dp=[[0,0] for _ in range(num+5)];ans=0;ad=0;arr=[[0,0,0] for _ in range(num+5)];i=1;while i<=num:arr[i][0]=que[0][0];arr[i][1]=que[0][1];arr[i][2]=que[0][2];que.pop(0);i+=1;i=1;while i<=num:te=0;td=0;j=1;while j<i:if arr[j][0]<arr[i][0] and arr[j][1]<arr[i][1] and dp[j][0]>te:te=dp[j][0];td=j;j+=1;dp[i][0]=te+1;dp[i][1]=td;if dp[i][0]>ans:ans=dp[i][0];ad=i;i+=1;print(ans);an=[];u=ad;while u>0:an.append(arr[u][2]);u=dp[u][1];for i in range(len(an)-1,-1,-1):print(an[i],end=' ');", "src": "public class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}", "index": 533, "complexity": "3"}
{"forwhile": "class GFG { static int findMinDiff(int[] arr, int n) { int diff = Integer.MAX_VALUE; int i = 0; while (i < n-1) { int j = i+1; while (j < n) { if (Math.abs((arr[i] - arr[j])) < diff) diff = Math.abs((arr[i] - arr[j])); j++; } i++; } return diff; } public static void main(String[] args) { int arr[] = new int[]{ 1, 5, 3, 19, 18, 25 }; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\nif\n(Math.abs((arr[i] - arr[j]) )< diff) \n\ndiff = Math.abs((arr[i] - arr[j])); \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 534, "complexity": "3"}
{"forwhile": "class Test { static int arr1[] = new int[]{ 0, 1, 0, 1, 1, 1, 1}; static int arr2[] = new int[]{ 1, 1, 1, 1, 1, 0, 1}; static int longestCommonSum( int n) { int maxLen = 0; int i=0; while(i<n) { int sum1 = 0, sum2 = 0; int j=i; while(j<n) { sum1 += arr1[j]; sum2 += arr2[j]; if(sum1 == sum2) { int len = j-i+ 1; if(len > maxLen) maxLen = len; } j++; } i++; } return maxLen; } public static void main(String[] args) { System.out.print( \"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\nsum1 = \n0\n, sum2 = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\nsum1 += arr1[j]; \n\nsum2 += arr2[j]; \n\n\n\n\n\n\nif\n(sum1 == sum2) \n\n{ \n\nint\nlen = j-i+\n1\n; \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 535, "complexity": "3"}
{"forwhile": "import java.util.*;\npublic class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n\t\tint j=0;\n\t\twhile(j<n){\n\t\t\tString a=sc.next();\n\t\t\tHashSet<Character> t = new HashSet<Character>();\n\t\t\tint i=0;\n\t\t\tchar[] arr = a.toCharArray();\n\t\t\twhile(i<arr.length){\n\t\t\t\tchar c=arr[i];\n\t\t\t\tt.add(c);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ts3.add(t);\n\t\t\tj++;\n\t\t}\n\t\tSystem.out.println(s3.size());\n\t}\n}", "src": "public class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "index": 536, "complexity": "3"}
{"forwhile": "n = int(input())\nm = int(input())\ns = [None] * n\ni = 0\nwhile i < n:\n    s[i] = input()\n    i += 1\nf = 0\ni = 0\nwhile i < n:\n    j = 0\n    while j < len(s[i]):\n        val = -1\n        if s[i][j] == '.':\n            val = 0\n        elif s[i][j] == '*':\n            j += 1\n            continue\n        else:\n            val = ord(s[i][j]) - ord('0')\n        c = 0\n        if i - 1 >= 0 and j < m and s[i - 1][j] == '*':\n            c += 1\n        if i - 1 >= 0 and j - 1 >= 0 and s[i - 1][j - 1] == '*':\n            c += 1\n        if i - 1 >= 0 and j + 1 < m and s[i - 1][j + 1] == '*':\n            c += 1\n        if j - 1 >= 0 and s[i][j - 1] == '*':\n            c += 1\n        if j + 1 < m and s[i][j + 1] == '*':\n            c += 1\n        if i + 1 < n and j < m and s[i + 1][j] == '*':\n            c += 1\n        if i + 1 < n and j + 1 < m and s[i + 1][j + 1] == '*':\n            c += 1\n        if i + 1 < n and j - 1 >= 0 and s[i + 1][j - 1] == '*':\n            c += 1\n        if c != val:\n            f = 1\n            break\n        j += 1\n    if f == 1:\n        break\n    i += 1\nif f == 0:\n    print('YES')\nelse:\n    print('NO')", "src": "public class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Pair { \n    int x; \n    int y; \n  \n    \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}", "index": 537, "complexity": "3"}
{"forwhile": "class\\nTest { \\n\\nstatic\\nint\\narr[] = \\nnew\\nint\\n[] { \\n1\\n, \\n20\\n, \\n6\\n, \\n4\\n, \\n5\\n}; \\n\\n\\nstatic\\nint\\ngetInvCount(\\nint\\nn) \\n\\n{ \\n\\nint\\ninv_count = \\n0\\n; \\n\\nint\\ni = \\n0\\n; \\nwhile i < n - \\n1\\n: \\n\\nint\\nj = i + \\n1\\n; \\nwhile j < n: \\n\\nif\\n(arr[i] > arr[j]): \\n\\ninv_count++; \\n\\nj += \\n1\\n; \\n\\ni += \\n1\\n; \\n\\n\\nreturn\\ninv_count; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nSystem.out.println(\\n\\\"Number of inversions are \\\"\\n\\n+ getInvCount(arr.length)); \\n\\n} \\n}", "src": "class\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n}", "index": 538, "complexity": "3"}
{"forwhile": "def minAbsSumPair(arr, arr_size): \n    inv_count = 0 \n    l = 0 \n    r = 1 \n    min_sum = arr[0] + arr[1] \n    min_l = 0 \n    min_r = 1 \n    if arr_size < 2: \n        print('Invalid Input') \n        return \n    l = 0 \n    while l < arr_size - 1: \n        r = l + 1 \n        while r < arr_size: \n            sum = arr[l] + arr[r] \n            if abs(min_sum) > abs(sum): \n                min_sum = sum \n                min_l = l \n                min_r = r \n            r += 1 \n        l += 1 \n    print(' The two elements whose ' + 'sum is minimum are ' + str(arr[min_l]) + ' and ' + str(arr[min_r])) \ndef main(args): \n    arr = [1, 60, -10, 70, -80, 85] \n    minAbsSumPair(arr, 6) \nmain([])", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 539, "complexity": "3"}
{"forwhile": "public class Main {\n    public static void main(String args[]) {new Main().run();}\n    \n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    \n    void run(){\n        int q=in.nextInt();\n        int i = 0;\n        while(i < q){\n            out.println(work());\n            i++;\n        }\n        out.flush();\n    }\n    int work() {\t\t\n        int n=in.nextInt();\n        int k=in.nextInt();\n        String str=in.next();\n        char[] chs=new char[]{'R','G','B'};\n        int c1=0,c2=0,c3=0;\n        int ret=99999999;\n        int i = 0, p1=0, p2=1, p3=2;\n        while(i < n){\n            char ch=str.charAt(i);\n            \n            if(ch!=chs[p1]){\n                c1++;\n            }\n            if(i>=k){\n                char pre1=str.charAt(i-k);\n                char pre2=chs[((p1-(k%3))+3)%3];\n                if(pre1!=pre2){\n                    c1--;\n                }\n            }\n            if(i+1>=k){\n                ret=Math.min(ret,c1);\n            }\n            \n            \n            if(ch!=chs[p2]){\n                c2++;\n            }\n            if(i>=k){\n                char pre1=str.charAt(i-k);\n                char pre2=chs[((p2-(k%3))+3)%3];\n                if(pre1!=pre2){\n                    c2--;\n                }\n            }\n            if(i+1>=k){\n                ret=Math.min(ret,c2);\n            }\n            \n            \n            if(ch!=chs[p3]){\n                c3++;\n            }\n            if(i>=k){\n                char pre1=str.charAt(i-k);\n                char pre2=chs[((p3-(k%3))+3)%3];\n                if(pre1!=pre2){\n                    c3--;\n                }\n            }\n            if(i+1>=k){\n                ret=Math.min(ret,c3);\n            }\n            i++;\n            p1=(p1+1)%3;\n            p2=(p2+1)%3;\n            p3=(p3+1)%3;\n        } \n        return ret;\n       \n    }\n}", "src": "public class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        \n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}", "index": 540, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\t\n\t\tint t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];\n\t\tString s;\n\t\tchar[] s1,s2,s3;\n\n\t\tt=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\ts=sc.next();\n\t\t\ts1=new char[n];\n\t\t\ts2=new char[n];\n\t\t\ts3=new char[n];\n\t\t\t\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i%3==0)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='R';\n\t\t\t\t\ts2[i]='G';\n\t\t\t\t\ts3[i]='B';\n\t\t\t\t}\n\t\t\t\tif(i%3==1)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='G';\n\t\t\t\t\ts2[i]='B';\n\t\t\t\t\ts3[i]='R';\n\t\t\t\t}\n\t\t\t\tif(i%3==2)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='B';\n\t\t\t\t\ts2[i]='R';\n\t\t\t\t\ts3[i]='G';\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr1=new int[n];\n\t\t\tarr2=new int[n];\n\t\t\tarr3=new int[n];\n\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)!=s1[i])\n\t\t\t\t\tarr1[i]=1;\n\t\t\t\tif(s.charAt(i)!=s2[i])\n\t\t\t\t\tarr2[i]=1;\n\t\t\t\tif(s.charAt(i)!=s3[i])\n\t\t\t\t\tarr3[i]=1;\n\t\t\t}\n\t\t\tfor(i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tarr1[i]=arr1[i]+arr1[i-1];\n\t\t\t\tarr2[i]=arr2[i]+arr2[i-1];\n\t\t\t\tarr3[i]=arr3[i]+arr3[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tmin1=arr1[k-1];\n\t\t\tmin2=arr2[k-1];\n\t\t\tmin3=arr3[k-1];\n\n\t\t\tfor(i=k;i<n;i++)\n\t\t\t{\n\t\t\t\tif(min1>(arr1[i]-arr1[i-k]))\n\t\t\t\t\tmin1=(arr1[i]-arr1[i-k]);\n\t\t\t\tif(min2>(arr2[i]-arr2[i-k]))\n\t\t\t\t\tmin2=(arr2[i]-arr2[i-k]);\n\t\t\t\tif(min3>(arr3[i]-arr3[i-k]))\n\t\t\t\t\tmin3=(arr3[i]-arr3[i-k]);\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(min1,Math.min(min2,min3)));\n\t\t}\n\t}\n}", "index": 541, "complexity": "3"}
{"forwhile": "q = cin.nextInt()\na = [0]*200005\nwhile q > 0:\n    n = cin.nextInt()\n    k = cin.nextInt()\n    chuoi = cin.nextLine()\n    chuoi = cin.nextLine()\n    i = 1\n    while i <= n:\n        ch = chuoi.charAt(i-1)\n        if ch == 'R':\n            a[i] = 1\n        if ch == 'G':\n            a[i] = 2\n        if ch == 'B':\n            a[i] = 0\n        i += 1\n    i = 1\n    while i <= n:\n        x = 0\n        while x < 3:\n            dp[i][x] = dp[i-1][x]\n            if a[i] != (x + i)%3:\n                dp[i][x] += 1\n            x += 1\n        i += 1\n    res = 1000000007\n    i = k\n    while i <= n:\n        x = 0\n        while x < 3:\n            res = min(res, dp[i][x] - dp[i-k][x])\n            x += 1\n        i += 1\n    cout.println(res)\n    q -= 1\ncout.close()", "src": "public class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}", "index": 542, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 543, "complexity": "3"}
{"forwhile": "class GFG { static void findTriplets( int arr[], int n) { boolean found = false; Arrays.sort(arr); int i=0; while (i<n-1) { int l = i + 1; int r = n - 1; int x = arr[i]; for (l; l < r; l += 1) { if (x + arr[l] + arr[r] == 0) { System.out.print(x + \" \"); System.out.print(arr[l]+ \" \"); System.out.println(arr[r]+ \" \"); l += 1; r -= 1; found = true; } else if (x + arr[l] + arr[r] < 0) l += 1; else r -= 1; } i += 1; } if (found == false) System.out.println(\" No Triplet Found\"); } public static void main (String[] args) { int arr[] = {0, -1, 2, -3, 1}; int n =arr.length; findTriplets(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n\n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n\n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n\n\n\n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n\n}", "index": 544, "complexity": "3"}
{"forwhile": "class\\nGFG { \\n\\n\\nstatic\\nint\\nbinomialCoeff(\\nint\\nn, \\nint\\nk) \\n\\n{ \\n\\nint\\nC[] = \\nnew\\nint[k + \\n1\\]; \\n\\n\\n\\n\\nC[\\n0\\] = \\n1\\; \\n\\n\\nint\\ni = \\n1\\; \\nwhile i <= n: \\n\\n{ \\n\\n\\n\\n\\nint\\nj = Math.min(i, k); \\nwhile j > \\n0\\: \\n\\nC[j] = C[j] + C[j-\\n1\\]; \\n\\nj -= \\n1\\; \\n} \\n\\nreturn\\nC[k]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\nn = \\n5\\, k = \\n2\\; \\n\\nSystem.out.printf(\\n\\\"Value of C(%d, %d) is %d \\\"\\n\\n, n, k, binomialCoeff(n, k)); \\n\\n} \\n}", "src": "class\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n\n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n}", "index": 545, "complexity": "3"}
{"forwhile": "class GFG {\n    static void printArray(int A[], int size) \n    {\n        int i = 0;\n        while (i < size) \n        {\n            System.out.print(A[i] + \" \"); \n            i++; \n        }\n        System.out.println(\"\"); \n    }\n\n    static void reverse(int arr[], int l, int r) \n    {\n        if (l < r) { \n            arr = swap(arr, l, r); \n            for (int i = l, j = r; i <= j; i++, j--) \n            { \n                int temp = arr[i]; \n                arr[i] = arr[j]; \n                arr[j] = temp; \n            }\n        }\n    }\n\n    static void merge(int arr[], int l, int m, int r) \n    {\n        int i = l; \n        int j = m + 1; \n\n        for (i = l; i <= m; i++) \n        {\n            if (arr[i] < 0) \n            {\n                while (i <= m && arr[i] < 0) \n                    i++; \n            }\n        }\n\n        while (j <= r) \n        {\n            if (arr[j] < 0) \n            {\n                while (j <= r && arr[j] < 0) \n                    j++; \n            }\n        }\n\n        reverse(arr, l, m); \n        reverse(arr, m + 1, j - 1); \n        reverse(arr, i, j - 1); \n    }\n\n    static void RearrangePosNeg(int arr[], int l, int r) \n    {\n        if (l < r) { \n            int m = l + (r - l) / 2; \n            RearrangePosNeg(arr, l, m); \n            RearrangePosNeg(arr, m + 1, r); \n            merge(arr, l, m, r); \n        }\n    }\n\n    static int[] swap(int arr[], int i, int j) \n    {\n        int temp = arr[i]; \n        arr[i] = arr[j]; \n        arr[j] = temp; \n        return arr; \n    }\n\n    public static void main(String[] args) \n    {\n        int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 }; \n        int arr_size = arr.length; \n\n        RearrangePosNeg(arr, 0, arr_size - 1); \n        printArray(arr, arr_size); \n    }\n}", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n\n\nint\nj = m + \n1\n; \n\n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n\n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n\n\n\n\n\n\n\nreverse(arr, i, m); \n\n\n\n\n\n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n\n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n}", "index": 546, "complexity": "3"}
{"forwhile": "class GFG { static int minJumps(int arr[], int n) { int[] jumps = new int[n]; int min; jumps[n - 1] = 0; int i = n - 2; while (i >= 0) { if (arr[i] == 0) jumps[i] = Integer.MAX_VALUE; else if (arr[i] >= n - i - 1) jumps[i] = 1; else { min = Integer.MAX_VALUE; int j = i + 1; while (j < n && j <= arr[i] + i) { if (min > jumps[j]) min = jumps[j]; j++; } if (min != Integer.MAX_VALUE) jumps[i] = min + 1; else jumps[i] = min; } i--; } return jumps[0]; } public static void main(String[] args) { int[] arr = {1, 3, 6, 1, 0, 9}; int size = arr.length; System.out.println(\"Minimum number of\" + \" jumps to reach end is \" + minJumps(arr, size)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 547, "complexity": "3"}
{"forwhile": "class GFG :    def minJumps(arr, n):        jumps = [0] * n        jumps[n - 1] = 0        i = n - 2        while i >= 0:            if arr[i] == 0:                jumps[i] = float('inf')            elif arr[i] >= n - i - 1:                jumps[i] = 1            else:                min_val = float('inf')                j = i + 1                while j < n and j <= arr[i] + i:                    if min_val > jumps[j]:                        min_val = jumps[j]                    j += 1                if min_val != float('inf'):                    jumps[i] = min_val + 1                else:                    jumps[i] = min_val                i -= 1        return jumps[0]    if __name__ == '__main__':        arr = [1, 3, 6, 1, 0, 9]        size = len(arr)        print('Minimum number of jumps to reach end is ' + str(minJumps(arr, size)))", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 548, "complexity": "3"}
{"forwhile": "public\\nclass\\nGfG{ \\n\\n\\n\\npublic\\nstatic\\nvoid\\nrearrangeArr(\\nint\\narr[], \\n\\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\nint\\nevenPos = n / \\n2\\n; \\n\\n\\n\\nint\\noddPos = n - evenPos; \\n\\n\\nint\\n[] tempArr = \\nnew\\nint\\n[n]; \\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\n\\nwhile (i < n) \\n\\ntempArr[i] = arr[i]; \\n\\n\\n\\nArrays.sort(tempArr); \\n\\n\\nint\\nj = oddPos - \\n1\\n; \\n\\n\\n\\n\\nint\\ni1 = \\n0\\n; \\nwhile (i1 < n) \\n\\n{ \\n\\narr[i1] = tempArr[j]; \\n\\nj--; \\n\\ni1 += \\n2\\n; \\n} \\n\\n\\nj = oddPos; \\n\\n\\n\\n\\nint\\ni2 = \\n1\\n; \\nwhile (i2 < n) \\n\\n{ \\n\\narr[i2] = tempArr[j]; \\n\\nj++; \\n\\ni2 += \\n2\\n; \\n} \\n\\n\\n\\nint\\ni3 = \\n0\\n; \\n\\nwhile (i3 < n) \\n\\n{ \\n\\nSystem.out.print(arr[i3] + \\n\\\" \\\"\\n); \\n\\ni3++; \\n} \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String argc[]){ \\n\\nint\\n[] arr = \\nnew\\nint\\n[]{ \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n\\n6\\n, \\n7\\n}; \\n\\nint\\nsize = \\n7\\n; \\n\\nrearrangeArr(arr, size); \\n\\n\\n} \\n}", "src": "public\nclass\nGfG{ \n\n\n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\nint\nevenPos = n / \n2\n; \n\n\n\n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n\n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n}", "index": 549, "complexity": "5"}
{"forwhile": "import java.util.ArrayList;import java.util.Collections;public class ladder {public static void main(String[] args) {Scanner sc = new Scanner(System.in);int problems = sc.nextInt();int i = 0;while (i < problems) {int numPlanks = sc.nextInt();solve(numPlanks, sc);i++;}}public static void solve(int numPlanks, Scanner sc) {int answer;ArrayList<Integer> planks  = new ArrayList<>();int i = 0;while (i < numPlanks) {planks.add(sc.nextInt());i++;}Collections.sort(planks);planks.remove(numPlanks - 1);planks.add(planks.get(numPlanks - 2));int base = planks.get(numPlanks - 1) - 1;if ((numPlanks - 2) > base) {answer = base;}else {answer = numPlanks - 2;}if (base == 0) {answer = 0;}System.out.println(answer);}}", "src": "public class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "index": 550, "complexity": "5"}
{"forwhile": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        int i = 0; \n        int j = 0; \n\n        for (i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        \n  \n        \n        int k = l; \n        for (; i < n1 && j < n2;) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        for (; i < n1;) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        for (; j < n2;) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        for(;q>0;) \n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(;i<n;) \n            {\n                a[i]=sc.nextInt();\n                i++;\n            }\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "src": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        \n  \n        \n        int i = 0, j = 0; \n  \n        \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        while(q>0)\n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(i=0;i<n;i++)\n                a[i]=sc.nextInt();\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "index": 551, "complexity": "5"}
{"forwhile": "import java.io.*;\nimport java.util.*;\nclass Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        int i = 0;\n        while (i<n){ a[i] = Long.parseLong(st.nextToken()); i++; }\n        Queue<Long> ts = new PriorityQueue<Long>();\n        int i=1; \n        while(i<n){ ts.add(a[i]-a[i-1]); i++; }\n        long sum = 0;\n        for(int i=0;i<n-k; i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "src": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "index": 552, "complexity": "5"}
{"forwhile": "public final class Cf:\n    def main(args):\n        ob = FastReader()\n        n = ob.nextInt()\n        k = ob.nextInt()\n        a = []\n        i = 0\n        while i < n:\n            a.append(ob.nextInt())\n            i += 1\n        x = a[n - 1] - a[0]\n        b = []\n        i = 0\n        while i < n - 1:\n            b.append(-a[i + 1] + a[i])\n            i += 1\n        b.sort()\n        i = 0\n        while i < k - 1:\n            x += b[i]\n            i += 1\n        print(x)\nclass FastReader:\n    def __init__(self):\n        self.br = BufferedReader(InputStreamReader(System.in))\n        self.st = None\n    def next(self):\n        while self.st == None or not self.st.hasMoreElements():\n            try:\n                self.st = StringTokenizer(self.br.readLine())\n            except IOException:\n                e.printStackTrace()\n        return self.st.nextToken()\n    def nextLine(self):\n        s = \"\"\n        try:\n            s = self.br.readLine()\n        except IOException:\n            e.printStackTrace()\n        return s\n    def nextInt(self):\n        return Integer.parseInt(self.next())\n    def nextLong(self):\n        return Long.parseLong(self.next())\n    def nextDouble(self):\n        return Double.parseDouble(self.next())", "src": "public final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        \n        \n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "index": 553, "complexity": "5"}
{"forwhile": "class GFG { static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = Integer.MIN_VALUE, curr_max = 0; int i = 0; while (i < n) { if (Arrays.binarySearch(B, A[i]) >= 0) { curr_max = 0; i++; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); i++; } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { Arrays.sort(B); int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if (maxSubarraySum == Integer.MIN_VALUE) { System.out.println(\"Maximum subarray sum cant be found\"); } else { System.out.println(\"The Maximum subarray sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = {3, 4, 5, -4, 6}; int B[] = {1, 8, 5}; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = Integer.MIN_VALUE, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\nif\n(Arrays.binarySearch(B, A[i]) >= \n0\n) \n\n{ \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\nArrays.sort(B); \n\n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == Integer.MIN_VALUE) \n\n{ \n\nSystem.out.println(\n\"Maximum subarray sum cant be found\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.println(\n\"The Maximum subarray sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = {\n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = {\n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 555, "complexity": "5"}
{"forwhile": "class GFG:     @staticmethod     def maximum(a, b, c):         return max(max(a, b), c)     @staticmethod     def minimum(a, b, c):         return min(min(a, b), c)     @staticmethod     def smallestDifferenceTriplet(arr1, arr2, arr3, n):         arr1.sort()         arr2.sort()         arr3.sort()         res_min, res_max, res_mid = 0, 0, 0         i, j, k = 0, 0, 0         diff = 2147483647         for i in range(n):             while i < n and j < n and k < n:                 sum_val = arr1[i] + arr2[j] + arr3[k]                 max_val = GFG.maximum(arr1[i], arr2[j], arr3[k])                 min_val = GFG.minimum(arr1[i], arr2[j], arr3[k])                 if min_val == arr1[i]:                     i += 1                 elif min_val == arr2[j]:                     j += 1                 else:                     k += 1                 if diff > (max_val - min_val):                     diff = max_val - min_val                     res_max = max_val                     res_mid = sum_val - (max_val + min_val)                     res_min = min_val         print(res_max, res_mid, res_min)     @staticmethod     def main(args):         arr1 = [5, 2, 8]         arr2 = [10, 7, 12]         arr3 = [9, 14, 6]         n = len(arr1)         GFG.smallestDifferenceTriplet(arr1, arr2, arr3, n) ", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nmaximum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.max(Math.max(a, b), c); \n\n} \n\n\n\n\nstatic\nint\nminimum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.min(Math.min(a, b), c); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nsmallestDifferenceTriplet(\nint\narr1[], \n\nint\narr2[], \nint\narr3[], \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n\n\nint\nres_min=\n0\n, res_max=\n0\n, res_mid=\n0\n; \n\n\n\n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\n\n\nint\ndiff = \n2147483647\n; \n\n\nwhile\n(i < n && j < n && k < n) \n\n{ \n\nint\nsum = arr1[i] + arr2[j] + arr3[k]; \n\n\n\n\nint\nmax = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n\n\nint\nmin = minimum(arr1[i], arr2[j], arr3[k]); \n\nif\n(min == arr1[i]) \n\ni++; \n\nelse\nif\n(min == arr2[j]) \n\nj++; \n\nelse\n\nk++; \n\n\n\n\n\n\nif\n(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n\n\nSystem.out.print(res_max + \n\", \"\n+ res_mid \n\n+ \n\", \"\n+ res_min); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\narr1[] = {\n5\n, \n2\n, \n8\n}; \n\nint\narr2[] = {\n10\n, \n7\n, \n12\n}; \n\nint\narr3[] = {\n9\n, \n14\n, \n6\n}; \n\n\nint\nn = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n}", "index": 557, "complexity": "5"}
{"forwhile": "class GFG: \n\n    @staticmethod\n    def R = 4\n    def C = 4\n\n    @staticmethod\n    def first(arr, low, high): \n\n        while high >= low: \n\n            mid = low + (high - low) // 2\n\n            if (mid == 0 or (arr[mid - 1] == 0) and arr[mid] == 1): \n                return mid\n\n            elif arr[mid] == 0: \n                high = mid - 1\n\n            else:\n                low = mid + 1\n\n        return -1\n\n    @staticmethod\n    def rowWithMax1s(mat): \n\n        max_row_index = 0\n        max = -1\n\n        i = 0\n        for i in range(R): \n            index = 0\n            while index != -1 and C - index > max: \n                max = C - index\n                max_row_index = i\n\n        return max_row_index\n\n    @staticmethod\n    def main(args): \n\n        mat = [ [0, 0, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0] ]\n        print(\"Index of row with maximum 1s is \")\n        print(rowWithMax1s(mat)) \n", "src": "class\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n\n\nint\nmid = low + (high - low) / \n2\n; \n\n\n\n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n\n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n\n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n\n\n\n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n}", "index": 558, "complexity": "5"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\n\\nstatic\\nvoid\\nrearrangeArray(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\nint\\nArrIndex = \\n0\\n; \\n\\n\\nint\\ni = \\n0\\n; \\nint\\nj = n-\\n1\\n; \\nwhile(i <= n / \\n2\\n|| j > n / \\n2\\n) { \\n\\nif\\n(ArrIndex < n) \\n\\n{ \\n\\ntempArr[ArrIndex] = arr[i]; \\n\\nArrIndex++; \\n\\n} \\n\\n\\nif\\n(ArrIndex < n) \\n\\n{ \\n\\ntempArr[ArrIndex] = arr[j]; \\n\\nArrIndex++; \\n\\n} \\n\\ni++; \\nj--; \\n} \\n\\ni = \\n0\\n; \\nwhile(i < n) { \\narr[i] = tempArr[i]; \\ni++; \\n} \\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\narr[] = { \\n5\\n, \\n8\\n, \\n1\\n, \\n4\\n, \\n2\\n, \\n9\\n, \\n3\\n, \\n7\\n, \\n6\\n}; \\n\\nint\\nn = arr.length; \\n\\nrearrangeArray(arr, n); \\n\\n\\nint\\ni = \\n0\\n; \\nwhile(i < n) { \\nSystem.out.print(arr[i]+\\n\\\" \\\"\\n); \\ni++; \\n} \\n} \\n}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\n\nint\nArrIndex = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 559, "complexity": "5"}
{"forwhile": "class LinkedList { static Node head; static class Node { int data; Node next, prev; Node(int d) { data = d; next = prev = null; } } void print(Node node) { Node temp = node; System.out.println(\"Forward Traversal using next pointer\"); for ( ; node != null; ) { System.out.print(node.data + \" \"); temp = node; node = node.next; } System.out.println(\"\\nBackward Traversal using prev pointer\"); for ( ; temp != null; ) { System.out.print(temp.data + \" \"); temp = temp.prev; } } Node split(Node head) { Node fast = head, slow = head; for ( ; fast.next != null && fast.next.next != null; ) { fast = fast.next.next; slow = slow.next; } Node temp = slow.next; slow.next = null; return temp; } Node mergeSort(Node node) { if (node == null || node.next == null) { return node; } Node second = split(node); node = mergeSort(node); second = mergeSort(second); return merge(node, second); } Node merge(Node first, Node second) { if (first == null) { return second; } if (second == null) { return first; } if (first.data < second.data) { first.next = merge(first.next, second); first.next.prev = first; first.prev = null; return first; } else { second.next = merge(first, second.next); second.next.prev = second; second.prev = null; return second; } } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(30); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(20); list.head.next.next.next.next.next = new Node(5); Node node = null; node = list.mergeSort(head); System.out.println(\"Linked list after sorting :\"); list.print(node); } }", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\n\n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n\n\n\n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n\n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n\n\nreturn\nmerge(node, second); \n\n} \n\n\n\n\nNode merge(Node first, Node second) { \n\n\n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n\n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n\n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n}", "index": 560, "complexity": "5"}
{"forwhile": "public\\nclass\\nGenerateBNo \\n{ \\n\\n\\n\\nstatic\\nvoid\\ngeneratePrintBinary(\\nint\\nn) \\n\\n{ \\n\\n\\n\\nQueue<String> q = \\nnew\\nLinkedList<String>(); \\n\\n\\n\\n\\nq.add(\\n\\\"1\\\"\\n); \\n\\n\\n\\n\\n\\n\\nfor (n = n; n > 0; n--) \\n\\n{ \\n\\n\\n\\nString s1 = q.peek(); \\n\\nq.remove(); \\n\\nSystem.out.println(s1); \\n\\n\\n\\nString s2 = s1; \\n\\n\\n\\nq.add(s1 + \\n\\\"0\\\"\\n); \\n\\n\\n\\n\\n\\nq.add(s2 + \\n\\\"1\\\"\\n); \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nint\\nn=\\n10\\n; \\n\\n\\ngeneratePrintBinary(n); \\n\\n} \\n}", "src": "public\nclass\nGenerateBNo \n{ \n\n\n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n\n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n\n\nq.add(\n\"1\"\n); \n\n\n\n\n\n\nwhile\n(n-- > \n0\n) \n\n{ \n\n\n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n\n\nString s2 = s1; \n\n\n\n\nq.add(s1 + \n\"0\"\n); \n\n\n\n\n\n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n}", "index": 561, "complexity": "5"}
{"forwhile": "class LIS: while True: if (r - l) <= 1: return r m = l + (r - l) // 2 if A[m] >= key: r = m else: l = m @staticmethod def LongestIncreasingSubsequenceLength(A, size): tailTable = [0] * size tailTable[0] = A[0] len = 1 i = 1 while i < size: if A[i] < tailTable[0]: tailTable[0] = A[i] elif A[i] > tailTable[len - 1]: tailTable[len] = A[i] len += 1 else: tailTable[LIS.CeilIndex(tailTable, -1, len - 1, A[i])] = A[i] i += 1 return len @staticmethod def CeilIndex(A, l, r, key): while (r - l) > 1: m = l + (r - l) // 2 if A[m] >= key: r = m else: l = m return r def main(args): A = [2, 5, 3, 7, 11, 8, 10, 13, 6] n = len(A) print(\"Length of Longest Increasing Subsequence is \" + str(LIS.LongestIncreasingSubsequenceLength(A, n))) if __name__ == '__main__': main([])", "src": "class\nLIS { \n\n\n\n\n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n\n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n\n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n\n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n\n\ntailTable[len++] = A[i]; \n\n\nelse\n\n\n\n\n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n}", "index": 562, "complexity": "5"}
{"forwhile": "class\\nGFG { \\n\\n\\n\\n\\n\\nstatic\\nint\\nmaxSumPairWithDifferenceLessThanK(\\nint\\narr[], \\n\\nint\\nN, \\nint\\nK) \\n\\n{ \\n\\n\\n\\nint\\ni = \\n1\\n; \\n\n\nwhile\n(\ni < N\n)\n\n{ \\n\\n\\n\\n\\n\\n\\nint\ndp[] = \nnew\nint\n[N]; \\n\n\\n\\n\\n\\ndp[\\i\\] = \\n0\\n; \\n\\n\\n\\nif\n(\ni >= \\n2\n)\n\\n{ \\n\\n\\n\\n\\nfor\n(\nint\ni = \\n1\\n; i < N; i++) \n\\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\ndp[i] = dp[i-\\n1\\]; \\n\\n\\n\\nif\n(arr[i] - arr[i-\\n1\\] < K) \n\\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\nif\n(i >= \\n2\n) \n\\n\\ndp[i] = Math.max(dp[i], dp[i-\\n2\\] + arr[i] + \n\\narr[i-\\n1\\]); \\n\\nelse\n\\n\\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\\n1\\]); \\n\\n} \\n\\n} \\n\\n} \\n\nelse\n\\n{ \\n\\n\\n\\n\\nint\ni = \\n1\\n; \\n\nwhile\n(\ni < N\n)\n\\n{ \\n\\n\\n\\n\\n\\n\\ndp[i] = dp[i-\\n1\\]; \\n\\n\\n\\nif\n(arr[i] - arr[i-\\n1\\] < K) \n\\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\nif\n(i >= \\n2\n) \n\\n\\ndp[i] = Math.max(dp[i], dp[i-\\n2\\] + arr[i] + \n\\narr[i-\\n1\\]); \\n\\nelse\n\\n\\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\\n1\\]); \\n\\n} \\n\\n\\n\\ni++; \\n\\n} \\n\\n} \\n\ni++; \\n\\n} \\n\\n\\nreturn\ndp[N - \\n1\\]; \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\nmain (String[] args) { \\n\\n\\nint\narr[] = {\\n3\\n, \\n5\\n, \\n10\\n, \\n15\\n, \\n17\\n, \\n12\\n, \\n9\\n}; \\n\\nint\nN = arr.length; \\n\\nint\nK = \\n4\\n; \\n\\n\\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \\n\\narr, N, K)); \\n\\n\\n} \\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n\n\n\n\ndp[i] = dp[i-\n1\n]; \n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n\n\n\n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n\n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n}", "index": 563, "complexity": "5"}
{"forwhile": "class GFG { static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int k) { int maxSum = 0; Arrays.sort(arr); int i = N-1; while(i > 0) { if(arr[i] - arr[i-1] < k) { maxSum += arr[i]; maxSum += arr[i-1]; i--; } i--; } return maxSum; } public static void main (String[] args) { int arr[] = {3, 5, 10, 15, 17, 12, 9}; int N = arr.length; int K = 4; System.out.println ( maxSumPairWithDifferenceLessThanK(arr, N, K)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nk) \n\n{ \n\nint\nmaxSum = \n0\n; \n\n\n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = N-\n1\n; i > \n0\n; --i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < k) \n\n{ \n\n\n\nmaxSum += arr[i]; \n\nmaxSum += arr[i-\n1\n]; \n\n\n\n\n--i; \n\n} \n\n} \n\n\nreturn\nmaxSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n} \n}", "index": 564, "complexity": "5"}
{"forwhile": "class GFG: \n    @staticmethod\n    def find_max(A, N, K): \n        Count = {}\n        i = 0\n        while i < K - 1: \n            if A[i] in Count: \n                Count[A[i]] = 1 + Count[A[i]] \n            else: \n                Count[A[i]] = 1 \n            i += 1\n        Myset = set()\n        for x in Count.items(): \n            if int(x[1]) == 1: \n                Myset.add(int(x[0])) \n        i = K - 1\n        while i < N: \n            if A[i] in Count: \n                Count[A[i]] = 1 + Count[A[i]] \n            else: \n                Count[A[i]] = 1 \n            if int(Count[A[i]]) == 1: \n                Myset.add(A[i]) \n            else: \n                Myset.remove(A[i]) \n            if len(Myset) == 0: \n                print('Nothing') \n            else: \n                print(max(Myset)) \n            x = A[i - K + 1] \n            Count[x] = Count[x] - 1\n            if int(Count[x]) == 1: \n                Myset.add(x) \n            if int(Count[x]) == 0: \n                Myset.remove(x) \n            i += 1\n\n    @staticmethod\n    def main(args): \n        a = [1, 2, 2, 3, 3] \n        n = len(a) \n        k = 3 \n        GFG.find_max(a, n, k) \n", "src": "class\nGFG { \n\n\nstatic\nvoid\nfind_max(\nint\n[] A, \nint\nN, \nint\nK) \n\n{ \n\n\n\n\n\nHashMap<Integer, Integer> Count = \nnew\nHashMap<>(); \n\nfor\n(\nint\ni = \n0\n; i < K - \n1\n; i++) \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nTreeSet<Integer> Myset = \nnew\nTreeSet<Integer>(); \n\nfor\n(Map.Entry x : Count.entrySet()) { \n\nif\n(Integer.parseInt(String.valueOf(x.getValue())) == \n1\n) \n\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()))); \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = K - \n1\n; i < N; i++) { \n\n\n\n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(A[i]))) == \n1\n) \n\nMyset.add(A[i]); \n\nelse\n\nMyset.remove(A[i]); \n\n\n\n\n\n\nif\n(Myset.size() == \n0\n) \n\nSystem.out.println(\n\"Nothing\"\n); \n\n\n\n\n\n\nelse\n\nSystem.out.println(Myset.last()); \n\n\n\n\n\n\nint\nx = A[i - K + \n1\n]; \n\nCount.put(x, Count.get(x) - \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n1\n) \n\nMyset.add(x); \n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n0\n) \n\nMyset.remove(x); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] a = { \n1\n, \n2\n, \n2\n, \n3\n, \n3\n}; \n\nint\nn = a.length; \n\nint\nk = \n3\n; \n\nfind_max(a, n, k); \n\n} \n}", "index": 566, "complexity": "5"}
{"forwhile": "class GFG { static void pairs( int arr[], int n, int k) { int smallest = Integer.MAX_VALUE; int count= 0 ; int i=0; while(i<n) { int j=i+1; while(j<n) { if ( Math.abs(arr[i] + arr[j] - k) < smallest ) { smallest = Math.abs(arr[i] + arr[j] - k); count = 1 ; } else if (Math.abs(arr[i] + arr[j] - k) == smallest) count++; j++; } i++; } System.out.println( \"Minimal Value = \"+ smallest); System.out.println( \"Total Pairs = \"+ count); } public static void main(String[] args) { int arr[] = {3, 5, 7, 5, 1, 9, 9}; int k = 12 ; int n = arr.length; pairs(arr, n, k); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\npairs(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nint\nsmallest = Integer.MAX_VALUE; \n\nint\ncount=\n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n( Math.abs(arr[i] + arr[j] - k) < \n\nsmallest ) \n\n{ \n\nsmallest = Math.abs(arr[i] + arr[j] \n\n- k); \n\ncount = \n1\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(Math.abs(arr[i] + arr[j] - k) \n\n== smallest) \n\ncount++; \n\n} \n\n\n\n\nSystem.out.println(\n\"Minimal Value = \"\n+ \n\nsmallest); \n\nSystem.out.println(\n\"Total Pairs = \"\n+ \n\ncount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n5\n, \n7\n, \n5\n, \n1\n, \n9\n, \n9\n}; \n\nint\nk = \n12\n; \n\nint\nn = arr.length; \n\npairs(arr, n, k); \n\n} \n}", "index": 567, "complexity": "5"}
{"forwhile": "class ActivitySelection { public static void printMaxActivities(int s[], int f[], int n) { int i, j; System.out.print(\"Following activities are selected : \"); i = 0; System.out.print(i+\" \"); j = 1; while (j < n) { if (s[j] >= f[i]) { System.out.print(j+\" \"); i = j; } j++; } } public static void main(String[] args) { int s[] = {1, 3, 0, 5, 8, 5}; int f[] = {2, 4, 6, 7, 9, 9}; int n = s.length; printMaxActivities(s, f, n); } }", "src": "class\nActivitySelection \n{ \n\n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n\n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n\n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n}", "index": 568, "complexity": "5"}
{"forwhile": "class DisjointSet: \n parent = [] \n def __init__(self, n): \n  self.parent = [i for i in range(n + 1)] \n def find(self, s): \n  if s == self.parent[s]: \n   return s \n  return self.find(self.parent[s]) \n def merge(self, u, v): \n  self.parent[v] = u \n class Job: \n  id = None \n  deadline = 0 \n  profit = 0 \n  def __init__(self): \n   pass \n  def __init__(self, id, deadline, profit): \n   self.id = id \n   self.deadline = deadline \n   self.profit = profit \n  @staticmethod \n  def findMaxDeadline(arr): \n   ans = float('-inf') \n   for temp in arr: \n    ans = max(temp.deadline, ans) \n   return ans \n  @staticmethod \n  def printJobScheduling(arr): \n   arr.sort(key=lambda x: x.profit, reverse=True) \n   maxDeadline = Job.findMaxDeadline(arr) \n   dsu = DisjointSet(maxDeadline) \n   for temp in arr: \n    availableSlot = dsu.find(temp.deadline) \n    if availableSlot > 0: \n     dsu.merge(dsu.find(availableSlot - 1), availableSlot) \n     print(temp.id, end=' ') \n   print() \n  def compare(self, j1, j2): \n   return -1 if j1.profit > j2.profit else 1 \n if __name__ == '__main__': \n  arr = [Job('a', 2, 100), Job('b', 1, 19), Job('c', 2, 27), Job('d', 1, 25), Job('e', 3, 15)] \n  print('Following jobs need to be executed for maximum profit') \n  Job.printJobScheduling(arr)", "src": "class\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n\n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n\n\nint\nfind(\nint\ns) \n\n{ \n\n\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n\n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n\n\n\n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n\n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n\n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n\n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n\n\n\n\nCollections.sort(arr, \nnew\nJob()); \n\n\n\n\n\n\n\n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n\n\nfor\n(Job temp : arr) \n\n{ \n\n\n\n\n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n\n\n\n\nif\n(availableSlot > \n0\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n\nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n}", "index": 569, "complexity": "5"}
{"forwhile": "class\\nGFG { \\n\\nvoid\\nfind3largest(\\nint\\n[] arr) \\n\\n{ \\n\\nArrays.sort(arr); \\n\\n\\n\\n\\nint\\nn = arr.length; \\n\\nint\\ncheck = \\n0\\n, count = \\n1\\n; \\n\\n\\nint\\ni = \\n1\\n; \\nwhile i <= n: \n\\n\\nif\\n(count<\\n4\\n): \\n\\nif\\n(check!=arr[n-i]): \\n\\n\\n\\nSystem.out.print(arr[n-i]+\\n\" \"\\n); \\n\\ncheck = arr[n-i]; \\n\\ncount++; \\n\\n\\n\\n\\nelse:  \\nbreak\\n; \\n\ni += \\n1\\n; \n\\n\\n} \\n\\n\\n} \\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nGFG obj = \\nnew\\nGFG(); \\n\\nint\\n[] arr={\\n12\\n,\\n45\\n,\\n1\\n,-\\n1\\n,\\n45\\n,\\n54\\n,\\n23\\n,\\n5\\n,\\n0\\n,-\\n10\\n}; \\n\\nobj.find3largest(arr); \\n\\n} \\n\\n}", "src": "class\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n\n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n}", "index": 570, "complexity": "5"}
{"forwhile": "class HuffmanNode:\n    def __init__(self):\n        self.data = None\n        self.c = None\n        self.left = None\n        self.right = None\n\n\nclass MyComparator:\n    def compare(self, x, y):\n        return x.data - y.data\n\n\nclass Huffman:\n    @staticmethod\n    def printCode(root, s):\n        if ((root.left is None) and (root.right is None) and root.c.isalpha()):\n            print(root.c + \":\" + s)\n            return\n        Huffman.printCode(root.left, s + \"0\")\n        Huffman.printCode(root.right, s + \"1\")\n\n    @staticmethod\n    def main(args):\n        import sys\n        n = 6\n        charArray = ['a', 'b', 'c', 'd', 'e', 'f']\n        charfreq = [5, 9, 12, 13, 16, 45]\n        q = []\n        for i in range(n):\n            hn = HuffmanNode()\n            hn.c = charArray[i]\n            hn.data = charfreq[i]\n            hn.left = None\n            hn.right = None\n            q.append(hn)\n\n        root = None\n        while len(q) > 1:\n            x = q[0]\n            q.pop(0)\n            y = q[0]\n            q.pop(0)\n            f = HuffmanNode()\n            f.data = x.data + y.data\n            f.c = '-'\n            f.left = x\n            f.right = y\n            root = f\n            q.append(f)\n\n        Huffman.printCode(root, \"\")\n\nif __name__ == '__main__':\n    MyArgs = list(sys.argv)\n    argss = MyArgs[1:]\n    Huffman.main(argss)\n", "src": "class\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n\n\n\n\nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n\n\n\n\n\n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n\n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n\n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n\n\n\n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n\n\n\n\nq.add(hn); \n\n} \n\n\n\n\nHuffmanNode root = \nnull\n; \n\n\n\n\n\n\n\n\n\n\nwhile\n(q.size() > \n1\n) { \n\n\n\n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n\n\n\n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n\n\nf.left = x; \n\n\n\n\nf.right = y; \n\n\n\n\nroot = f; \n\n\n\n\nq.add(f); \n\n} \n\n\n\n\nprintCode(root, \n\"\"\n); \n\n} \n}", "index": 571, "complexity": "5"}
{"forwhile": "class Graph:  class Edge:  def compareTo(self, compareEdge):  return self.weight-compareEdge.weight  class subset:  def __init__(self):  self.parent = 0  self.rank = 0  def find(subsets, i):  if subsets[i].parent != i:  subsets[i].parent = find(subsets, subsets[i].parent)  return subsets[i].parent  def Union(subsets, x, y):  xroot = find(subsets, x)  yroot = find(subsets, y)  if subsets[xroot].rank < subsets[yroot].rank:  subsets[xroot].parent = yroot  elif subsets[xroot].rank > subsets[yroot].rank:  subsets[yroot].parent = xroot  else:  subsets[yroot].parent = xroot  subsets[xroot].rank += 1  def KruskalMST():  result = [Edge() for i in range(V)]  e = 0  i = 0  edge.sort(key=lambda x: x.weight)  subsets = [subset() for i in range(V)]  for v in range(V):  subsets[v].parent = v  subsets[v].rank = 0  i = 0  while e < V - 1:  next_edge = edge[i]  i += 1  x = find(subsets, next_edge.src)  y = find(subsets, next_edge.dest)  if x != y:  result[e] = next_edge  e += 1  Union(subsets, x, y)  print('Following are the edges in the constructed MST')  for i in range(e):  print(result[i].src, '--', result[i].dest, '==', result[i].weight)  V = 4  E = 5  graph = Graph(V, E)  graph.edge[0].src = 0  graph.edge[0].dest = 1  graph.edge[0].weight = 10  graph.edge[1].src = 0  graph.edge[1].dest = 2  graph.edge[1].weight = 6  graph.edge[2].src = 0  graph.edge[2].dest = 3  graph.edge[2].weight = 5  graph.edge[3].src = 1  graph.edge[3].dest = 3  graph.edge[3].weight = 15  graph.edge[4].src = 2  graph.edge[4].dest = 3  graph.edge[4].weight = 4  KruskalMST()", "src": "class\nGraph \n{ \n\n\n\nclass\nEdge \nimplements\nComparable<Edge> \n\n{ \n\nint\nsrc, dest, weight; \n\n\n\n\n\n\npublic\nint\ncompareTo(Edge compareEdge) \n\n{ \n\nreturn\nthis\n.weight-compareEdge.weight; \n\n} \n\n}; \n\n\n\n\nclass\nsubset \n\n{ \n\nint\nparent, rank; \n\n}; \n\n\nint\nV, E; \n\n\nEdge edge[]; \n\n\n\n\n\nGraph(\nint\nv, \nint\ne) \n\n{ \n\nV = v; \n\nE = e; \n\nedge = \nnew\nEdge[E]; \n\nfor\n(\nint\ni=\n0\n; i<e; ++i) \n\nedge[i] = \nnew\nEdge(); \n\n} \n\n\n\n\n\n\nint\nfind(subset subsets[], \nint\ni) \n\n{ \n\n\n\nif\n(subsets[i].parent != i) \n\nsubsets[i].parent = find(subsets, subsets[i].parent); \n\n\nreturn\nsubsets[i].parent; \n\n} \n\n\n\n\n\n\nvoid\nUnion(subset subsets[], \nint\nx, \nint\ny) \n\n{ \n\nint\nxroot = find(subsets, x); \n\nint\nyroot = find(subsets, y); \n\n\n\n\n\n\nif\n(subsets[xroot].rank < subsets[yroot].rank) \n\nsubsets[xroot].parent = yroot; \n\nelse\nif\n(subsets[xroot].rank > subsets[yroot].rank) \n\nsubsets[yroot].parent = xroot; \n\n\n\n\n\n\nelse\n\n{ \n\nsubsets[yroot].parent = xroot; \n\nsubsets[xroot].rank++; \n\n} \n\n} \n\n\n\n\nvoid\nKruskalMST() \n\n{ \n\nEdge result[] = \nnew\nEdge[V]; \n\n\nint\ne = \n0\n; \n\n\nint\ni = \n0\n; \n\n\nfor\n(i=\n0\n; i<V; ++i) \n\nresult[i] = \nnew\nEdge(); \n\n\n\n\n\n\n\n\nArrays.sort(edge); \n\n\n\n\nsubset subsets[] = \nnew\nsubset[V]; \n\nfor\n(i=\n0\n; i<V; ++i) \n\nsubsets[i]=\nnew\nsubset(); \n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; ++v) \n\n{ \n\nsubsets[v].parent = v; \n\nsubsets[v].rank = \n0\n; \n\n} \n\n\ni = \n0\n; \n\n\n\n\n\nwhile\n(e < V - \n1\n) \n\n{ \n\n\n\n\n\nEdge next_edge = \nnew\nEdge(); \n\nnext_edge = edge[i++]; \n\n\nint\nx = find(subsets, next_edge.src); \n\nint\ny = find(subsets, next_edge.dest); \n\n\n\n\n\n\n\n\nif\n(x != y) \n\n{ \n\nresult[e++] = next_edge; \n\nUnion(subsets, x, y); \n\n} \n\n\n\n} \n\n\n\n\n\n\nSystem.out.println(\n\"Following are the edges in \"\n+ \n\n\"the constructed MST\"\n); \n\nfor\n(i = \n0\n; i < e; ++i) \n\nSystem.out.println(result[i].src+\n\" -- \"\n+ \n\nresult[i].dest+\n\" == \"\n+ result[i].weight); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\nint\nV = \n4\n; \n\n\nint\nE = \n5\n; \n\n\nGraph graph = \nnew\nGraph(V, E); \n\n\n\n\ngraph.edge[\n0\n].src = \n0\n; \n\ngraph.edge[\n0\n].dest = \n1\n; \n\ngraph.edge[\n0\n].weight = \n10\n; \n\n\n\n\ngraph.edge[\n1\n].src = \n0\n; \n\ngraph.edge[\n1\n].dest = \n2\n; \n\ngraph.edge[\n1\n].weight = \n6\n; \n\n\n\n\ngraph.edge[\n2\n].src = \n0\n; \n\ngraph.edge[\n2\n].dest = \n3\n; \n\ngraph.edge[\n2\n].weight = \n5\n; \n\n\n\n\ngraph.edge[\n3\n].src = \n1\n; \n\ngraph.edge[\n3\n].dest = \n3\n; \n\ngraph.edge[\n3\n].weight = \n15\n; \n\n\n\n\ngraph.edge[\n4\n].src = \n2\n; \n\ngraph.edge[\n4\n].dest = \n3\n; \n\ngraph.edge[\n4\n].weight = \n4\n; \n\n\ngraph.KruskalMST(); \n\n} \n}", "index": 572, "complexity": "5"}
{"forwhile": "public\\nclass\\nprims { \\n\\n\\nclass\\nnode1 { \\n\\n\\n\\n\\nint\\ndest; \\n\\n\\n\\nint\\nweight; \\n\\n\\n\\nnode1(\\nint\\na, \\nint\\nb) \\n\\n{ \\n\\ndest = a; \\n\\nweight = b; \\n\\n} \\n\\n} \\n\\nstatic\\nclass\\nGraph { \\n\\n\\n\\n\\nint\\nV; \\n\\n\\n\\nLinkedList<node1>[] adj; \\n\\n\\n\\nGraph(\\nint\\ne) \\n\\n{ \\n\\nV = e; \\n\\nadj = \\nnew\\nLinkedList[V]; \\n\\n\\nint\\no = \\n0\\n; \\nwhile (o < V) \\n{ \\nadj[o] = \\nnew\\nLinkedList<>(); \\no++; \\n} \\n} \\n\\n} \\n\\n\\n\\n\\n\\n\\nclass\\nnode { \\n\\nint\\nvertex; \\n\\nint\\nkey; \\n} \\n\\n\\n\\n\\n\\n\\n\\nclass\\ncomparator \\nimplements\\nComparator<node> { \\n\\n\\n@Override\\n\\npublic\\nint\\ncompare(node node0, node node1) \\n\\n{ \\n\\nreturn\\nnode0.key - node1.key; \\n} \\n\\n} \\n\\n\\n\\n\\nvoid\\naddEdge(Graph graph, \\nint\\nsrc, \\nint\\ndest, \\nint\\nweight) \\n\\n{ \\n\\n\\nnode1 node0 = \\nnew\\nnode1(dest, weight); \\n\\nnode1 node = \\nnew\\nnode1(src, weight); \\n\\ngraph.adj[src].addLast(node0); \\ngraph.adj[dest].addLast(node); \\n} \\n\\n\\n\\nvoid\\nprims_mst(Graph graph) \\n\\n{ \\n\\n\\n\\nBoolean[] mstset = \\nnew\\nBoolean[graph.V]; \\nnode[] e = \\nnew\\nnode[graph.V]; \\n\\n\\nint\\no = \\n0\\n; \\nwhile (o < graph.V) \\n{ \\ne[o] = \\nnew\\nnode(); \\no++; \\n} \\n\\n\\nint\\no = \\n0\\n; \\nwhile (o < graph.V) { \\n\\n\\n\\nmstset[o] = \\nfalse\\n; \\n\\n\\n\\ne[o].key = Integer.MAX_VALUE; \\n\\ne[o].vertex = o; \\nparent[o] = -\\n1\\n; \\n\\n\\n\\no++; \\n} \\n\\n\\n\\n\\n\\nmstset[\\n0\\n] = \\ntrue\\n; \\n\\n\\n\\n\\n\\ne[\\n0\\n].key = \\n0\\n; \\n\\n\\n\\nTreeSet<node> queue = \\nnew\\nTreeSet<node>(\\nnew\\ncomparator()); \\n\\n\\n\\nint\\no = \\n0\\n; \\nwhile (o < graph.V) \\n{ \\nqueue.add(e[o]); \\no++; \\n} \\n\\n\\n\\nwhile\\n(!queue.isEmpty()) { \\n\\n\\n\\nnode node0 = queue.pollFirst(); \\n\\n\\n\\nmstset[node0.vertex] = \\ntrue\\n; \\n\\n\\n\\nnode1 iterator; \\no = \\n0\\n; \\nwhile (o < graph.adj[node0.vertex].size()) { \\n\\niterator = graph.adj[node0.vertex].get(o); \\n\\n\\nif\\n(mstset[iterator.dest] == \\nfalse\\n) { \\n\\n\\n\\n\\n\\n\\nif\\n(e[iterator.dest].key > iterator.weight) { \\nqueue.remove(e[iterator.dest]); \\ne[iterator.dest].key = iterator.weight; \\nqueue.add(e[iterator.dest]); \\nparent[iterator.dest] = node0.vertex; \\n} \\n\\n} \\n\\no++; \\n} \\n\\n} \\n\\n\\n\\nint\\no = \\n1\\n; \\nwhile (o < graph.V) \\n{ \\nSystem.out.println(parent[o] + \\n\" \"\\n\\n+ \\n\"-\"\\n\\n+ \\n\" \"\\n+ o); \\no++; \\n} \\n} \\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n{ \\nint\\nV = \\n9\\n; \\n\\nGraph graph = \\nnew\\nGraph(V); \\n\\nprims e = \\nnew\\nprims(); \\n\\n\\nint\\no = \\n0\\n; \\nwhile (o < V) \\n{ \\n\\ne.addEdge(graph, \\n0\\n, \\n1\\n, \\n4\\n); \\n\\ne.addEdge(graph, \\n0\\n, \\n7\\n, \\n8\\n); \\n\\ne.addEdge(graph, \\n1\\n, \\n2\\n, \\n8\\n); \\n\\ne.addEdge(graph, \\n1\\n, \\n7\\n, \\n11\\n); \\n\\ne.addEdge(graph, \\n2\\n, \\n3\\n, \\n7\\n); \\n\\ne.addEdge(graph, \\n2\\n, \\n8\\n, \\n2\\n); \\n\\ne.addEdge(graph, \\n2\\n, \\n5\\n, \\n4\\n); \\n\\ne.addEdge(graph, \\n3\\n, \\n4\\n, \\n9\\n); \\n\\ne.addEdge(graph, \\n3\\n, \\n5\\n, \\n14\\n); \\n\\ne.addEdge(graph, \\n4\\n, \\n5\\n, \\n10\\n); \\n\\ne.addEdge(graph, \\n5\\n, \\n6\\n, \\n2\\n); \\n\\ne.addEdge(graph, \\n6\\n, \\n7\\n, \\n1\\n); \\n\\ne.addEdge(graph, \\n6\\n, \\n8\\n, \\n6\\n); \\n\\ne.addEdge(graph, \\n7\\n, \\n8\\n, \\n7\\n); \\n\\no++; \\n} \\n\\ne.prims_mst(graph); \\n} \\n}", "src": "public\nclass\nprims { \n\nclass\nnode1 { \n\n\n\n\nint\ndest; \n\n\n\n\nint\nweight; \n\n\n\n\nnode1(\nint\na, \nint\nb) \n\n{ \n\ndest = a; \n\nweight = b; \n\n} \n\n} \n\nstatic\nclass\nGraph { \n\n\n\n\nint\nV; \n\n\n\n\nLinkedList<node1>[] adj; \n\n\n\n\nGraph(\nint\ne) \n\n{ \n\nV = e; \n\nadj = \nnew\nLinkedList[V]; \n\nfor\n(\nint\no = \n0\n; o < V; o++) \n\nadj[o] = \nnew\nLinkedList<>(); \n\n} \n\n} \n\n\n\n\n\n\n\n\nclass\nnode { \n\nint\nvertex; \n\nint\nkey; \n\n} \n\n\n\n\n\n\n\n\n\n\nclass\ncomparator \nimplements\nComparator<node> { \n\n\n@Override\n\npublic\nint\ncompare(node node0, node node1) \n\n{ \n\nreturn\nnode0.key - node1.key; \n\n} \n\n} \n\n\n\n\n\n\nvoid\naddEdge(Graph graph, \nint\nsrc, \nint\ndest, \nint\nweight) \n\n{ \n\n\nnode1 node0 = \nnew\nnode1(dest, weight); \n\nnode1 node = \nnew\nnode1(src, weight); \n\ngraph.adj[src].addLast(node0); \n\ngraph.adj[dest].addLast(node); \n\n} \n\n\n\n\nvoid\nprims_mst(Graph graph) \n\n{ \n\n\n\n\nBoolean[] mstset = \nnew\nBoolean[graph.V]; \n\nnode[] e = \nnew\nnode[graph.V]; \n\n\n\n\nint\n[] parent = \nnew\nint\n[graph.V]; \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\ne[o] = \nnew\nnode(); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) { \n\n\n\n\nmstset[o] = \nfalse\n; \n\n\n\n\ne[o].key = Integer.MAX_VALUE; \n\ne[o].vertex = o; \n\nparent[o] = -\n1\n; \n\n} \n\n\n\n\nmstset[\n0\n] = \ntrue\n; \n\n\n\n\n\n\n\n\ne[\n0\n].key = \n0\n; \n\n\n\n\nTreeSet<node> queue = \nnew\nTreeSet<node>(\nnew\ncomparator()); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\nqueue.add(e[o]); \n\n\n\n\nwhile\n(!queue.isEmpty()) { \n\n\n\n\nnode node0 = queue.pollFirst(); \n\n\n\n\nmstset[node0.vertex] = \ntrue\n; \n\n\n\n\nfor\n(node1 iterator : graph.adj[node0.vertex]) { \n\n\n\n\nif\n(mstset[iterator.dest] == \nfalse\n) { \n\n\n\n\n\n\n\n\n\nif\n(e[iterator.dest].key > iterator.weight) { \n\nqueue.remove(e[iterator.dest]); \n\ne[iterator.dest].key = iterator.weight; \n\nqueue.add(e[iterator.dest]); \n\nparent[iterator.dest] = node0.vertex; \n\n} \n\n} \n\n} \n\n} \n\n\n\n\nfor\n(\nint\no = \n1\n; o < graph.V; o++) \n\nSystem.out.println(parent[o] + \n\" \"\n\n+ \n\"-\"\n\n+ \n\" \"\n+ o); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nV = \n9\n; \n\n\nGraph graph = \nnew\nGraph(V); \n\n\nprims e = \nnew\nprims(); \n\n\ne.addEdge(graph, \n0\n, \n1\n, \n4\n); \n\ne.addEdge(graph, \n0\n, \n7\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n2\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n7\n, \n11\n); \n\ne.addEdge(graph, \n2\n, \n3\n, \n7\n); \n\ne.addEdge(graph, \n2\n, \n8\n, \n2\n); \n\ne.addEdge(graph, \n2\n, \n5\n, \n4\n); \n\ne.addEdge(graph, \n3\n, \n4\n, \n9\n); \n\ne.addEdge(graph, \n3\n, \n5\n, \n14\n); \n\ne.addEdge(graph, \n4\n, \n5\n, \n10\n); \n\ne.addEdge(graph, \n5\n, \n6\n, \n2\n); \n\ne.addEdge(graph, \n6\n, \n7\n, \n1\n); \n\ne.addEdge(graph, \n6\n, \n8\n, \n6\n); \n\ne.addEdge(graph, \n7\n, \n8\n, \n7\n); \n\n\n\n\ne.prims_mst(graph); \n\n} \n}", "index": 573, "complexity": "5"}
{"forwhile": "public\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n\n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n\n\n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\ni = \n0\n; \nwhile i < n / \n2\n: \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\ni += \n1\n\n\n\n\n\nint\nMaximumSum = \n0\n; \n\n\n\n\n\n\n\n\ndefine LoopCondition1(i, n):\n    return i < n - \n1\n\ni = \n0\n; \nwhile LoopCondition1(i, n): \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\ni += \n1\n\n\n\n\n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n\nreturn\nMaximumSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n\n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n\n\n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n\n\n\n\n\n\nint\nMaximumSum = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n\n\n\n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n\n\nreturn\nMaximumSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n}", "index": 574, "complexity": "5"}
{"forwhile": "class MaxSum {\n\n\n\n\n\nstatic int maxSum(\nint arr[], \nint n) {\n\nint sum = 0;\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\nint i = 0;\nwhile (i < n/2) {\n\nsum -= (2 * arr[i]); \n\nsum += (2 * arr[n - i - 1]); \n\ni++;\n\n}\n\n\nreturn sum;\n\n}\n\n\n\n\npublic static void main (String[] args) {\n\nint arr[] = { 4, 2, 1, 8}; \n\nint n = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n}\n}", "src": "class\nMaxSum \n{ \n\n\n\n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n}", "index": 575, "complexity": "5"}
{"forwhile": "class GFG { static int maxLevel(int[] boxes, int n) { Arrays.sort(boxes); int ans = 1; int prev_width = boxes[0]; int prev_count = 1; int curr_count = 0; int curr_width = 0; int i = 1; while(i < n) { curr_width += boxes[i]; curr_count += 1; if(curr_width > prev_width && curr_count > prev_count) { prev_width = curr_width; prev_count = curr_count; curr_count = 0; curr_width = 0; ans++; } i++; } return ans; } static public void main (String[] args) { int[] boxes = {10, 20, 30, 50, 60, 70}; int n = boxes.length; System.out.println(maxLevel(boxes, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxLevel(\nint\n[]boxes, \nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(boxes); \n\n\nint\nans = \n1\n; \n\n\n\n\n\n\n\n\n\nint\nprev_width = boxes[\n0\n]; \n\nint\nprev_count = \n1\n; \n\n\n\n\n\n\nint\ncurr_count = \n0\n; \n\n\n\n\nint\ncurr_width = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\ncurr_width += boxes[i]; \n\ncurr_count += \n1\n; \n\n\n\n\n\n\n\n\nif\n(curr_width > prev_width && \n\ncurr_count > prev_count) \n\n{ \n\n\n\n\n\n\n\n\nprev_width = curr_width; \n\nprev_count = curr_count; \n\n\n\n\n\n\n\n\ncurr_count = \n0\n; \n\ncurr_width = \n0\n; \n\n\n\n\n\n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]boxes = {\n10\n, \n20\n, \n30\n, \n50\n, \n60\n, \n70\n}; \n\nint\nn = boxes.length; \n\nSystem.out.println(maxLevel(boxes, n)); \n\n} \n}", "index": 576, "complexity": "5"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\nstatic\\nint\\nmaxDifference(\\nint\\narr[], \\nint\\nN, \\nint\\nk) \\n{ \\n\\nint\\nM, S = \\n0\\n, S1 = \\n0\\n, max_difference = \\n0\\n; \\n\\n\\n\\nint\\ni = \\n0\\n;\\nwhile i < N:\\n\\nS += arr[i]; \\n\\ni += \\n1\\n;\\nint\\ntemp; \\n\\n\\n\\nint\\ni = \\n0\\n;\\nwhile i < N:\\n\\n{ \\n\\nint\\nj = i + \\n1\\n;\\nwhile nj < N:\\n\\n{ \\n\\nif\\n(arr[i] < arr[j]) \\n\\n{ \\n\\ntemp = arr[i]; \\n\\narr[i] = arr[j]; \\n\\narr[j] = temp; \\n\\n} \\n\\nj += \\n1\\n;\\n} \\n\\ni += \\n1\\n;\\n} \\n\\n\\nM = Math.max(k, N - k); \\n\\nint\\ni = \\n0\\n;\\nwhile i < M:\\n\\n{ \\n\\nS1 += arr[i]; \\n\\ni += \\n1\\n;\\n} \\n\\n\\n\\nmax_difference = S1 - (S - S1); \\n\\nreturn\\nmax_difference; \\n} \\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n{ \\n\\nint\\narr[] = { \\n8\\n, \\n4\\n, \\n5\\n, \\n2\\n, \\n10\\n}; \\n\\nint\\nN = arr.length; \\n\\nint\\nk = \\n2\\n; \\n\\nSystem.out.println(maxDifference(arr, N, k)); \\n} \\n}", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxDifference(\nint\narr[], \nint\nN, \nint\nk) \n{ \n\nint\nM, S = \n0\n, S1 = \n0\n, max_difference = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nS += arr[i]; \n\nint\ntemp; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\n{ \n\nif\n(arr[i] < arr[j]) \n\n{ \n\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n} \n\n\nM = Math.max(k, N - k); \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nS1 += arr[i]; \n\n\n\n\nmax_difference = S1 - (S - S1); \n\nreturn\nmax_difference; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n8\n, \n4\n, \n5\n, \n2\n, \n10\n}; \n\nint\nN = arr.length; \n\nint\nk = \n2\n; \n\nSystem.out.println(maxDifference(arr, N, k)); \n} \n}", "index": 577, "complexity": "5"}
{"forwhile": "class GFG { static void findElements( int arr[], int n) { Arrays.sort(arr); int i = 0; while (i < n - 2) System.out.print(arr[i] + \" \"); i++; } public static void main(String args[]) { int arr[] = { 2, -6, 3, 5, 1}; int n = arr.length; findElements(arr, n); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n}", "index": 578, "complexity": "5"}
{"forwhile": "class MinSum \n{ \n\n\n\n\n\nstatic long findMinSum(\nlong a[], \nlong b[], \nlong n) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong sum = 0; \n\nint i = 0; \nwhile (i < n) \n{\nsum = sum + Math.abs(a[i] - b[i]); \n\ni++; \n} \n\n\nreturn sum; \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\n\n\nlong a[] = {\n4, 1, 8, 7}; \n\nlong b[] = {\n2, 3, 6, 5}; \n\nint n = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "src": "class\nMinSum \n{ \n\n\n\n\n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "index": 579, "complexity": "5"}
{"forwhile": "class MinSum {\npublic static long solve(int[] a) {\nPriorityQueue<Integer> pq = new PriorityQueue<Integer>();\nStringBuilder num1 = new StringBuilder();\nStringBuilder num2 = new StringBuilder();\nint i = 0;\nint len = a.length;\nwhile (i < len) {\nint x = a[i];\npq.add(x);\ni++;\n}\nfor (Integer element : pq) {\nnum1.append(element + \"\");\nif (!pq.isEmpty()) {\nnum2.append(pq.poll() + \"\");\n}\n}\nlong sum = Long.parseLong(num1.toString()) + Long.parseLong(num2.toString());\nreturn sum;\n}\npublic static void main(String[] args) {\nint arr[] = {6, 8, 4, 5, 2, 3};\nSystem.out.println(\"The required sum is \" + solve(arr));\n}\n}", "src": "class\nMinSum \n{ \n\n\n\n\n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n\n\n\n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n\n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n\n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n\n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n}", "index": 580, "complexity": "5"}
{"forwhile": "class GFG :\n\n    public static int DecreasingArray(int a[], int n) :\n\n        int sum = 0, dif = 0\n\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>()\n\n\n\n\n        int i = 0\n        while i < n :\n\n            if not pq.isEmpty() and pq.element() < a[i] :\n\n                dif = a[i] - pq.element()\n                sum += dif\n                pq.remove()\n                pq.add(a[i])\n\n            pq.add(a[i])\n\n            i += 1\n\n        return sum\n\n\n\n    public static void main(String[] args) :\n\n\n        int[] a = {3, 1, 2, 1}\n\n\n        int n = a.length\n\n\n        System.out.println(DecreasingArray(a, n))\n", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n}", "index": 581, "complexity": "5"}
{"forwhile": "class GFG \n{ \nstatic int MinOperation(\nint a[], \n\nint b[], \n\nint n) \n{ \n  Arrays.sort(a); \n  Arrays.sort(b); \n  int result = 0; \n  int i = 0; \n  while (i < n) \n  { \n    if (a[i] > b[i]) \n      result = result + Math.abs(a[i] - b[i]); \n    else if (a[i] < b[i]) \n      result = result + Math.abs(a[i] - b[i]); \n    i++; \n  } \n  return result; \n} \n\npublic static void main (String[] args) \n{ \n  int a[] = { 3, 1, 1 }; \n  int b[] = { 1, 2, 2 }; \n  int n = a.length; \n  System.out.println(MinOperation(a, b, n)); \n} \n}", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n\n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n}", "index": 582, "complexity": "5"}
{"forwhile": "class GFG { static boolean ifPossible( int arr[], int n) { int copy[] = Arrays.copyOf(arr, arr.length); Arrays.sort(copy); int i = 0; while (i < n) { if (!(arr[i] == copy[i]) && !(arr[n - 1 - i] == copy[i])) return false; i++; } return true; } public static void main(String[] args) { int arr[] = { 1, 7, 6, 4, 5, 3, 2, 8}; int n = arr.length; if (ifPossible(arr, n)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n\n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 583, "complexity": "5"}
{"forwhile": "class GFG : \n\n    @staticmethod \n    def MaxTotalRectangleArea(a, n) : \n\n        a.sort() \n        sum = 0 \n        flag = False \n        len = 0 \n        i = 0 \n        while i < n : \n            if (a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and not flag : \n                flag = True \n                len = a[i + 1] \n                i += 1 \n            elif (a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and flag : \n                sum = sum + a[i + 1] * len \n                flag = False \n                i += 1 \n            i += 1 \n        return sum \n\n    @staticmethod \n    def main(args) : \n        a = [10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8] \n        n = len(a) \n        print(GFG.MaxTotalRectangleArea(a, n))", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n\n\n\n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n\n\n\n\n\n\nflag = \ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlen = a[i + \n1\n]; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n\n\n\n\nsum = sum + a[i + \n1\n] * len; \n\n\n\n\n\n\n\n\n\n\nflag = \nfalse\n; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n}", "index": 584, "complexity": "5"}
{"forwhile": "public class FractionalKnapSack  {\n\n\n\npublic static void main(String[] args) \n\n{ \n\nint[] wt = {10, 40, 20, 30}; \n\nint[] val = {60, 40, 100, 120}; \n\nint capacity = 50; \n\ndouble maxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\"Maximum value we can obtain = \"+ maxValue); \n\n\n} \n\n\n\nprivate static double getMaxValue( int[] wt, int[] val, int capacity) \n\n{ \n\nItemValue[] iVal = new ItemValue[wt.length]; \n\n\nint i = 0; \n\nwhile (i < wt.length) \n\n{ \n\niVal[i] = new ItemValue(wt[i], val[i], i); \n\ni++; \n\n} \n\n\n\nItemValue[] tempArr = new ItemValue[iVal.length]; \n\ni = 0; \n\nfor (ItemValue item : iVal) \n\n{ \n\ntempArr[i] = item; \n\ni += 1; \n\n} \n\n\n\nArrays.sort(tempArr, new Comparator<ItemValue>() \n\n{ \n\n@Override\n\npublic int compare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn o2.cost.compareTo(o1.cost); \n\n} \n\n}); \n\n\n\ndouble totalValue = 0d; \n\n\nint j = 0; \n\nfor (j = 0; j < tempArr.length; j++) \n\n{ \n\nItemValue i = tempArr[j]; \n\n\nint curWt = (int) i.wt; \n\nint curVal = (int) i.val; \n\n\nif (capacity - curWt >= 0) \n\n{ \n\ncapacity = capacity - curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse \n\n{ \n\n\n\ndouble fraction = ((double) capacity / (double) curWt); \n\ntotalValue += (curVal * fraction); \n\ncapacity = (int) (capacity - (curWt * fraction)); \n\nbreak; \n\n} \n\n\n\n} \n\n\nreturn totalValue; \n\n} \n\n\n\n\nstatic class ItemValue \n\n{ \n\nDouble cost; \n\ndouble wt, val, ind; \n\n\n\n\npublic ItemValue(int wt, int val, int ind) \n\n{ \n\nthis.wt = wt; \n\nthis.val = val; \n\nthis.ind = ind; \n\ncost = new Double(val/wt ); \n\n} \n\n} \n}", "src": "public\nclass\nFractionalKnapSack \n{ \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n\n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n\n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n\n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n\n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n\n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n\n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n}", "index": 585, "complexity": "5"}
{"forwhile": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nint\ni = \n0\n; \nwhile i < n: \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nn = n - k; \n\ni += 1 \n}\n\nreturn\nres; \n\n} \n\n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nint\ni = n - \n1\n; \nwhile i >= index: \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nindex += k; \n\ni -= 1 \n}\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \" \n+ findMaximum(arr, n, k)); \n\n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n}", "index": 586, "complexity": "5"}
{"forwhile": "class GFG { static long calculate( long a[], int n) { Arrays.sort(a); int i,j; Vector<Long> s = new Vector<>(); i = 0; j = n - 1; while (i < j) { s.add((a[i] + a[j])); i++; j--; } long mini = Collections.min(s); long maxi = Collections.max(s); return Math.abs(maxi - mini); } public static void main(String[] args) { long a[] = { 2, 6, 4, 3 }; int n = a.length; System.out.println(calculate(a, n)); } }", "src": "class\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n\n\nArrays.sort(a); \n\nint\ni,j; \n\n\n\n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n}", "index": 587, "complexity": "5"}
{"forwhile": "class MinHeap: \n\n    def __init__(self, a, size): \n        self.heap_size = size \n        self.capacity = size \n        self.harr = a \n        i = (self.heap_size - 1) // 2 \n        while i >= 0: \n            self.MinHeapify(i) \n            i -= 1 \n\n    def MinHeapify(self, i): \n        l = self.left(i) \n        r = self.right(i) \n        smallest = i \n        if l < self.heap_size and self.harr[l] < self.harr[i]: \n            smallest = l \n        if r < self.heap_size and self.harr[r] < self.harr[smallest]: \n            smallest = r \n        if smallest != i: \n            self.swap(i, smallest) \n            self.MinHeapify(smallest) \n\n    def parent(self, i): \n        return (i - 1) // 2 \n\n    def left(self, i): \n        return 2 * i + 1 \n\n    def right(self, i): \n        return 2 * i + 2 \n\n    def extractMin(self): \n        if self.heap_size <= 0: \n            return float('inf') \n        if self.heap_size == 1: \n            self.heap_size -= 1 \n            return self.harr[0] \n        root = self.harr[0] \n        self.harr[0] = self.harr[self.heap_size - 1] \n        self.heap_size -= 1 \n        self.MinHeapify(0) \n        return root \n\n    def insertKey(self, k): \n        if self.heap_size == self.capacity: \n            print('Overflow: Could not insertKey') \n            return \n        self.heap_size += 1 \n        i = self.heap_size - 1 \n        self.harr[i] = k \n        while i != 0 and self.harr[self.parent(i)] > self.harr[i]: \n            self.swap(i, self.parent(i)) \n            i = self.parent(i) \n\n    def isSizeOne(self): \n        return self.heap_size == 1 \n\n    def swap(self, x, y): \n        temp = self.harr[x] \n        self.harr[x] = self.harr[y] \n        self.harr[y] = temp \n\n    @staticmethod \n    def minCost(length, n): \n        cost = 0 \n        minHeap = MinHeap(length, n) \n        while not minHeap.isSizeOne(): \n            min_val = minHeap.extractMin() \n            sec_min = minHeap.extractMin() \n            cost += (min_val + sec_min) \n            minHeap.insertKey(min_val + sec_min) \n        return cost \n\n    @staticmethod \n    def main(args): \n        length = [4, 3, 2, 6] \n        size = len(length) \n        print('Total cost for connecting ropes is', MinHeap.minCost(length, size))", "src": "class\nMinHeap { \n\nint\n[] harr; \n\n\nint\nheap_size; \n\n\nint\ncapacity; \n\n\n\n\n\n\n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n\n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n\n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n\n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n\n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n\n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n\n\n\n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n\n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n\n\n\n\n\n\n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n\n\nwhile\n(!minHeap.isSizeOne()) { \n\n\n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n\n\n\n\n\n\n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n\n\n\n\nreturn\ncost; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n};", "index": 588, "complexity": "5"}
{"forwhile": "class GFG { static int minCost(int coin[], int n, int k) { Arrays.sort(coin); int coins_needed = (int)Math.ceil(1.0 * n / (k + 1)); int ans = 0; int i = 0; while (i <= coins_needed - 1) { ans += coin[i]; i++; } return ans; } public static void main(String arg[]) { int coin[] = { 8, 5, 3, 10, 2, 1, 15, 25 }; int n = coin.length; int k = 3; System.out.print(minCost(coin, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\n\n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n\n\n\n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n}", "index": 589, "complexity": "5"}
{"forwhile": "import java.util.Arrays;\npublic class GFG {\n\n\n    static void preprocess(int[] coin, int n) {\n        Arrays.sort(coin);\n        int i = 1;\n        while (i <= n - 1) {\n            coin[i] += coin[i - 1];\n            i++;\n        }\n    }\n\n\n    static int minCost(int[] coin, int n, int k) {\n        int coins_needed = (int) Math.ceil(1.0 * n / (k + 1));\n        return coin[coins_needed - 1];\n    }\n\n\n    static public void main(String[] args) {\n        int[] coin = {8, 5, 3, 10, 2, 1, 15, 25};\n        int n = coin.length;\n\n        preprocess(coin, n);\n\n        int k = 3;\n        System.out.println(minCost(coin, n, k));\n\n        for (k = 7; k != 0 && k < 8; k++) {\n            System.out.println(minCost(coin, n, k));\n        }\n    }\n}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n\n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n}", "index": 590, "complexity": "5"}
{"forwhile": "n = len(arr)\ni = 1\nj = 0\nplat_needed = 1\nresult = 1\nwhile i < n and j < n:\n    if arr[i] <= dep[j]:\n        plat_needed += 1\n        i += 1\n        if plat_needed > result:\n            result = plat_needed\n    else:\n        plat_needed -= 1\n        j += 1\nprint(result)", "src": "class\nGFG { \n\n\nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n\n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n\n\n\n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n\n\n\n\nwhile\n(i < n && j < n) \n\n{ \n\n\n\n\n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n\n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n\n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n}", "index": 591, "complexity": "5"}
{"forwhile": "class GFG { static int getMinDiff(int arr[], int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } int i = 1; while (i < n-1) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) continue; if (big - subtract <= add - small) small = subtract; else big = add; i++; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = { 4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \" + getMinDiff(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 592, "complexity": "5"}
{"forwhile": "class\nGFG { \n\n\n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n\n\n\nint\ni = \n0\n; \nwhile i < n:\n\n\n\n\n\nif\n((max - arr[i]) % k != \n0\n): \n\nreturn\n-\n1\n; \n\n\n\n\nelse:\n\nres += (max - arr[i]) / k; \n\ni += 1\n\n\n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n}", "src": "class\nGFG { \n\n\n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n\n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n}", "index": 593, "complexity": "5"}
{"forwhile": "class GFG { static int minElements( int arr[], int n) { int halfSum = 0; int i = 0; while i < n { halfSum = halfSum + arr[i]; i++; } halfSum = halfSum / 2; Arrays.sort(arr); int res = 0, curr_sum = 0; int i = n - 1; for i >= 0 { curr_sum += arr[i]; res++; if curr_sum > halfSum { return res; } i--; } return res; } public static void main (String[] args) { int arr[] = {3, 1, 7, 1}; int n = arr.length; System.out.println(minElements(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n\n\n\n\n\n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n\n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n}", "index": 594, "complexity": "5"}
{"forwhile": "class Main { static void minAbsSumPair(int arr[], int n) { int sum, min_sum = 999999; int l = 0, r = n-1; int min_l = l, min_r = n-1; if (n < 2) { System.out.println(\"Invalid Input\"); return; } sort(arr, l, r); for (l = 0; l < r;) { sum = arr[l] + arr[r]; if (Math.abs(sum) < Math.abs(min_sum)) { min_sum = sum; min_l = l; min_r = r; } if (sum < 0) l++; else r--; } System.out.println(\" The two elements whose \" + \"sum is minimum are \" + arr[min_l]+ \" and \"+arr[min_r]); } public static void main (String[] args) { int arr[] = {1, 60, -10, 70, -80, 85}; int n = arr.length; minAbsSumPair(arr, n); } static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low - 1); j = low; while (j < high) { if (arr[j] <= pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } j++; } int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return i + 1; } static void sort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); sort(arr, low, pi - 1); sort(arr, pi + 1, high); } } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 595, "complexity": "5"}
{"forwhile": "class GFG: \n\n    public static void kLargest(Integer[] arr, int k): \n\n        Arrays.sort(arr, Collections.reverseOrder()) \n\n        i = 0 \n        while i < k: \n            System.out.print(arr[i] + \" \") \n            i += 1 \n\n    public static void main(String[] args): \n\n        Integer arr[] = new Integer[] { 1, 23, 12, 9, 30, 2, 50 } \n        k = 3 \n        kLargest(arr, k) ", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n\n\n\n\n\n\n\n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n}", "index": 596, "complexity": "5"}
{"forwhile": "n = scanner.nextInt()\nm = scanner.nextInt()\na = [0] * (n + 1)\nb = [0] * (n + 1)\ni = 0\nwhile i < n:\n    a[i] = scanner.nextInt()\n    i += 1\ni = 0\nwhile i < n:\n    b[i] = scanner.nextInt()\n    i += 1\nb[n] = b[0]\nERROR = 0.0000001\nmax = 1000000000\nmin = 0\nfound = False\nwhile max >= min:\n    mid = max + min\n    mid /= 2\n    v = isValid(a, b, m, n, mid)\n    if v:\n        max = mid\n    else:\n        min = mid\n    if max - min <= ERROR and v:\n        found = True\n        break\n    if max == min:\n        break\nif found:\n    print(max)\nelse:\n    print(-1)\n\n\ndef isValid(a, b, m, n, fuel):\n    total = m + fuel\n    i = 0\n    while i < n:\n        lost = total\n        lost /= a[i]\n        total -= lost\n\n        lost = total\n        lost /= b[i + 1]\n        total -= lost\n        if total - m < 0:\n            return False\n        i += 1\n    if total - m < 0:\n        return False\n    return True", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 598, "complexity": "5"}
{"forwhile": "n = scanner.nextBigInteger()\nk = scanner.nextBigInteger()\nscanner.nextLine()\nstring = scanner.nextLine()\nch = list(string)\nans = 0\nnumber = 0\nch.sort()\nprev = 0\ni = 0\nwhile BigInteger(i).subtract(n).compareTo(0) < 0:\n    if i == 0:\n        ans += ch[i] - ord('a') + 1\n        prev = i\n        number += 1\n    else:\n        if ch[i] - ch[prev] > 1:\n            ans += ch[i] - ord('a') + 1\n            prev = i\n            number += 1\n    if number == k:\n        break\n    i += 1\nif number - k < 0:\n    System.out.println(-1)\nelse:\n    System.out.println(ans)", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 599, "complexity": "5"}
{"forwhile": "def SQR(a):\n\treturn a * a\n\ndef main():\n\timport array\n\tn = int(input())\n\tk = int(input())\n\tstr = input()\n\ts = array.array('u', str)\n\ts = sorted(s)\n\tstr = ''.join(s)\n\td = 0\n\tans = 0\n\ti = 0\n\twhile i < len(str):\n\t\tx = ord(str[i]) - ord('a')\n\t\tif k == 0:\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tif x >= d:\n\t\t\tans = ans + x + 1\n\t\t\td = x + 2\n\t\t\tk = k - 1\n\t\ti += 1\n\tif k > 0:\n\t\tans = -1\n\tprint(ans)\n\nmain()", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 600, "complexity": "5"}
{"forwhile": "class GFG { static int k = 16; static int N = 100000; static long table[][] = new long[N][k + 1]; static void buildSparseTable(int arr[], int n) { int i = 0; while(i < n) { table[i][0] = arr[i]; i++; } int j = 1; while(j <= k) { int i = 0; while(i <= n - (1 << j)) { table[i][j] = table[i][j - 1] + table[i + (1 << (j - 1))][j - 1]; i++; } j++; } } static long query(int L, int R) { long answer = 0; int j = k; while(j >= 0) { if(L + (1 << j) - 1 <= R) { answer = answer + table[L][j]; L += 1 << j; } j--; } return answer; } public static void main(String args[]) { int arr[] = { 3, 7, 2, 5, 8, 9 }; int n = arr.length; buildSparseTable(arr, n); System.out.println(query(0, 5)); System.out.println(query(3, 5)); System.out.println(query(2, 4)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nk = \n16\n; \n\n\nstatic\nint\nN = \n100000\n; \n\n\n\nstatic\nlong\ntable[][] = \nnew\nlong\n[N][k + \n1\n]; \n\n\nstatic\nvoid\nbuildSparseTable(\nint\narr[], \n\nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntable[i][\n0\n] = arr[i]; \n\n\nfor\n(\nint\nj = \n1\n; j <= k; j++) \n\nfor\n(\nint\ni = \n0\n; i <= n - (\n1\n<< j); i++) \n\ntable[i][j] = table[i][j - \n1\n] + \n\ntable[i + (\n1\n<< (j - \n1\n))][j - \n1\n]; \n} \n\n\n\nstatic\nlong\nquery(\nint\nL, \nint\nR) \n{ \n\n\n\n\n\nlong\nanswer = \n0\n; \n\nfor\n(\nint\nj = k; j >= \n0\n; j--) \n\n{ \n\nif\n(L + (\n1\n<< j) - \n1\n<= R) \n\n{ \n\nanswer = answer + table[L][j]; \n\n\n\n\n\n\nL += \n1\n<< j; \n\n} \n\n} \n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n3\n, \n7\n, \n2\n, \n5\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nbuildSparseTable(arr, n); \n\n\nSystem.out.println(query(\n0\n, \n5\n)); \n\nSystem.out.println(query(\n3\n, \n5\n)); \n\nSystem.out.println(query(\n2\n, \n4\n)); \n} \n}", "index": 601, "complexity": "5"}
{"forwhile": "class loser:\n    class InputReader:\n        def __init__(self, stream):\n            self.br = BufferedReader(InputStreamReader(stream), 32768)\n            self.token = None\n\n        def next(self):\n            while self.token is None or not self.token.hasMoreTokens():\n                try:\n                    self.token = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n            return self.token.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n    class card:\n        def __init__(self, s, i):\n            self.s = s\n            self.l = i\n\n    class sort:\n        def compare(self, o1, o2):\n            if o1.l != o2.l:\n                return o1.l - o2.l\n            else:\n                return o1.s.compareTo(o2.s)\n\n    def shuffle(a):\n        l = []\n        i = 0\n        while i < len(a):\n            l.append(a[i])\n            i += 1\n        Collections.shuffle(l)\n        i = 0\n        while i < len(a):\n            a[i] = l[i]\n            i += 1\n\n    class Pair:\n        def __init__(self, a, b):\n            self.a = a\n            self.b = b\n\n    sc = InputReader(System.in)\n    n = sc.nextInt()\n    m = {}\n    i = 0\n    while i < n:\n        t = sc.next()\n        if t in m:\n            m[t] += 1\n        else:\n            m[t] = 1\n        i += 1\n    ans = 0\n    i = 0\n    while i < n:\n        t = sc.next()\n        if t in m and m[t] > 0:\n            m[t] -= 1\n            ans += 1\n        i += 1\n    print(n - ans)", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 602, "complexity": "5"}
{"forwhile": "public class Fly:\n\n    ERROR = 0.0000001\n\n    def main():\n        n =  int(input())\n        m = int(input())\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        i = 0\n        while i < n:\n            a[i] = int(input())\n            i += 1\n\n        i = 0\n        while i < n:\n            b[i] = int(input())\n            i += 1\n        b[n] = b[0]\n\n        max_val =  1000000000\n        min_val = 0\n        found = False\n        while max_val >= min_val:\n            mid = max_val + min_val\n            mid /= 2\n            v = is_valid(a, b, m, n, mid)\n            \n            if v:\n                max_val = mid\n            else:\n                min_val = mid\n            if max_val - min_val <= ERROR and v:\n                found = True\n                break\n            if max_val ==  min_val:\n                break\n        \n        if found:\n            print(max_val)\n        else:\n            print(-1)\n\n    def is_valid(a, b, m, n, fuel):\n        total = m + fuel\n        i = 0\n        while i < n:\n            lost = total\n            lost /= a[i]\n            total -= lost\n\n            lost = total\n            lost /= b[i + 1]\n            total -= lost\n            if (total - m) < 0:\n                return False\n            i += 1\n        if (total - m) < 0:\n            return False\n        return True\n", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 603, "complexity": "5"}
{"forwhile": "n = scanner.nextBigInteger()\nk = scanner.nextBigInteger()\nscanner.nextLine()\nstring = scanner.nextLine()\nch = list(string)\nans = BigInteger.ZERO\nnumber = BigInteger.ZERO\nch.sort()\nprev = 0\ni = 0\nwhile BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0:\n    if i == 0:\n        ans = ans.add(BigInteger.valueOf(ord(ch[i]) - ord('a') + 1))\n        prev = i\n        number = number.add(BigInteger.ONE)\n    else:\n        if ord(ch[i]) - ord(ch[prev]) > 1:\n            ans = ans.add(BigInteger.valueOf(ord(ch[i]) - ord('a') + 1))\n            prev = i\n            number = number.add(BigInteger.ONE)\n    if number.equals(k):\n        break\n    i += 1\nif number.subtract(k).compareTo(BigInteger.ZERO) < 0:\n    print(-1)\nelse:\n    print(ans)", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 604, "complexity": "5"}
{"forwhile": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tint i = 0;\n\t\twhile(i < str.length()) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0){\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 605, "complexity": "5"}
{"forwhile": "class GFG { static int getMinDiff(int arr[], int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } int i = 1; while (i < n-1) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) { i ++; continue; } if (big - subtract <= add - small) small = subtract; else big = add; i ++; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = {4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \"+ getMinDiff(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 606, "complexity": "5"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 195 column 22 (char 5307)", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            \n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "index": 607, "complexity": "5"}
{"forwhile": "import java.util.*;\nimport java.io.*;\n\npublic class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        int i = 0;\n        while(i < n) {\n            a[i] = rd.nextInt();\n            i++;\n        }\n        i = 0;\n        while(i < n) {\n            b[i] = rd.nextInt();\n            i++;\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        int i = 0;\n        while(i < n * 2) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n            i++;\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            int i = 0;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n                i++;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            int i = 0;\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            int i = 0;\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                i = 0;\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                    i++;\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "src": "public class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "index": 608, "complexity": "5"}
{"forwhile": "ERROR:Expecting ':' delimiter: line 497 column 23 (char 16616)", "src": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}", "index": 609, "complexity": "5"}
{"forwhile": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        int i = 0;\n        while (i < n) {\n            int x = s.nextInt();\n            if (!map.containsKey(x)) {\n                map.put(x, 1);\n                max = Math.max(max, 1);\n            } else {\n                map.put(x, map.get(x) + 1);\n                max = Math.max(max, map.get(x));\n            }\n            i++;\n        }\n\n        System.out.println(max);\n    }\n\n}", "src": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}", "index": 610, "complexity": "5"}
{"forwhile": "class GFG { static int findMinDiff(int[] arr, int n) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; int i = 0; while(i < n - 1) { if(arr[i + 1] - arr[i] < diff) diff = arr[i + 1] - arr[i]; i++; } return diff; } public static void main(String[] args) { int arr[] = new int[]{ 1, 5, 3, 19, 18, 25 }; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 611, "complexity": "5"}
{"forwhile": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < m) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tint j = 0;\n\t\t\twhile (j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 612, "complexity": "5"}
{"forwhile": "class\nAlternativeString \n{ \n\n\n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni = 0, j = n-\n1\n; \n\nfor ( ; i < j; ) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nArrays.sort(arr); \n\nint\ni = 0, j = n-\n1\n; \n\nwhile (i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n}", "src": "class\nAlternativeString \n{ \n\n\n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\n\n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n}", "index": 613, "complexity": "5"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            int i = 0;\n            while (i < n1) {\n                p1[i] = in.nextInt();\n                i++;\n            }\n            int[] p2 = new int[n2];\n            i = 0;\n            while (i < n2) {\n                p2[i] = in.nextInt();\n                i++;\n            }\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "index": 614, "complexity": "5"}
{"forwhile": "class\\nGFG \\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\nrearrange(\\nint\\n[] arr, \\nint\\nn, \\nint\\nx) \\n\\n{ \\n\\nTreeMap<Integer, ArrayList<Integer>> m = \\nnew\\nTreeMap<>(); \\n\\n\\n\\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile (i < n) \\n\\n{ \\n\\nint\\ndiff = Math.abs(x - arr[i]); \\n\\nif\\n(m.containsKey(diff)) \\n\\n{ \\n\\nArrayList<Integer> al = m.get(diff); \\n\\nal.add(arr[i]); \\n\\nm.put(diff, al); \\n\\n} \\n\\nelse\\n\\n{ \\n\\nArrayList<Integer> al = \\nnew\\nArrayList<>(); \\n\\nal.add(arr[i]); \\n\\nm.put(diff,al); \\n\\n} \\n\\ni++; \\n} \\n\\n\\n\\nint\\nindex = \\n0\\n; \\nfor\\n(Map.Entry entry : m.entrySet()) \\n\\n{ \\n\\nArrayList<Integer> al = m.get(entry.getKey()); \\n\\nint\\ni = \\n0\\n; \\nwhile (i < al.size()) \\n\\narr[index++] = al.get(i); \\n\\ni++; \\n} \\n\\n} \\n\\n\\n\\nstatic\\nvoid\\nprintArray(\\nint\\n[] arr, \\nint\\nn) \\n\\n{ \\n\\nint\\ni = \\n0\\n; \\nwhile (i < n) \\n\\nSystem.out.print(arr[i] + \\n\\\" \\\"\\n); \\n\\ni++; \\n} \\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\n[] arr = {\\n10\\n, \\n5\\n, \\n3\\n, \\n9\\n,\\n2\\n}; \\n\\nint\\nn = arr.length; \\n\\nint\\nx = \\n7\\n; \\n\\nrearrange(arr, n, x); \\n\\nprintArray(arr, n); \\n\\n} \\n}", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n\n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n}", "index": 615, "complexity": "5"}
{"forwhile": "from queue import PriorityQueue\n\nn, k = map(int, input().split())\nnum = list(map(int, input().split()))\n\npq = PriorityQueue()\ni = 0\nwhile i < n:\n\tpq.put(num[i])\n\ti += 1\n\nif k == 0:\n\ty = pq.get()\n\tif y == 1:\n\t\tprint(-1)\n\t\texit()\n\telse:\n\t\tprint(y - 1)\n\t\texit()\n\ncount = 0\nmax_val = 0\nfor _ in range(n):\n\tx = pq.get()\n\twhile count <= k and not pq.empty() and pq.queue[0] == x:\n\t\tpq.get()\n\t\tcount += 1\n\n\tcount += 1\n\tmax_val = x\n\tif count == k:\n\t\tbreak\n\nif count == k:\n\tif max_val + 1 not in pq.queue and max_val < 1e9:\n\t\tprint(max_val + 1)\n\telse:\n\t\tprint(max_val)\nelse:\n\tprint(-1)", "src": "public class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}", "index": 616, "complexity": "5"}
{"forwhile": "n = int(input())\nm = int(input())\nsum = 0\n\n# Input d\ni = 0\nwhile i < n:\n    d[i] = int(input())\n    sum += d[i]\n    ds[i] = sum\n    i += 1\n\n# Input le\ni = 0\nwhile i < m:\n    le[i] = int(input())\n    i += 1\n\nl = 0\nh = n\nk = (h - l) // 2 + l\n\ni = 0\nwhile i < m:\n    l = 0\n    h = n\n    k = (h - l) // 2 + l\n    while l <= h:\n        k = (h - l) // 2 + l\n        if ds[k] < le[i]:\n            l = k + 1\n        elif ds[k] == le[i]:\n            break\n        else:\n            h = k - 1\n\n        if ds[k] < le[i]:\n            k += 1\n        if k == 0:\n            print(int(k + 1), le[i])\n        else:\n            print(int(k + 1), le[i] - ds[k - 1])\n    i += 1\n", "src": "public class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        for(int i =0;i<n;i++){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n        }\n        long[]le=new long[m];\n        for(int i =0;i<m;i++){\n            le[i]=sc.nextLong();\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        for(int i=0;i<m;i++){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[i]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[i]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            \n            if(ds[k]<le[i]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[i]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\n           }\n        }\n        \n    }\n    \n}", "index": 617, "complexity": "5"}
{"forwhile": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tint i=0;\n\t\t\twhile(i<n){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0){\n\t\t\tint j = 0;\n\t\t\twhile(j<(n/2) - 1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tSystem.out.println(list.get(j));\n\t\t}\n\t\telse{\n\t\t\tint j=0;\n\t\t\twhile(j<(n/2)){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tSystem.out.println(list.get(j));\n\t\t}\n\t}\n}", "src": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}", "index": 618, "complexity": "5"}
{"forwhile": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tint i = 0;\n\t\twhile (i < p.length) {\n\t\t\tp[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tsum += Math.abs(p[i] - (i * 2 + offset));\n\t\t}\n\t\treturn sum;\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}", "index": 619, "complexity": "5"}
{"forwhile": "class Sol:\n    def main(args):\n        sc = MyScanner()\n        out = PrintWriter(BufferedOutputStream(System.out))\n        n = sc.nextInt()\n        k = sc.nextInt()\n        l = sc.nextInt()\n        a = [None] * (n * k)\n        i = 0\n        while i < n * k:\n            a[i] = sc.nextInt()\n            i += 1\n        a.sort()\n        if a[n - 1] - a[0] > l:\n            out.println(0)\n        else:\n            maxPos = n * k - 1\n            i = 0\n            while i < n * k:\n                if a[i] - a[0] > l:\n                    maxPos = i - 1\n                    break\n                i += 1\n            o = a[0]\n            s = 0\n            t = 1\n            i = 1\n            while i <= maxPos:\n                if s < k - 1 and maxPos - i + 1 > n - t:\n                    s += 1\n                else:\n                    s = 0\n                    t += 1\n                    o += a[i]\n                i += 1\n            out.println(o)\n        out.close()\n\n    class MyScanner:\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n\n        def next(self):\n            while self.st is None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            str = \"\"\n            try:\n                str = self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str", "src": "public class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tInteger[] a = new Integer[n*k];\n\t\tfor(int i = 0; i < n*k; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (a[n - 1] - a[0] > l) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint maxPos = n*k - 1;\n\t\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\t\tif (a[i] - a[0] > l) {\n\t\t\t\t\tmaxPos = i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong o = a[0];\n\t\t\tint s = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i <= maxPos; i++) {\n\t\t\t\t\n\t\t\t\tif (s < k - 1 && maxPos-i+1 > n-t) {\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ts = 0;\n\t\t\t\t\tt++;\n\t\t\t\t\to += a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(o);\n\t\t}\n\t\tout.close();\n\t}\n\n\t\n\tpublic static PrintWriter out;\n\n\t\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t\n}", "index": 620, "complexity": "5"}
{"forwhile": "tokens = ['token1', 'token2', 'token3']\nindex = 0\nwhile index < 10:\n    print('For loop: ' + str(index))\n    index += 1\ntokens = ['token1', 'token2', 'token3']\nfor token in iter(tokens.pop, None):\n    print(token)", "src": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}", "index": 621, "complexity": "5"}
{"forwhile": "class gr1:\n    class InputReader:\n        def __init__(self, stream):\n            self.br = BufferedReader(InputStreamReader(stream), 32768)\n            self.token = None\n\n        def next(self):\n            while self.token is None or not self.token.hasMoreTokens():\n                try:\n                    self.token = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n            return self.token.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n    class card:\n        def __init__(self, a, cnt, i):\n            self.a = a\n            self.cnt = cnt\n            self.i = i\n\n    class ascend:\n        def compare(self, o1, o2):\n            if o1.b != o2.b:\n                return int(o1.b - o2.b)\n            else:\n                return int(o1.a - o2.a)\n\n    class extra:\n        @staticmethod\n        def shuffle(a):\n            l = []\n            for i in range(len(a)):\n                l.append(a[i])\n            Collections.shuffle(l)\n            for i in range(len(a)):\n                a[i] = l[i]\n\n        @staticmethod\n        def gcd(a, b):\n            while b != 0:\n                a, b = b, a % b\n            return a\n\n        @staticmethod\n        def valid(i, j, r, c):\n            return i >= 0 and i < r and j >= 0 and j < c\n\n        v = [False] * 100001\n        l = []\n        t = 0\n\n        @staticmethod\n        def seive():\n            for i in range(2, 100001):\n                if not extra.v[i]:\n                    extra.t += 1\n                    extra.l.append(i)\n                    for j in range(2 * i, 100001, i):\n                        extra.v[j] = True\n\n        @staticmethod\n        def binary(a, val, n):\n            l, r, ans = 0, n - 1, 0\n            while l <= r:\n                mid = (l + r) >> 1\n                if a[mid].a == val:\n                    r = mid - 1\n                    ans = mid\n                elif a[mid].a > val:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n                    ans = l\n            return ans\n\n    class pair:\n        def __init__(self, a, n):\n            self.a = a\n            self.b = n\n\n    sc = InputReader(System.in)\n    out = PrintWriter(System.out)\n\n    def main(self, args):\n        s = gr1.solver()\n        t = 1\n        for _ in range(t):\n            s.solve()\n\n    class solver:\n        def solve(self):\n            n = gr1.sc.nextInt()\n            a = [0] * n\n            sum = 0\n            i = 0\n            while i < n:\n                a[i] = gr1.sc.nextInt()\n                sum += a[i]\n                i += 1\n            Arrays.sort(a)\n            k = int(round(4.5 * n) - sum)\n\n            if k <= 0:\n                print(0)\n            else:\n                p, ans = 0, 0\n                i = 0\n                while i < n:\n                    if a[i] != 5:\n                        p += 5 - a[i]\n                        if p >= k:\n                            ans += 1\n                            print(ans)\n                            break\n                        ans += 1\n                    i += 1", "src": "public class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    \n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           \n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 622, "complexity": "5"}
{"forwhile": "class Test { static int mergeSort(int arr[], int array_size) { int temp[] = new int[array_size]; return _mergeSort(arr, temp, 0, array_size - 1); } static int _mergeSort(int arr[], int temp[], int left, int right) { int mid, inv_count = 0; if (right > left) { mid = (right + left) / 2; inv_count = _mergeSort(arr, temp, left, mid); inv_count += _mergeSort(arr, temp, mid + 1, right); inv_count += merge(arr, temp, left, mid + 1, right); } return inv_count; } static int merge(int arr[], int temp[], int left, int mid, int right) { int i, j, k; int inv_count = 0; i = left; j = mid; k = left; for (int i = left; i <= right; i++) { arr[i] = temp[i]; } return inv_count; } public static void main(String[] args) { int arr[] = new int[] { 1, 20, 6, 4, 5 }; System.out.println(\"Number of inversions are \" + mergeSort(arr, 5)); } }", "src": "class\nTest { \n\n\n\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n\n\nmid = (right + left) / \n2\n; \n\n\n\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n\n\nj = mid; \n\n\nk = left; \n\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n}", "index": 623, "complexity": "5"}
{"forwhile": "class Main { static void minAbsSumPair(int arr[], int n) { int sum, min_sum = 999999; int l = 0, r = n-1; int min_l = l, min_r = n-1; if (n < 2) { System.out.println(\"Invalid Input\"); return; } sort(arr, l, r); for (int i = l, i < r, i++) { sum = arr[l] + arr[r]; if (Math.abs(sum) < Math.abs(min_sum)) { min_sum = sum; min_l = l; min_r = r; } if (sum < 0) l++; else r--; } System.out.println(\" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l] + \" and \" + arr[min_r]); } public static void main (String[] args) { int arr[] = { 1, 60, -10, 70, -80, 85 }; int n = arr.length; minAbsSumPair(arr, n); } static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low-1); int j = low; while (j < high) { if (arr[j] <= pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } j++; } int temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return i+1; } static void sort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); sort(arr, low, pi-1); sort(arr, pi+1, high); } } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 624, "complexity": "5"}
{"forwhile": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        int i = 0;\n        while (i < n) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n            i++;\n        }\n\n        for (int e : solve(h, w, requests)) {\n            System.out.println(e);\n        }\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        int i = 0;\n        while (i < n) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n            i++;\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        int i = 0;\n        while (i < requests.length) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n            i++;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override\n        public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "src": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n        }\n\n        for (long e : solve(h, w, requests))\n            System.out.println(e);\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "index": 625, "complexity": "5"}
{"forwhile": "li = list(map(int, input().split()))\nn = li[0]\ns = li[1]\nli = [list(map(int, input().split())) for i in range(n)]\nli.sort(key=lambda x: x[1], reverse=True)\nans = 0\ni = 0\nwhile i < n:\n    current = li[i]\n    ans += s - current[1]\n    if current[0] > ans:\n        ans += current[0] - ans\n    s = current[1]\n    i += 1\nans += s\nprint(ans)", "src": "public class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "index": 626, "complexity": "5"}
{"forwhile": "n = sc.nextInt()\nfloor = sc.nextInt()\ntime = 0\n\narr = [None] * n\ni = 0\nwhile i < n:\n    arr[i] = Pair(sc.nextInt(), sc.nextInt())\n    i += 1\n\ni = 0\nwhile i < n:\n    time += floor - arr[i].a\n    floor = arr[i].a\n    time = max(time, arr[i].b)\n    i += 1\n\ntime += arr[n-1].a\n\npw.println(time)\npw.close()", "src": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            \n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}", "index": 627, "complexity": "5"}
