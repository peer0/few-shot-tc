{"back-translation": "{'src': 'public class TestClass1 {\\n\\n\\n    public static void main(String[] args) throws  Exception{\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        String s[] = br.readLine().split(\" \");\\n\\n        long A,B,y,g,b;\\n        A= Long.parseLong(s[0]);\\n        B= Long.parseLong(s[1]);\\n        s=br.readLine().split(\" \");\\n\\n        y = Long.parseLong(s[0]);\\n        g = Long.parseLong(s[1]);\\n        b = Long.parseLong(s[2]);\\n\\nlong ans=0;\\n        if(A-2*y-g < 0){\\n            ans+=Math.abs(A-2*y-g);\\n        }\\n        \\n        if(B-g-3*b < 0){\\n            ans+=Math.abs(B-g-3*b);\\n        }\\n        System.out.println(ans);\\n\\n\\n\\n    }\\n}', 'complexity': '0', 'index': 1}", "src": "public class TestClass1 {\n\n\n    public static void main(String[] args) throws  Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = br.readLine().split(\" \");\n\n        long A,B,y,g,b;\n        A= Long.parseLong(s[0]);\n        B= Long.parseLong(s[1]);\n        s=br.readLine().split(\" \");\n\n        y = Long.parseLong(s[0]);\n        g = Long.parseLong(s[1]);\n        b = Long.parseLong(s[2]);\n\nlong ans=0;\n        if(A-2*y-g < 0){\n            ans+=Math.abs(A-2*y-g);\n        }\n        \n        if(B-g-3*b < 0){\n            ans+=Math.abs(B-g-3*b);\n        }\n        System.out.println(ans);\n\n\n\n    }\n}", "index": 1, "complexity": "0"}
{"back-translation": "def reverse(s):\n    return s[::-1]\n\n\nimport math\n\nn, m = map(int, input().split())\nx = m % (2 ** n)\nprint(x)", "src": "public class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "index": 2, "complexity": "0"}
{"back-translation": "class task1:\n    def main(args):\n        in = [int(x) for x in input().split()]\n        n = in[0]\n        pos = in[1]\n        l = in[2]\n        r = in[3]\n        b = False\n        c = True\n        if l == 1 and r == n:\n            c = False\n            print(0)\n        if c:\n            if l == 1:\n                if pos < r:\n                    print(r - pos + 1)\n                    b = True\n                else:\n                    print(pos - r + 1)\n                    b = True\n        if r == n:\n            if pos > l:\n                print(pos - l + 1)\n                b = True\n            else:\n                print(l - pos + 1)\n                b = True\n        if not b and c:\n            if pos < l:\n                print(l - pos + 1 + r - l + 1)\n            elif pos > r:\n                print(pos - r + 1 + r - l + 1)\n            else:\n                if pos - l < r - pos:\n                    print(pos - l + 1 + r - l + 1)\n                elif pos - l > r - pos:\n                    print(r - pos + 1 + r - l + 1)\n                else:\n                    print((r - pos) * 3 + 2)", "src": "public class task1{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int n=in.nextInt();\n        int pos=in.nextInt();\n        int l=in.nextInt();\n        int r=in.nextInt();\n        boolean b=false;\n        boolean c=true;\n        if(l==1&&r==n){\n            c=false;\n            System.out.println(0);\n        }\n        if(c){\n            if(l==1){\n            if(pos<r){\n                System.out.println(r-pos+1);\n                b=true;}\n            else{\n                System.out.println(pos-r+1);\n                b=true;\n            }\n        }\n        if(r==n){\n            if(pos>l){\n                System.out.println(pos-l+1);\n                b=true;}\n            else{\n                System.out.println(l-pos+1);\n                b=true;\n            }\n        }\n        }\n        if(b==false&&c){\n            if(pos<l){\n            System.out.println(l-pos+1+r-l+1);\n        }\n        else if(pos>r){\n            System.out.println(pos-r+1+r-l+1);\n        }\n        else{\n            if(((pos-l)<(r-pos))){\n                System.out.println(pos-l+1+r-l+1);\n                \n            }\n            \n            else if((pos-l)>(r-pos)){\n                System.out.println(r-pos+1+r-l+1);\n                \n            }\n            else{\n                System.out.println((r-pos)*3+2);\n                \n            }\n        }\n        }\n        \n    }\n}", "index": 3, "complexity": "0"}
{"back-translation": "{'src': 'public class C\\n{\\n\\n\\tstatic StringBuilder st = new StringBuilder();\\n\\t\\n\\tpublic static void main(String[] args) throws Exception \\n\\t{\\n\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\n\\t\\t\\n\\t\\tint [] freq = new int [5] ; \\n\\t\\t\\n\\t\\tint k = 3;  \\n\\t\\twhile(k -- >0)\\n\\t\\t{\\n\\t\\t\\tint x = sc.nextInt();\\n\\t\\t\\t\\n\\t\\t\\tif(x <= 4) freq[x]++;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tfreq[2] += freq[4]/ 2 ;\\n\\t\\t\\n\\t\\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\\n\\t\\t\\tout.println('YES');\\n\\t\\telse\\n\\t\\t\\tout.println('NO');\\n\\t\\t\\n\\t\\t\\n\\t\\tout.flush();\\n\\t\\tout.close();\\n\\n\\t}\\n\\t\\n\\tstatic class Scanner \\n\\t{\\n\\t\\tBufferedReader br;\\n\\t\\tStringTokenizer st;\\n\\n\\t\\tScanner(InputStream in) \\n\\t\\t{\\n\\t\\t\\tbr = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\t}\\n\\n\\t\\tString next() throws Exception {\\n\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\tst = new StringTokenizer(br.readLine());\\n\\t\\t\\treturn st.nextToken();\\n\\t\\t}\\n\\n\\t\\tint nextInt() throws Exception {\\n\\t\\t\\treturn Integer.parseInt(next());\\n\\t\\t}\\n\\n\\t\\tlong nextLong() throws Exception {\\n\\t\\t\\treturn Long.parseLong(next());\\n\\t\\t}\\n\\n\\t\\tdouble nextDouble() throws Exception {\\n\\t\\t\\treturn Double.parseDouble(next());\\n\\t\\t}\\n\\n\\t}\\n\\n\\tstatic void shuffle(int[] a) {\\n\\t\\tint n = a.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint r = i + (int) (Math.random() * (n - i));\\n\\t\\t\\tint tmp = a[i];\\n\\t\\t\\ta[i] = a[r];\\n\\t\\t\\ta[r] = tmp;\\n\\t\\t}\\n\\t}\\n\\n}', 'complexity': '0', 'index': 4}", "src": "public class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 4, "complexity": "0"}
{"back-translation": "{'src': 'public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}', 'complexity': '0', 'index': 5}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 5, "complexity": "0"}
{"back-translation": "{'src': 'public class A912 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t\\n\\n\\t\\tScanner scan = new Scanner(System.in);\\n\\t\\t\\n\\t\\tint A = scan.nextInt();\\n\\t\\tint B = scan.nextInt();\\n\\t\\tlong x = scan.nextInt();\\n\\t\\tlong y = scan.nextInt();\\n\\t\\tlong z = scan.nextInt();\\n\\t\\t\\n\\t\\tlong requiredA = x * 2 + y;\\n\\t\\tlong requiredB = y + z * 3;\\n\\t\\t\\n\\t\\tlong neededA = Math.max(0, requiredA - A);\\n\\t\\tlong neededB = Math.max(0, requiredB - B);\\n\\t\\tSystem.out.print(neededA + neededB);\\n\\t}\\n\\n}', 'complexity': '0', 'index': 6}", "src": "public class A912 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint A = scan.nextInt();\n\t\tint B = scan.nextInt();\n\t\tlong x = scan.nextInt();\n\t\tlong y = scan.nextInt();\n\t\tlong z = scan.nextInt();\n\t\t\n\t\tlong requiredA = x * 2 + y;\n\t\tlong requiredB = y + z * 3;\n\t\t\n\t\tlong neededA = Math.max(0, requiredA - A);\n\t\tlong neededB = Math.max(0, requiredB - B);\n\t\tSystem.out.print(neededA + neededB);\n\t}\n\n}", "index": 6, "complexity": "0"}
{"back-translation": "{'src': 'public class Test3 {\\n\\tpublic static void main(String[] args) throws NumberFormatException, IOException {\\n\\t\\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tint x=Integer.parseInt(br.readLine());\\n\\t\\tint y=Integer.parseInt(br.readLine());\\n\\t\\tSystem.out.print((int)(y%(Math.pow(2, x))));\\n\\t}\\n}', 'complexity': '0', 'index': 7}", "src": "public class Test3 {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint x=Integer.parseInt(br.readLine());\n\t\tint y=Integer.parseInt(br.readLine());\n\t\tSystem.out.print((int)(y%(Math.pow(2, x))));\n\t}\n}", "index": 7, "complexity": "0"}
{"back-translation": "{'src': 'public class RENAMETHISBITCH {\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\n\\t\\ttry (Scanner sc = new Scanner(System.in)) {\\n\\t\\t\\t\\n\\t\\t\\tint n = sc.nextInt();\\n\\t\\t\\tBigInteger m = sc.nextBigInteger();\\n\\t\\t\\t\\n\\t\\t\\tSystem.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\\n\\t\\t}\\n\\t\\tcatch (Exception e) {\\n\\t\\t\\te.printStackTrace();\\n\\t\\t}\\n\\t}\\n}', 'complexity': '0', 'index': 8}", "src": "public class RENAMETHISBITCH {\n\t\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tBigInteger m = sc.nextBigInteger();\n\t\t\t\n\t\t\tSystem.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "index": 8, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\tScanner sc = new Scanner(System.in);\\n\\t\twhile(sc.hasNext()) {\\n\\t\tint n = sc.nextInt();\\n\\t\tint pos = sc.nextInt();\\n\\t\tint l = sc.nextInt();\\n\\t\tint r = sc.nextInt();\\n\\t\t\\n\\t\tif(l==1&&r==n) {\\n\\t\\t\\tSystem.out.println(0);\\n\\t\\t}\\n\\t\\telse if(l==1&&r<n) {\\n\\t\\t\\tSystem.out.println(Math.abs(r-pos)+1);\\n\\t\\t}\\n\\t\\telse if(l>1&&r==n) {\\n\\t\\t\\tSystem.out.println(Math.abs(l-pos)+1);\\n\\t\\t}\\n\\t\\telse if(l>1&&r<n) {\\n\\t\\t\\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\\n\\t\\t\\tSystem.out.println(c+2+r-l);\\n\\t\\t}\\n\\t\\t}\\n\\t}\\t\\n}', 'complexity': '0', 'index': 9}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}", "index": 9, "complexity": "0"}
{"back-translation": "class A:\n    def __init__(self):\n        self.scan = None\n        self.out = None\n\n    def main(self):\n        solver = self.Solver()\n        self.scan = self.FastReader()\n        self.out = None\n        testCases = 1\n        for i in range(1, testCases + 1):\n            solver.solve()\n        self.out.close()\n\n    class Solver:\n        def solve(self):\n            a, b = self.scan.nextInt(), self.scan.nextInt()\n            if b <= a:\n                self.out.println(1)\n            else:\n                self.out.println(b//a + min(1, b%a))\n\n    class DSU:\n        def __init__(self, n):\n            self.root = [i for i in range(n)]\n            self.size = [1] * n\n            self.n = n\n\n        def findParent(self, idx):\n            while self.root[idx] != idx:\n                self.root[idx] = self.root[self.root[idx]]\n                idx = self.root[idx]\n            return idx\n\n        def union(self, x, y):\n            parX = self.findParent(x)\n            parY = self.findParent(y)\n            if parX == parY:\n                return False\n            if self.size[parX] < self.size[parY]:\n                self.root[parY] = parX\n                self.size[parX] += self.size[parY]\n            else:\n                self.root[parX] = parY\n                self.size[parY] += self.size[parX]\n            return True\n\n    class Extra:\n        @staticmethod\n        def sort(a):\n            aa = [i for i in a]\n            aa.sort()\n            for i in range(len(aa)):\n                a[i] = aa[i]\n\n        @staticmethod\n        def gcd(a, b):\n            while b > 0:\n                temp = b\n                b = a % b\n                a = temp\n            return a\n\n        @staticmethod\n        def lcm(a, b):\n            return a * (b // Extra.gcd(a, b))\n\n        @staticmethod\n        def isPrime(n):\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0 or n % 3 == 0:\n                return False\n            for i in range(5, int(n**0.5) + 1, 6):\n                if n % i == 0 or n % (i + 2) == 0:\n                    return False\n            return True\n\n        @staticmethod\n        def sieve(n):\n            prime = [False] * (n + 1)\n            res = []\n            for p in range(2, int(n**0.5) + 1):\n                if not prime[p]:\n                    res.append(p)\n                    for i in range(p * p, n + 1, p):\n                        prime[i] = True\n            return res\n\n        @staticmethod\n        def primeFactorization(n):\n            res = {}\n            while n % 2 == 0:\n                res[2] = res.get(2, 0) + 1\n                n //= 2\n            for i in range(3, int(n**0.5) + 1, 2):\n                while n % i == 0:\n                    res[i] = res.get(i, 0) + 1\n                    n //= i\n            if n > 2:\n                res[n] = 1\n            return res\n\n    class FastReader:\n        def __init__(self):\n            self.br = None\n            self.st = None\n\n        def next(self):\n            while self.st is None or not self.st:\n                self.st = input().split()\n            return self.st.pop(0)\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            return input()\n", "src": "public class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "index": 10, "complexity": "0"}
{"back-translation": "class Param:\n\n    @staticmethod\n    def main(args):\n        param = MyScanner()\n        highestcoin = param.nextInt()\n        sum = param.nextInt()\n        remainder = sum % highestcoin\n        remainder = 1 if remainder != 0 else 0\n        count = (sum - remainder) // highestcoin\n\n        if highestcoin >= sum:\n            print('1')\n        else:\n            print(count + remainder)\n\n        out.close()\n\n\nclass MyScanner:\n\n    def __init__(self):\n        self.br = BufferedReader(InputStreamReader(System.in))\n        self.st = None\n\n    def next(self):\n        while self.st is None or not self.st.hasMoreElements():\n            try:\n                self.st = StringTokenizer(self.br.readLine())\n            except IOException as e:\n                e.printStackTrace()\n        return self.st.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n\n    def nextDouble(self):\n        return float(self.next())\n\n    def nextLine(self):\n        str = ''\n        try:\n            str = self.br.readLine()\n        except IOException as e:\n            e.printStackTrace()\n        return str", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 11, "complexity": "0"}
{"back-translation": "{'src': 'public class pr1023B {\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        PrintWriter out = new PrintWriter(System.out);\\n\\n        long n = sc.nextLong();\\n        long k = sc.nextLong();\\n\\n        out.println(solve(n, k));\\n        out.flush();\\n        out.close();\\n    }\\n\\n\\n    static long solve(long n, long k) {\\n        if(k <= n) return (long)Math.floor((double)(k-1)/2);\\n        else{\\n            long mx = n;\\n            long mn = k-n;\\n            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));\\n        }\\n    }\\n}', 'complexity': '0', 'index': 12}", "src": "public class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n\n    static long solve(long n, long k) {\n        if(k <= n) return (long)Math.floor((double)(k-1)/2);\n        else{\n            long mx = n;\n            long mn = k-n;\n            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));\n        }\n    }\n}", "index": 12, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n    \\n    static Scanner in = new Scanner();\\n    static PrintWriter out = new PrintWriter(System.out);\\n    \\n    public static void main(String[] args) throws IOException {\\n        int x = in.nextInt(),\\n            y = in.nextInt(),\\n            z = in.nextInt(),\\n            t1 = in.nextInt(),\\n            t2 = in.nextInt(),\\n            t3 = in.nextInt()*3,\\n            d = Math.abs(x - y);\\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \\", "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \"NO\" : \"YES\"));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "index": 13, "complexity": "0"}
{"back-translation": "{'src': 'public class Solution {\\n\\n\\tstatic long MOD = 1_000_000_000 + 7;\\n\\n\\tpublic static void main(String[] args) throws Exception {\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\n\\t\\tlong n = Long.parseLong(st.nextToken());\\n\\t\\tlong m = Long.parseLong(st.nextToken());\\n\\t\\tlong k = Long.parseLong(st.nextToken());\\n\\t\\tlong l = Long.parseLong(st.nextToken());\\n\\n\\t\\tlong p = (l + k) / m;\\n\\n\\t\\tif (p * m != l + k) {\\n\\t\\t\\tp++;\\n\\t\\t}\\n\\n\\t\\tif (m * p <= n) {\\n\\t\\t\\tSystem.out.println(p);\\n\\t\\t} else {\\n\\t\\t\\tSystem.out.println(-1);\\n\\t\\t}\\n\\n\\t}\\n}', 'complexity': '0', 'index': 14}", "src": "public class Solution {\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong k = Long.parseLong(st.nextToken());\n\t\tlong l = Long.parseLong(st.nextToken());\n\n\t\tlong p = (l + k) / m;\n\n\t\tif (p * m != l + k) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (m * p <= n) {\n\t\t\tSystem.out.println(p);\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\n\t}\n}", "index": 14, "complexity": "0"}
{"back-translation": "{'src': 'public class A {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\tBufferedReader br = null;\\n\\t\tbr = new BufferedReader(new InputStreamReader(System.in));\\n        String input;\\n\\t\ttry {\\n\\t\\t\\tinput = br.readLine();\\n\\t\\t\\tlong n = Long.parseLong(input.split(\\\" \\\\x22)[0]);\\n\\t        long k = Long.parseLong(input.split(\\\" \\\\x22)[1]);\\n\\t        long red = (long) (Math.ceil((n * 2.0)/k));\\n\\t        long blue = (long) (Math.ceil((n * 5.0)/k));\\n\\t        long green = (long) (Math.ceil((n * 8.0)/k));\\n\\t        System.out.println(red + blue +green);\\n\\t\\t} catch (IOException e) {\\n\\t\\t\\te.printStackTrace();\\n\\t\\t}\\n\\t}\\n\\n}', 'complexity': '0', 'index': 15}", "src": "public class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tlong n = Long.parseLong(input.split(\" \")[0]);\n\t        long k = Long.parseLong(input.split(\" \")[1]);\n\t        long red = (long) (Math.ceil((n * 2.0)/k));\n\t        long blue = (long) (Math.ceil((n * 5.0)/k));\n\t        long green = (long) (Math.ceil((n * 8.0)/k));\n\t        System.out.println(red + blue +green);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "index": 15, "complexity": "0"}
{"back-translation": "class EhabAndAnotherConstructionProblem: \n    def __init__(self): \n        self.in = sys.stdin \n        self.out = sys.stdout \n        self.st = None \n    \n    def main(self): \n        x = self.nextInt() \n        print(-1 if x == 1 else str(x) + ' ' + str(x)) \n    \n    def nextLine(self): \n        return self.in.readline() \n\n    def nextString(self): \n        while self.st is None or not self.st.hasMoreTokens(): \n            self.st = StringTokenizer(self.in.readline()) \n        return self.st.nextToken() \n\n    def nextInt(self): \n        return int(self.nextString()) \n\n    def nextLong(self): \n        return int(self.nextString()) \n\n    def intArray(self, n): \n        a = [self.nextInt() for _ in range(n)] \n        return a \n\n    def intArray(self, n, m): \n        a = [[self.nextInt() for _ in range(m)] for _ in range(n)] \n        return a \n\n    def longArray(self, n): \n        a = [self.nextLong() for _ in range(n)] \n        return a", "src": "public class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 16, "complexity": "0"}
{"back-translation": "from sys import stdin, stdout\nfrom io import StringIO\nimport sys\nimport math\nimport os\nimport io\nimport threading\n\nclass A1008:\n    def main():\n        inputReader = sys.stdin\n        outputReader = sys.stdout\n        in = InputReader(inputReader)\n        out = PrintWriter(outputReader)\n        solver = Algorithm()\n        solver.solve(in, out)\n        out.close()\n\nclass Algorithm:\n    def solve(self, ir, pw):\n        n, k = ir.nextLong(), ir.nextLong()\n        l = max(1, k - n)\n        r = (k + 1) // 2\n        l = max(0, r - l)\n        pw.print(l)\n\nclass InputReader:\n    def __init__(self, stream):\n        self.reader = io.BufferedReader(stream, 32768)\n        self.tokenizer = None\n    def next(self):\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = io.StringTokenizer(self.reader.readLine())\n            except Exception as e:\n                raise RuntimeException(e)\n        return self.tokenizer.nextToken()\n    def nextLine(self):\n        fullLine = None\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            try:\n                fullLine = self.reader.readLine()\n            except Exception as e:\n                raise RuntimeException(e)\n        return fullLine\n    def toArray(self):\n        return self.nextLine().split(' ')\n    def nextInt(self):\n        return int(self.next())\n    def nextDouble(self):\n        return float(self.next())\n    def nextLong(self):\n        return int(self.next())", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 17, "complexity": "0"}
{"back-translation": "class B:\n\t\n\tdef main(args):\n\t\tsc = Scanner()\n\t\tout = PrintWriter(System.out)\n\t\t\n\t\tn = sc.nextInt()\n\t\tm = sc.nextInt()\n\t\t\n\t\tfirst = \"\"\n\t\tsecond = \"\"\n\t\t\n\t\tfor i in range(126):\n\t\t\tfirst += \"9\"\n\t\t\tsecond += \"9\"\n\t\t\n\t\tfor i in range(125):\n\t\t\tfirst += \"0\"\n\t\t\n\t\tfirst += \"1\"\n\t\t\n\t\tout.println(first + \" \" + second)\n\t\t\n\t\tout.flush()\n\t\tout.close()\n\t\n\t\n\tdef sumDigits(num):\n\t\tans = 0\n\t\t\n\t\twhile num > 0:\n\t\t\tans += num % 10\n\t\t\t\n\t\t\tnum //= 10\n\t\t\n\t\treturn ans\n\t\n\t\nclass Scanner:\n\t\t\n\t\tdef next(self):\n\t\t\twhile not self.st or len(self.st) == 0:\n\t\t\t\tself.st = self.br.readline().split()\n\t\t\n\t\t\treturn self.st.pop(0)\n\t\t\n\n\t\tdef nextInt(self):\n\t\t\treturn int(self.next())\n\t\t\n\t\tdef nextLong(self):\n\t\t\treturn int(self.next())\n\t\t\n\t\tdef nextDouble(self):\n\t\t\treturn float(self.next())\n\t\t\n\t\tdef nextChar(self):\n\t\t\treturn self.next()[0]\n\t\t\n\n\t\tdef nextCharArray(self):\n\t\t\treturn list(self.next())", "src": "public class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}", "index": 18, "complexity": "0"}
{"back-translation": "{'src': 'public class A {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\tBufferedReader br = null;\\n\\t\tbr = new BufferedReader(new InputStreamReader(System.in));\\n        String input;\\n\\t\ttry {\\n\\t\\t\\tinput = br.readLine();\\n\\t\\t\\tint n = Integer.parseInt(input);\\n\\t\\t\\tinput = br.readLine();\\n\\t\\t\\tint qx = Integer.parseInt(input.split(\\", "src": "public class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif((kx<qx && gx<qx)||(kx>qx && gx>qx)) {\n\t\t\t\tif((ky<qy && gy<qy)||(ky>qy && gy>qy))System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}else System.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "index": 19, "complexity": "0"}
{"back-translation": "class A_KingEscape:\n    def main(args=None):\n        inputStream = System.in\n        outputStream = System.out\n        inp = InputReader(inputStream)\n        out = PrintWriter(outputStream)\n        solver = Solver()\n        solver.solve(inp, out)\n        out.close()\n\n    class Solver:\n        def solve(inp, out):\n            n = inp.nextInt()\n            Qx, Qy = inp.nextInt(), inp.nextInt()\n            Kx, Ky = inp.nextInt(), inp.nextInt()\n            Tx, Ty = inp.nextInt(), inp.nextInt()\n            if ((Kx < Qx and Tx < Qx) or (Kx > Qx and Tx > Qx)) and ((Ky < Qy and Ty < Qy) or (Ky > Qy and Ty > Qy)):\n                out.println('YES')\n            else:\n                out.println('NO')\n\n    class InputReader:\n        def __init__(self, stream):\n            self.reader = BufferedReader(stream, 32768)\n            self.tokenizer = None\n\n        def next(self):\n            while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n                try:\n                    self.tokenizer = StringTokenizer(self.reader.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n            return self.tokenizer.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())", "src": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 20, "complexity": "0"}
{"back-translation": "{'src': 'public class Main\\n{\\n\\t\\n\\tpublic static void main(String[] args) throws IOException\\n\\t{\\n\\t\\tBufferedReader st = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tStringTokenizer s = new StringTokenizer(st.readLine());\\n\\t\\tlong n = Long.parseLong(s.nextToken());\\n\\t\\tlong k = Long.parseLong(s.nextToken());\\n\\t\\tlong ans = k/n;\\n\\t\\tif(k%n != 0) ans++;\\n\\t\\tSystem.out.println(ans+\"\");\\n\\t}\\n}', 'complexity': '0', 'index': 21}", "src": "public class Main\n{\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader st = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer s = new StringTokenizer(st.readLine());\n\t\tlong n = Long.parseLong(s.nextToken());\n\t\tlong k = Long.parseLong(s.nextToken());\n\t\tlong ans = k/n;\n\t\tif(k%n != 0) ans++;\n\t\tSystem.out.println(ans+\"\");\n\t}\n}", "index": 21, "complexity": "0"}
{"back-translation": "class A1008:\n    def main():\n        inputReader = System.in\n        outputReader = System.out\n        in = InputReader(inputReader)\n        out = PrintWriter(outputReader)\n        solver = Algorithm()\n        solver.solve(in, out)\n        out.close()\nclass Algorithm:\n    def solve(ir, pw):\n        n, k = ir.nextLong(), ir.nextLong()\n        pw.print((n + k - 1) // n)\n    def Qsort(array, low, high):\n        i = low\n        j = high\n        x = array[low + (high - low) // 2]\n        while i <= j:\n            while array[i] < x:\n                i += 1\n            while array[j] > x:\n                j -= 1\n            if i <= j:\n                array[i], array[j] = array[j], array[i]\n                i += 1\n                j -= 1\n        if low < j:\n            Qsort(array, low, j)\n        if i < high:\n            Qsort(array, i, high)\nclass InputReader:\n    def __init__(stream):\n        reader = BufferedReader(InputStreamReader(stream), 32768)\n        tokenizer = None\n    def next():\n        while tokenizer == None or not tokenizer.hasMoreTokens():\n            try:\n                tokenizer = StringTokenizer(reader.readLine())\n            except IOException as e:\n                raise RuntimeException(e)\n        return tokenizer.nextToken()\n    def nextLine():\n        while tokenizer == None or not tokenizer.hasMoreTokens():\n            try:\n                fullLine = reader.readLine()\n            except IOException as e:\n                raise RuntimeException(e)\n        return fullLine\n    def toArray():\n        return nextLine().split(\" \")\n    def nextInt():\n        return int(next())\n    def nextDouble():\n        return float(next())\n    def nextLong():\n        return int(next())", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 22, "complexity": "0"}
{"back-translation": "class Param:\n\n    class MyScanner:\n        \n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n\n        def next(self):\n            while self.st is None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            try:\n                return self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n\n\n    def main(args):\n        param = MyScanner()\n        out = PrintWriter(BufferedOutputStream(System.out))\n        highestcoin = param.nextInt()\n        sum = param.nextInt()\n        remainder = sum % highestcoin\n        remainder = 1 if remainder != 0 else 0\n        count = (sum - remainder) // highestcoin\n        if highestcoin >= sum:\n            print(\"1\")\n        else:\n            print(count + remainder)\n        out.close()\n\n\nout = None", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 23, "complexity": "0"}
{"back-translation": "class Main:\n\n    def main(args):\n        speedScanner = SpeedScanner()\n        out = PrintWriter(System.out)\n        taskSolver(speedScanner, out)\n        out.close()\n\n    def taskSolver(speedScanner, out):\n        n = speedScanner.nextLong()\n        m = speedScanner.nextLong()\n        k = speedScanner.nextLong()\n        l = speedScanner.nextLong()\n\n        tempM = None\n\n        if k + l < m:\n            if n < m:\n                out.print(-1)\n            else:\n                out.print(1)\n        else:\n            tempM = (k + l) // m\n            if (k + l) % m == 0:\n                if tempM * m <= n:\n                    out.print(tempM)\n                else:\n                    out.print(-1)\n            else:\n                if (tempM + 1) * m <= n:\n                    out.print(tempM + 1)\n                else:\n                    out.print(-1)\n\n\n    class SpeedScanner:\n        br = None\n        st = None\n\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n\n        def nextToken(self):\n            while self.st == None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return Integer.parseInt(self.nextToken())\n\n        def nextLong(self):\n            return Long.parseLong(self.nextToken())\n\n        def nextDouble(self):\n            return Double.parseDouble(self.nextToken())", "src": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "index": 24, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n\\n    static StringBuilder data;\\n    final static FastReader in = new FastReader();\\n\\n\\n    public static void main(String[] args) {\\n        int n = in.nextInt(), k = in.nextInt();\\n               long answ = 0;\\n        if (n * 2 > k) {\\n         if((n*2)%k==0){\\n             answ+=(n*2)/k;\\n         }else{\\n             answ+=((n*2)/k)+1;\\n         }\\n        }else{\\n            answ++;\\n        }\\n        if (n * 5 > k) {\\n            if((n*5)%k==0){\\n                answ+=(n*5)/k;\\n            }else{\\n                answ+=((n*5)/k)+1;\\n            }\\n        }else{\\n            answ++;\\n        }\\n        if (n * 8 > k) {\\n            if((n*8)%k==0){\\n                answ+=(n*8)/k;\\n            }else{\\n                answ+=((n*8)/k)+1;\\n            }\\n        }else{\\n            answ++;\\n        }\\n\\n        System.out.println(answ);\\n    }\\n\\n\\n    static void fileOut(String s) {\\n        File out = new File(\\\"output.txt\\\");\\n        try {\\n            FileWriter fw = new FileWriter(out);\\n            fw.write(s);\\n            fw.flush();\\n            fw.close();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n\\n    }\\n\\n    static class FastReader {\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastReader() {\\n            br = new BufferedReader(new\\n                    InputStreamReader(System.in));\\n        }\\n\\n        public FastReader(String path) {\\n            try {\\n                br = new BufferedReader(new\\n                        InputStreamReader(new FileInputStream(path)));\\n            } catch (FileNotFoundException e) {\\n                e.printStackTrace();\\n            }\\n        }\\n\\n        String next() {\\n            while (st == null || !st.hasMoreElements()) {\\n                try {\\n                    st = new StringTokenizer(br.readLine());\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n            return st.nextToken();\\n        }\\n\\n        int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() {\\n            return Long.parseLong(next());\\n        }\\n\\n        float nextFloat() {\\n            return Float.parseFloat(next());\\n        }\\n\\n        double nextDouble() {\\n            return Double.parseDouble(next());\\n        }\\n\\n\\n        String nextLine() {\\n            String str = \\\"\\\";\\n            try {\\n                str = br.readLine();\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            }\\n            return str;\\n        }\\n    }\\n\\n}', 'complexity': '0', 'index': 25}", "src": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 25, "complexity": "0"}
{"back-translation": "import sys\ninput = sys.stdin.readline\nn, k = map(int, input().split())\nt1 = -(-n*2//k)\nt2 = -(-n*5//k)\nt3 = -(-n*8//k)\nprint(t1+t2+t3)", "src": "public class programA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int)Math.ceil((double)n*2/k);\n\t\tint t2 = (int)Math.ceil((double)n*5/k);\n\t\tint t3 = (int)Math.ceil((double)n*8/k);\n\t\tSystem.out.println(t1+t2+t3);\n\t}\n}", "index": 26, "complexity": "0"}
{"back-translation": "", "src": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "index": 27, "complexity": "0"}
{"back-translation": "{'src': 'public class DS {\\n\\n    \\n   \\n\\n\\n\\n    public static void main(String[] args) throws IOException {\\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n       int x=Integer.parseInt(br.readLine());\\n         \\nif (x==1)\\n            System.out.println(-1);\\nelse\\n            System.out.println(x+\\\" \\\"+x);\\n\\n        }\\n\\n        \\n    }', 'complexity': '0', 'index': 28}", "src": "public class DS {\n\n    \n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 28, "complexity": "0"}
{"back-translation": "print(-1 if int(input()) == 1 else ' '.join([str(int(input()))]*2))", "src": "public class DS {\n\n    \n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 29, "complexity": "0"}
{"back-translation": "class FirstApp:\n    \n    def main(self):\n        inputStream = sys.stdin\n        outputStream = sys.stdout\n        in_ = self.InputReader(inputStream)\n        out = self.print(outputStream)\n        solve = self.TaskA()\n        solve.solve(1, in_, out)\n        out.close()\n\n    class TaskA:\n        def solve(self, testNumber, in_, out):\n            number = in_.nextInt()\n\n            if number > 2 and number % 2 == 0:\n                out.println('YES')\n            else:\n                out.println('NO')\n\n    class InputReader:\n        def __init__(self, stream):\n            self.reader = io.BufferedReader(io.InputStreamReader(stream), 32768)\n            self.tokenizer = None\n\n        def next(self):\n            while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n                try:\n                    self.tokenizer = io.StringTokenizer(self.reader.readLine())\n                except IOError as e:\n                    raise RuntimeError(e)\n            return self.tokenizer.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n", "src": "public class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "index": 30, "complexity": "0"}
{"back-translation": "class Main:\n    @staticmethod\n    def readLn(maxLength):\n        line = bytearray(maxLength)\n        length = 0\n        input_val = -1\n        try:\n            while length < maxLength:\n                input_val = ord(sys.stdin.read(1))\n                if input_val < 0 or chr(input_val) == '\\n':\n                    break\n                line[length] += input_val\n                length += 1\n\n            if input_val < 0 and length == 0:\n                return None\n\n            return str(line[:length])\n        except IOError as e:\n            return None\n\n    def main(self, args):\n        myWork = Main()\n        myWork.run()\n\n    def run(self):\n        Watermelon().run()\n\n\nclass Watermelon:\n    def run(self):\n        line = Main.readLn(100).strip()\n        weight = int(line)\n        print('YES' if weight % 2 == 0 and weight > 2 else 'NO')\n", "src": "public class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      while (length < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "index": 31, "complexity": "0"}
{"back-translation": "print('YES' if (lambda x: x % 2 == 0 and x != 2)(int(input())) else 'NO')", "src": "public class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            \n            \n        if(q%2 == 0 && q!=2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n            \n        }\n        catch(IOException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n        \n        \n \n       \n \n    }\n}", "index": 32, "complexity": "0"}
{"back-translation": "for i in range(10):\n    if i % 2 == 0:\n        print('Mahmoud')\n    else:\n        print('Ehab')", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 33, "complexity": "0"}
{"back-translation": "class Main:\n    class FastReader:\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n        def next(self):\n            while self.st == None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n        def nextInt(self):\n            return int(self.next())\n        def nextLong(self):\n            return int(self.next())\n        def nextDouble(self):\n            return float(self.next())\n        def nextFloat(self):\n            return float(self.next())\n        def nextBoolean(self):\n            return bool(self.next())\n        def nextLine(self):\n            str = \"\"\n            try:\n                str = self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str\n    @staticmethod\n    def modExp(x, n, mod):\n        result = 1\n        while n > 0:\n            if n % 2 == 1:\n                result = (result % mod * x % mod) % mod\n            x = (x % mod * x % mod) % mod\n            n = n / 2\n        return result\n    @staticmethod\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return Main.gcd(b % a, a)\n    @staticmethod\n    def main(args):\n        fr = Main.FastReader()\n        print((int)(fr.nextInt()/2) + 1)\nclass pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n    def first(self):\n        return self.first\n    def second(self):\n        return self.second\n    def setFirst(self, first):\n        self.first = first\n    def setSecond(self, second):\n        self.second = second\nclass myComp(Comparator):\n    def compare(a, b):\n        return a.first - b.first\nclass BIT:\n    def __init__(self, dat):\n        self.m_array = [0] * (len(dat) + 1)\n        for i in range(len(dat)):\n            self.m_array[i + 1] = dat[i]\n        for i in range(1, len(self.m_array)):\n            j = i + (i & -i)\n            if j < len(self.m_array):\n                self.m_array[j] = self.m_array[j] + self.m_array[i]\n    def prefix_query(self, i):\n        result = 0\n        for i in range(1, i + 1):\n            result = result + self.m_array[i]\n        return result\n    def range_query(self, fro, to):\n        if fro == 0:\n            return self.prefix_query(to)\n        else:\n            return self.prefix_query(to) - self.prefix_query(fro - 1)\n    def update(self, i, add):\n        for i in range(i + 1, len(self.m_array)):\n            self.m_array[i] = self.m_array[i] + add", "src": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}", "index": 34, "complexity": "0"}
{"back-translation": "{'src': 'public class SolutionB {\\n       \\n      public static void main(String args[])throws IOException{\\n              Scanner sc = new Scanner(System.in);\\n              long a[] = new long[14];\\n              for(int i = 0; i < 14; i++)\\n                     a[i] = sc.nextLong();\\n              long cpy[] = new long[14];\\n              long max = 0;\\n              for(int i = 0; i < 14; i++){\\n                     if(a[i] == 0)continue;\\n                     long score = 0;\\n                     long curr = a[i];\\n                     for(int j = 0; j < 14; j++)\\n                            cpy[j] = a[j];\\n                     cpy[i] = 0;\\n                     long amnt = curr / 14l;\\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\\n                     }\\n                     amnt = curr % 14;\\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\\n                            cpy[j % 14]++;\\n                     }\\n                     for(int j = 0; j < 14; j++){\\n                            if(cpy[j] % 2 == 0)\\n                                   score += cpy[j];\\n                     }\\n                     max = Math.max(max, score);\\n              }\\n              System.out.println(max);\\n      }\\n}', 'complexity': '0', 'index': 35}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "index": 35, "complexity": "0"}
{"back-translation": "class Main:\n    def __init__(self):\n        pass\n\n    def solve(self, testNumber, in_obj, out_obj):\n        n = in_obj.nextLong()\n        n = n + 1\n        if n % 2 == 0:\n            out_obj.println(n // 2)\n        else:\n            if n != 1:\n                out_obj.println(n)\n            else:\n                out_obj.println(0)\n\n\nclass OutputWriter:\n    def __init__(self, outputStream):\n        self.writer = outputStream\n\n    def close(self):\n        self.writer.close()\n\n    def println(self, i):\n        self.writer.println(i)\n\n\nclass InputReader:\n    def __init__(self, stream):\n        self.stream = stream\n\n    def read(self):\n        pass\n\n    def nextLong(self):\n        c = self.read()\n        while self.isSpaceChar(c):\n            c = self.read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = self.read()\n        res = 0\n        while not self.isSpaceChar(c):\n            if c < '0' or c > '9':\n                pass\n            res *= 10\n            res += c - '0'\n            c = self.read()\n        return res * sgn\n\n    def isSpaceChar(self, c):\n        pass", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 36, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "index": 37, "complexity": "0"}
{"back-translation": "if a<n and b<n and c < n and (a+b-c)<n and c<=a and c<=b: print((n)-(a+b-c))\nelse: print('-1')", "src": "public class IfAtFIrstYouDIdnt {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tint n  = input.nextInt();\n\t\tif(a<n && b<n && c < n && (a+b-c)<n && c<=a && c<=b){\n\t\t\tSystem.out.println((n)-(a+b-c));\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"-1\");\n\t}\n\n}", "index": 38, "complexity": "0"}
{"back-translation": "class C_NNAndTheOpticalIllusion:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        inp = InputReader(inputStream)\n        out = PrintWriter(outputStream)\n        solver = Solver()\n        solver.solve(inp, out)\n        out.close()\n\n    class Solver:\n        def solve(inp, out):\n            n, r = inp.nextInt(), inp.nextInt()\n            x = math.cos((n - 2) * math.pi / (2 * n))\n            out.print((r * x) / (1 - x))\n\n    class InputReader:\n        def InputReader(stream):\n            reader = BufferedReader(InputStreamReader(stream), 32768)\n            tokenizer = None\n\n        def next():\n            while tokenizer is None or not tokenizer.hasMoreTokens():\n                try:\n                    tokenizer = StringTokenizer(reader.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n            return tokenizer.nextToken()\n\n        def nextInt():\n            return int(next())\n\n        def nextLong():\n            return int(next())", "src": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 39, "complexity": "0"}
{"back-translation": "class HelloWorld:\n    def __init__(self, inputStream, outputStream):\n        self.inputStream = inputStream\n        self.outputStream = outputStream\n        self.inp = InputReader(self.inputStream)\n        self.out = PrintWriter(self.outputStream)\n        self.solver = Palindrome()\n\n    def main(self):\n        self.solver.solve(1, self.inp, self.out)\n        self.out.close()\n\n    class Palindrome:\n        def solve(self, testNumber, inp, out):\n            l = inp.nextLong()\n            if l % 4 == 0 or l % 4 == 3:\n                out.print('0')\n            else:\n                out.print('1')\n\n    class InputReader:\n        def __init__(self, stream):\n            self.reader = BufferedReader(stream)\n            self.tokenizer = None\n\n        def next(self):\n            while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n                try:\n                    self.tokenizer = StringTokenizer(self.reader.readLine())\n                except Exception as e:\n                    raise RuntimeException(e)\n            return self.tokenizer.nextToken()\n\n        def nextLong(self):\n            return int(self.next())\n\n    class BufferedReader:\n        def __init__(self, stream):\n            pass\n\n    class PrintWriter:\n        def __init__(self, stream):\n            pass\n\n    class StringTokenizer:\n        def __init__(self, line):\n            pass\n\n    class RuntimeException(Exception):\n        pass\n\ninputStream = System.in\noutputStream = System.out\nhelloWorld = HelloWorld(inputStream, outputStream)\nhelloWorld.main()", "src": "public class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "index": 40, "complexity": "0"}
{"back-translation": "sumB, sumA, n = 0, 0, int(input())\nrem = n % 4\nfor i in range(rem, 0, -1):\n    if sumB <= sumA:\n        sumB += i\n    else:\n        sumA += i\nprint(abs(sumA - sumB))", "src": "public class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "index": 41, "complexity": "0"}
{"back-translation": "def fillzero(a, n):\n    for i in range(n):\n        for j in range(n - 1):\n            if a[j][i] == 0 and a[j + 1][i] == 0:\n                a[j][i] = 1\n                a[j + 1][i] = 1\n                return j, i\ndef fillone(a, n):\n    for i in range(n):\n        for j in range(n - 1):\n            if a[i][j] == 0 and a[i][j + 1] == 0:\n                a[i][j] = 1\n                a[i][j + 1] = 1\n                return i, j\ndef check(a, n):\n    for i in range(4):\n        if a[i][0] == 1 and a[i][1] == 1 and a[i][2] == 1 and a[i][3] == 1:\n            a[i][0] = 0\n            a[i][1] = 0\n            a[i][2] = 0\n            a[i][3] = 0\n    for i in range(4):\n        if a[0][i] == 1 and a[1][i] == 1 and a[2][i] == 1 and a[3][i] == 1:\n            a[0][i] = 0\n            a[1][i] = 0\n            a[2][i] = 0\n            a[3][i] = 0\ndef main(args):\n    n = int(input())\n    ans = float('inf')\n    sum = 0\n    sum2 = (n * (n + 1)) / 2\n    if sum2 % 2 == 0:\n        print(0)\n    else:\n        print(1)", "src": "public class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}", "index": 42, "complexity": "0"}
{"back-translation": "{'src': 'public class SashaAndHisTrip {\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        int N = in.nextInt();\\n        int v = in.nextInt();\\n        if (v > N) {\\n            System.out.println(N-1);\\n        }\\n        else {\\n            int price = v + ((N-v-1) * (2+ N - v))/2;\\n            int counter = 0;\\n            System.out.println(price);\\n        }\\n    }\\n}', 'complexity': '0', 'index': 43}", "src": "public class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        }\n        else {\n            int price = v + ((N-v-1) * (2+ N - v))/2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}", "index": 43, "complexity": "0"}
{"back-translation": "class Main:\n    def main(args):\n        fr = FastReader()\n        out = PrintWriter(System.out)\n        n, v = fr.nextInt(), fr.nextInt()\n        if v >= n:\n            out.println(n - 1)\n        else:\n            out.println((n - v) * (n - v + 1) // 2 + v - 1)\n        out.flush()\n\n    class FastReader:\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n\n        def next(self):\n            while self.st is None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            try:\n                str = self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str\n\n        def nextIntArray(self, n):\n            a = [self.nextInt() for _ in range(n)]\n            return a\n\n        def memset(self, n, val):\n            ar = [val]*n\n            return ar", "src": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "index": 44, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\twhile (sc.hasNext()) {\\n\\t\\t\\tint n = sc.nextInt();\\n\\t\\t\\tif (n % 2 != 0) {\\n\\t\\t\\t\\tSystem.out.println(\"Ehab\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tSystem.out.println(\"Mahmoud\");\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}', 'complexity': '0', 'index': 45}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "index": 45, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 46, "complexity": "0"}
{"back-translation": "print(((n-1)//s+1)*k//p + ((n-1)//s+1)*k%p and ((n-1)//s+1)*k//p+1 or ((n-1)//s+1)*k//p)", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s;\n\t\tif (n % s != 0)\n\t\t{\n\t\t\teach++;\n\t\t}\n\t\tint all = each * k;\n\n\t\tif (all % p == 0)\n\t\t{\n\t\t\tSystem.out.println(all / p);\n\t\t} else\n\t\t{\n\t\t\tSystem.out.println(all / p + 1);\n\t\t}\n\t}\n}", "index": 47, "complexity": "0"}
{"back-translation": "class A:\n    n = 0\n    Primes = set()\n    arr = []\n    arr2 = []\n\n    @staticmethod\n    def copyOf(arr):\n        arr2 = [0] * len(arr)\n        for i in range(len(arr)):\n            arr2[i] += arr[i]\n        return arr2\n\n    @staticmethod\n    def addEvens(arr):\n        r = 0\n        for i in range(len(arr)):\n            if arr[i] % 2 == 0:\n                r += arr[i]\n        return r\n\n    @staticmethod\n    def main():\n        import sys\n        arr = [int(x) for x in input().split()]\n        x = 5535\n        y = x\n        max_val = float('-inf')\n        for i in range(14):\n            a = arr[i]\n            arr2 = A.copyOf(arr)\n            arr2[i] = 0\n            rem = arr[i] // 14\n            steps = arr[i] % 14\n            j = i\n            c = 0\n            for _ in range(i + 1, i + 1 + 14):\n                j %= 14\n                arr2[c] += rem\n                c += 1\n                j += 1\n            j = i\n            c = 0\n            for _ in range(i + 1, i + 1 + steps):\n                j %= 14\n                arr2[j] += 1\n                c += 1\n                j += 1\n            max_val = max(max_val, A.addEvens(arr2))\n        sys.stdout.write(str(max_val))\n\n    if __name__ == '__main__':\n        A.main()", "src": "public class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}", "index": 48, "complexity": "0"}
{"back-translation": "class helloWorld: \n\tdef main(args): \t\t\n\t\tin_value = int(input())\n\t\tans = in_value + 1\n\t\t\n\t\tif ans == 1:\n\t\t\tans = 0\n\t\tif ans % 2 == 0:\n\t\t\tans /= 2\n\t\t\n\t\tprint(ans)", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong ans = n+1;\n\t\t\n\t\tif(ans == 1)\n\t\t\tans = 0;\n\t\tif(ans % 2 == 0)\n\t\t\tans /= 2;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 49, "complexity": "0"}
{"back-translation": "a,b,c,n=map(int,input().split())\nS=a+b-c\nprint('-1' if n-S<1 or c< min(a,b) else n-S)", "src": "public class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int a=Integer.parseInt(s1[0]);\n            int b=Integer.parseInt(s1[1]);\n            int c=Integer.parseInt(s1[2]);\n            int n=Integer.parseInt(s1[3]);\n            int S=a+b-c;\n            if(n-S<1 || c>Math.min(a,b))\n             System.out.println(\"-1\");\n            else\n             System.out.println(n-S);\n      }\n}", "index": 50, "complexity": "0"}
{"back-translation": "class aaaaaaaaaaaaaaaa:\n    def run(self):\n        a, b, c, n = map(int, input().split())\n        a -= c\n        b -= c\n        if a < 0 or b < 0:\n            print(-1)\n        else:\n            x = a + b + c\n            if x >= n:\n                print(-1)\n            else:\n                print(n - x)\n\n    @staticmethod\n    def main():\n        aaaaaaaaaaaaaaaa().run()\n\naaaaaaaaaaaaaaaa.main()", "src": "public class aaaaaaaaaaaaaaaa {\n\tpublic void run() throws Exception {\n\t\tScanner file = new Scanner(System.in);\n\t\tint a = file.nextInt(), b= file.nextInt(), c = file.nextInt(), n = file.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew aaaaaaaaaaaaaaaa().run();\n\t}\n\n}", "index": 51, "complexity": "0"}
{"back-translation": "{'src': 'public class C {\\n\\tpublic static void main(String[]args){\\n\\t\tScanner sc=new Scanner(System.in);\\n\\tdouble n=sc.nextDouble(),r=sc.nextDouble();\\n\\tSystem.out.println(r/(1/Math.sin(Math.PI/n)-1));\\n\\tsc.close();\\n}\\n}', 'complexity': '0', 'index': 52}", "src": "public class C {\n\tpublic static void main(String[]args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble n=sc.nextDouble(),r=sc.nextDouble();\n\t\tSystem.out.println(r/(1/Math.sin(Math.PI/n)-1));\n\t\tsc.close();\n\t}\n}", "index": 52, "complexity": "0"}
{"back-translation": "", "src": "public class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}", "index": 53, "complexity": "0"}
{"back-translation": "with open('input.txt', 'r') as file:\n    n = int(file.read().strip())\n\nif n % 2 == 0:\n    n = n // 2\n    if n % 2 == 0:\n        print(0)\n    else:\n        print(1)\nelse:\n    n += 1\n    n = n // 2\n    if n % 2 == 0:\n        print(0)\n    else:\n        print(1)", "src": "public class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 54, "complexity": "0"}
{"back-translation": "class Codechef:    class FastScanner:        def __init__(self, is):            self.br = BufferedReader(InputStreamReader(is))        def next(self):            while self.stok is None or not self.stok.hasMoreTokens():                s = self.br.readLine()                if s is None:                    return None                self.stok = StringTokenizer(s)            return self.stok.nextToken()        def ni(self):            return int(self.next())        def nl(self):            return int(self.next())        def nd(self):            return double(self.next())        def nc(self):            return char(self.br.read())        def ns(self):            return self.br.readLine()        def nia(self, n):            a = [0]*n            for i in range(n):                a[i] = self.ni()            return a        def nla(self, n):            a = [0]*n            for i in range(n):                a[i] = self.nl()            return a        def nda(self, n):            a = [0.0]*n            for i in range(n):                a[i] = self.nd()            return a        def imat(self, n, m):            mat = [[0]*m for _ in range(n)]            for i in range(n):                for j in range(m):                    mat[i][j] = self.ni()            return mat    @staticmethod    def main(args):        hm = {}        arr = []        set = set()        pq = []        n = in.nl()        v = in.nl()        temp = n-1        ans = 0        ans += min(v, temp)        temp -= v        if temp > 0:            ans += ((temp+1)*(temp+2))/(long)2-1        out.println(ans)        out.close()    @staticmethod    def gcd(a, b):        while b != 0:            a, b = b, a%b        return a    @staticmethod    def exponent(a, n):        ans = 1        while n != 0:            if n%2 == 1:                ans = (ans*a)%mod            a = (a*a)%mod            n >>= 1        return ans    @staticmethod    def binarySearch(a, item, low, high):        if high <= low:            return (low+1) if item > a[low] else low        mid = (low+high)//2        if item == a[mid]:            return mid+1        if item > a[mid]:            return  binarySearch(a, item, mid+1, high)        return binarySearch(a, item, low, mid-1)    @staticmethod    def merge(arr, l, m, r):        n1 = m-l+1        n2 = r-m        L, R = [0]*n1, [0]*n2        for i in range(n1):            L[i] = arr[l+i]        for j in range(n2):            R[j] = arr[m+1+j]        i, j, k = 0, 0, l        while i < n1 and j < n2:            if L[i] <= R[j]:                arr[k] = L[i]                i += 1            else:                arr[k] = R[j]                j += 1            k += 1        while i < n1:            arr[k] = L[i]            i += 1            k += 1        while j < n2:            arr[k] = R[j]            j += 1            k += 1    @staticmethod    def Sort(arr, l, r):        if l < r:            m = (l+r)//2            Sort(arr, l, m)            Sort(arr, m+1, r)            merge(arr, l, m, r)    @staticmethod    def sort(a):        Sort(a, 0, len(a)-1)", "src": "public class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n        \n    \n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        \n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   static void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "index": 55, "complexity": "0"}
{"back-translation": "{'src': 'class SashaAndHisTrip: \\n\\t\\t\\n\\tdef main(args): \\n\\t\\tn = nextInt() \\n\\t\\tv = nextInt() \\n\\t\\t\\n\\t\\tif v >= n-1: \\n\\t\\t\\tprint(n-1) \\n\\t\\telse: \\n\\t\\t\\tprint((n-v)*(n-v+1)//2+v-1) \\n\\t\\n\\tdef nextLine(): \\n\\t\\treturn input() \\n\\t\\ndef nextString(): \\n\\t\\twhile st == None or not st.hasMoreTokens(): \\n\\t\\t\\tst = input().split() \\n\\t\\treturn st[0] \\n\\t\\n\\tdef nextInt(): \\n\\t\\treturn int(nextString()) \\n\\t\\n\\tdef nextLong(): \\n\\t\\treturn int(nextString()) \\n\\t\\ndef intArray(n): \\n\\t\\ta = [] \\n\\tp = input().split() \\n\\tfor i in range(n): \\n\\t\\t\\ta.append(int(p[i])) \\n\\t\\treturn a \\n\\t\\n\\ndef intArray(n, m): \\n\\t\\ta = [] \\n\\tfor i in range(n): \\n\\t\\t\\tb = [] \\n\\t\\t\\tp = input().split() \\n\\t\\tfor j in range(m): \\n\\t\\t\\t\\tb.append(int(p[j])) \\n\\t\\ta.append(b) \\n\\t\\treturn a \\n\\t\\n\\ndef longArray(n): \\n\\t\\ta = [] \\n\\tp = input().split() \\n\\tfor i in range(n): \\n\\t\\t\\ta.append(int(p[i])) \\n\\t\\treturn a \\n', 'complexity': '0', 'index': 56}", "src": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 56, "complexity": "0"}
{"back-translation": "class DLL: def __init__(self): self.head = None class Node: def __init__(self, data): self.data = data self.prev = None self.next = None def push(self, new_data): new_Node = Node(new_data) new_Node.next = self.head new_Node.prev = None if self.head != None: self.head.prev = new_Node self.head = new_Node def printlist(self, node): last = None while node != None: print(node.data, end=' ') last = node node = node.next print() def deleteNode(self, head_ref, del_Node): if self.head == None or del_Node == None: return if self.head == del_Node: self.head = del_Node.next if del_Node.next != None: del_Node.next.prev = del_Node.prev if del_Node.prev != None: del_Node.prev.next = del_Node.next return @staticmethod def main(args): dll = DLL() dll.push(2) dll.push(4) dll.push(8) dll.push(10) print('Created DLL is:', end=' ') dll.printlist(dll.head) dll.deleteNode(dll.head, dll.head) print('\\nList after deleting first node:', end=' ') dll.printlist(dll.head) dll.deleteNode(dll.head, dll.head.next) print('\\nList after Deleting middle node:', end=' ') dll.printlist(dll.head)", "src": "public\nclass\nDLL { \n\nNode head; \n\n\n\n\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n\n\n\n\n\n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n\n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\n\n\nNode new_Node = \nnew\nNode(new_data); \n\n\n\n\n\n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n\n\nhead = new_Node; \n\n} \n\n\n\n\n\n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n\n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n\n\n\n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n\n\n\n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n\n\nreturn\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nDLL dll = \nnew\nDLL(); \n\n\n\n\ndll.push(\n2\n); \n\n\n\n\ndll.push(\n4\n); \n\n\n\n\ndll.push(\n8\n); \n\n\n\n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head); \n\n\n\n\n\n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n}", "index": 57, "complexity": "0"}
{"back-translation": "class GfG: \n\n    class StackWithMax: \n\n        mainStack = [] \n        trackStack = [] \n\n        def push(x): \n            mainStack.append(x) \n            if len(mainStack) == 1: \n                trackStack.append(x) \n                return \n            if x > trackStack[-1]: \n                trackStack.append(x) \n            else: \n                trackStack.append(trackStack[-1]) \n\n        def getMax(): \n            return trackStack[-1] \n\n        def pop(): \n            mainStack.pop() \n            trackStack.pop() \n\n    def main(args): \n        s = StackWithMax() \n        s.push(20) \n        print(s.getMax()) \n        s.push(10) \n        print(s.getMax()) \n        s.push(50) \n        print(s.getMax())", "src": "class\nGfG { \n\nstatic\nclass\nStackWithMax \n{ \n\n\n\nstatic\nStack<Integer> mainStack = \nnew\nStack<Integer> (); \n\n\n\n\nstatic\nStack<Integer> trackStack = \nnew\nStack<Integer> (); \n\nstatic\nvoid\npush(\nint\nx) \n\n{ \n\nmainStack.push(x); \n\nif\n(mainStack.size() == \n1\n) \n\n{ \n\ntrackStack.push(x); \n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(x > trackStack.peek()) \n\ntrackStack.push(x); \n\nelse\n\ntrackStack.push(trackStack.peek()); \n\n} \n\n\nstatic\nint\ngetMax() \n\n{ \n\nreturn\ntrackStack.peek(); \n\n} \n\n\nstatic\nvoid\npop() \n\n{ \n\nmainStack.pop(); \n\ntrackStack.pop(); \n\n} \n}; \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nStackWithMax s = \nnew\nStackWithMax(); \n\ns.push(\n20\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n10\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n50\n); \n\nSystem.out.println(s.getMax()); \n} \n}", "index": 58, "complexity": "0"}
{"back-translation": "class GFG: def count(n): if n < 4: return -1 rem = n % 4 if rem == 0: return n // 4 if rem == 1: if n < 9: return -1 return (n - 9) // 4 + 1 if rem == 2: return (n - 6) // 4 + 1 if rem == 3: if n < 15: return -1 return (n - 15) // 4 + 2 return 0 def main(): n = 90 print(count(n)) n = 143 print(count(n)) if __name__ == '__main__': main()", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\nif\n(n < \n4\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\nint\nrem = n % \n4\n; \n\n\n\n\n\n\nif\n(rem == \n0\n) \n\nreturn\nn / \n4\n; \n\n\n\n\nif\n(rem == \n1\n) { \n\n\n\n\n\n\n\n\n\n\nif\n(n < \n9\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nreturn\n(n - \n9\n) / \n4\n+ \n1\n; \n\n} \n\n\n\n\n\n\n\n\n\nif\n(rem == \n2\n) \n\nreturn\n(n - \n6\n) / \n4\n+ \n1\n; \n\n\n\n\n\n\n\nif\n(rem == \n3\n) \n\n{ \n\nif\n(n < \n15\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\nreturn\n(n - \n15\n) / \n4\n+ \n2\n; \n\n} \n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n90\n; \n\nSystem.out.println(count(n)); \n\n\nn = \n143\n; \n\nSystem.out.println(count(n)); \n\n} \n}", "index": 59, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n\\n        long n = sc.nextLong();\\n        long s = sc.nextLong();\\n\\n        long ans = (s - 1) / n + 1;\\n        System.out.print(ans);\\n    }\\n}', 'complexity': '0', 'index': 60}", "src": "public class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "index": 60, "complexity": "0"}
{"back-translation": "{'src': 'public class OrangeJuice{\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner in=new Scanner(System.in);\\n\\t\\tint n=in.nextInt();\\n\\t\\tint s=in.nextInt();\\n\\t\\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\\n\\t\\t\\tif(s%n==0){\\n\\t\\t\\t\\tSystem.out.println(s/n);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tint o=s%n;\\n\\t\\t\\t\\tSystem.out.println((s-o)/n+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}', 'complexity': '0', 'index': 61}", "src": "public class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tif(s%n==0){\n\t\t\t\tSystem.out.println(s/n);\n\t\t\t}else{\n\t\t\t\tint o=s%n;\n\t\t\t\tSystem.out.println((s-o)/n+1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 61, "complexity": "0"}
{"back-translation": "coins = s//n + 1 if s%n != 0 else s//n\nprint(coins)", "src": "public class Solution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        if(s%n != 0)\n            coins = s/n + 1;\n        else\n            coins = s/n;\n\n        System.out.println(coins);\n\n    }\n}", "index": 62, "complexity": "0"}
{"back-translation": "class Param:\n    def main(args):\n        param = MyScanner()\n        out = PrintWriter(BufferedOutputStream(System.out))\n        l2 = param.nextLong()\n        dice1 = param.nextLong()\n        dice2 = param.nextLong()\n        \n        l1 = 1\n        r1 = 1\n        r2 = l2\n        count = 0\n        check = 0\n        count = l2 - dice1\n        count = count + (r2 - dice2)\n        check = dice1 - l1\n        check = check + (dice2 - r1)\n        \n        if check <= count:\n            System.out.println('White')\n        else:\n            System.out.println('Black')\n        out.close()\n\n    class MyScanner:\n        def __init__():\n            br = BufferedReader(InputStreamReader(System.in))\n            st = None\n\n        def next():\n            while st == None or not st.hasMoreElements():\n                try:\n                    st = StringTokenizer(br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return st.nextToken()\n\n        def nextInt():\n            return Integer.parseInt(next())\n\n        def nextLong():\n            return Long.parseLong(next())\n\n        def nextDouble():\n            return Double.parseDouble(next())\n\n        def nextLine():\n            str = ''\n            try:\n                str = br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 63, "complexity": "0"}
{"back-translation": "{'src': 'public class Dont:\\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\\n    static long n;\\n    static long x, y;\\n\\n    public static void main(String[] args) throws Exception {\\n        n = nextLong();\\n        x = nextLong();\\n        y = nextLong();\\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\\n    }\\n\\n    static long max(long a, long b) {\\n        return (a > b)? a : b ;\\n    }\\n\\n    static long nextLong() throws Exception {\\n        long res = 0;\\n        int ch = jin.read();\\n        while(ch < '0' || '9' < ch) ch = jin.read();\\n        while('0'<= ch && ch <= '9') {\\n            res = res*10 + ch - '0';\\n            ch = jin.read();\\n        }\\n        return res;\\n    }\\n}', 'complexity': '0', 'index': 64}", "src": "public class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "index": 64, "complexity": "0"}
{"back-translation": "class GFG: public static int N = 1000; static int prefixans[] = new int[1000]; public static void countIndex(int a[], int n): for i in range(n): if i + 1 < n and a[i] == a[i + 1]: prefixans[i] = 1; if i != 0: prefixans[i] += prefixans[i - 1]; public static int answer_query(int l, int r): if l == 0: return prefixans[r - 1]; else: return prefixans[r - 1] - prefixans[l - 1]; public static void main(String args[]): a = [1, 2, 2, 2, 3, 3, 4, 4, 4]; n = 9; countIndex(a, n); L, R = 1, 8; System.out.println(answer_query(L, R)); L, R = 0, 4; System.out.println(answer_query(L, R));", "src": "class\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n\n\n\nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n\npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n\n\npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n\n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n\n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n}", "index": 65, "complexity": "0"}
{"back-translation": "import sys\n\nhp = int(input())\nif hp % 4 == 1:\n    print(\"0 A\")\nelif hp % 4 == 2:\n    print(\"1 B\")\nelif hp % 4 == 3:\n    print(\"2 A\")\nelse:\n    print(\"1 A\")", "src": "public class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n         int hp = scanner.nextInt();\n        if (hp%4 == 1){\n            System.out.println(\"0 A\");\n        }\n        else if (hp%4 == 2){\n            System.out.println(\"1 B\");\n        }\n        else if (hp%4 == 3){\n            System.out.println(\"2 A\");\n        }\n        else {\n            System.out.println(\"1 A\");\n        }\n\n    }\n    }", "index": 66, "complexity": "0"}
{"back-translation": "{'src': 'public class mainA {\\n    public static PrintWriter out = new PrintWriter(System.out);\\n    public static FastScanner enter = new FastScanner(System.in);\\n\\n    public static void main(String[] args) throws IOException {\\n        int x=enter.nextInt();\\n        if(x%4==0){\\n            System.out.println(1 +\\\" A\\\");\\n        }\\n        else if(x%4==1){\\n            System.out.println(0+\\\" A\\\");\\n        }\\n        else if(x%4==2){\\n            System.out.println(1+\\\" B\\\");\\n        }\\n        else if(x%4==3){\\n            System.out.println(2+\\\" A\\\");\\n        }\\n    }\\n\\n    static class FastScanner {\\n        BufferedReader br;\\n        StringTokenizer stok;\\n\\n        FastScanner(InputStream is) {\\n            br = new BufferedReader(new InputStreamReader(is));\\n        }\\n\\n        String next() throws IOException {\\n            while (stok == null || !stok.hasMoreTokens()) {\\n                String s = br.readLine();\\n                if (s == null) {\\n                    return null;\\n                }\\n                stok = new StringTokenizer(s);\\n            }\\n            return stok.nextToken();\\n        }\\n\\n        int nextInt() throws IOException {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() throws IOException {\\n            return Long.parseLong(next());\\n        }\\n\\n        double nextDouble() throws IOException {\\n            return Double.parseDouble(next());\\n        }\\n\\n        char nextChar() throws IOException {\\n            return (char) (br.read());\\n        }\\n\\n        String nextLine() throws IOException {\\n            return br.readLine();\\n        }\\n    }\\n}', 'complexity': '0', 'index': 67}", "src": "public class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "index": 67, "complexity": "0"}
{"back-translation": "def check(n):\n    return 'D' if n%4 == 0 else ('A' if n%4 == 1 else ('C' if n%4 == 2 else 'B'))\n\nimport sys\n\nn = int(sys.stdin.readline())\na = n + 1\nb = n + 2\nn1 = check(n)\na1 = check(a)\nb1 = check(b)\nresult = min(min(a1, b1), n1)\n\nif result == n1:\n    print('0', result)\nelif result == a1:\n    print('1', result)\nelif result == b1:\n    print('2', result)", "src": "public class TokitsukazeAndEnhancement {\n\t\n\tstatic char check(int n) {\n\t\tif(n%4 == 0)\n\t\t\treturn 'D';\n\t\tif(n%4 == 1)\n\t\t\treturn 'A';\n\t\tif(n%4 == 2)\n\t\t\treturn 'C';\n\t\treturn 'B';\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st;\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint a = n + 1;\n\t\tint b = n + 2;\n\t\tchar n1 = check(n);\n\t\tchar a1 = check(a);\n\t\tchar b1 = check(b);\n\t\tchar sol = (char) Math.min(Math.min(a1, b1),n1);\n\t\tif(sol == n1)\n\t\t\tpw.println(0 + \" \" + sol);\n\t\telse if(sol == a1)\n\t\t\tpw.println(1 + \" \" + sol);\n\t\telse if(sol == b1)\n\t\t\tpw.println(2 + \" \" + sol);\n\t\tpw.close();\n\t}\n}", "index": 68, "complexity": "0"}
{"back-translation": "{'src': 'class problem2: def thisMethod2(int a): returneval(a) I = problem2() I.thisMethod2(input())', 'complexity': '0', 'index': 69}", "src": "public class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            \n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "index": 69, "complexity": "0"}
{"back-translation": "def returnLetter(n):\n    if n % 4 == 1:\n        return 'A'\n    elif n % 4 == 3:\n        return 'B'\n    elif n % 4 == 2:\n        return 'C'\n    else:\n        return 'D'\n\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        String[] a = new String[3];\n\n        for (int i = 0; i < a.length; i++) {\n            a[i] = sc.next();\n        }\n        boolean equal = true;\n\n        for (int i = 1; i < a.length; i++) {\n            if (a[i].charAt(1) != a[i - 1].charAt(1) || a[i].charAt(0) != a[i - 1].charAt(0)) {\n                equal = false;\n                break;\n            }\n        }\n        if (equal) {\n            System.out.println(0);\n        } else {\n            Arrays.sort(a);\n            boolean ord = true;\n\n            for (int i = 1; i < a.length; i++) {\n                if (a[i].charAt(1) != a[i - 1].charAt(1) || a[i].charAt(0) - a[i - 1].charAt(0) != 1) {\n                    ord = false;\n                    break;\n                }\n            }\n            if (ord) {\n                System.out.println(0);\n            } else if (a[1].charAt(1) == a[0].charAt(1) && a[1].charAt(0) - a[0].charAt(0) == 2) {\n                System.out.println(1);\n            } else if (a[2].charAt(1) == a[1].charAt(1) && a[2].charAt(0) - a[1].charAt(0) == 2) {\n                System.out.println(1);\n\n            } else if (a[2].charAt(1) == a[0].charAt(1) && a[2].charAt(0) - a[0].charAt(0) == 2) {\n                System.out.println(1);\n\n            } else if (a[0].charAt(1) == a[1].charAt(1) && a[0].charAt(0) - a[1].charAt(0) == 2) {\n                System.out.println(1);\n\n            } else if (a[1].charAt(1) == a[2].charAt(1) && a[1].charAt(0) - a[2].charAt(0) == 2) {\n                System.out.println(1);\n\n            } else if (a[0].charAt(1) == a[2].charAt(1) && a[0].charAt(0) - a[2].charAt(0) == 2) {\n                System.out.println(1);\n\n            } else if (a[1].charAt(1) == a[0].charAt(1) && a[1].charAt(0) - a[0].charAt(0) == 1) {\n                System.out.println(1);\n\n            } else if (a[2].charAt(1) == a[1].charAt(1) && a[2].charAt(0) - a[1].charAt(0) == 1) {\n                System.out.println(1);\n            } else if (a[2].charAt(1) == a[0].charAt(1) && a[2].charAt(0) - a[0].charAt(0) == 1) {\n                System.out.println(1);\n            } else if (a[0].charAt(1) == a[1].charAt(1) && a[0].charAt(0) - a[1].charAt(0) == 1) {\n                System.out.println(1);\n\n            } else if (a[1].charAt(1) == a[2].charAt(1) && a[1].charAt(0) - a[2].charAt(0) == 1) {\n                System.out.println(1);\n\n            } else if (a[0].charAt(1) == a[2].charAt(1) && a[0].charAt(0) - a[2].charAt(0) == 1) {\n                System.out.println(1);\n\n            } else if (a[1].charAt(1) == a[0].charAt(1) && a[1].charAt(0) == a[0].charAt(0)) {\n                System.out.println(1);\n\n            } else if (a[2].charAt(1) == a[1].charAt(1) && a[1].charAt(0) == a[2].charAt(0)) {\n                System.out.println(1);\n\n            } else {\n                System.out.println(2);\n            }\n\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            int start = 0;\n            boolean dec = false, neg = false;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n}", "src": "public class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}", "index": 70, "complexity": "0"}
{"back-translation": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = InputReader(inputStream)\n        out = OutputWriter(outputStream)\n        solver = KingEscape()\n        solver.solve(1, in, out)\n        out.close()\n\nclass KingEscape:\n    def solve(testNumber, in, out):\n        n = in.nextInt()\n        qx = in.nextInt()\n        qy = in.nextInt()\n        kx = in.nextInt()\n        ky = in.nextInt()\n        safex = in.nextInt()\n        safey = in.nextInt()\n        possible = False\n        if qx > max(kx, safex) or qx < min(kx, safex):\n            if qy > max(ky, safey) or qy < min(ky, safey):\n                possible = True\n        if possible:\n            out.println(\"YES\")\n        else:\n            out.println(\"NO\")\n\nclass OutputWriter:\n    def __init__(outputStream):\n        this.writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))\n\n    def print(*objects):\n        for i in range(len(objects)):\n            if i != 0:\n                writer.print(' ')\n            writer.print(objects[i])\n\n    def println(*objects):\n        print(objects)\n        writer.println()\n\n    def close():\n        writer.close()\n\nclass InputReader:\n    def __init__(stream):\n        this.stream = stream\n        this.buf = bytearray(1024)\n        this.curChar = 0\n        this.numChars = 0\n        this.filter = None\n\n    def read():\n        if numChars == -1:\n            raise InputMismatchException()\n        if curChar >= numChars:\n            curChar = 0\n            try:\n                numChars = stream.read(buf)\n            except IOException as e:\n                raise InputMismatchException()\n            if numChars <= 0:\n                return -1\n        return buf[curChar++]\n\n    def nextInt():\n        c = read()\n        while isSpaceChar(c):\n            c = read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = read()\n        res = 0\n        while not isSpaceChar(c):\n            if c < '0' or c > '9':\n                raise InputMismatchException()\n            res *= 10\n            res += c - '0'\n            c = read()\n        return res * sgn\n\n    def isSpaceChar(c):\n        if filter is not None:\n            return filter.isSpaceChar(c)\n        return isWhitespace(c)\n\n    @staticmethod\n    def isWhitespace(c):\n        return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n\n    class SpaceCharFilter:\n        def isSpaceChar(ch):\n            return True\n", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 71, "complexity": "0"}
{"back-translation": "{'src': 'class helloWorld:\\n    def main():\\n        n, m = map(int, input().split())\\n        ans = m // n\\n        if m % n > 0:\\n            ans += 1\\n        print(ans)' if __name__ == '__main__':\\n    main()}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tlong ans = m / n;\n\t\t\n\t\tif(m % n > 0)\n\t\t\tans++;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 72, "complexity": "0"}
{"back-translation": "class main:\n    def main(args):\n        init()\n        x = nextInt()\n        y = nextInt()\n        z = nextInt()\n        t1 = nextInt()\n        t2 = nextInt()\n        t3 = nextInt()\n        lift = abs(z - x) * t2 + 2 * t3 + abs(x - y) * t2 + t3\n        stair = abs(x - y) * t1\n        if lift <= stair:\n            pw.print('YES')\n        else:\n            pw.print('NO')\n        pw.close()\n\n    def next():\n        while st == None or not st.hasMoreElements():\n            st = StringTokenizer(sc.readLine())\n        return st.nextToken()\n\n    def nextInt():\n        return int(next())\n\n    def nextLong():\n        return next()\n\n    def init(in, out):\n        sc = BufferedReader(FileReader(in))\n        pw = PrintWriter(out)\n\n    def init():\n        sc = BufferedReader(InputStreamReader(System.in))\n        pw = PrintWriter(System.out)\n\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = [0] * n\n        for i in range(n):\n            self.parent[i] = i\n\n    def get(self, i):\n        if i == self.parent[i]:\n            return i\n        p = self.get(self.parent[i])\n        self.parent[i] = p\n        return p\n\n    def union(self, a, b):\n        a = self.get(a)\n        b = self.get(b)\n        if a == b:\n            return False\n        self.parent[a] = b\n        return True", "src": "public class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "index": 73, "complexity": "0"}
{"back-translation": "{'src': 'public class Main {\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n\\n        long n = sc.nextLong();\\n        long s = sc.nextLong();\\n\\n        long ans = (s - 1) / n + 1;\\n        System.out.print(ans);\\n    }\\n}', 'complexity': '0', 'index': 74}", "src": "public class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "index": 74, "complexity": "0"}
{"back-translation": "{'src': 'public class origami {\\n\\tpublic static void main(String args[]){\\n\\t\tScanner input = new Scanner(System.in);\\n\\t\tdouble n = input.nextInt();\\n\\t\tdouble k = input.nextInt();\\n\\t\tdouble red = 0;\\n\\t\tdouble green = 0;\\n\\t\tdouble blue = 0;\\n\\t\tdouble ans = 0;\\n\\t\tred = (2 * n) / k;\\n\\t\tgreen = (5 * n) / k;\\n\\t\tblue = (8 * n) / k;\\n\\n\\t\tdouble red1 = Math.ceil(red) ;\\n\\t\tdouble green1 = Math.ceil(green);\\n\\t\tdouble blue1 = Math.ceil(blue);\\n\\n\\t\tans+=red1;\\n\\t\tans+=green1;\\n\\t\tans+=blue1;\\n\\t\tDouble answer = new Double(ans);\\n\\t\tint finished = answer.intValue();\\n\\t\tSystem.out.println(finished);\\n\\t}\\n}', 'complexity': '0', 'index': 75}", "src": "public class origami {\n\tpublic static void main(String args[]){\n\t\tScanner input = new Scanner(System.in);\n\t\tdouble n = input.nextInt();\n\t\tdouble k = input.nextInt();\n\t\tdouble red = 0;\n\t\tdouble green = 0;\n\t\tdouble blue = 0;\n\t\tdouble ans = 0;\n\t\tred = (2 * n) / k;\n\t\tgreen = (5 * n) / k;\n\t\tblue = (8 * n) / k;\n\n\t\tdouble red1 = Math.ceil(red) ;\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\n\t\tans+=red1;\n\t\tans+=green1;\n\t\tans+=blue1;\n\t\tDouble answer = new Double(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}", "index": 75, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class VJudgeProblem2{\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int x = Integer.parseInt(reader.readLine());\n\n        if (x == 1)\n            System.out.println(-1);\n        else\n            System.out.println(x + \" \" + x);    \n    }\n        \n}", "index": 76, "complexity": "0"}
{"back-translation": "print('\n'.join(str(int(input()) // 7 + 1) for _ in range(int(input()))))", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "index": 77, "complexity": "0"}
{"back-translation": "class Main:\n    num = int(input())\n    for i in range(num):\n        a, b = map(int, input().split())\n        print(a, 2*a)", "src": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}", "index": 78, "complexity": "0"}
{"back-translation": "a = int(input())\nif 1 <= a <= 100:\n    if a > 2:\n        if a % 2 == 0:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        print('NO')", "src": "public class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint a = in.nextInt();\n\n\t\tif(a>=1 && a<=100){\n\t\t\tif(a>2){\n\t\t\t\tif(a%2==0){\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t}\n}", "index": 79, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class b {\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n1 = 0,n2 = 0,n3 = 0,n4 = 0;\n\t\tint n = 3;\n\t\twhile(n --> 0) {\n\t\t\tint x = zizo.nextInt();\n\t\t\tswitch(x) {\n\t\t\tcase 1:n1++;break;\n\t\t\tcase 4:n4++;break;\n\t\t\tcase 2:n2++;break;\n\t\t\tcase 3:n3++;break;\n\t\t\t}\n\t\t}\n\t\tn2 += n4/2;\n\t\tif(n1>0 || n2>1 || n3>2)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\twr.close();\n\t}\n}\nclass pair{\n\tint l,r;\n\tpair(int a,int b){l = a;r = b;}\n}\n\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n}", "index": 80, "complexity": "0"}
{"back-translation": "{'src': 'public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tout.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}', 'complexity': '0', 'index': 81}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 81, "complexity": "0"}
{"back-translation": "{'src': 'public class Main{\\n    public static void main(String [] args)\\n    {\\n        Scanner scan=new Scanner(System.in);\\n        long n=scan.nextLong();\\n        long m=scan.nextLong();\\n        n=(long)Math.pow(2,n);\\n        long ans=m%n;\\n        System.out.println(ans);\\n    }\\n}', 'complexity': '0', 'index': 82}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        long n=scan.nextLong();\n        long m=scan.nextLong();\n        n=(long)Math.pow(2,n);\n        long ans=m%n;\n        System.out.println(ans);\n    }\n}", "index": 82, "complexity": "0"}
{"back-translation": "{'src': 'public class tab{public static void main(String[] args){int n,pos,l,r;Scanner sc=new Scanner(System.in);n=sc.nextInt();pos=sc.nextInt();l=sc.nextInt();r=sc.nextInt();int sum;int a=(n-r)+(l-1);if((abs(pos-l)<abs(r-pos))&&a!=0){if(l!=1){sum=abs(pos-l);sum++;if(r!=n)sum+=(r-l)+1;}else sum=abs(r-pos)+1;}else if(a==0)sum=0;else{if(r!=n){sum=abs(r-pos);sum++;if(l!=1)sum+=(r-l)+1;}else sum=abs(pos-l)+1;}System.out.println(sum);}}', 'complexity': '0', 'index': 83}", "src": "public class tab\n{\npublic static void main(String[] args)\n{\nint n,pos,l,r;\nScanner sc=new Scanner(System.in);\nn=sc.nextInt();\npos=sc.nextInt();\nl=sc.nextInt();\nr=sc.nextInt();\nint sum;\nint a=(n-r)+(l-1);\nif((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)\n{\n if(l!=1)\n   {sum=Math.abs(pos-l);\n    sum++;\n    if(r!=n)\n      sum+=(r-l)+1;\n   }\n else\n   sum=Math.abs(r-pos)+1;\n}\nelse if(a==0)\n  sum=0; \nelse\n{\n  if(r!=n)\n  {  sum=Math.abs(r-pos);\n     sum++;\n     if(l!=1) \n     sum+=(r-l)+1;\n  }\n  else\n   sum=Math.abs(pos-l)+1;\n}\nSystem.out.println(sum);\n}}", "index": 83, "complexity": "0"}
{"back-translation": "{'src': 'public class Main { \\n\\n\\tpublic static void main(String[] args) { \\n\\t\\tScanner kai = new Scanner(System.in); \\n\\t\\twhile (kai.hasNext()) { \\n\\t\\t\\tint a = kai.nextInt(); \\n\\t\\t\\tif ((a & 1) == 0) { \\n\\t\\t\\t\\tSystem.out.println(\"Mahmoud\"); \\n\\t\\t\\t}else { \\n\\t\\t\\t\\tSystem.out.println(\"Ehab\"); \\n\\t\\t\\t} \\n\\t\\t} \\n\\t} \\n}', 'complexity': '0', 'index': 84}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 84, "complexity": "0"}
{"back-translation": "class PizzaPizzaPizza:\n    in = BufferedReader(InputStreamReader(System.in))\n    out = PrintWriter(BufferedOutputStream(System.out))\n    st = None\n    \n    def main(args):\n        n = nextLong()\n        if n == 0:\n            System.out.println(0)\n        elif n % 2 == 0:\n            System.out.println(n+1)\n        else:\n            System.out.println((n+1)//2)\n    \n    def nextLine():\n        return in.readLine()\n\n    def nextString():\n        while st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readLine());\n        return st.nextToken()\n\n    def nextInt():\n        return int(nextString())\n\n    def nextLong():\n        return int(nextString())\n\n    def intArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextInt()\n        return a\n\n    def intArray(n, m):\n        a = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                a[i][j] = nextInt()\n        return a\n\n    def longArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextLong()\n        return a", "src": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 85, "complexity": "0"}
{"back-translation": "print(max(int(input())-sum(map(int,input().split())), 1))", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b)\n\t\t\tans = -1;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 86, "complexity": "0"}
{"back-translation": "class AlexAndARhombus:\n    \n    def intArray(n):\n        a = [int(nextString()) for _ in range(n)]\n        return a\n    \n    def intArray(n, m):\n        a = [[int(nextString()) for _ in range(m)] for _ in range(n)]\n        return a\n    \n    def longArray(n):\n        a = [long(nextString()) for _ in range(n)]\n        return a\n    \n    def nextInt():\n        return int(nextString())\n    \n    def nextLong():\n        return long(nextString())\n    \n    def nextString():\n        while st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readline())\n        return st.nextToken()\n    \n    def nextLine():\n        return in.readLine()\n    \n    def main(args):\n        n = nextInt()\n        print(n*n + (n - 1)*(n - 1))", "src": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 87, "complexity": "0"}
{"back-translation": "class simple:\n    def run(self):\n        input = InputReader(sys.stdin)\n        w = PrintWriter(sys.stdout)\n        n = input.nextInt()\n        print((2 * n * n) - (2 * n) + 1)\n    \n    class Graph:\n        def __init__(self, v):\n            self.v = v\n            self.adj = [[] for _ in range(v)]\n            \n        def addEdge(self, a, b):\n            self.adj[a].append(b)\n        \n        def isCyclic(self):\n            visited = [False] * self.v\n            recStack = [False] * self.v\n            for i in range(self.v):\n                if self.isCyclicUtil(i, visited, recStack):\n                    return True\n            return False\n        \n        def isCyclicUtil(self, i, visited, recStack):\n            if recStack[i]:\n                return True\n            if visited[i]:\n                return False\n            visited[i] = True\n            recStack[i] = True\n            children = self.adj[i]\n            for c in children:\n                if self.isCyclicUtil(c, visited, recStack):\n                    return True\n            recStack[i] = False\n            return False\n\n    @staticmethod\n    def sortbyColumn(arr, col):\n        arr.sort(key = lambda x: x[col])\n        \n    @staticmethod\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return simple.gcd(b, a % b)\n    \n    class DJSet:\n        def __init__(self, n):\n            self.upper = [-1] * n\n        \n        def root(self, x):\n            return x if self.upper[x] < 0 else (self.upper[x] = self.root(self.upper[x]))\n        \n        def equiv(self, x, y):\n            return self.root(x) == self.root(y)\n        \n        def union(self, x, y):\n            x = self.root(x)\n            y = self.root(y)\n            if x != y:\n                if self.upper[y] < self.upper[x]:\n                    d = x\n                    x = y\n                    y = d\n                self.upper[x] += self.upper[y]\n                self.upper[y] = x\n            return x == y\n        \n    @staticmethod\n    def radixSort(f):\n        to = [0] * len(f)\n        b = [0] * 65537\n        for i in range(len(f)):\n            b[1 + (f[i] & 0xffff)] += 1\n        for i in range(1, 65537):\n            b[i] += b[i - 1]\n        for i in range(len(f)):\n            to[b[f[i] & 0xffff] += 1\n        d = f\n        f = to\n        to = d\n        b = [0] * 65537\n        for i in range(len(f)):\n            b[1 + (f[i] >> 16)] += 1\n        for i in range(1, 65537):\n            b[i] += b[i - 1]\n        for i in range(len(f)):\n            to[b[f[i] >> 16] += 1\n        d = f\n        f = to\n        to = d\n        return f\n\n    class InputReader:\n        def __init__(self, stream):\n            self.stream = stream\n            self.buf = bytearray(b'\n') * 1024\n            self.curChar = 0\n            self.numChars = 0\n            self.filter = None\n            self.br = io.BufferedReader(io.FileIO(stream.fileno(), 'r'))\n        \n        def read(self):\n            if self.numChars == -1:\n                raise InputMismatchException()\n            if self.curChar >= self.numChars:\n                self.curChar = 0\n                try:\n                    self.numChars = self.stream.readinto(self.buf)\n                except IOError:\n                    raise InputMismatchException()\n                if self.numChars <= 0:\n                    return -1\n            return self.buf[self.curChar]\n        \n        def nextLine(self):\n            return self.br.readline().decode().strip()\n        \n        def nextInt(self):\n            c = self.read()\n            while c <= 32:\n                c = self.read()\n            sgn = 1\n            if c == 45:\n                sgn = -1\n                c = self.read()\n            res = 0\n            while c >= 48:\n                res = 10 * res + c - 48\n                c = self.read()\n            return sgn * res\n        def nextLong(self):\n            c = self.read()\n            while c <= 32:\n                c = self.read()\n            sgn = 1\n            if c == 45:\n                sgn = -1\n                c = self.read()\n            res = 0\n            while c >= 48:\n                res = 10 * res + c - 48\n                c = self.read()\n            return sgn * res\n\n        def nextDouble(self):\n            return float(self.next())\n        \n        def readString(self):\n            c = self.read()\n            while c <= 32:\n                c = self.read()\n            res = b''\n            while c > 32:\n                res += bytes([c])\n                c = self.read()\n            return res.decode()\n        \n        def isSpaceChar(self, c):\n            return c == 32 or c == 10 or c == 13 or c == 9 or c == -1\n        \n        def next(self):\n            return self.readString()\n    \nif __name__ == '__main__':\n    simple().run()", "src": "public class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "index": 88, "complexity": "0"}
{"back-translation": "class\nGFG:\n\n    @staticmethod\n    def countStr(n):\n        return 1 + (n * 2) + (n * ((n * n) - 1) // 2)\n\n    @staticmethod\n    def main(args):\n        n = 3\n        print(GFG.countStr(n))\n", "src": "class\nGFG \n{ \n\nstatic\nint\ncountStr(\nint\nn) \n\n{ \n\nreturn\n1\n+ (n * \n2\n) + \n\n(n * ((n * n) - \n1\n) / \n2\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\nn = \n3\n; \n\nSystem.out.println( countStr(n)); \n} \n}", "index": 89, "complexity": "0"}
{"back-translation": "class Test: def binarySearch(arr, l, r, x): if r>=l: mid = l + (r - l)//2 if arr[mid] == x: return mid if arr[mid] > x: return binarySearch(arr, l, mid-1, x) return binarySearch(arr, mid+1, r, x) return -1 def findPos(arr, key): l, h = 0, 1 val = arr[0] while val < key: l = h if (2*h < len(arr)-1): h = 2*h else: h = len(arr)-1 val = arr[h] return binarySearch(arr, l, h, key) def main(args): arr = [3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170] ans = findPos(arr, 10) if ans==-1: print('Element not found') else: print('Element found at index '+ str(ans))", "src": "class\nTest \n{ \n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r>=l) \n\n{ \n\nint\nmid = l + (r - l)/\n2\n; \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid-\n1\n, x); \n\nreturn\nbinarySearch(arr, mid+\n1\n, r, x); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindPos(\nint\narr[],\nint\nkey) \n\n{ \n\nint\nl = \n0\n, h = \n1\n; \n\nint\nval = arr[\n0\n]; \n\n\n\n\nwhile\n(val < key) \n\n{ \n\nl = h; \n\n\n\n\n\n\nif\n(\n2\n*h < arr.length-\n1\n) \n\nh = \n2\n*h; \n\nelse\n\nh = arr.length-\n1\n; \n\n\nval = arr[h]; \n\n\n} \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, l, h, key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n3\n, \n5\n, \n7\n, \n9\n, \n10\n, \n90\n, \n\n100\n, \n130\n, \n140\n, \n160\n, \n170\n}; \n\nint\nans = findPos(arr,\n10\n); \n\n\nif\n(ans==-\n1\n) \n\nSystem.out.println(\n\"Element not found\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ ans); \n\n} \n}", "index": 90, "complexity": "2"}
{"back-translation": "class Main : def ceilSearch(arr, low, high, x): mid = (low + high) // 2 if x <= arr[low]: return low if x > arr[high]: return -1 if arr[mid] == x: return mid elif arr[mid] < x: return mid + 1 if mid + 1 <= high and x <= arr[mid + 1] else ceilSearch(arr, mid + 1, high, x) else: return mid if mid - 1 >= low and x > arr[mid - 1] else ceilSearch(arr, low, mid - 1, x) def main(args): arr = [1, 2, 8, 10, 10, 12, 19] n = len(arr) x = 8 index = ceilSearch(arr, 0, n - 1, x) if index == -1: print('Ceiling of ' + str(x) + ' doesn\\'t exist in array') else: print('ceiling of ' + str(x) + ' is ' + str(arr[index])) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n\n\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 91, "complexity": "2"}
{"back-translation": "class Majority:\n    @staticmethod\n    def _binarySearch(arr, low, high, x):\n        if high >= low:\n            mid = (low + high) // 2\n            if (mid == 0 or x > arr[mid - 1]) and (arr[mid] == x):\n                return mid\n            elif x > arr[mid]:\n                return Majority._binarySearch(arr, mid + 1, high, x)\n            else:\n                return Majority._binarySearch(arr, low, mid - 1, x)\n        return -1\n\n    @staticmethod\n    def isMajority(arr, n, x):\n        i = Majority._binarySearch(arr, 0, n - 1, x)\n        if i == -1:\n            return False\n        if (i + n // 2) <= (n - 1) and arr[i + n // 2] == x:\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def main(args):\n        arr = [1, 2, 3, 3, 3, 3, 10]\n        n = len(arr)\n        x = 3\n        if Majority.isMajority(arr, n, x) == True:\n            print(x + ' appears more than ' + str(n // 2) + ' times in arr[]')\n        else:\n            print(x + ' does not appear more than ' + str(n // 2) + ' times in arr[]')\n", "src": "class\nMajority { \n\n\n\n\nstatic\nint\n_binarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nif\n(high >= low) \n\n{ \n\nint\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n( (mid == \n0\n|| x > arr[mid-\n1\n]) && (arr[mid] == x) ) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\n_binarySearch(arr, (mid + \n1\n), high, x); \n\nelse\n\nreturn\n_binarySearch(arr, low, (mid -\n1\n), x); \n\n} \n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\nstatic\nboolean\nisMajority(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni = _binarySearch(arr, \n0\n, n-\n1\n, x); \n\n\n\n\nif\n(i == -\n1\n) \n\nreturn\nfalse\n; \n\n\n\n\nif\n(((i + n/\n2\n) <= (n -\n1\n)) && arr[i + n/\n2\n] == x) \n\nreturn\ntrue\n; \n\nelse\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n, \n10\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nif\n(isMajority(arr, n, x)==\ntrue\n) \n\nSystem.out.println(x + \n\" appears more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\nelse\n\nSystem.out.println(x + \n\" does not appear more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\n} \n}", "index": 92, "complexity": "2"}
{"back-translation": "{'src': 'public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) // 2; \n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) // 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println('---------');\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}', 'complexity': '2', 'index': 93}", "src": "public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2; \n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "index": 93, "complexity": "2"}
{"back-translation": "class findMedianTwoArrays:\n    def main(arr1, start1, end1, arr2, start2, end2):\n        if end1 - start1 == 1 and end2 - start2 == 1:\n            return (max(arr1[start1], arr2[start2]) + min(arr1[end1], arr2[end2])) / 2\n        median1Index = (start1 + end1) // 2\n        median2Index = (start2 + end2) // 2\n        median1 = arr1[median1Index]\n        median2 = arr2[median2Index]\n        if median1 == median2:\n            return median1\n        if median1 < median2:\n            start1 = median1Index\n            if end2 - start2 > 1:\n                end2 = median2Index\n        else:\n            start2 = median2Index\n            if end1 - start1 > 1:\n                end1 = median1Index\n        return main(arr1, start1, end1, arr2, start2, end2)\nclass test:\n    def main(args):\n        A = [1, 2, 3, 4, 4]\n        B = [6, 9, 10, 11, 15]\n        findMedian = findMedianTwoArrays()\n        print(\"Hello Python\")\n        print(findMedian.main(A, 0, 4, B, 0, 4))\ntest.main([])", "src": "class findMedianTwoArrays\n{\n  public static double main(\n    int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n    if ( end1 - start1 == 1 && end2 - start2 == 1 ) {\n        return ( Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2]) ) / 2;\n    }    \n  \n  int median1Index = Math.floor((start1 + end1 ) / 2);\n  int median2Index = Math.floor((start2 + end2 ) / 2);\n  int median1 = arr1[median1Index];\n  int median2 = arr2[median2Index];\n\n  if ( median1 == median2 ) {\n    return median1;\n  }    \n\n  if ( median1 < median2 ) {\n    start1 = median1Index;\n    if ( end2 - start2 > 1 ) { \n        end2 = median2Index;\n    }        \n  } else {\n    start2 = median2Index;\n    if ( end1 - start1 > 1 ) { \n        end1 = median1Index;\n    }    \n  }            \n\n  return main(arr1, start1, end1, arr2, start2, end2);\n  }\n}\n\nclass test {\n  public static void main(String[] args) {\n    int[] A = { 1, 2, 3, 4, 4 };\n    int[] B = { 6, 9, 10, 11, 15};\n    findMedianTwoArrays findMedian = new findMedianTwoArrays();\n    System.out.println(\"Hello Java\");\n    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));\n  }    \n}", "index": 94, "complexity": "2"}
{"back-translation": "class MedianOfTwoSortedArrayOfDifferentLength:\n\n    def findMedianSortedArrays(self, input1, input2):\n\n        if len(input1) > len(input2):\n            return self.findMedianSortedArrays(input2, input1)\n        x = len(input1)\n        y = len(input2)\n\n        low = 0\n        high = x\n        while low <= high:\n            partitionX = (low + high)//2\n            partitionY = (x + y + 1)//2 - partitionX\n\n            maxLeftX = input1[partitionX - 1] if partitionX != 0 else float('-inf')\n            minRightX = input1[partitionX] if partitionX != x else float('inf')\n\n            maxLeftY = input2[partitionY - 1] if partitionY != 0 else float('-inf')\n            minRightY = input2[partitionY] if partitionY != y else float('inf')\n\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY))/2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n\n        raise ValueError()\n\n    def main(self):\n        x = [1, 3, 8, 9, 15]\n        y = [7, 11, 19, 21, 18, 25]\n\n        mm = MedianOfTwoSortedArrayOfDifferentLength()\n        mm.findMedianSortedArrays(x, y)\n", "src": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high)/2;\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            \n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "index": 95, "complexity": "2"}
{"back-translation": "{'src': 'public class FloorAndCeilingSortedArray {\\n\\n    public int floor(int[] input, int x) {\\n        int low = 0;\\n        int high = input.length - 1;\\n        while (low <= high) {\\n            int middle = (low + high) / 2;\\n            if (input[middle] == x || (input[middle] < x && (middle == input.length - 1 || input[middle + 1] > x))) {\\n                return middle;\\n            } else if (input[middle] < x) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public int ceiling(int[] input, int x) {\\n        int low = 0;\\n        int high = input.length - 1;\\n        while (low <= high) {\\n            int middle = (low + high) / 2;\\n            if (input[middle] == x || (input[middle] > x && (middle == 0 || input[middle - 1] < x))) {\\n                return middle;\\n            } else if (input[middle] < x) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public static void main(String[] args) {\\n        int[] input = {1, 2, 5, 6, 11, 15};\\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\\n        System.out.println(foc.floor(input, 15));\\n        System.out.println(foc.ceiling(input, 2));\\n    }\\n}', 'complexity': '2', 'index': 96}", "src": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "index": 96, "complexity": "2"}
{"back-translation": "{'src': 'public class FloorAndCeilingInASortedArray {\\n\\n\\t\\n\\tprivate static int ceilSearch(int arr[], int low, int high, int x) {\\n\\t\\tint mid;\\n\\n\\t\\t\\n\\t\\tif (x <= arr[low])\\n\\t\\t\\treturn low;\\n\\n\\t\\t\\n\\t\\tif (x > arr[high])\\n\\t\\t\\treturn -1;\\n\\n\\t\\t\\n\\t\\tmid = (low + high) // 2; \\n\\n\\t\\t\\n\\t\\tif (arr[mid] == x)\\n\\t\\t\\treturn mid;\\n\\n\\t\\t\\n\\t\\telse if (x > arr[mid]) {\\n\\t\\t\\tif (mid + 1 <= high && x <= arr[mid + 1])\\n\\t\\t\\t\\treturn mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn ceilSearch(arr, mid + 1, high, x);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif (mid - 1 >= low && x > arr[mid - 1])\\n\\t\\t\\t\\treturn mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn ceilSearch(arr, low, mid - 1, x);\\n\\t\\t}\\n\\t}\\n\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tint arr[] = { 1, 2, 8, 10, 10, 12, 19 };\\n\\t\\tint n = arr.length;\\n\\t\\tint x = 11;\\n\\t\\tint index = ceilSearch(arr, 0, n - 1, x);\\n\\t\\tif (index == -1)\\n\\t\\t\\tSystem.out.println(\\\"Ceiling of doesn't exist in array \\\" + x);\\n\\t\\telse\\n\\t\\t\\tSystem.out.println(\\\"ceiling of\\\" + x + \\\" is \\\" + arr[index]);\\n\\n\\t}\\n\\n}', 'complexity': '2', 'index': 97}", "src": "public class FloorAndCeilingInASortedArray {\n\n\t\n\tprivate static int ceilSearch(int arr[], int low, int high, int x) {\n\t\tint mid;\n\n\t\t\n\t\tif (x <= arr[low])\n\t\t\treturn low;\n\n\t\t\n\t\tif (x > arr[high])\n\t\t\treturn -1;\n\n\t\t\n\t\tmid = (low + high) / 2; \n\n\t\t\n\t\tif (arr[mid] == x)\n\t\t\treturn mid;\n\n\t\t\n\t\telse if (x > arr[mid]) {\n\t\t\tif (mid + 1 <= high && x <= arr[mid + 1])\n\t\t\t\treturn mid + 1;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, mid + 1, high, x);\n\t\t}\n\n\t\t\n\t\telse {\n\t\t\tif (mid - 1 >= low && x > arr[mid - 1])\n\t\t\t\treturn mid;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, low, mid - 1, x);\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tint arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n\t\tint n = arr.length;\n\t\tint x = 11;\n\t\tint index = ceilSearch(arr, 0, n - 1, x);\n\t\tif (index == -1)\n\t\t\tSystem.out.println(\"Ceiling of doesn't exist in array \" + x);\n\t\telse\n\t\t\tSystem.out.println(\"ceiling of\" + x + \" is \" + arr[index]);\n\n\t}\n\n}", "index": 97, "complexity": "2"}
{"back-translation": "class FloorInSortedArray:\n    def floor(A, val):\n        if val < A[0]:\n            raise Exception('All elements are greater than val')\n        elif val > A[len(A) - 1]:\n            return A[len(A) - 1]\n        return FloorInSortedArray.floor(A, 0, len(A) - 1, val)\n\n    def floor_helper(A, l, r, val):\n        if l > r:\n            raise Exception('Not found')\n        mid = (l + r) // 2\n        if val == A[mid]:\n            return A[mid]\n        elif val < A[mid]:\n            if val >= A[mid - 1]:\n                return A[mid - 1]\n            return FloorInSortedArray.floor_helper(A, l, mid - 1, val)\n        else:\n            if val < A[mid + 1]:\n                return A[mid]\n            return FloorInSortedArray.floor_helper(A, mid + 1, r, val)\n\n    def main(args):\n        A = [1, 3, 4, 7, 8, 12, 32, 45, 78, 98]\n        print(FloorInSortedArray.floor(A, 11))\n        print(FloorInSortedArray.floor(A, 32))\n        print(FloorInSortedArray.floor(A, 70))\n        print(FloorInSortedArray.floor(A, 125))\n\nif __name__ == '__main__':\n    import sys\n    sys.exit(main(sys.argv))\n", "src": "public class FloorInSortedArray {\n\tpublic static int floor(int[] A, int val) throws Exception {\n\t\tif (val < A[0])\n\t\t\tthrow new Exception(\"All elements are greater than val\");\n\t\telse if (val > A[A.length - 1])\n\t\t\treturn A[A.length - 1];\n\t\treturn floor(A, 0, A.length - 1, val);\n\t}\n\n\tprivate static int floor(int[] A, int l, int r, int val) throws Exception {\n\t\tif (l > r) {\n\t\t\tthrow new Exception(\"Not found\");\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tif (val == A[mid])\n\t\t\treturn A[mid];\n\t\telse if (val < A[mid]) {\n\t\t\tif (val >= A[mid - 1])\n\t\t\t\treturn A[mid - 1];\n\t\t\treturn floor(A, l, mid - 1, val);\n\t\t} else {\n\t\t\tif (val < A[mid + 1])\n\t\t\t\treturn A[mid];\n\t\t\treturn floor(A, mid + 1, r, val);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[] { 1, 3, 4, 7, 8, 12, 32, 45, 78, 98 };\n\t\t\n\t\tSystem.out.println(floor(A, 11));\n\t\tSystem.out.println(floor(A, 32));\n\t\tSystem.out.println(floor(A, 70));\n\t\tSystem.out.println(floor(A, 125));\n\t}\n\n}", "index": 98, "complexity": "2"}
{"back-translation": "class BinarySearch:\n\n    def search(self, input_arr, search):\n        low = 0\n        high = len(input_arr) - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if input_arr[mid] == search:\n                return mid\n            elif input_arr[mid] < search:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def main(self):\n        bSearch = BinarySearch()\n        arr1 = [1, 2, 4, 5, 7, 8]\n        print(bSearch.search(arr1, -1))\n        print(bSearch.search(arr1, 1))\n        print(bSearch.search(arr1, 8))\n        print(bSearch.search(arr1, 2))\n", "src": "public class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "index": 99, "complexity": "2"}
{"back-translation": "class CircularBinarySearch:\n\n    def search(self, arr):\n        low = 0\n        high = len(arr) - 1\n        mid = 0\n        while low < high:\n            mid = (low + high) // 2\n            if (low == mid or arr[mid] < arr[mid - 1]) and arr[mid] < arr[mid + 1]:\n                return arr[mid]\n            if arr[mid] >= arr[low] and arr[mid] >= arr[high]:\n                if arr[low] < arr[high]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if arr[mid - 1] < arr[mid + 1]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return arr[low]\n\n    def main(self):\n        cbs = CircularBinarySearch()\n        arr = [7, 10, 8, 5, 2, 3, 5]\n        print(cbs.search(arr))\n\n        arr1 = [5, 8, 10, 7, 5, 3, 2]\n        print(cbs.search(arr1))\n\n        arr2 = [3, 5, 7, 10, 8, 5, 2]\n        print(cbs.search(arr2))\n\n        arr3 = [8, 5, 2, 3, 5, 7, 10]\n        print(cbs.search(arr3))\n\n        arr4 = [5, 3, 2, 5, 8, 10, 7]\n        print(cbs.search(arr4))\n\n        arr5 = [100, 20, 10, 5, 2, 8, 11, 16, 19]\n        print(cbs.search(arr5))\n\n        arr6 = [200, 2, 10, 15, 20, 80, 110, 160, 190]\n        print(cbs.search(arr6))\n\n        arr7 = [5, 10, 20, 50, 200, 800, 1100, 1600, 1900, 2]\n        print(cbs.search(arr7))\n\n        arr8 = [2, 5, 10, 20, 50, 200, 800, 1100, 1600, 1900]\n        print(cbs.search(arr8))\n\n        arr9 = [3, 1, 8, 5, 4]\n        print(cbs.search(arr9))\n\nCircularBinarySearch().main()", "src": "public class CircularBinarySearch {\n\n    \n    \n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            \n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "index": 100, "complexity": "2"}
{"back-translation": "class MonotonicallyIncreasingFunctionBecomesPositive:\n\n    def f(self, x):\n        return x*x - 10*x - 20\n\n    def findPoint(self):\n        i = 1\n        while self.f(i) <= 0:\n            i = i*2\n        return self.binarySearch(i//2, i)\n\n    def binarySearch(self, start, end):\n        mid = (start+end)//2\n        while start < end:\n            mid = (start+end)//2\n            if self.f(mid) > 0 and self.f(mid-1) <= 0:\n                return mid\n            if self.f(mid) <= 0 and self.f(mid+1) > 0:\n                return mid+1\n            if self.f(mid) <= 0:\n                start = mid+1\n            else:\n                end = mid-1\n        return mid\n\n    def main(self):\n        mif = MonotonicallyIncreasingFunctionBecomesPositive()\n        print(mif.findPoint())\n\nmif = MonotonicallyIncreasingFunctionBecomesPositive()\nmif.main()", "src": "public class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "index": 101, "complexity": "2"}
{"back-translation": "class SortedAndRotatedArraySearch:\n\n    def search(self, arr, search):\n        low = 0\n        high = len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == search:\n                return mid\n            \n            if arr[mid] < arr[high]:\n                if arr[mid] < search and search <= arr[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if search >= arr[low] and search < arr[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return -1\n\n    def searchWithDuplicates(self, arr, search):\n        low = 0\n        high = len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == search:\n                return True\n            \n            if arr[mid] == arr[low]:\n                low += 1\n            elif arr[mid] == arr[high]:\n                high -= 1\n            elif arr[mid] < arr[high]:\n                if arr[mid] < search and search <= arr[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if search >= arr[low] and search < arr[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return False\n\n    def main(self):\n        ras = SortedAndRotatedArraySearch()\n        arr1 = [1, 2, 5, 6, 7, 8, 11, 21]\n        print(ras.search(arr1, 1), end='')\n        print(ras.search(arr1, 5), end='')\n        print(ras.search(arr1, 22))\n\n        arr2 = [18, 21, 1, 2, 5, 6, 7, 8, 10, 15]\n        print(ras.search(arr2, 1), end='')\n        print(ras.search(arr2, 5), end='')\n        print(ras.search(arr2, 10), end='')\n        print(ras.search(arr2, 14))\n\n        arr3 = [7, 8, 15, 17, 18, 21, 1, 2, 5, 6]\n        print(ras.search(arr3, 1), end='')\n        print(ras.search(arr3, 5), end='')\n        print(ras.search(arr3, 10), end='')\n        print(ras.search(arr3, 7), end='')\n        print(ras.search(arr3, 6), end='')\n        print(ras.search(arr3, 16))\n\nras.main()", "src": "public class SortedAndRotatedArraySearch {\n\n    \n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            \n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { \n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "index": 102, "complexity": "2"}
{"back-translation": "{'src': 'public class SearchForRange {\\n    public int[] searchRange(int[] nums, int target) {\\n        int first = firstOccurence(nums, target);\\n        if (first == -1) {\\n            return new int[]{-1, -1};\\n        }\\n        int last = lastOccurence(nums, target);\\n        return new int[]{first, last};\\n    }\\n\\n    private int firstOccurence(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\\n                return mid;\\n            } else if (nums[mid] >= target) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int lastOccurence(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\\n                return mid;\\n            } else if (nums[mid] <= target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String args[]) {\\n        SearchForRange searchForRange = new SearchForRange();\\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\\n        int[] r = searchForRange.searchRange(nums, 11);\\n        System.out.println(r[0] + ' ' + r[1]);\\n        r = searchForRange.searchRange(nums, 0);\\n        System.out.println(r[0] + ' ' + r[1]);\\n    }\\n}', 'complexity': '2', 'index': 103}", "src": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "index": 103, "complexity": "2"}
{"back-translation": "class PeakElement:\n\n    def findPeakElement(self, nums):\n        low = 0\n        high = len(nums) - 1\n        middle = 0\n        while low <= high:\n            middle = (low + high)//2\n            before = float('-inf')\n            if middle > 0:\n                before = nums[middle - 1]\n            after = float('-inf')\n            if middle < len(nums) - 1:\n                after = nums[middle + 1]\n            if nums[middle] > before and nums[middle] > after:\n                return middle\n            elif before > after:\n                high = middle - 1\n            else:\n                low = middle + 1\n        return middle\n\n    def main(self):\n        arr = [10, 5, 15, 2, 23, 90, 67]\n        pe = PeakElement()\n        print(pe.findPeakElement(arr))\n        arr1 = [10, 20, 30, 40, 50]\n        print(pe.findPeakElement(arr1))\n        arr2 = [100, 90, 80, 70, 60]\n        print(pe.findPeakElement(arr2))\n", "src": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}", "index": 104, "complexity": "2"}
{"back-translation": "class FirstOccurrenceOfNumberInSortedArray:\n\n    def firstOccurrence(self, input, x):\n        low = 0\n        high = len(input) - 1\n        while low <= high:\n            middle = (low + high) // 2\n            if input[middle] == x and (middle == 0 or input[middle - 1] < x):\n                return middle\n            elif input[middle] < x:\n                low = middle + 1\n            else:\n                high = middle - 1\n        return -1\n    \n    def main(self, args):\n        fos = FirstOccurrenceOfNumberInSortedArray()\n        input = [1, 2, 2, 2, 2, 2, 5, 7, 7]\n        print(fos.firstOccurrence(input, 6))\n", "src": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "index": 105, "complexity": "2"}
{"back-translation": "class CountOne:\n\n    def countOne(a):\n        l = 0\n        h = len(a) - 1\n        mid = -1\n\n        while l <= h:\n            mid = (l + h) // 2\n\n            if (mid == h or a[mid + 1] == 0) and a[mid] == 1:\n                print('Count ' + str(mid + 1))\n                return\n\n            if a[mid] < 1:\n                h = mid - 1\n            else:\n                l = mid + 1\n\n        print(' No one\\'s found ')\n\ndef main(args):\n    arr = [0, 0, 0, 0, 0, 0, 0]\n    countOne(arr)\n\nmain(None)", "src": "class CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    \n    \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       while(l<=h)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "index": 106, "complexity": "2"}
{"back-translation": "{'src': 'public class Search {\\n\\n    public static bool find2(lst, begin, end, element):\\n        if begin <= end:\\n            medium = begin + (end - begin) // 2\\n            if lst[medium] == element:\\n                return True\\n            # this condition got removed in translation\\n            # this condition got removed in translation\\n            if lst[medium] > element:\\n                return find2(lst, 0, medium - 2, element)\\n            return find2(lst, medium + 2, end, element)\\n        return False\\n\\n    public static int find(lst, begin, end, element):\\n        if begin < end:\\n            medium = begin + (end - begin) // 2\\n            if lst[medium] == element:\\n                return medium\\n            # this condition got removed in translation\\n            # this condition got removed in translation\\n            if lst[medium] > element:\\n                return find(lst, 0, medium - 2, element)\\n            return find(lst, medium + 2, end, element)\\n\\n\\n        return -1\\n\\n    public static void main(args):\\n        lst = [12, 13, 21, 36, 3, 43, 65, 76, 88, 91, 100]\\n        print(find2(lst, 0, len(lst)-1, 13)\\n\\n}'", "no-text": true, "src": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n\n\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length-1, 13));\n    }\n\n\n}", "index": 107, "complexity": "2"}
{"back-translation": "class GFG: \n    \n    st = [] \n\n    def push_digits(number): \n        while number != 0: \n            st.append(number % 10) \n            number = number // 10 \n\n    def reverse_number(number): \n        push_digits(number) \n        reverse = 0 \n        i = 1 \n        while st: \n            reverse += st[-1] * i \n            st.pop() \n            i *= 10 \n        return reverse \n\n    def main(args): \n        number = 39997 \n        print(reverse_number(number)) \n\nif __name__ == '__main__': \n    GFG.main(None)", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n\n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nwhile\n(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\n} \n\n} \n\n\n\n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n\n\n\n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n\n\n\n\nwhile\n(!st.isEmpty()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\nst.pop(); \n\ni = i * \n10\n; \n\n} \n\n\n\n\nreturn\nreverse; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n}", "index": 108, "complexity": "2"}
{"back-translation": "class BinarySearch: def countRotations(arr, low, high): if high < low: return 0 if high == low: return low mid = low + (high - low)//2 if mid < high and arr[mid+1] < arr[mid]: return mid + 1 if mid > low and arr[mid] < arr[mid - 1]: return mid if arr[high] > arr[mid]: return countRotations(arr, low, mid - 1) return countRotations(arr, mid + 1, high) def main(args): arr = [15, 18, 2, 3, 6, 12] n = len(arr) print(countRotations(arr, 0, n-1)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nBinarySearch \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountRotations(\nint\narr[], \nint\nlow, \n\nint\nhigh) \n\n{ \n\n\n\n\n\n\n\nif\n(high < low) \n\nreturn\n0\n; \n\n\n\n\nif\n(high == low) \n\nreturn\nlow; \n\n\n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\n(mid + \n1\n); \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nmid; \n\n\n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\ncountRotations(arr, low, mid - \n1\n); \n\n\nreturn\ncountRotations(arr, mid + \n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n15\n, \n18\n, \n2\n, \n3\n, \n6\n, \n12\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(countRotations(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 109, "complexity": "2"}
{"back-translation": "class Minimum: def findMin(arr, low, high): if high < low: return arr[0] if high == low: return arr[low] mid = low + (high - low)//2 if mid < high and arr[mid+1] < arr[mid]: return arr[mid+1] if mid > low and arr[mid] < arr[mid - 1]: return arr[mid] if arr[high] > arr[mid]: return findMin(arr, low, mid-1) return findMin(arr, mid+1, high) def main(args): arr1 = [5, 6, 1, 2, 3, 4] n1 = len(arr1) print('The minimum element is ' + str(findMin(arr1, 0, n1-1))) arr2 = [1, 2, 3, 4] n2 = len(arr2) print('The minimum element is ' + str(findMin(arr2, 0, n2-1))) arr3 = [1] n3 = len(arr3) print('The minimum element is ' + str(findMin(arr3, 0, n3-1))) arr4 = [1, 2] n4 = len(arr4) print('The minimum element is ' + str(findMin(arr4, 0, n4-1))) arr5 = [2, 1] n5 = len(arr5) print('The minimum element is ' + str(findMin(arr5, 0, n5-1))) arr6 = [5, 6, 7, 1, 2, 3, 4] n6 = len(arr6) print('The minimum element is ' + str(findMin(arr6, 0, n6-1))) arr7 = [1, 2, 3, 4, 5, 6, 7] n7 = len(arr7) print('The minimum element is ' + str(findMin(arr7, 0, n7-1))) arr8 = [2, 3, 4, 5, 6, 7, 8, 1] n8 = len(arr8) print('The minimum element is ' + str(findMin(arr8, 0, n8-1))) arr9 = [3, 4, 5, 1, 2] n9 = len(arr9) print('The minimum element is ' + str(findMin(arr9, 0, n9-1))) if __name__ == '__main__': import sys ret_code = main(sys.argv)", "src": "class\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n\n\nif\n(high == low) \nreturn\narr[low]; \n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n}", "index": 110, "complexity": "2"}
{"back-translation": "class BinarySearch:\n    def binarySearch(self, arr, l, r, x):\n        if r >= l:\n            mid = l + (r - l) // 2\n            if arr[mid] == x:\n                return mid\n            if arr[mid] > x:\n                return self.binarySearch(arr, l, mid - 1, x)\n            return self.binarySearch(arr, mid + 1, r, x)\n        return -1\n\n    def main(self, args):\n        ob = BinarySearch()\n        arr = [2, 3, 4, 10, 40]\n        n = len(arr)\n        x = 10\n        result = ob.binarySearch(arr, 0, n - 1, x)\n        if result == -1:\n            print(\"Element not present\")\n        else:\n            print(\"Element found at index \" + str(result))\n", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) { \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n1\n, x); \n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ result); \n\n} \n}", "index": 111, "complexity": "2"}
{"back-translation": "class BinarySearch:\n    def binarySearch(self, arr, x):\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            if arr[m] == x:\n                return m\n            if arr[m] < x:\n                l = m + 1\n            else:\n                r = m - 1\n        return -1\n    def main(self, args):\n        ob = BinarySearch()\n        arr = [2, 3, 4, 10, 40]\n        n = len(arr)\n        x = 10\n        result = ob.binarySearch(arr, x)\n        if result == -1:\n            print(\"Element not present\")\n        else:\n            print(\"Element found at index \" + str(result))", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n\n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n\n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n}", "index": 112, "complexity": "2"}
{"back-translation": "class Binary :\n\n    @staticmethod\n    def f(x) :\n        return x*x - 10*x - 20\n\n    @staticmethod\n    def findFirstPositive() :\n        if Binary.f(0) > 0 :\n            return 0\n\n        i = 1\n        while Binary.f(i) <= 0 :\n            i = i * 2\n\n        return Binary.binarySearch(i // 2, i)\n\n    @staticmethod\n    def binarySearch(low, high) :\n        if high >= low :\n            mid = low + (high - low)//2\n\n            if Binary.f(mid) > 0 and (mid == low or Binary.f(mid-1) <= 0) :\n                return mid\n\n            if Binary.f(mid) <= 0 :\n                return Binary.binarySearch((mid + 1), high)\n            else :\n                return Binary.binarySearch(low, (mid - 1))\n\n        return -1\n\n    @staticmethod\n    def main(args) :\n        print(\"The value n where f() \" + \"becomes positive first is \" + str(Binary.findFirstPositive()))\n", "src": "class\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n\n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n\n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n\n\n\n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n\n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n\n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n}", "index": 113, "complexity": "2"}
{"back-translation": "class Main: def pivotedBinarySearch(arr, n, key): pivot = findPivot(arr, 0, n-1); if pivot == -1: return binarySearch(arr, 0, n-1, key); if arr[pivot] == key: return pivot; if arr[0] <= key: return binarySearch(arr, 0, pivot-1, key); return binarySearch(arr, pivot+1, n-1, key); def findPivot(arr, low, high): if high < low: return -1; if high == low: return low; mid = (low + high)/2; if mid < high and arr[mid] > arr[mid + 1]: return mid; if mid > low and arr[mid] < arr[mid - 1]: return (mid-1); if arr[low] >= arr[mid]: return findPivot(arr, low, mid-1); return findPivot(arr, mid + 1, high); def binarySearch(arr, low, high, key): if high < low: return -1; mid = (low + high)/2; if key == arr[mid]: return mid; if key > arr[mid]: return binarySearch(arr, (mid + 1), high, key); return binarySearch(arr, low, (mid -1), key); def main(args): arr1 = [5, 6, 7, 8, 9, 10, 1, 2, 3]; n = len(arr1); key = 3; print('Index of the element is : ' + str(pivotedBinarySearch(arr1, n, key))); if __name__ == '__main__': import sys; main(sys.argv[1:])", "src": "class\nMain \n{ \n\n\n\n\nstatic\nint\npivotedBinarySearch(\nint\narr[], \nint\nn, \nint\nkey) \n\n{ \n\nint\npivot = findPivot(arr, \n0\n, n-\n1\n); \n\n\n\n\n\n\nif\n(pivot == -\n1\n) \n\nreturn\nbinarySearch(arr, \n0\n, n-\n1\n, key); \n\n\n\n\n\n\n\n\nif\n(arr[pivot] == key) \n\nreturn\npivot; \n\nif\n(arr[\n0\n] <= key) \n\nreturn\nbinarySearch(arr, \n0\n, pivot-\n1\n, key); \n\nreturn\nbinarySearch(arr, pivot+\n1\n, n-\n1\n, key); \n\n} \n\n\n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid < high && arr[mid] > arr[mid + \n1\n]) \n\nreturn\nmid; \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\n(mid-\n1\n); \n\nif\n(arr[low] >= arr[mid]) \n\nreturn\nfindPivot(arr, low, mid-\n1\n); \n\nreturn\nfindPivot(arr, mid + \n1\n, high); \n\n} \n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nkey) \n\n{ \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(key == arr[mid]) \n\nreturn\nmid; \n\nif\n(key > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high, key); \n\nreturn\nbinarySearch(arr, low, (mid -\n1\n), key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nint\narr1[] = {\n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n, \n1\n, \n2\n, \n3\n}; \n\nint\nn = arr1.length; \n\nint\nkey = \n3\n; \n\nSystem.out.println(\n\"Index of the element is : \"\n\n+ pivotedBinarySearch(arr1, n, key)); \n\n} \n}", "index": 114, "complexity": "2"}
{"back-translation": "class\nGfG { \n\n\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n\n\nint\nm1 = median(ar1, n); \n\n\n\n\nint\nm2 = median(ar2, n); \n\n\n\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n}", "src": "class\nGfG { \n\n\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n\n\nint\nm1 = median(ar1, n); \n\n\n\n\nint\nm2 = median(ar2, n); \n\n\n\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n}", "index": 115, "complexity": "2"}
{"back-translation": "class Main : def ceilSearch(arr, low, high, x) : mid = (low + high) // 2 if x <= arr[low] : return low if x > arr[high] : return -1 if arr[mid] == x : return mid elif arr[mid] < x : if mid + 1 <= high and x <= arr[mid+1] : return mid + 1 else : return ceilSearch(arr, mid+1, high, x) else : if mid - 1 >= low and x > arr[mid-1] : return mid else : return ceilSearch(arr, low, mid - 1, x) def main(args) : arr = [1, 2, 8, 10, 10, 12, 19] n = len(arr) x = 8 index = ceilSearch(arr, 0, n-1, x) if index == -1 : print(\"Ceiling of \"+str(x)+\" doesn't exist in array\") else : print(\"ceiling of \"+str(x)+\" is \"+str(arr[index]))", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n\n\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 116, "complexity": "2"}
{"back-translation": "class GFG: def binarySearch(arr, l, r, x): if r < l: return -1 mid = l + (r - l) // 2 if arr[mid] == x: return mid if arr[mid] > x: return binarySearch(arr, l, mid - 1, x) return binarySearch(arr, mid + 1, r, x) def countOccurrences(arr, n, x): ind = binarySearch(arr, 0, n - 1, x) if ind == -1: return 0 count = 1 left = ind - 1 while left >= 0 and arr[left] == x: count += 1 left -= 1 right = ind + 1 while right < n and arr[right] == x: count += 1 right += 1 return count def main(arr): n = len(arr) x = 2 print(countOccurrences(arr, n, x)) arr = [1, 2, 2, 2, 2, 3, 4, 7, 8, 8] main(arr)", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n\n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n\n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n\n\n\n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n}", "index": 117, "complexity": "2"}
{"back-translation": "class Main: def binarySearch(arr, low, high): if high >= low: mid = (low + high) // 2 if mid == arr[mid]: return mid if mid > arr[mid]: return binarySearch(arr, mid + 1, high) else: return binarySearch(arr, low, mid - 1) return -1 def main(args): arr = [-10, -1, 0, 3, 10, 11, 30, 50, 100] n = len(arr) print('Fixed Point is ' + str(binarySearch(arr, 0, n - 1)))", "src": "class\nMain \n{ \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid == arr[mid]) \n\nreturn\nmid; \n\nif\n(mid > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high); \n\nelse\n\nreturn\nbinarySearch(arr, low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ binarySearch(arr,\n0\n, n-\n1\n)); \n\n} \n}", "index": 118, "complexity": "2"}
{"back-translation": "class Main:\n    @staticmethod\n    def findMaximum(arr, low, high):\n        if low == high:\n            return arr[low]\n        if (high == low + 1) and arr[low] >= arr[high]:\n            return arr[low]\n        if (high == low + 1) and arr[low] < arr[high]:\n            return arr[high]\n        mid = (low + high)//2\n        if arr[mid] > arr[mid + 1] and arr[mid] > arr[mid - 1]:\n            return arr[mid]\n        if arr[mid] > arr[mid + 1] and arr[mid] < arr[mid - 1]:\n            return Main.findMaximum(arr, low, mid-1)\n        else:\n            return Main.findMaximum(arr, mid + 1, high)\n\n    @staticmethod\n    def main(args):\n        arr = [1, 3, 50, 10, 9, 7, 6]\n        n = len(arr)\n        print(\"The maximum element is \", Main.findMaximum(arr, 0, n-1))\n", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\nif\n(low == high) \n\nreturn\narr[low]; \n\n\n\n\nif\n((high == low + \n1\n) && arr[low] >= arr[high]) \n\nreturn\narr[low]; \n\n\n\n\nif\n((high == low + \n1\n) && arr[low] < arr[high]) \n\nreturn\narr[high]; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\n\n\n\nif\n( arr[mid] > arr[mid + \n1\n] && arr[mid] > arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[mid] > arr[mid + \n1\n] && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nfindMaximum(arr, low, mid-\n1\n); \n\nelse\n\nreturn\nfindMaximum(arr, mid + \n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n50\n, \n10\n, \n9\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 119, "complexity": "2"}
{"back-translation": "class\nPeakElement \n{ \n\n\n\n\n\nstatic\nint\nfindPeakUtil(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nn) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n((mid == \n0\n|| arr[mid-\n1\n] <= arr[mid]) && (mid == n-\n1\n|| \n\narr[mid+\n1\n] <= arr[mid])) \n\nreturn\nmid; \n\n\n\n\n\n\nelse\nif\n(mid > \n0\n&& arr[mid-\n1\n] > arr[mid]) \n\nreturn\nfindPeakUtil(arr, low, (mid -\n1\n), n); \n\n\n\n\n\n\n\n\nelse\nreturn\nfindPeakUtil(arr, (mid + \n1\n), high, n); \n\n} \n\n\n\n\nstatic\nint\nfindPeak(\nint\narr[], \nint\nn) \n\n{ \n\nreturn\nfindPeakUtil(arr, \n0\n, n-\n1\n, n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n20\n, \n4\n, \n1\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Index of a peak point is \"\n+ \n\nfindPeak(arr, n)); \n\n} \n}", "src": "class\nPeakElement \n{ \n\n\n\n\n\nstatic\nint\nfindPeakUtil(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nn) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n((mid == \n0\n|| arr[mid-\n1\n] <= arr[mid]) && (mid == n-\n1\n|| \n\narr[mid+\n1\n] <= arr[mid])) \n\nreturn\nmid; \n\n\n\n\n\n\nelse\nif\n(mid > \n0\n&& arr[mid-\n1\n] > arr[mid]) \n\nreturn\nfindPeakUtil(arr, low, (mid -\n1\n), n); \n\n\n\n\n\n\n\n\nelse\nreturn\nfindPeakUtil(arr, (mid + \n1\n), high, n); \n\n} \n\n\n\n\nstatic\nint\nfindPeak(\nint\narr[], \nint\nn) \n\n{ \n\nreturn\nfindPeakUtil(arr, \n0\n, n-\n1\n, n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n20\n, \n4\n, \n1\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Index of a peak point is \"\n+ \n\nfindPeak(arr, n)); \n\n} \n}", "index": 120, "complexity": "2"}
{"back-translation": "class Minimum: def findMin(arr, low, high): if high < low: return arr[0] if high == low: return arr[low] mid = low + (high - low)//2 if mid < high and arr[mid+1] < arr[mid]: return arr[mid+1] if mid > low and arr[mid] < arr[mid - 1]: return arr[mid] if arr[high] > arr[mid]: return findMin(arr, low, mid-1) return findMin(arr, mid+1, high) def main(args): arr1 = [5, 6, 1, 2, 3, 4] n1 = len(arr1) print('The minimum element is ' + str(findMin(arr1, 0, n1-1))) arr2 = [1, 2, 3, 4] n2 = len(arr2) print('The minimum element is ' + str(findMin(arr2, 0, n2-1))) arr3 = [1] n3 = len(arr3) print('The minimum element is ' + str(findMin(arr3, 0, n3-1))) arr4 = [1, 2] n4 = len(arr4) print('The minimum element is ' + str(findMin(arr4, 0, n4-1))) arr5 = [2, 1] n5 = len(arr5) print('The minimum element is ' + str(findMin(arr5, 0, n5-1))) arr6 = [5, 6, 7, 1, 2, 3, 4] n6 = len(arr6) print('The minimum element is ' + str(findMin(arr6, 0, n6-1))) arr7 = [1, 2, 3, 4, 5, 6, 7] n7 = len(arr7) print('The minimum element is ' + str(findMin(arr7, 0, n7-1))) arr8 = [2, 3, 4, 5, 6, 7, 8, 1] n8 = len(arr8) print('The minimum element is ' + str(findMin(arr8, 0, n8-1))) arr9 = [3, 4, 5, 1, 2] n9 = len(arr9) print('The minimum element is ' + str(findMin(arr9, 0, n9-1))) if __name__ == '__main__': main(None)", "src": "class\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n\n\nif\n(high == low) \nreturn\narr[low]; \n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n}", "index": 121, "complexity": "2"}
{"back-translation": "class GFG: def binarySearch(arr, l, r, x): if r >= l: mid = l + (r - l) // 2 if arr[mid] == x: return mid if mid > l and arr[mid - 1] == x: return mid - 1 if mid < r and arr[mid + 1] == x: return mid + 1 if arr[mid] > x: return binarySearch(arr, l, mid - 2, x) return binarySearch(arr, mid + 2, r, x) return -1 def main(args): ob = GFG() arr = [3, 2, 10, 4, 40] n = len(arr) x = 4 result = ob.binarySearch(arr, 0, n - 1, x) if result == -1: print('Element is not present in array') else: print('Element is present at index ' + str(result)) if __name__ == '__main__': import sys main(sys.argv[1:])", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) \n\n{ \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(mid > l && arr[mid - \n1\n] == x) \n\nreturn\n(mid - \n1\n); \n\nif\n(mid < r && arr[mid + \n1\n] == x) \n\nreturn\n(mid + \n1\n); \n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n2\n, x); \n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n2\n, r, x); \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGFG ob = \nnew\nGFG(); \n\nint\narr[] = {\n3\n, \n2\n, \n10\n, \n4\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n4\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element is not present in array\"\n); \n\nelse\n\nSystem.out.println(\n\"Element is present at index \"\n+ \n\nresult); \n\n} \n}", "index": 122, "complexity": "2"}
{"back-translation": "class CountOnes: def countOnes(arr, low, high): if high >= low: mid = low + (high - low)//2 if ((mid == high or arr[mid+1] == 0) and (arr[mid] == 1)): return mid+1 if arr[mid] == 1: return countOnes(arr, mid + 1, high) return countOnes(arr, low, mid - 1) return 0 def main(args): ob = CountOnes() arr = [1, 1, 1, 1, 0, 0, 0] n = len(arr) print('Count of 1\\'s in given array is ' + str(ob.countOnes(arr, 0, n-1))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nCountOnes \n{ \n\n\n\nint\ncountOnes(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\nif\n( (mid == high || arr[mid+\n1\n] == \n0\n) && \n\n(arr[mid] == \n1\n)) \n\nreturn\nmid+\n1\n; \n\n\n\n\nif\n(arr[mid] == \n1\n) \n\nreturn\ncountOnes(arr, (mid + \n1\n), high); \n\n\n\n\nreturn\ncountOnes(arr, low, (mid -\n1\n)); \n\n} \n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nCountOnes ob = \nnew\nCountOnes(); \n\nint\narr[] = {\n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n0\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Count of 1's in given array is \"\n+ \n\nob.countOnes(arr, \n0\n, n-\n1\n) ); \n\n} \n}", "index": 123, "complexity": "2"}
{"back-translation": "class SmallestMissing: def findFirstMissing(array, start, end): if start > end: return end + 1 if start != array[start]: return start mid = (start + end) // 2 if array[mid] == mid: return findFirstMissing(array, mid+1, end) return findFirstMissing(array, start, mid) def main(args): small = SmallestMissing() arr = [0, 1, 2, 3, 4, 5, 6, 7, 10] n = len(arr) print('First Missing element is : ' + str(small.findFirstMissing(arr, 0, n - 1)))", "src": "class\nSmallestMissing \n{ \n\nint\nfindFirstMissing(\nint\narray[], \nint\nstart, \nint\nend) \n\n{ \n\nif\n(start > end) \n\nreturn\nend + \n1\n; \n\n\nif\n(start != array[start]) \n\nreturn\nstart; \n\n\nint\nmid = (start + end) / \n2\n; \n\n\n\n\nif\n(array[mid] == mid) \n\nreturn\nfindFirstMissing(array, mid+\n1\n, end); \n\n\nreturn\nfindFirstMissing(array, start, mid); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSmallestMissing small = \nnew\nSmallestMissing(); \n\nint\narr[] = {\n0\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"First Missing element is : \"\n\n+ small.findFirstMissing(arr, \n0\n, n - \n1\n)); \n\n} \n}", "index": 124, "complexity": "2"}
{"back-translation": "class Main {\n    static int count(int arr[], int x, int n) {\n        int i;\n        int j;\n        i = first(arr, 0, n-1, x, n);\n        if (i == -1)\n            return i;\n        j = last(arr, i, n-1, x, n);\n        return j-i+1;\n    }\n    static int first(int arr[], int low, int high, int x, int n) {\n        if (high >= low) {\n            int mid = (low + high) / 2;\n            if ((mid == 0 || x > arr[mid-1]) && arr[mid] == x)\n                return mid;\n            else if (x > arr[mid])\n                return first(arr, mid + 1, high, x, n);\n            else\n                return first(arr, low, mid - 1, x, n);\n        }\n        return -1;\n    }\n    static int last(int arr[], int low, int high, int x, int n) {\n        if (high >= low) {\n            int mid = (low + high) / 2;\n            if ((mid == n-1 || x < arr[mid+1]) && arr[mid] == x)\n                return mid;\n            else if (x < arr[mid])\n                return last(arr, low, mid - 1, x, n);\n            else\n                return last(arr, mid + 1, high, x, n);\n        }\n        return -1;\n    }\n    public static void main(String args[]) {\n        int arr[] = {1, 2, 2, 3, 3, 3, 3};\n        int x = 3;\n        int n = arr.length;\n        int c = count(arr, x, n);\n        System.out.println(x+\" occurs \"+c+\" times\");\n    }\n}", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncount(\nint\narr[], \nint\nx, \nint\nn) \n\n{ \n\n\n\nint\ni; \n\n\n\n\nint\nj; \n\n\n\n\ni = first(arr, \n0\n, n-\n1\n, x, n); \n\n\n\n\nif\n(i == -\n1\n) \n\nreturn\ni; \n\n\n\n\nj = last(arr, i, n-\n1\n, x, n); \n\n\n\n\nreturn\nj-i+\n1\n; \n\n} \n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == \n0\n|| x > arr[mid-\n1\n]) && arr[mid] == x) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\nfirst(arr, (mid + \n1\n), high, x, n); \n\nelse\n\nreturn\nfirst(arr, low, (mid -\n1\n), x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\nstatic\nint\nlast(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == n-\n1\n|| x < arr[mid+\n1\n]) && arr[mid] == x ) \n\nreturn\nmid; \n\nelse\nif\n(x < arr[mid]) \n\nreturn\nlast(arr, low, (mid -\n1\n), x, n); \n\nelse\n\nreturn\nlast(arr, (mid + \n1\n), high, x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n}; \n\n\n\n\nint\nx = \n3\n; \n\nint\nn = arr.length; \n\nint\nc = count(arr, x, n); \n\nSystem.out.println(x+\n\" occurs \"\n+c+\n\" times\"\n); \n\n} \n}", "index": 125, "complexity": "2"}
{"back-translation": "print(1 + sum(i for i in range(n-1)))", "src": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tfor(int i =1 ;i < layers + 1 ; i ++) {\n\t\t\tcounter += i ;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "index": 126, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 127, "complexity": "1"}
{"back-translation": "class Main:\n    oo = 1000000000000\n    memo = None\n\n    def main(args):\n        n = int(input())\n        a = list(map(int, input().split()))\n        if n % 2 == 0:\n            for i in range(n):\n                if a[i] >= 0:\n                    a[i] = -a[i] - 1\n        else:\n            maxi, max_val = -1, -1\n            for i in range(n):\n                x = -a[i] - 1 if a[i] >= 0 else a[i]\n                x = -x\n                if x > max_val:\n                    max_val = x\n                    maxi = i\n            if max_val == 1:\n                a[0] = 0\n            else:\n                for i in range(n):\n                    if i == maxi:\n                        if a[i] < 0:\n                            a[i] = -a[i] - 1\n                    else:\n                        if a[i] >= 0:\n                            a[i] = -a[i] - 1\n        print(*a)\n\n\n    @staticmethod\n    def lcm(a, b):\n        return a * b // Main.gcd(a, b)\n\n    @staticmethod\n    def next_permutation(a):\n        pass\n\n    @staticmethod\n    def shuffle(a):\n        pass\n\n    @staticmethod\n    def lower_bound(a, n, k):\n        pass\n\n    @staticmethod\n    def gcd(a, b):\n        return a if b == 0 else Main.gcd(b, a % b)\n\n\nclass Pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __lt__(self, other):\n        return (self.first, self.second) < (other.first, other.second)\n\n    def __hash__(self):\n        return hash((self.first, self.second))\n\n    def __eq__(self, other):\n        return (self.first, self.second) == (other.first, other.second)\n\n\nclass InputReader:\n    def __init__(self, st):\n        self.stream = st\n        self.buf = bytearray()\n        self.cur_char = 0\n        self.num_chars = 0\n\n    def read(self):\n        pass\n\n    def read_int(self):\n        pass\n\n    def read_long(self):\n        pass\n\n    def read_int_array(self, n):\n        pass\n\n    def read_string(self):\n        pass\n\n    def read_line(self):\n        pass\n\n    @staticmethod\n    def is_space_char(c):\n        pass\n\n    @staticmethod\n    def is_end_of_line(c):\n        pass", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 128, "complexity": "1"}
{"back-translation": "{'src': 'public class MyClass {\\n    public static void main(String args[]) {\\n        Scanner sc= new Scanner(System.in);\\n        int n=sc.nextInt();\\n        int [] a= new int[n];\\n        int k=0;\\n        int m=0;\\n        for (int i=0;i<n;i++){\\n            a[i]=sc.nextInt();\\n            if (a[i]>=0){\\n                a[i]=-a[i]-1;\\n            }\\n            if (a[i]<m){\\n                m=a[i];\\n                k=i;\\n            }\\n        }\\n        if (n%2==1){\\n            a[k]=-a[k]-1;\\n        }\\n        for (int i=0;i<n;i++){\\n            System.out.print(a[i]+\\\" \");\\n        }\\n    }\\n}', 'complexity': '1', 'index': 129}", "src": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}", "index": 129, "complexity": "1"}
{"back-translation": "{'src': 'public class round569d2c {\\n\\n\\tpublic static void main(String args[]) {\\n\\t\\tFastScanner in = new FastScanner(System.in);\\n\\t\\t\\n\\t\\tint n = in.nextInt();\\n\\t\\tint q = in.nextInt();\\n\\t\\tArrayDeque<Integer> de...t() {\\n\\t\\t\\treturn res.toString();\\n\\t\\t}\\n\\n\\t\\tpublic String nextLine() {\\n\\t\\t\\tint c = read();\\n\\t\\t\\twhile (isEndline(c))\\n\\t\\t\\t\\tc = read();\\n\\t\\t\\tStringBuilder res = new StringBuilder();\\n\\t\\t\\tdo {\\n\\t\\t\\...", "src": "public class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 130, "complexity": "1"}
{"back-translation": "class Kello:\n    @staticmethod\n    def main(args):\n        n, q, m, max_val, inp, k, i = map(int, input().split())\n        in_q = int(input())\n        a = [0] * (n - 1)\n        b = [0] * (n - 1)\n        c = [0] * (n - 1)\n        max_val = int(input())\n        for i in range(n-1):\n            inp = int(input())\n            a[i] = max_val\n            b[i] = inp\n            if inp > max_val:\n                c[i] = max_val\n                max_val = inp\n            else:\n                c[i] = inp\n        for i in range(q):\n            in_q = int(input())\n            if in_q < n:\n                print(a[in_q-1], b[in_q-1])\n            else:\n                k = (in_q % (n-1)) - 1\n                if k == -1:\n                    k = n - 2\n                print(max_val, c[k])\n\n    @staticmethod\n    def display(a, b):\n        for i in range(len(a)):\n            print(a[i], b[i])", "src": "public class Kello\n{\n    public static void  main(String args[])\n    {\n        Scanner sc =new Scanner(System.in);\n        int n,q,m,max,inp,k,i;\n        long in_q;\n        n=sc.nextInt();\n        q=sc.nextInt();\n        int a[]=new int[n-1];\n        int b[]=new int[n-1];\n        int c[]=new int[n-1];\n        max=sc.nextInt();\n        for(i=0;i<n-1;i++)\n        {\n            inp=sc.nextInt();\n            a[i]=max;\n            b[i]=inp;\n            if(inp>max)\n            {\n                c[i]=max;\n             max=inp;\n        }\n        else\n        c[i]=inp;\n    }\n   \n        for(i=0;i<q;i++)\n        {\n            in_q=sc.nextLong();\n            if(in_q<n)\n            System.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n          else   {\n          k=(int)(in_q %(n-1))-1;\n          if(k==-1)\n          k=n-2;\n          System.out.println(max+\" \"+c[k]);\n            }\n        }\n    }\n    public static void display(int a[],int b[])\n    {\n        int i;\n        for(i=0;i<a.length;i++)\n        System.out.println(a[i]+\" \"+b[i]);\n}\n}", "index": 131, "complexity": "1"}
{"back-translation": "class Main:\n\n    @staticmethod\n    def printUnsorted(arr, n):\n        s = 0\n        e = n - 1\n        max_val = arr[s]\n        min_val = arr[s]\n\n        for s in range(n - 1):\n            if arr[s] > arr[s + 1]:\n                break\n        if s == n - 1:\n            print('The complete array is sorted')\n            return\n\n        for e in range(n - 1, 0, -1):\n            if arr[e] < arr[e - 1]:\n                break\n\n        for i in range(s + 1, e + 1):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if arr[i] < min_val:\n                min_val = arr[i]\n\n        for i in range(s):\n            if arr[i] > min_val:\n                s = i\n                break\n\n        for i in range(n - 1, e, -1):\n            if arr[i] < max_val:\n                e = i\n                break\n\n        print('The unsorted subarray which makes the given array sorted lies between the indices {} and {}'.format(s, e))\n        return\n\n    @staticmethod\n    def main(args):\n        arr = [10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60]\n        arr_size = len(arr)\n        Main.printUnsorted(arr, arr_size)\n", "src": "class\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n\n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n\n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n\n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n}", "index": 132, "complexity": "1"}
{"back-translation": "{'src': 'public class C {\\n    static class FastWriter {\\n        private final BufferedWriter bw;\\n\\n        public FastWriter() {\\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\\n        }\\n\\n        public void print(Object object) throws IOException {\\n            bw.append(\\\"\\\" + object);\\n        }\\n\\n        public void println(Object object) throws IOException {\\n            print(object);\\n            bw.append(\\\"\\\\n\\\");\\n        }\\n\\n        public void close() throws IOException {\\n            bw.close();\\n        }\\n    }\\n\\n    static class FastReader {\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastReader() {\\n            br = new BufferedReader(new InputStreamReader(System.in));\\n        }\\n\\n        String next() {\\n            while (st == null || !st.hasMoreElements()) {\\n                try {\\n                    st = new StringTokenizer(br.readLine());\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n            return st.nextToken();\\n        }\\n\\n        int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() {\\n            return Long.parseLong(next());\\n        }\\n\\n        double nextDouble() {\\n            return Double.parseDouble(next());\\n        }\\n\\n        String nextLine() {\\n            String str = \\\"\\\";\\n            try {\\n                str = br.readLine();\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            }\\n            return str;\\n        }\\n\\n        BigInteger nextBigInteger() {\\n            try {\\n                return new BigInteger(nextLine());\\n            } catch (NumberFormatException e) {\\n                throw new InputMismatchException();\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        FastReader fr = new FastReader();\\n        FastWriter fw = new FastWriter();\\n        int n = fr.nextInt();\\n        int q = fr.nextInt();\\n        int[] aa = new int[n - 1];\\n        int[] ab = new int[n - 1];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\\n        for (int i = 0; i < n - 1; i++) {\\n            int a = dq.removeFirst();\\n            int b = dq.removeFirst();\\n            aa[i] = a;\\n            ab[i] = b;\\n            int mi = Math.min(a, b);\\n            int ma = Math.max(a, b);\\n            dq.addFirst(ma);\\n            dq.addLast(mi);\\n        }\\n        int fm = dq.removeFirst();\\n        int[] arr = new int[n - 1];\\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\\n        while (q-- > 0) {\\n            long m = fr.nextLong() - 1;\\n            if (m < n - 1) {\\n                System.out.println(aa[(int) m] + \\\" \\\" + ab[(int) m]);\\n            } else {\\n                m = m % (n - 1);\\n                System.out.println(fm + \\\" \\\" + arr[(int) m]);\\n            }\\n        }\\n    }\\n}', 'complexity': '1', 'index': 133}", "src": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}", "index": 133, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n \\n    public static void main(String[] args) {\\n\\t\\n        Scanner scan = new Scanner(System.in);\\n        int T = scan.nextInt();\\n        for(; T > 0; T--) {\\n            int n = scan.nextInt();\\n            int[] arr = new int[n];\\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\\n            int m1 = 1, m2 = 1;\\n            for(int i = 0; i < n; i++) {\\n                if(arr[i] >= m1) {\\n                    m2 = m1;\\n                    m1 = arr[i];\\n                } else if (arr[i] >= m2) {\\n                    m2 = arr[i];\\n                }\\n            }\\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\\n        }\\n    }\\n}', 'complexity': '1', 'index': 134}", "src": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "index": 134, "complexity": "1"}
{"back-translation": "class CF111111:\n    def __init__(self):\n        a = int(input())\n        nums = list(map(int, input().split()))\n        max_num = max(nums)\n        index = nums.index(max_num)\n        left_index = index - 1\n        right_index = index + 1\n        done = 1\n        top = max_num\n        while True:\n            done += 1\n            if left_index < 0:\n                if nums[right_index] > top:\n                    print('NO')\n                    exit()\n                else:\n                    top = nums[right_index]\n                    right_index += 1\n            elif right_index >= a:\n                if nums[left_index] > top:\n                    print('NO')\n                    exit()\n                else:\n                    top = nums[left_index]\n                    left_index -= 1\n            else:\n                if nums[left_index] > top or nums[right_index] > top:\n                    print('NO')\n                    exit()\n                else:\n                    if nums[left_index] > nums[right_index]:\n                        top = nums[left_index]\n                        left_index -= 1\n                    else:\n                        top = nums[right_index]\n                        right_index += 1\n            if done == a:\n                print('YES')\n                exit()", "src": "public class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  public void no()\n  {\n    System.out.println(\"NO\");\n    System.exit(0);\n  }\n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      nums = new int [a];\n      int max = -1;\n      int index = -1;\n     for(int x = 0;x<a;x++)\n     {\n       nums[x] = nextInt();\n       if(nums[x] > max)\n       {\n         max = nums[x];\n         index = x;\n       }\n     }\n      int lindex = index-1;\n      int rindex = index+1;\n      int done = 1;\n      int top = max;\n      for(;;)\n      {\n        done++;\n      \n        if(lindex < 0)\n        {\n           if(nums[rindex] > top)\n           {\n             no();\n           }\n           else\n             top = nums[rindex];\n           rindex++;\n        }\n        else if(rindex >= a)\n        {\n          if(nums[lindex] > top)\n            no();\n          else\n            top = nums[lindex];\n          lindex--;\n        }\n        else\n        {\n          if(nums[lindex] > top || nums[rindex] > top)\n            no();\n          else\n          {\n            if(nums[lindex] > nums[rindex])\n            {\n              top = nums[lindex];\n              lindex--;\n            }\n            else\n            {\n              top = nums[rindex];\n              rindex++;\n            }\n          }\n        }\n        if(done == a)\n        {\n          System.out.println(\"YES\");\n          System.exit(0);\n        }\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "index": 135, "complexity": "1"}
{"back-translation": "{'src': 'public class codef { public static void main(String ar[]) throws IOException { BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); int n=Integer.parseInt(br.readLine()); String st[]=br.readLine().split(\" \"); int a[]=new int[n]; for(int i=0;i<n;i++) a[i]=Integer.parseInt(st[i]); int max=0; for(int i=0;i<n;i++) { if(i!=0 && a[i]>a[max]) max=i; } int maxi=max; int i=max-1; while(i>=0) { if(a[i]>a[max]) { System.out.println(\"NO\"); return; } max=i; i--; } max=maxi; i=max+1; while(i<n) { if(a[i]>a[max]) { System.out.println(\"NO\"); return; } max=i; i++; } System.out.println(\"YES\"); } }', 'complexity': '1', 'index': 136}", "src": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "index": 136, "complexity": "1"}
{"back-translation": "class PairSum: def constructArr(arr, pair, n): arr[0] = (pair[0] + pair[1] - pair[n-1]) // 2 for i in range(1, n): arr[i] = pair[i-1] - arr[0] if __name__ == '__main__': pair = [15, 13, 11, 10, 12, 10, 9, 8, 7, 5] n = 5 arr = [0] * n constructArr(arr, pair, n) for i in range(n): print(arr[i], end=' ')", "src": "class\nPairSum { \n\n\n\n\n\n\nstatic\nvoid\nconstructArr(\nint\narr[], \nint\npair[], \nint\nn) \n\n{ \n\narr[\n0\n] = (pair[\n0\n]+pair[\n1\n]-pair[n-\n1\n]) / \n2\n; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\narr[i] = pair[i-\n1\n]-arr[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\npair[] = {\n15\n, \n13\n, \n11\n, \n10\n, \n12\n, \n10\n, \n9\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = \n5\n; \n\nint\n[] arr = \nnew\nint\n[n]; \n\nconstructArr(arr, pair, n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 137, "complexity": "1"}
{"back-translation": "class GfG: def minMaxProduct(arr1, arr2, n1, n2): max_val = arr1[0] min_val = arr2[0] i = 1 while i < n1 and i < n2: if arr1[i] > max_val: max_val = arr1[i] if arr2[i] < min_val: min_val = arr2[i] i += 1 while i < n1: if arr1[i] > max_val: max_val = arr1[i] i += 1 while i < n2: if arr2[i] < min_val: min_val = arr2[i] i += 1 return max_val * min_val def main(argc): arr1 = [10, 2, 3, 6, 4, 1] arr2 = [5, 1, 4, 2, 6, 9] n1 = 6 n2 = 6 print(minMaxProduct(arr1, arr2, n1, n2))", "src": "class\nGfG \n{ \n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\nint\nmax = arr1[\n0\n]; \n\n\n\n\n\n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n\n\n\n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n\n\n\n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n\n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n}", "index": 138, "complexity": "1"}
{"back-translation": "class GFG: MAX_CHAR = 26\n\n\n    def commonCharacters(strList, n):\n        prim = [True] * MAX_CHAR\n\n        for i in range(n):\n            sec = [False] * MAX_CHAR\n\n            for j in range(len(strList[i])):\n                if prim[ord(strList[i][j]) - ord('a')]:\n                    sec[ord(strList[i][j]) - ord('a')] = True\n\n            prim[:MAX_CHAR] = sec\n\n        for i in range(26):\n            if prim[i]:\n                print(chr(i + 97), end=' ')\n\n\n    def main(args):\n        strList = [\"geeksforgeeks\", \"gemkstones\", \"acknowledges\", \"aguelikes\"]\n        n = len(strList)\n        commonCharacters(strList, n)\n\n\n    if __name__ == \"__main__\":\n        main([])", "src": "class\nGFG { \n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\npublic\nstatic\nvoid\ncommonCharacters(String str[], \n\nint\nn) \n\n{ \n\n\n\n\n\n\nBoolean[] prim = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(prim, \nnew\nBoolean(\ntrue\n)); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nBoolean[] sec = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(sec, \nnew\nBoolean(\nfalse\n)); \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str[i].length(); j++) \n\n{ \n\n\n\n\n\n\nif\n(prim[str[i].charAt(j) - \n'a'\n]) \n\nsec[str[i].charAt(j) - \n'a'\n] = \ntrue\n; \n\n} \n\n\n\n\nSystem.arraycopy(sec, \n0\n, prim, \n0\n, MAX_CHAR); \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n26\n; i++) \n\nif\n(prim[i]){ \n\nSystem.out.print(Character.toChars(i \n\n+ \n97\n)); \n\nSystem.out.print(\n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str[] = { \n\"geeksforgeeks\"\n, \n\n\"gemkstones\"\n, \n\n\"acknowledges\"\n, \n\n\"aguelikes\"\n}; \n\n\nint\nn = str.length; \n\ncommonCharacters(str, n); \n\n} \n}", "index": 139, "complexity": "1"}
{"back-translation": "class GFG: static MAX_CHAR = 26 def findAndPrintUncommonChars(str1, str2): present = [0] * MAX_CHAR l1 = len(str1) l2 = len(str2) for i in range(l1): present[ord(str1[i]) - ord('a')] = 1 for i in range(l2): if present[ord(str2[i]) - ord('a')] == 1 or present[ord(str2[i]) - ord('a')] == -1: present[ord(str2[i]) - ord('a')] = -1 else: present[ord(str2[i]) - ord('a')] = 2 for i in range(MAX_CHAR): if present[i] == 1 or present[i] == 2: print(chr(i + ord('a')), end=' ') def main(): str1 = 'characters' str2 = 'alphabets' findAndPrintUncommonChars(str1, str2) if __name__ == '__main__': main()", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n\n\n\n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n\n\n\n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n\n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n}", "index": 140, "complexity": "1"}
{"back-translation": "class GFG : def isVowel(ch): return ch in ['a', 'e', 'i', 'o', 'u'] def createAltStr(str1, str2, start, l): finalStr = '' for i, j in zip(range(0, l - start), range(start, l)): finalStr += str1[i] + str2[j] return finalStr def findAltStr(str): nv, nc = 0, 0; vstr, cstr = '', ''; l = len(str) for i in range(l): ch = str[i] if isVowel(ch): nv += 1 vstr += ch else: nc += 1 cstr += ch if abs(nv - nc) >= 2: return 'no such string' if nv > nc: return vstr[0] + createAltStr(cstr, vstr, 1, nv) if nc > nv: return cstr[0] + createAltStr(vstr, cstr, 1, nc) if cstr[0] < vstr[0]: return createAltStr(cstr, vstr, 0, nv) return createAltStr(vstr, cstr, 0, nc) str = 'geeks' print(findAltStr(str))", "src": "class\nGFG \n{ \n\n\nstatic\nboolean\nisVowel(\nchar\nch) \n{ \n\nif\n(ch == \n'a'\n|| ch == \n'e'\n|| ch == \n'i'\n|| \n\nch == \n'o'\n|| ch ==\n'u'\n) \n\nreturn\ntrue\n; \n\nreturn\nfalse\n; \n} \n\n\n\nstatic\nString createAltStr(String str1, String str2, \n\nint\nstart, \nint\nl) \n{ \n\nString finalStr = \n\"\"\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n, j = start; j < l; i++, j++) \n\nfinalStr = (finalStr + str1.charAt(i)) + \n\nstr2.charAt(j); \n\nreturn\nfinalStr; \n} \n\n\n\nstatic\nString findAltStr(String str) \n{ \n\nint\nnv = \n0\n, nc = \n0\n; \n\nString vstr = \n\"\"\n, cstr = \n\"\"\n; \n\nint\nl = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\n{ \n\nchar\nch = str.charAt(i); \n\n\n\n\nif\n(isVowel(ch)) \n\n{ \n\nnv++; \n\nvstr = vstr + ch; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nnc++; \n\ncstr = cstr + ch; \n\n} \n\n} \n\n\n\n\nif\n(Math.abs(nv - nc) >= \n2\n) \n\nreturn\n\"no such string\"\n; \n\n\n\n\n\n\n\n\nif\n(nv > nc) \n\nreturn\n(vstr.charAt(\n0\n) + createAltStr(cstr, vstr, \n1\n, nv)); \n\n\n\n\n\n\n\n\nif\n(nc > nv) \n\nreturn\n(cstr.charAt(\n0\n) + createAltStr(vstr, cstr, \n1\n, nc)); \n\n\n\n\n\n\n\n\nif\n(cstr.charAt(\n0\n) < vstr.charAt(\n0\n)) \n\nreturn\ncreateAltStr(cstr, vstr, \n0\n, nv); \n\n\n\n\nreturn\ncreateAltStr(vstr, cstr, \n0\n, nc); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nString str = \n\"geeks\"\n; \n\nSystem.out.println(findAltStr(str)); \n} \n}", "index": 141, "complexity": "1"}
{"back-translation": "class CountSubString: def countSubStr(str, n): m = 0 for i in range(n): if str[i] == '1': m += 1 return m * (m - 1) // 2 if __name__ == '__main__': count = CountSubString() string = '00100101' str = list(string) n = len(str) print(count.countSubStr(str, n))", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n\n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n}", "index": 142, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\nstatic\\nfinal\\nint\\nM = \\n26\\n; \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\ngetIdx(\\nchar\\nch) \\n\\n{ \\n\\nreturn\\n(ch - \\n\\'a\\'\\n); \\n\\n} \\n\\n\\n\\n\\nstatic\\nboolean\\nallSame(\\nint\\nfreq[], \\nint\\nN) \\n\\n{ \\n\\nint\\nsame = \\n0\\n; \\n\\n\\n\\nint\\ni; \\n\\nfor\\n(i = \\n0\\n; i < N; i++) { \\n\\nif\\n(freq[i] > \\n0\\n) { \\n\\nsame = freq[i]; \\n\nbreak\\n; \\n\n} \\n\\n} \\n\\n\\n\\n\\nfor\\n(\\nint\\nj = i + \\n1\\n; j < N; j++) \\n\\nif\\n(freq[j] > \\n0\\n&& freq[j] != same) \\n\nreturn\\nfalse\\n; \\n\\n\\nreturn\\ntrue\\n; \\n\\n} \\n\\n\\n\\n\\nstatic\\nboolean\\npossibleSameCharFreqByOneRemoval(String str) \\n\\n{ \\n\\nint\\nl = str.length(); \\n\\n\\n\\nint\\n[] freq = \\nnew\\nint\\n[M]; \\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < l; i++) \\n\nfreq[getIdx(str.charAt(i))]++; \\n\\n\\n\\nif\\n(allSame(freq, M)) \\n\nreturn\\ntrue\\n; \\n\\n\\n\\nfor\\n(\\nchar\\nc = \\n\\'a\\'\\n; c <= \\n\\'z\\'\\n; c++) { \\n\\nint\\ni = getIdx(c); \\n\\n\\n\\nif\\n(freq[i] > \\n0\\n) { \\n\nfreq[i]--; \\n\\n\\nif\\n(allSame(freq, M)) \\n\nreturn\\ntrue\\n; \\n\nfreq[i]++; \\n\n} \\n\\n} \\n\\n\\nreturn\\nfalse\\n; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString str = \\n\\\"xyyzz\\\"\\n; \\n\\nif\\n(possibleSameCharFreqByOneRemoval(str)) \\n\nSystem.out.println(\\n\\\"Yes\\\"\\n); \\n\\nelse\\n\\nSystem.out.println(\\n\\\"No\\\"\\n); \\n\\n} \\n}', 'complexity': '1', 'index': 143}", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n\n\n\n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n\n\n\n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n\n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 143, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintMinIndexChar(String str, String patt) \\n\\n{ \\n\\n\\n\\nHashMap<Character, Integer> hm = \\nnew\\nHashMap<>(); \\n\\n\\n\\n\\n\\nint\\nminIndex = Integer.MAX_VALUE; \\n\\n\\n\\nint\\nm = str.length(); \\n\\nint\\nn = patt.length(); \\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < m; i++) \\n\nif\\n(hm.get(str.charAt(i)) == \\nnull) \\n\\nhm.put(str.charAt(i), i); \\n\\n\\n\\nfor(\\nint\\ni = \\n0\\n; i < n; i++) \\n\\n\\n\\n\\nif\\n(hm.containsKey(patt.charAt(i)) && \\n\\nhm.get(patt.charAt(i)) < minIndex) \\n\\nminIndex = hm.get(patt.charAt(i)); \\n\\n\\n\\nif\\n(minIndex != Integer.MAX_VALUE) \\n\\nSystem.out.println(\\n'Minimum Index Character = '\\n+ \\nstr.charAt(minIndex)); \\n\\n\\n\\nelse\\n\\nSystem.out.println(\\n'No character present'\\n); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nString str = \\n\"geeksforgeeks\"\\n; \\n\\nString patt = \\n\"set\"\\n; \\n\\nprintMinIndexChar(str, patt); \\n\\n} \\n}', 'complexity': '1', 'index': 144}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\n\n\n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 144, "complexity": "1"}
{"back-translation": "class GFG : def getCharCountArray(str): NO_OF_CHARS = 256 count = [0]*NO_OF_CHARS for i in range(len(str)): count[ord(str[i])] += 1 return count def removeDirtyChars(str, mask_str): count = getCharCountArray(mask_str) ip_ind, res_ind = 0, 0 arr = list(str) while ip_ind != len(arr): temp = arr[ip_ind] if count[ord(temp)] == 0: arr[res_ind] = arr[ip_ind] res_ind += 1 ip_ind += 1 str = ''.join(arr) return str[:res_ind] if __name__ == '__main__': str = 'geeksforgeeks' mask_str = 'mask' print(removeDirtyChars(str, mask_str))", "src": "public\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i<str.length(); i++) \n\ncount[str.charAt(i)]++; \n\n\nreturn\ncount; \n\n} \n\n\n\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nwhile\n(ip_ind != arr.length) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n}", "index": 145, "complexity": "1"}
{"back-translation": "class GFG:\n    class Pair:\n        def __init__(self, first, second):\n            self.first = first\n            self.second = second\n    def longestNull(str):\n        arr = []\n        arr.append(Pair('@', -1))\n        maxlen = 0\n        for i in range(len(str)):\n            arr.append(Pair(str[i], i))\n            while len(arr) >= 3 and arr[-3].first == '1' and arr[-2].first == '0' and arr[-1].first == '0':\n                arr.pop(-3)\n                arr.pop(-2)\n                arr.pop(-1)\n            tmp = arr[-1].second\n            maxlen = max(maxlen, i - tmp)\n        return maxlen\n    def main(args):\n        print(longestNull(\"1011100000100\"))\nmain(None)", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n\n\n\n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n\n\n\n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n\n\n\n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n\n\n\n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n\n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n}", "index": 146, "complexity": "1"}
{"back-translation": "class Test: MAX_CHAR = 26\n\n    @staticmethod\n    def countPairs(str):\n        result = 0\n        n = len(str)\n\n        for i in range(n):\n            for j in range(1, min(n - i, MAX_CHAR)):\n                if abs(ord(str[i + j]) - ord(str[i])) == j:\n                    result += 1\n\n        return result\n\n    if __name__ == '__main__':\n        str = \"geeksforgeeks\"\n        print(Test.countPairs(str))", "src": "class\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 147, "complexity": "1"}
{"back-translation": "class\nReverseArray:\n\n    @staticmethod\n    def reverseArray(arr, start, end):\n        if start >= end:\n            return\n        arr[start], arr[end] = arr[end], arr[start]\n        ReverseArray.reverseArray(arr, start+1, end-1)\n\n    @staticmethod\n    def printArray(arr, size):\n        for i in range(size):\n            print(arr[i], end=' ')\n        print('')\n\n    if __name__ == '__main__':\n        arr = [1, 2, 3, 4, 5, 6]\n        ReverseArray.printArray(arr, 6)\n        ReverseArray.reverseArray(arr, 0, 5)\n        print('Reversed array is ')\n        ReverseArray.printArray(arr, 6)", "src": "class\nReverseArray { \n\n\n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n}", "index": 148, "complexity": "1"}
{"back-translation": "class GFG: static MAX_CHARS = 26 def longestSubseqWithK(str, k): n = len(str) freq = [0] * MAX_CHARS for i in range(n): freq[ord(str[i]) - ord('a')] += 1 for i in range(n): if freq[ord(str[i]) - ord('a')] >= k: print(str[i]) def main(args): str = 'geeksforgeeks' k = 2 longestSubseqWithK(str, k) main([])", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n}", "index": 149, "complexity": "1"}
{"back-translation": "def calculate_subsequences_count(s):\n    a_count = 0\n    b_count = 0\n    c_count = 0\n    for i in range(len(s)):\n        if s[i] == 'a':\n            a_count = (1 + 2 * a_count)\n        elif s[i] == 'b':\n            b_count = (a_count + 2 * b_count)\n        elif s[i] == 'c':\n            c_count = (b_count + 2 * c_count)\n    return c_count\n\ns = 'abbc'\nprint(calculate_subsequences_count(s))", "src": "public\nclass\nNo_of_subsequence { \n\n\n\n\n\n\nstatic\nint\ncountSubsequences(String s) \n\n{ \n\n\n\n\n\nint\naCount = \n0\n; \n\n\n\n\n\n\n\n\nint\nbCount = \n0\n; \n\n\n\n\n\n\n\n\nint\ncCount = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i< s.length(); i++) \n\n{ \n\n\n\nif\n(s.charAt(i) == \n'a'\n) \n\naCount = (\n1\n+ \n2\n* aCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'b'\n) \n\nbCount = (aCount + \n2\n* bCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'c'\n) \n\ncCount = (bCount + \n2\n* cCount); \n\n} \n\n\nreturn\ncCount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abbc\"\n; \n\nSystem.out.println(countSubsequences(s)); \n\n} \n}", "index": 150, "complexity": "1"}
{"back-translation": "class GFG: def countOccurrences(s, K): n = len(s) C, c1, c2 = 0, 0, 0 for i in range(n): if s[i] == 'a': c1 += 1 if s[i] == 'b': c2 += 1 C += c1 return C * K + (K * (K - 1) // 2) * c1 * c2 if __name__ == '__main__': S = 'abcb' k = 2 print(countOccurrences(S, k))", "src": "class\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n\n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n\n\n\n\n\n\n\nC += c1; \n\n} \n\n} \n\n\n\n\n\n\n\n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n}", "index": 151, "complexity": "1"}
{"back-translation": "class GFG: \n    max = 100 \n    def countSubsequence(s, n): \n        cntG, cntF, result, C = 0, 0, 0, 0 \n        for i in range(n): \n            if s[i] == 'G': \n                cntG += 1 \n                result += C \n            elif s[i] == 'F': \n                cntF += 1 \n                C += cntG \n            else: \n                continue \n        print(result) \n    def main(args): \n        s = 'GFGFG' \n        n = len(s) \n        countSubsequence(s, n) \n", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n\n\n\n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nswitch\n(s.charAt(i)) { \n\n\n\n\n\n\n\n\n\n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n\n\n\n\n\n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n\n\ndefault\n: \n\ncontinue\n; \n\n} \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n}", "index": 152, "complexity": "1"}
{"back-translation": "class Count_Subsequences:\n    MAX_CHAR = 256\n\n    @staticmethod\n    def countSub(str):\n        last = [-1] * Count_Subsequences.MAX_CHAR\n        n = len(str)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = 2 * dp[i - 1]\n            if last[ord(str[i - 1])] != -1:\n                dp[i] = dp[i] - dp[last[ord(str[i - 1])]]\n            last[ord(str[i - 1])] = i - 1\n        return dp[n]\n\n    @staticmethod\n    def main(args):\n        print(Count_Subsequences.countSub('gfg'))\n\nCount_Subsequences.main('')", "src": "public\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n\n\nstatic\nint\ncountSub(String str) \n\n{ \n\n\n\n\n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n\n\nint\nn = str.length(); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\n\n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n\n\n\n\n\n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n\n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n}", "index": 153, "complexity": "1"}
{"back-translation": "class UglyNumber:\n    def getNthUglyNo(self, n):\n        ugly = [0] * n\n        i2, i3, i5 = 0, 0, 0\n        next_multiple_of_2 = 2\n        next_multiple_of_3 = 3\n        next_multiple_of_5 = 5\n        next_ugly_no = 1\n        ugly[0] = 1\n        for i in range(1, n):\n            next_ugly_no = min(next_multiple_of_2, min(next_multiple_of_3, next_multiple_of_5))\n            ugly[i] = next_ugly_no\n            if next_ugly_no == next_multiple_of_2:\n                i2 += 1\n                next_multiple_of_2 = ugly[i2] * 2\n            if next_ugly_no == next_multiple_of_3:\n                i3 += 1\n                next_multiple_of_3 = ugly[i3] * 3\n            if next_ugly_no == next_multiple_of_5:\n                i5 += 1\n                next_multiple_of_5 = ugly[i5] * 5\n        return next_ugly_no\n\n\nn = 150\nobj = UglyNumber()\nprint(obj.getNthUglyNo(n))", "src": "class\nUglyNumber \n{ \n\n\n\nint\ngetNthUglyNo(\nint\nn) \n\n{ \n\nint\nugly[] = \nnew\nint\n[n]; \n\n\nint\ni2 = \n0\n, i3 = \n0\n, i5 = \n0\n; \n\nint\nnext_multiple_of_2 = \n2\n; \n\nint\nnext_multiple_of_3 = \n3\n; \n\nint\nnext_multiple_of_5 = \n5\n; \n\nint\nnext_ugly_no = \n1\n; \n\n\nugly[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nnext_ugly_no = Math.min(next_multiple_of_2, \n\nMath.min(next_multiple_of_3, \n\nnext_multiple_of_5)); \n\n\nugly[i] = next_ugly_no; \n\nif\n(next_ugly_no == next_multiple_of_2) \n\n{ \n\ni2 = i2+\n1\n; \n\nnext_multiple_of_2 = ugly[i2]*\n2\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_3) \n\n{ \n\ni3 = i3+\n1\n; \n\nnext_multiple_of_3 = ugly[i3]*\n3\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_5) \n\n{ \n\ni5 = i5+\n1\n; \n\nnext_multiple_of_5 = ugly[i5]*\n5\n; \n\n} \n\n} \n\n\nreturn\nnext_ugly_no; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n150\n; \n\nUglyNumber obj = \nnew\nUglyNumber(); \n\nSystem.out.println(obj.getNthUglyNo(n)); \n\n} \n}", "index": 154, "complexity": "1"}
{"back-translation": "class GFG: \n    @staticmethod \n    def permutationCoeff(n, k): \n        fact = [0] * (n + 1) \n        fact[0] = 1 \n        for i in range(1, n + 1): \n            fact[i] = i * fact[i - 1] \n        return fact[n] // fact[n - k] \n    @staticmethod \n    def main(args): \n        n, k = 10, 2 \n        print('Value of P( ' + str(n) + ', ' + str(k) + ') is ' + str(GFG.permutationCoeff(n, k)))", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n\n\nfact[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n\n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 155, "complexity": "1"}
{"back-translation": "class GFG: def countFriendsPairings(n): dp = [0] * (n + 1) for i in range(n + 1): dp[i] = i if i <= 2 else dp[i - 1] + (i - 1) * dp[i - 2] return dp[n] def main(args): n = 4 print(countFriendsPairings(n)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 156, "complexity": "1"}
{"back-translation": "class Test: def rotate(): x = arr[len(arr)-1]; i; for i in range(len(arr)-1, 0, -1): arr[i] = arr[i-1]; arr[0] = x; def main(args): print('Given Array is') print(Arrays.toString(arr)) rotate() print('Rotated Array is') print(Arrays.toString(arr))", "src": "public\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n\n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n}", "index": 157, "complexity": "1"}
{"back-translation": "class GFG: dp = [-1] * 1000 def countFriendsPairings(n): if dp[n] != -1: return dp[n] if n > 2: dp[n] = countFriendsPairings(n - 1) + (n - 1) * countFriendsPairings(n - 2) else: dp[n] = n return dp[n] if __name__ == '__main__': for i in range(1000): dp[i] = -1 n = 4 print(countFriendsPairings(n))", "src": "class\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 158, "complexity": "1"}
{"back-translation": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))\n\n\nn = 10\nprint(sequence(n))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\nif\n(n == \n1\n|| n == \n2\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\nsequence(sequence(n - \n1\n)) \n\n+ sequence(n - sequence(n - \n1\n)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n} \n}", "index": 159, "complexity": "1"}
{"back-translation": "class GFG: def sequence(n): f = [0] * (n + 1) f[0] = 0 f[1] = 1 f[2] = 1 for i in range(3, n + 1): f[i] = f[f[i - 1]] + f[i - f[i - 1]] return f[n] def main(): n = 10 print(sequence(n)) if __name__ == '__main__': main()", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n\n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n}", "index": 160, "complexity": "1"}
{"back-translation": "class RearrangeArray:\n\n    def rearrangeNaive(self, arr, n):\n        temp = [0] * n\n        for i in range(n):\n            temp[arr[i]] = i\n        for i in range(n):\n            arr[i] = temp[i]\n\n    def printArray(self, arr, n):\n        for i in range(n):\n            print(arr[i], end=' ')\n        print()\n\n\nif __name__ == '__main__':\n    arrange = RearrangeArray()\n    arr = [1, 3, 0, 2]\n    n = len(arr)\n\n    print('Given array is ')\n    arrange.printArray(arr, n)\n\n    arrange.rearrangeNaive(arr, n)\n\n    print('Modified array is ')\n    arrange.printArray(arr, n)", "src": "class\nRearrangeArray { \n\n\n\n\n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 161, "complexity": "1"}
{"back-translation": "class GFG: def maxSumWO3Consec(arr, n): sum = [0]*n if(n >= 1): sum[0] = arr[0] if(n >= 2): sum[1] = arr[0] + arr[1] if(n > 2): sum[2] = max(sum[1], max(arr[1] + arr[2], arr[0] + arr[2])) for i in range(3, n): sum[i] = max(max(sum[i - 1], sum[i - 2] + arr[i]), arr[i] + arr[i - 1] + sum[i - 3]) return sum[n - 1] def main(args): arr = [100, 1000, 100, 1000, 1] n = len(arr) print(maxSumWO3Consec(arr, n)) if __name__ == \"__main__\": import sys main(sys.argv)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n\n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n}", "index": 162, "complexity": "1"}
{"back-translation": "class GFG: \n    arr = [100, 1000, 100, 1000, 1] \n    sum = [-1] * 10000 \n\n    def maxSumWO3Consec(n): \n        if sum[n] != -1: \n            return sum[n] \n        if n == 0: \n            sum[n] = 0 \n            return sum[n] \n        if n == 1: \n            sum[n] = arr[0] \n            return sum[n] \n        if n == 2: \n            sum[n] = arr[1] + arr[0] \n            return sum[n] \n        sum[n] = max(max(maxSumWO3Consec(n - 1), maxSumWO3Consec(n - 2) + arr[n - 1]), arr[n - 2] + arr[n - 1] + maxSumWO3Consec(n - 3)) \n        return sum[n] \n\n    def main(args): \n        n = len(arr) \n        sum[:] = [-1] * 10000 \n        print(maxSumWO3Consec(n)) \n\nmain([]) \n", "src": "class\nGFG \n{ \n\nstatic\nint\narr[] = {\n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \nstatic\nint\nsum[] = \nnew\nint\n[\n10000\n]; \n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\nn) \n{ \n\nif\n(sum[n] != -\n1\n) \n\nreturn\nsum[n]; \n\n\n\n\n\nif\n(n == \n0\n) \n\nreturn\nsum[n] = \n0\n; \n\n\nif\n(n == \n1\n) \n\nreturn\nsum[n] = arr[\n0\n]; \n\n\nif\n(n == \n2\n) \n\nreturn\nsum[n] = arr[\n1\n] + arr[\n0\n]; \n\n\n\n\n\n\nreturn\nsum[n] = Math.max(Math.max(maxSumWO3Consec(n - \n1\n), \n\nmaxSumWO3Consec(n - \n2\n) + arr[n - \n1\n]), \n\narr[n - \n2\n] + arr[n - \n1\n] + maxSumWO3Consec(n - \n3\n)); \n\n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = arr.length; \n\nArrays.fill(sum, -\n1\n); \n\nSystem.out.println(maxSumWO3Consec(n)); \n} \n}", "index": 163, "complexity": "1"}
{"back-translation": "class GFG { static int maximumSegments(int n, int a, int b, int c) { int[] dp = new int[n + 10]; Arrays.fill(dp, -1); dp[0] = 0; for (int i = 0; i < n; i++) { if (dp[i] != -1) { if (i + a <= n ) dp[i + a] = Math.max(dp[i] + 1, dp[i + a]); if (i + b <= n ) dp[i + b] = Math.max(dp[i] + 1, dp[i + b]); if (i + c <= n ) dp[i + c] = Math.max(dp[i] + 1, dp[i + c]); } } return dp[n]; } public static void main(String arg[]) { int n = 7, a = 5, b = 2, c = 5; System.out.print(maximumSegments(n, a, b, c)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n\n\nArrays.fill(dp, -\n1\n); \n\n\n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n\n\nif\n(i + a <= n ) \n\n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n\n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n\n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n}", "index": 164, "complexity": "1"}
{"back-translation": "class RearrangeArray: def rearrangeUtil(arr, n, i): val = -(i + 1) i = arr[i] - 1 while arr[i] > 0: new_i = arr[i] - 1 arr[i] = val val = -(i + 1) i = new_i def rearrange(arr, n): i = 0 for i in range(n): arr[i] += 1 for i in range(n): if arr[i] > 0: rearrangeUtil(arr, n, i) for i in range(n): arr[i] = (-arr[i]) - 1 def printArray(arr, n): for i in range(n): print(arr[i], end=' ') print('') if __name__ == '__main__': arrange = RearrangeArray() arr = [2, 0, 1, 4, 5, 3] n = len(arr) print('Given array is ') printArray(arr, n) arrange.rearrange(arr, n) print('Modified array is ') printArray(arr, n)", "src": "class\nRearrangeArray { \n\n\n\n\n\n\n\n\n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n\n\n\n\n\nint\nval = -(i + \n1\n); \n\n\n\n\n\n\ni = arr[i] - \n1\n; \n\n\n\n\nwhile\n(arr[i] > \n0\n) { \n\n\n\n\n\nint\nnew_i = arr[i] - \n1\n; \n\n\n\n\narr[i] = val; \n\n\n\n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n\n\n\n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\n\n\n\n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 165, "complexity": "1"}
{"back-translation": "class GFG: \n    MAX = 1000000 \n    @staticmethod \n    def breakSum(n): \n        dp = [0] * (n + 1) \n        dp[1] = 1 \n        for i in range(2, n + 1): \n            dp[i] = max(dp[i // 2] + dp[i // 3] + dp[i // 4], i) \n        return dp[n] \n    \n    @staticmethod \n    def main(args): \n        n = 24 \n        print(GFG.breakSum(n)) \n", "src": "class\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n\n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n}", "index": 166, "complexity": "1"}
{"back-translation": "class GFG:\n    @staticmethod\n    def maxSum(grid, n):\n        incl = max(grid[0][0], grid[1][0])\n        excl = 0\n        for i in range(1, n):\n            excl_new = max(excl, incl)\n            incl = excl + max(grid[0][i], grid[1][i])\n            excl = excl_new\n        return max(excl, incl)\n    @staticmethod\n    def main(args):\n        grid = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\n        n = 5\n        print(GFG.maxSum(grid, n))", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n\n\n\n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n\n\nint\nexcl = \n0\n, excl_new; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n\n\n\n\nexcl_new = Math.max(excl, incl); \n\n\n\n\n\n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n\n\nexcl = excl_new; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n}", "index": 167, "complexity": "1"}
{"back-translation": "class GFG: def findLength(str, n): current_sum = 0 max_sum = 0 for i in range(n): current_sum += 1 if str[i] == '0' else -1 current_sum = 0 if current_sum < 0 max_sum = max(current_sum, max_sum) return -1 if max_sum == 0 else max_sum def main(args): str = '11000010001' n = len(str) print(findLength(str, n))", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n\n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n\n\n\n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n}", "index": 168, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG{ \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nminTimeForWritingChars(\\nint\\nN, \\nint\\ninsert, \\n\\nint\\nremove, \\nint\\ncopy) \\n\\n{ \\n\\nif\\n(N == \\n0\\n) \\n\\nreturn\\n0\\n; \\n\\nif\\n(N == \\n1\\n) \\n\\nreturn\\ninsert; \\n\\n\\n\\n\\nint\\ndp[] = \\nnew\\nint\\n[N + \\n1\\n]; \\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n1\\n; i <= N; i++) \\n\\n{ \\n\\n\\n\\nif\\n(i % \\n2\\n== \\n0\\n) \\n\\ndp[i] = Math.min(dp[i-\\n1\\n] + insert, dp[i/\\n2\\n] + copy); \\n\\n\\n\\nelse\\n\\ndp[i] = Math.min(dp[i-\\n1\\n] + insert, \\n\\n\\ndp[(i+\\n1\\n)/\\n2\\n] + copy + remove); \\n\\n} \\n\\nreturn\\ndp[N]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String []args) \\n\\n{ \\n\\nint\\nN = \\n9\\n; \\n\\nint\\ninsert = \\n1\\n, remove = \\n2\\n, copy = \\n1\\n; \\n\\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \\n\\n} \\n\\n\\n}', 'complexity': '1', 'index': 169}", "src": "public\nclass\nGFG{ \n\n\n\n\n\n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n\n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n\n}", "index": 169, "complexity": "1"}
{"back-translation": "class GFG:\n    \n    def sumOfSubstrings(num):\n        n = len(num)\n        sumofdigit = [0] * n\n        sumofdigit[0] = ord(num[0]) - ord('0')\n        res = sumofdigit[0]\n        for i in range(1, n):\n            numi = ord(num[i]) - ord('0')\n            sumofdigit[i] = (i + 1) * numi + 10 * sumofdigit[i - 1]\n            res += sumofdigit[i]\n        return res\n\n    def main(args):\n        num = \"1234\"\n        print(sumOfSubstrings(num))\n\nmain([])", "src": "class\nGFG{ \n\n\n\n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n\n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n\n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n\n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n\n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n}", "index": 170, "complexity": "1"}
{"back-translation": "class GFG: def maxLoot(hval, n): if n == 0: return 0 if n == 1: return hval[0] if n == 2: return max(hval[0], hval[1]) dp = [0] * n dp[0] = hval[0] dp[1] = max(hval[0], hval[1]) for i in range(2, n): dp[i] = max(hval[i] + dp[i-2], dp[i-1]) return dp[n-1] def main(args): hval = [6, 7, 1, 3, 8, 2, 4] n = len(hval) print('Maximum loot value : ' + str(maxLoot(hval, n))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 171, "complexity": "1"}
{"back-translation": "class GFG: def maxLoot(hval, n): if n == 0: return 0 value1 = hval[0] if n == 1: return value1 value2 = max(hval[0], hval[1]) if n == 2: return value2 max_val = 0 for i in range(2, n): max_val = max(hval[i] + value1, value2) value1, value2 = value2, max_val return max_val def main(args): hval = [6, 7, 1, 3, 8, 2, 4] n = len(hval) print('Maximum loot value : ' + str(maxLoot(hval, n)))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n\n\nint\nmax_val = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 172, "complexity": "1"}
{"back-translation": "class GFG: def countWays(n): DP = [0] * (n + 1) DP[0] = DP[1] = DP[2] = 1 DP[3] = 2 for i in range(4, n + 1): DP[i] = DP[i - 1] + DP[i - 3] + DP[i - 4] return DP[n] def main(): n = 10 print(countWays(n)) if __name__ == '__main__': main()", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n\n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n}", "index": 173, "complexity": "1"}
{"back-translation": "class GFG: def countWays(n): dp = [[0 for _ in range(n + 1)] for _ in range(2)] dp[0][1] = 1 dp[1][1] = 2 for i in range(2, n + 1): dp[0][i] = dp[0][i - 1] + dp[1][i - 1] dp[1][i] = dp[0][i - 1] * 2 + dp[1][i - 1] return dp[0][n] + dp[1][n] def main(args): n = 5 print('Total no of ways with n = ' + str(n) + ' are: ' + str(countWays(n))) if __name__ == '__main__': import sys main(sys.argv)", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n\n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n\n\n\n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n\n\n\n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n}", "index": 174, "complexity": "1"}
{"back-translation": "class GFG:\n    @staticmethod\n    def countWays(n, m):\n        count = [0] * (n + 1)\n        count[0] = 0\n        for i in range(1, n + 1):\n            if i > m:\n                count[i] = count[i - 1] + count[i - m]\n            elif i < m:\n                count[i] = 1\n            else:\n                count[i] = 2\n        return count[n]\n\n    @staticmethod\n    def main(args):\n        n = 7\n        m = 4\n        print(\"Number of ways = \" + str(GFG.countWays(n, m)))", "src": "class\nGFG { \n\n\n\nstatic\nint\ncountWays(\nint\nn, \nint\nm) \n\n{ \n\n\n\n\n\nint\ncount[] = \nnew\nint\n[n + \n1\n]; \n\ncount[\n0\n] = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n1\n; i <= n; i++) { \n\n\n\nif\n(i > m) \n\ncount[i] = count[i - \n1\n] + count[i - m]; \n\n\n\n\nelse\nif\n(i < m) \n\ncount[i] = \n1\n; \n\n\n\n\nelse\n\ncount[i] = \n2\n; \n\n} \n\n\n\n\nreturn\ncount[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n7\n; \n\nint\nm = \n4\n; \n\nSystem.out.println(\n\"Number of ways = \"\n\n+ countWays(n, m)); \n\n} \n}", "index": 175, "complexity": "1"}
{"back-translation": "class Grid: def count(n): dp = [0] * (n + 1) dp[0] = 0 for i in range(1, n + 1): if i >= 1 and i <= 3: dp[i] = 1 elif i == 4: dp[i] = 2 else: dp[i] = dp[i - 1] + dp[i - 4] return dp[n] def main(args): n = 5 print('Count of ways is: ' + str(count(n))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGrid \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n\n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n\n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n}", "index": 176, "complexity": "1"}
{"back-translation": "class GFG:\n    @staticmethod\n    def nonDecNums(n):\n        a = [[0 for _ in range(10)] for _ in range(n + 1)]\n        for i in range(10):\n            a[0][i] = 1\n        for i in range(1, n + 1):\n            a[i][9] = 1\n        for i in range(1, n + 1):\n            for j in range(8, -1, -1):\n                a[i][j] = a[i - 1][j] + a[i][j + 1]\n        return a[n][0]\n\nif __name__ == '__main__':\n    n = 2\n    print('Non-decreasing digits = ' + str(GFG.nonDecNums(n)))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n}", "index": 177, "complexity": "1"}
{"back-translation": "class GFG: def maxRevenue(m, x, revenue, n, t): maxRev = [0] * (m + 1) nxtbb = 0 for i in range(1, m + 1): if nxtbb < n: if x[nxtbb] != i: maxRev[i] = maxRev[i - 1] else: if i <= t: maxRev[i] = max(maxRev[i - 1], revenue[nxtbb]) else: maxRev[i] = max(maxRev[i - t - 1] + revenue[nxtbb], maxRev[i - 1]) nxtbb += 1 else: maxRev[i] = maxRev[i - 1] return maxRev[m] def main(args): m = 20 x = [6, 7, 12, 13, 14] revenue = [5, 6, 5, 3, 1] n = len(x) t = 5 print(maxRevenue(m, x, revenue, n, t)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n\n\n\n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n\n\n\n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n\n\n\n\nif\n(nxtbb < n) \n\n{ \n\n\n\n\n\n\n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n\n\n\n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n\npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n}", "index": 178, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nMain { \\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nrearrange(\\nint\\narr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\nint\\nmax_ele = arr[n - \\n1\\]; \\n\\nint\\nmin_ele = arr[\\n0\\]; \\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i++) { \\n\\n\\n\\nif\\n(i % \\n2\\n== \\n0\\n) { \\n\\narr[i] = max_ele; \\n\\nmax_ele -= \\n1\\n; \\n\\n} \\n\\n\\n\\nelse\\n{ \\n\\narr[i] = min_ele; \\n\\nmin_ele += \\n1\\n; \\n\\n} \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n6\\n, \\n7\\n, \\n8\\n, \\n9\\n}; \\n\\nint\\nn = arr.length; \\n\\n\\nSystem.out.println(\\n\\\"Original Array\\\"\\n); \\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i++) \\n\\nSystem.out.print(arr[i] + \\n\\\" \\\"\\n); \\n\\n\\nrearrange(arr, n); \\n\\n\\nSystem.out.print(\\n\\\"\\\\nModified Array\\\\n\\\"\\n); \\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i++) \\n\\nSystem.out.print(arr[i] + \\n\\\" \\\"\\n); \\n\\n} \\n}', 'complexity': '1', 'index': 179}", "src": "public\nclass\nMain { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n\n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 179, "complexity": "1"}
{"back-translation": "class LisTree:\n\n    class node:\n        def __init__(self, data):\n            self.data = data\n            self.liss = 0\n            self.left = None\n            self.right = None\n\n    @staticmethod\n    def liss(root):\n        if root is None:\n            return 0\n        if root.liss != 0:\n            return root.liss\n        if root.left is None and root.right is None:\n            return root.liss = 1\n\n        liss_excl = LisTree.liss(root.left) + LisTree.liss(root.right)\n\n        liss_incl = 1\n        if root.left is not None:\n            liss_incl += (LisTree.liss(root.left.left) + LisTree.liss(root.left.right))\n        if root.right is not None:\n            liss_incl += (LisTree.liss(root.right.left) + LisTree.liss(root.right.right))\n\n        return root.liss = max(liss_excl, liss_incl)\n\n    @staticmethod\n    def main(args):\n        root = LisTree.node(20)\n        root.left = LisTree.node(8)\n        root.left.left = LisTree.node(4)\n        root.left.right = LisTree.node(12)\n        root.left.right.left = LisTree.node(10)\n        root.left.right.right = LisTree.node(14)\n        root.right = LisTree.node(22)\n        root.right.right = LisTree.node(25)\n        print('Size of the Largest Independent Set is ' + str(LisTree.liss(root)))\n\nLisTree.main(None)", "src": "public\nclass\nLisTree \n{ \n\n\n\nstatic\nclass\nnode \n\n{ \n\nint\ndata, liss; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.liss = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nliss(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.liss != \n0\n) \n\nreturn\nroot.liss; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.liss = \n1\n; \n\n\n\n\n\n\nint\nliss_excl = liss(root.left) + liss(root.right); \n\n\n\n\n\n\nint\nliss_incl = \n1\n; \n\nif\n(root.left != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.left.left) + liss(root.left.right)); \n\n} \n\nif\n(root.right != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.right.left) + liss(root.right.right)); \n\n} \n\n\n\n\n\n\nreturn\nroot.liss = Math.max(liss_excl, liss_incl); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\nnode root = \nnew\nnode(\n20\n); \n\nroot.left = \nnew\nnode(\n8\n); \n\nroot.left.left = \nnew\nnode(\n4\n); \n\nroot.left.right = \nnew\nnode(\n12\n); \n\nroot.left.right.left = \nnew\nnode(\n10\n); \n\nroot.left.right.right = \nnew\nnode(\n14\n); \n\nroot.right = \nnew\nnode(\n22\n); \n\nroot.right.right = \nnew\nnode(\n25\n); \n\nSystem.out.println(\n\"Size of the Largest Independent Set is \"\n+ liss(root)); \n\n} \n}", "index": 180, "complexity": "1"}
{"back-translation": "class GFG: def max(x, y): return x if x > y else y def maxTasks(high, low, n): task_dp = [0] * (n + 1) task_dp[0] = 0 task_dp[1] = high[0] for i in range(2, n + 1): task_dp[i] = max(high[i - 1] + task_dp[i - 2], low[i - 1] + task_dp[i - 1]) return task_dp[n] def main(args): n = 5 high = [3, 6, 8, 7, 6] low = [1, 5, 4, 5, 3] print(maxTasks(high, low, n)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n\n\nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n\n\n\n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n\n\ntask_dp[\n0\n] = \n0\n; \n\n\n\n\n\n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n}", "index": 181, "complexity": "1"}
{"back-translation": "class GFG: def segregateElements(arr, n): temp = [0]*n j = 0 for i in range(n): if arr[i] >= 0: temp[j] = arr[i] j += 1 if j == n or j == 0: return for i in range(n): if arr[i] < 0: temp[j] = arr[i] j += 1 for i in range(n): arr[i] = temp[i] def main(arr): n = len(arr) segregateElements(arr, n) for i in range(n): print(arr[i], end=' ') arr = [1, -1, -3, -2, 7, 5, 11, 6] main(arr)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n\n\n\n\nint\nj = \n0\n; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\n\n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 182, "complexity": "1"}
{"back-translation": "class Node:\n\n    def __init__(self, item):\n        self.key = item\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n\n    def __init__(self):\n        self.root = None\n\n    def printPostorder(self, node):\n        if node is None:\n            return\n        self.printPostorder(node.left)\n        self.printPostorder(node.right)\n        print(node.key, end=' ')\n\n    def printInorder(self, node):\n        if node is None:\n            return\n        self.printInorder(node.left)\n        print(node.key, end=' ')\n        self.printInorder(node.right)\n\n    def printPreorder(self, node):\n        if node is None:\n            return\n        print(node.key, end=' ')\n        self.printPreorder(node.left)\n        self.printPreorder(node.right)\n\n    def printPostorder(self):\n        self.printPostorder(self.root)\n\n    def printInorder(self):\n        self.printInorder(self.root)\n\n    def printPreorder(self):\n        self.printPreorder(self.root)\n\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(5)\n\n    print('Preorder traversal of binary tree is')\n    tree.printPreorder()\n\n    print('\\nInorder traversal of binary tree is')\n    tree.printInorder()\n\n    print('\\nPostorder traversal of binary tree is')\n    tree.printPostorder()\n\n\nif __name__ == '__main__':\n    import sys\n    main(sys.argv[1:])", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\nkey = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\nBinaryTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\nprintPostorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintPostorder(node.left); \n\n\n\n\nprintPostorder(node.right); \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\nvoid\nprintPreorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n\n\nprintPreorder(node.left); \n\n\n\n\nprintPreorder(node.right); \n\n} \n\n\n\n\nvoid\nprintPostorder() { printPostorder(root); } \n\nvoid\nprintInorder() { printInorder(root); } \n\nvoid\nprintPreorder() { printPreorder(root); } \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Preorder traversal of binary tree is \"\n); \n\ntree.printPreorder(); \n\n\nSystem.out.println(\n\"\\nInorder traversal of binary tree is \"\n); \n\ntree.printInorder(); \n\n\nSystem.out.println(\n\"\\nPostorder traversal of binary tree is \"\n); \n\ntree.printPostorder(); \n\n} \n}", "index": 183, "complexity": "1"}
{"back-translation": "class Solution: \n    class INT: \n        def __init__(self, d): \n            self.data = d \n\n    @staticmethod \n    def findPostOrderUtil(pre, n, minval, maxval, preIndex): \n        if preIndex.data == n: \n            return \n        if pre[preIndex.data] < minval or pre[preIndex.data] > maxval: \n            return \n        val = pre[preIndex.data] \n        preIndex.data += 1 \n        Solution.findPostOrderUtil(pre, n, minval, val, preIndex) \n        Solution.findPostOrderUtil(pre, n, val, maxval, preIndex) \n        print(val, end=' ') \n\n    @staticmethod \n    def findPostOrder(pre, n): \n        preIndex = Solution.INT(0) \n        Solution.findPostOrderUtil(pre, n, float('-inf'), float('inf'), preIndex) \n\nif __name__ == '__main__': \n    pre = [40, 30, 35, 80, 100] \n    n = len(pre) \n    Solution.findPostOrder(pre, n)", "src": "class\nSolution \n{ \nstatic\nclass\nINT \n{ \n\nint\ndata; \n\nINT(\nint\nd) \n\n{ \n\ndata=d; \n\n} \n} \n\n\n\nstatic\nvoid\nfindPostOrderUtil(\nint\npre[], \nint\nn, \nint\nminval, \n\nint\nmaxval, INT preIndex) \n{ \n\n\n\n\n\n\n\n\nif\n(preIndex.data == n) \n\nreturn\n; \n\n\n\n\n\n\nif\n(pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { \n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nint\nval = pre[preIndex.data]; \n\npreIndex.data++; \n\n\n\n\n\n\nfindPostOrderUtil(pre, n, minval, val, preIndex); \n\n\n\n\n\n\nfindPostOrderUtil(pre, n, val, maxval, preIndex); \n\n\nSystem.out.print( val + \n\" \"\n); \n} \n\n\nstatic\nvoid\nfindPostOrder(\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\n\n\n\nINT preIndex = \nnew\nINT(\n0\n); \n\n\nfindPostOrderUtil(pre, n, Integer.MIN_VALUE, \n\nInteger.MAX_VALUE, preIndex); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\npre[] = { \n40\n, \n30\n, \n35\n, \n80\n, \n100\n}; \n\n\nint\nn = pre.length; \n\n\n\n\nfindPostOrder(pre, n); \n} \n}", "index": 184, "complexity": "1"}
{"back-translation": "class Solution: def __init__(self): self.data = 0 self.left = None self.right = None class INT: def __init__(self): self.data = 0 @staticmethod def getNode(data): new_node = Solution() new_node.data = data new_node.left = new_node.right = None return new_node @staticmethod def storeInorderTraversal(root, arr): if root == None: return storeInorderTraversal(root.left, arr) arr.append(root.data) storeInorderTraversal(root.right, arr) @staticmethod def replaceNodeWithSum(root, arr, i): if root == None: return replaceNodeWithSum(root.left, arr, i) root.data = arr[i.data - 1] + arr[i.data + 1] i.data += 1 replaceNodeWithSum(root.right, arr, i) @staticmethod def replaceNodeWithSumUtil(root): if root == None: return arr = [] arr.append(0) storeInorderTraversal(root, arr) arr.append(0) i = INT() i.data = 1 replaceNodeWithSum(root, arr, i) @staticmethod def preorderTraversal(root): if root == None: return print(root.data, end=' ') preorderTraversal(root.left) preorderTraversal(root.right) if __name__ == '__main__': root = Solution.getNode(1) root.left = Solution.getNode(2) root.right = Solution.getNode(3) root.left.left = Solution.getNode(4) root.left.right = Solution.getNode(5) root.right.left = Solution.getNode(6) root.right.right = Solution.getNode(7) print('Preorder Traversal before tree modification:') preorderTraversal(root) replaceNodeWithSumUtil(root) print('\\nPreorder Traversal after tree modification:') preorderTraversal(root)", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nclass\nINT \n{ \n\nint\ndata; \n} \n\n\nstatic\nNode getNode(\nint\ndata) \n{ \n\n\n\nNode new_node =\nnew\nNode(); \n\n\n\n\nnew_node.data = data; \n\nnew_node.left = new_node.right = \nnull\n; \n\n\nreturn\nnew_node; \n} \n\n\n\nstatic\nvoid\nstoreInorderTraversal( Node root, \n\nVector<Integer> arr) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nstoreInorderTraversal(root.left, arr); \n\n\n\n\narr.add(root.data); \n\n\n\n\nstoreInorderTraversal(root.right, arr); \n} \n\n\n\nstatic\nvoid\nreplaceNodeWithSum( Node root, \n\nVector<Integer> arr, INT i) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nreplaceNodeWithSum(root.left, arr, i); \n\n\n\n\n\n\nroot.data = arr.get(i.data - \n1\n) + arr.get(i.data + \n1\n); \n\n\n\n\ni.data++; \n\n\n\n\nreplaceNodeWithSum(root.right, arr, i); \n} \n\n\n\n\nstatic\nvoid\nreplaceNodeWithSumUtil( Node root) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\nVector<Integer> arr= \nnew\nVector<Integer>(); \n\n\n\n\n\n\narr.add(\n0\n); \n\n\n\n\nstoreInorderTraversal(root, arr); \n\n\n\n\n\n\narr.add(\n0\n); \n\n\n\n\nINT i = \nnew\nINT(); \n\n\ni.data=\n1\n; \n\n\nreplaceNodeWithSum(root, arr, i); \n} \n\n\n\nstatic\nvoid\npreorderTraversal( Node root) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print( root.data + \n\" \"\n); \n\n\n\n\npreorderTraversal(root.left); \n\n\n\n\npreorderTraversal(root.right); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root = getNode(\n1\n); \n\n\nroot.left = getNode(\n2\n); \n\n\nroot.right = getNode(\n3\n); \n\n\nroot.left.left = getNode(\n4\n); \n\n\nroot.left.right = getNode(\n5\n); \n\n\nroot.right.left = getNode(\n6\n); \n\nroot.right.right = getNode(\n7\n); \n\n\nSystem.out.println( \n\"Preorder Traversal before tree modification:\"\n); \n\npreorderTraversal(root); \n\n\nreplaceNodeWithSumUtil(root); \n\n\nSystem.out.println(\n\"\\nPreorder Traversal after tree modification:\"\n); \n\npreorderTraversal(root); \n\n} \n}", "index": 185, "complexity": "1"}
{"back-translation": "class GFG: def rearrange(arr, n): for i in range(n - 1): if i % 2 == 0 and arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] if i % 2 != 0 and arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] def printArray(arr, size): for i in range(size): print(arr[i], end=' ') print() if __name__ == '__main__': arr = [6, 4, 2, 1, 8, 3] n = len(arr) print('Before rearranging: ') printArray(arr, n) rearrange(arr, n) print('After rearranging: ') printArray(arr, n)", "src": "class\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 186, "complexity": "1"}
{"back-translation": "{'src': 'class Solution { static class Node { int data; Node left, right; } static Node temp = new Node(); static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null; return temp; } static Node leftMostNode(Node node) { while(node != null && node.left != null) node = node.left; return node; } static Node rightMostNode(Node node) { while(node != null && node.right != null) node = node.right; return node; } static Node findInorderRecursive(Node root, Node x ) { if(root==null) return null; if(root==x || (temp = findInorderRecursive(root.left,x))!=null || (temp = findInorderRecursive(root.right,x))!=null) { if(temp!=null) { if(root.left == temp) { System.out.print( 'Inorder Successor of '+x.data); System.out.print( ' is '+ root.data + '\\n'); return null; } } return root; } return null; } static void inorderSuccesor(Node root, Node x) { if(x.right != null) { Node inorderSucc = leftMostNode(x.right); System.out.print('Inorder Successor of '+x.data+' is '); System.out.print(inorderSucc.data+'\\n'); } if(x.right == null) { int f = 0; Node rightMost = rightMostNode(root); if(rightMost == x) System.out.print('No inorder successor! Right most node.\\n'); else findInorderRecursive(root, x); } } public static void main(String args[]) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.right.right = newNode(6); inorderSuccesor(root, root.right); inorderSuccesor(root, root.left.left); inorderSuccesor(root, root.right.right); } }', 'complexity': '1', 'index': 187}", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode temp = \nnew\nNode(); \n\n\nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n\nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n\n\nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n\n\nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n\n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n\n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n\n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\n\n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n\n\ninorderSuccesor(root, root.right); \n\n\n\n\ninorderSuccesor(root, root.left.left); \n\n\n\n\ninorderSuccesor(root, root.right.right); \n\n} \n}", "index": 187, "complexity": "1"}
{"back-translation": "class Solution: \n    count = 0 \n\n    class Node: \n        def __init__(self): \n            self.data = None \n            self.left = None \n            self.right = None \n\n    @staticmethod \n    def newNode(data): \n        node = Solution.Node() \n        node.data = data \n        node.left = None \n        node.right = None \n        return node \n\n    @staticmethod \n    def NthInorder(node, n): \n        if node is None: \n            return \n        if Solution.count <= n: \n            Solution.NthInorder(node.left, n) \n            Solution.count += 1 \n            if Solution.count == n: \n                print(node.data, end=' ') \n            Solution.NthInorder(node.right, n) \n\n    if __name__ == '__main__': \n        root = Solution.newNode(10) \n        root.left = Solution.newNode(20) \n        root.right = Solution.newNode(30) \n        root.left.left = Solution.newNode(40) \n        root.left.right = Solution.newNode(50) \n        n = 4 \n        Solution.NthInorder(root, n)", "src": "class\nSolution \n{ \nstatic\nint\ncount =\n0\n; \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\n\nreturn\n(node); \n} \n\n\n\nstatic\nvoid\nNthInorder( Node node, \nint\nn) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\nif\n(count <= n) { \n\n\n\nNthInorder(node.left, n); \n\ncount++; \n\n\n\n\nif\n(count == n) \n\nSystem.out.printf(\n\"%d \"\n, node.data); \n\n\n\n\nNthInorder(node.right, n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\n\nint\nn = \n4\n; \n\n\nNthInorder(root, n); \n} \n}", "index": 188, "complexity": "1"}
{"back-translation": "class NthNodePostOrder: \n    flag = 0 \n\n    @staticmethod \n    def NthPostordernode(root, N): \n        if root is None: \n            return \n        if flag <= N: \n            NthPostordernode(root.left, N) \n            NthPostordernode(root.right, N) \n            flag += 1 \n            if flag == N: \n                print(root.data) \n\n    @staticmethod \n    def main(args): \n        root = Node(25) \n        root.left = Node(20) \n        root.right = Node(30) \n        root.left.left = Node(18) \n        root.left.right = Node(22) \n        root.right.left = Node(24) \n        root.right.right = Node(32) \n        N = 6 \n        NthPostordernode(root, N) \n\n\nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.left = None \n        self.right = None", "src": "public\nclass\nNthNodePostOrder { \n\n\nstatic\nint\nflag = \n0\n; \n\n\n\n\n\n\npublic\nstatic\nvoid\nNthPostordernode(Node root, \nint\nN) \n\n{ \n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nif\n(flag <= N) \n\n{ \n\n\n\nNthPostordernode(root.left, N); \n\n\n\nNthPostordernode(root.right, N); \n\nflag++; \n\n\n\nif\n(flag == N) \n\nSystem.out.print(root.data); \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n25\n); \n\nroot.left = \nnew\nNode(\n20\n); \n\nroot.right = \nnew\nNode(\n30\n); \n\nroot.left.left = \nnew\nNode(\n18\n); \n\nroot.left.right = \nnew\nNode(\n22\n); \n\nroot.right.left = \nnew\nNode(\n24\n); \n\nroot.right.right = \nnew\nNode(\n32\n); \n\n\nint\nN = \n6\n; \n\n\n\n\nNthPostordernode(root, N); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 189, "complexity": "1"}
{"back-translation": "class\nNode: \n\n    def __init__(self, item): \n        self.data = item \n        self.left = None \n        self.right = None \n\n\nclass\nBinaryTree: \n\n    def printSpiral(self, node): \n        if node is None: \n            return \n\n        s1 = [] \n        s2 = [] \n\n        s1.append(node) \n\n        while s1 or s2: \n\n            while s1: \n                temp = s1[-1] \n                s1.pop() \n                print(temp.data, end=\" \") \n\n                if temp.right: \n                    s2.append(temp.right) \n\n                if temp.left: \n                    s2.append(temp.left) \n\n            while s2: \n                temp = s2[-1] \n                s2.pop() \n                print(temp.data, end=\" \") \n\n                if temp.left: \n                    s1.append(temp.left) \n\n                if temp.right: \n                    s1.append(temp.right) \n\n\nif __name__ == '__main__': \n    tree = BinaryTree() \n    tree.root = Node(1) \n    tree.root.left = Node(2) \n    tree.root.right = Node(3) \n    tree.root.left.left = Node(7) \n    tree.root.left.right = Node(6) \n    tree.root.right.left = Node(5) \n    tree.root.right.right = Node(4) \n\n    print(\"Spiral Order traversal of Binary Tree is \") \n    tree.printSpiral(tree.root)", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n\n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n\n\ns1.push(node); \n\n\n\n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n\n\n\n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n\n\n\n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n}", "index": 190, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\nstatic\\nclass\\nNode { \\n\\nint\\ndata; \\n\\nNode left; \\n\\nNode right; \\n\\n\\nNode(\\nint\\ndata) { \\n\\nthis\\n.data = data; \\n\\nleft = \\nNone\\n; \\n\nright = \\nNone\\n; \\n\n} \\n\n} \\n\\n\\n\\n\\n\\nstatic\\nvoid\\nlevelOrder(Node root) { \\n\\nif\\n(root == \\nNone\\n) \\n\\nreturn\\n; \\n\\n\\nQueue<Node> q = \\nnew\\nLinkedList<>(); \\n\\n\\n\\n\\nq.add(root); \\n\\n\\n\\nq.add(\\nNone\\n); \\n\\n\\n\\n\\n\\nwhile\\n(!q.isEmpty()) { \\n\\n\\nNode curr = q.poll(); \\n\\n\\n\\n\\n\\nif\\n(curr == \\nNone\\n) { \\n\\nif\\n(!q.isEmpty()) { \\n\\nq.add(\\nNone\\n); \\n\\nSystem.out.println(); \\n\\n} \\n\\n} \\nelse { \\n\\n\\n\\nif\\n(curr.left != \\nNone\\n) \\n\\nq.add(curr.left); \\n\\n\\n\\nif\\n(curr.right != \\nNone\\n) \\n\\nq.add(curr.right); \\n\\nSystem.out.print(curr.data + \\n\" \"\\n); \\n\\n} \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) { \\n\\n\\nNode root = \\nnew\\nNode(\\n1\\n); \\n\\nroot.left = \\nnew\\nNode(\\n2\\n); \\n\\nroot.right = \\nnew\\nNode(\\n3\\n); \\n\\nroot.left.left = \\nnew\\nNode(\\n4\\n); \\n\\nroot.left.right = \\nnew\\nNode(\\n5\\n); \\n\\nroot.right.right = \\nnew\\nNode(\\n6\\n); \\n\\n\\nlevelOrder(root); \\n\\n} \\n}', 'complexity': '1', 'index': 191}", "src": "public\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n\n\nq.add(root); \n\n\n\n\nq.add(\nnull\n); \n\n\n\n\n\n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n\n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n}", "index": 191, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def reverseLevelOrder(self, node):\n        S = []\n        Q = []\n        Q.append(node)\n        while(Q):\n            node = Q[0]\n            Q = Q[1:]\n            S.insert(0, node)\n            if node.right:\n                Q.append(node.right)\n            if node.left:\n                Q.append(node.left)\n        while(S):\n            node = S[0]\n            print(node.data, end=' ')\n            S = S[1:]\n\ndef main():\n    tree = BinaryTree()\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(5)\n    tree.root.right.left = Node(6)\n    tree.root.right.right = Node(7)\n    print('Level Order traversal of binary tree is :')\n    tree.reverseLevelOrder(tree.root)\n\nif __name__ == '__main__':\n    main()", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n\n\n\n\n\n\n\n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n\n\nif\n(node.right != \nnull\n) \n\n\n\nQ.add(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n\n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n}", "index": 192, "complexity": "1"}
{"back-translation": "class Node: def __init__(self, item): self.data = item self.left = self.right = None class BinaryTree: def printSpecificLevelOrder(self, node): if node is None: return print(node.data, end='') if node.left and node.right: print(' ' + str(node.left.data) + ' ' + str(node.right.data), end='') if node.left.left is None: return from collections import deque q = deque() q.append(node.left) q.append(node.right) first, second = None, None while q: first = q.popleft() second = q.popleft() print(' ' + str(first.left.data) + ' ' + str(second.right.data), end='') print(' ' + str(first.right.data) + ' ' + str(second.left.data), end='') if first.left.left is None: continue q.append(first.left) q.append(second.right) q.append(first.right) q.append(second.left) @staticmethod def main(args): tree = BinaryTree() tree.root = Node(1) tree.root.left = Node(2) tree.root.right = Node(3) tree.root.left.left = Node(4) tree.root.left.right = Node(5) tree.root.right.left = Node(6) tree.root.right.right = Node(7) tree.root.left.left.left = Node(8) tree.root.left.left.right = Node(9) tree.root.left.right.left = Node(10) tree.root.left.right.right = Node(11) tree.root.right.left.left = Node(12) tree.root.right.left.right = Node(13) tree.root.right.right.left = Node(14) tree.root.right.right.right = Node(15) tree.root.left.left.left.left = Node(16) tree.root.left.left.left.right = Node(17) tree.root.left.left.right.left = Node(18) tree.root.left.left.right.right = Node(19) tree.root.left.right.left.left = Node(20) tree.root.left.right.left.right = Node(21) tree.root.left.right.right.left = Node(22) tree.root.left.right.right.right = Node(23) tree.root.right.left.left.left = Node(24) tree.root.right.left.left.right = Node(25) tree.root.right.left.right.left = Node(26) tree.root.right.left.right.right = Node(27) tree.root.right.right.left.left = Node(28) tree.root.right.right.left.right = Node(29) tree.root.right.right.right.left = Node(30) tree.root.right.right.right.right = Node(31) print(\"Specific Level Order traversal of binary tree is \") tree.printSpecificLevelOrder(tree.root)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.data); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n\n\n\n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n\n\n\n\nNode first = \nnull\n, second = \nnull\n; \n\n\n\n\nwhile\n(!q.isEmpty()) \n\n{ \n\n\n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n\n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n\n\n\n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n}", "index": 193, "complexity": "1"}
{"back-translation": "class Multiply: def modify(arr, n): if n <= 1: return prev = arr[0] arr[0] = arr[0] * arr[1] for i in range(1, n-1): curr = arr[i] arr[i] = prev * arr[i+1] prev = curr arr[n-1] = prev * arr[n-1] def main(args): arr = [2, 3, 4, 5, 6] n = len(arr) modify(arr, n) for i in range(n): print(arr[i], end=' ')", "src": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 194, "complexity": "1"}
{"back-translation": "class Node {\n    char data;\n    Node left, right;\n    Node(char item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass Index {\n    int index;\n}\n\nclass BinaryTree {\n    Node root;\n    Index index_obj = new Index();\n\n    void storeAlternate(Node node, char arr[], Index index, int l) {\n        if(node == null) {\n            return;\n        }\n        storeAlternate(node.left, arr, index, l + 1);\n        if(l % 2 != 0) {\n            arr[index.index] = node.data;\n            index.index++;\n        }\n        storeAlternate(node.right, arr, index, l + 1);\n    }\n\n    void modifyTree(Node node, char arr[], Index index, int l) {\n        if(node == null) {\n            return;\n        }\n        modifyTree(node.left, arr, index, l + 1);\n        if(l % 2 != 0) {\n            node.data = arr[index.index];\n            (index.index)++;\n        }\n        modifyTree(node.right, arr, index, l + 1);\n    }\n\n    void reverse(char arr[], int n) {\n        int l = 0, r = n - 1;\n        while(l < r) {\n            char temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    void reverseAlternate() {\n        reverseAlternate(root);\n    }\n\n    void reverseAlternate(Node node) {\n        char[] arr = new char[100];\n        storeAlternate(node, arr, index_obj, 0);\n        reverse(arr, index_obj.index);\n        index_obj.index = 0;\n        modifyTree(node, arr, index_obj, 0);\n    }\n\n    void printInorder() {\n        printInorder(root);\n    }\n\n    void printInorder(Node node) {\n        if(node == null) {\n            return;\n        }\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node('a');\n        tree.root.left = new Node('b');\n        tree.root.right = new Node('c');\n        tree.root.left.left = new Node('d');\n        tree.root.left.right = new Node('e');\n        tree.root.right.left = new Node('f');\n        tree.root.right.right = new Node('g');\n        tree.root.left.left.left = new Node('h');\n        tree.root.left.left.right = new Node('i');\n        tree.root.left.right.left = new Node('j');\n        tree.root.left.right.right = new Node('k');\n        tree.root.right.left.left = new Node('l');\n        tree.root.right.left.right = new Node('m');\n        tree.root.right.right.left = new Node('n');\n        tree.root.right.right.right = new Node('o');\n        System.out.println(\"Inorder Traversal of given tree\");\n        tree.printInorder();\n        tree.reverseAlternate();\n        System.out.println(\"\");\n        System.out.println(\"\");\n        System.out.println(\"Inorder Traversal of modified tree\");\n        tree.printInorder();\n    }\n}", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) { \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\nNode root; \n\nIndex index_obj = \nnew\nIndex(); \n\n\n\n\nvoid\nstoreAlternate(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\nstoreAlternate(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\narr[index.index] = node.data; \n\nindex.index++; \n\n} \n\n\nstoreAlternate(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nmodifyTree(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nmodifyTree(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\nnode.data = arr[index.index]; \n\n(index.index)++; \n\n} \n\n\n\n\nmodifyTree(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nreverse(\nchar\narr[], \nint\nn) { \n\nint\nl = \n0\n, r = n - \n1\n; \n\nwhile\n(l < r) { \n\nchar\ntemp = arr[l]; \n\narr[l] = arr[r]; \n\narr[r] = temp; \n\nl++; \n\nr--; \n\n} \n\n} \n\n\nvoid\nreverseAlternate() { \n\nreverseAlternate(root); \n\n} \n\n\n\n\nvoid\nreverseAlternate(Node node) { \n\n\n\n\nchar\n[] arr = \nnew\nchar\n[\n100\n]; \n\n\n\n\nstoreAlternate(node, arr, index_obj, \n0\n); \n\n\n\n\n\n\n\nreverse(arr, index_obj.index); \n\n\n\n\nindex_obj.index = \n0\n; \n\nmodifyTree(node, arr, index_obj, \n0\n); \n\n} \n\n\nvoid\nprintInorder() { \n\nprintInorder(root); \n\n} \n\n\n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n'a'\n); \n\ntree.root.left = \nnew\nNode(\n'b'\n); \n\ntree.root.right = \nnew\nNode(\n'c'\n); \n\ntree.root.left.left = \nnew\nNode(\n'd'\n); \n\ntree.root.left.right = \nnew\nNode(\n'e'\n); \n\ntree.root.right.left = \nnew\nNode(\n'f'\n); \n\ntree.root.right.right = \nnew\nNode(\n'g'\n); \n\ntree.root.left.left.left = \nnew\nNode(\n'h'\n); \n\ntree.root.left.left.right = \nnew\nNode(\n'i'\n); \n\ntree.root.left.right.left = \nnew\nNode(\n'j'\n); \n\ntree.root.left.right.right = \nnew\nNode(\n'k'\n); \n\ntree.root.right.left.left = \nnew\nNode(\n'l'\n); \n\ntree.root.right.left.right = \nnew\nNode(\n'm'\n); \n\ntree.root.right.right.left = \nnew\nNode(\n'n'\n); \n\ntree.root.right.right.right = \nnew\nNode(\n'o'\n); \n\nSystem.out.println(\n\"Inorder Traversal of given tree\"\n); \n\ntree.printInorder(); \n\n\ntree.reverseAlternate(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder Traversal of modified tree\"\n); \n\ntree.printInorder(); \n\n} \n}", "index": 195, "complexity": "1"}
{"back-translation": "class Sol: def __init__(self): pass @staticmethod def preorder(root1, root2, lvl): if root1 is None or root2 is None: return if lvl % 2 == 0: t = root1.key; root1.key, root2.key = root2.key, t preorder(root1.left, root2.right, lvl + 1); preorder(root1.right, root2.left, lvl + 1) @staticmethod def reverseAlternate(root): preorder(root.left, root.right, 0) @staticmethod def printInorder(root): if root is None: return printInorder(root.left); print(root.key, end=' '); printInorder(root.right) @staticmethod def newNode(key): temp = Sol.Node(); temp.left = temp.right = None; temp.key = chr(key); return temp def main(args): root = Sol.newNode('a'); root.left = Sol.newNode('b') # Updating the node values here root.right = Sol.newNode('c') root.left.left = Sol.newNode('d'); root.left.right = Sol.newNode('e'); root.right.left = Sol.newNode('f'); root.right.right = Sol.newNode('g'); root.left.left.left = Sol.newNode('h'); root.left.left.right = Sol.newNode('i') # Updating the node values here root.left.right.left = Sol.newNode('j'); root.left.right.right = Sol.newNode('k'); root.right.left.left = Sol.newNode('l'); root.right.left.right = Sol.newNode('m'); root.right.right.left = Sol.newNode('n'); root.right.right.right = Sol.newNode('o') # Updating the node values here print('Inorder Traversal of given tree\\n'); Sol.printInorder(root); Sol.reverseAlternate(root); print('\\n\\nInorder Traversal of modified tree\\n'); Sol.printInorder(root) if __name__ == '__main__': import sys; main(sys.argv)", "src": "class\nSol \n{ \n\nstatic\nclass\nNode \n{ \n\nchar\nkey; \n\nNode left, right; \n}; \n\nstatic\nvoid\npreorder( Node root1, Node root2, \nint\nlvl) \n{ \n\n\n\nif\n(root1 == \nnull\n|| root2==\nnull\n) \n\nreturn\n; \n\n\n\n\nif\n(lvl % \n2\n== \n0\n) \n\n{ \n\nchar\nt = root1.key; \n\nroot1.key = root2.key; \n\nroot2.key = t; \n\n} \n\n\n\n\n\n\n\n\npreorder(root1.left, root2.right, lvl+\n1\n); \n\npreorder(root1.right, root2.left, lvl+\n1\n); \n} \n\n\n\nstatic\nvoid\nreverseAlternate( Node root) \n{ \n\npreorder(root.left, root.right, \n0\n); \n} \n\n\n\nstatic\nvoid\nprintInorder( Node root) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\nprintInorder(root.left); \n\nSystem.out.print( root.key + \n\" \"\n); \n\nprintInorder(root.right); \n} \n\n\nstatic\nNode newNode(\nint\nkey) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.left = temp.right = \nnull\n; \n\ntemp.key = (\nchar\n)key; \n\nreturn\ntemp; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n'a'\n); \n\nroot.left = newNode(\n'b'\n); \n\nroot.right = newNode(\n'c'\n); \n\nroot.left.left = newNode(\n'd'\n); \n\nroot.left.right = newNode(\n'e'\n); \n\nroot.right.left = newNode(\n'f'\n); \n\nroot.right.right = newNode(\n'g'\n); \n\nroot.left.left.left = newNode(\n'h'\n); \n\nroot.left.left.right = newNode(\n'i'\n); \n\nroot.left.right.left = newNode(\n'j'\n); \n\nroot.left.right.right = newNode(\n'k'\n); \n\nroot.right.left.left = newNode(\n'l'\n); \n\nroot.right.left.right = newNode(\n'm'\n); \n\nroot.right.right.left = newNode(\n'n'\n); \n\nroot.right.right.right = newNode(\n'o'\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of given tree\\n\"\n); \n\nprintInorder(root); \n\n\nreverseAlternate(root); \n\n\nSystem.out.print(\n\"\\n\\nInorder Traversal of modified tree\\n\"\n); \n\nprintInorder(root); \n\n} \n}", "index": 196, "complexity": "1"}
{"back-translation": "class Node: def __init__(self, item): self.data = item self.left = self.right = None class BinaryTree: def __init__(self): self.root = None self.list = [] def postOrderIterative(self, node): if not node: return self.list S = [] prev = None S.append(node) while S: current = S[-1] if not prev or prev.left == current or prev.right == current: if current.left: S.append(current.left) elif current.right: S.append(current.right) else: S.pop() self.list.append(current.data) elif current.left == prev: if current.right: S.append(current.right) else: S.pop() self.list.append(current.data) elif current.right == prev: S.pop() self.list.append(current.data) prev = current return self.list def main(args): tree = BinaryTree() tree.root = Node(1) tree.root.left = Node(2) tree.root.right = Node(3) tree.root.left.left = Node(4) tree.root.left.right = Node(5) tree.root.right.left = Node(6) tree.root.right.right = Node(7) mylist = tree.postOrderIterative(tree.root) print('Post order traversal of binary tree is :') print(mylist)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n}", "index": 197, "complexity": "1"}
{"back-translation": "class Node: def __init__(self, item): self.data = item self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def printLeaves(node): if node is not None: printLeaves(node.left) if node.left is None and node.right is None: print(node.data, end=' ') printLeaves(node.right) def printBoundaryLeft(node): if node is not None: if node.left is not None: print(node.data, end=' ') printBoundaryLeft(node.left) elif node.right is not None: print(node.data, end=' ') printBoundaryLeft(node.right) def printBoundaryRight(node): if node is not None: if node.right is not None: printBoundaryRight(node.right) print(node.data, end=' ') elif node.left is not None: printBoundaryRight(node.left) print(node.data, end=' ') def printBoundary(node): if node is not None: print(node.data, end=' ') printBoundaryLeft(node.left) printLeaves(node.left) printLeaves(node.right) printBoundaryRight(node.right) def main(args): tree = BinaryTree() tree.root = Node(20) tree.root.left = Node(8) tree.root.left.left = Node(4) tree.root.left.right = Node(12) tree.root.left.right.left = Node(10) tree.root.left.right.right = Node(14) tree.root.right = Node(22) tree.root.right.right = Node(25) printBoundary(tree.root) if __name__ == '__main__': import sys main(sys.argv[1:])", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintLeaves(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nprintLeaves(node.left); \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintLeaves(node.right); \n\n} \n\n} \n\n\n\n\n\n\nvoid\nprintBoundaryLeft(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.left != \nnull\n) { \n\n\n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.left); \n\n} \n\nelse\nif\n(node.right != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.right); \n\n} \n\n\n\n\n\n\n} \n\n} \n\n\n\n\n\n\nvoid\nprintBoundaryRight(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.right != \nnull\n) { \n\n\n\n\n\nprintBoundaryRight(node.right); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\nelse\nif\n(node.left != \nnull\n) { \n\nprintBoundaryRight(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\n\n\n\n\n} \n\n} \n\n\n\n\nvoid\nprintBoundary(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintBoundaryLeft(node.left); \n\n\n\n\nprintLeaves(node.left); \n\nprintLeaves(node.right); \n\n\n\n\nprintBoundaryRight(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n20\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n12\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n14\n); \n\ntree.root.right = \nnew\nNode(\n22\n); \n\ntree.root.right.right = \nnew\nNode(\n25\n); \n\ntree.printBoundary(tree.root); \n\n} \n}", "index": 198, "complexity": "1"}
{"back-translation": "class ListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.head = None\n        self.root = None\n    \n    def push(self, new_data):\n        new_node = ListNode(new_data)\n        new_node.next = self.head\n        self.head = new_node\n    \n    def convertList2Binary(self, node):\n        q = []\n        if self.head is None:\n            node = None\n            return None\n        node = BinaryTreeNode(self.head.data)\n        q.append(node)\n        self.head = self.head.next\n        while self.head is not None:\n            parent = q[0]\n            pp = q.pop(0)\n            left_child = BinaryTreeNode(self.head.data)\n            q.append(left_child)\n            self.head = self.head.next\n            if self.head is not None:\n                right_child = BinaryTreeNode(self.head.data)\n                q.append(right_child)\n                self.head = self.head.next\n            parent.left = left_child\n            parent.right = right_child\n        return node\n    \n    def inorderTraversal(self, node):\n        if node is not None:\n            self.inorderTraversal(node.left)\n            print(node.data, end=' ')\n            self.inorderTraversal(node.right)\n\ndef main(args):\n    tree = BinaryTree()\n    tree.push(36)\n    tree.push(30)\n    tree.push(25)\n    tree.push(15)\n    tree.push(12)\n    tree.push(10)\n    node = tree.convertList2Binary(tree.root)\n    print('Inorder Traversal of the constructed Binary Tree is:')\n    tree.inorderTraversal(node)\n\nif __name__ == '__main__':\n    import sys\n    main(sys.argv[1:])", "src": "class\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\n\n\n\n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n\n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n\n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n\n\nhead = head.next; \n\n\n\n\n\n\nwhile\n(head != \nnull\n) \n\n{ \n\n\n\n\n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n\n\n\n\n\n\n\n\n\n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif\n(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n\n\n\n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n\n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\"\n); \n\ntree.inorderTraversal(node); \n\n} \n}", "index": 199, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nTree { \\n\\nNode root; \\n\\n\\n\\n\\n\\nstatic\\nclass\\nNode { \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\nNode(\\nint\\ndata) \\n\\n{ \\n\\nthis\\n.data = data; \\n\\nthis\\n.left = \\nnull\\; \\n\\nthis\\n.right = \\nnull\\; \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nNode insertLevelOrder(\\nint\\n[] arr, Node root, \\n\\nint\\ni) \\n\\n{ \\n\\n\\n\\nif\\n(i < arr.length) { \\n\\nNode temp = \\nnew\\nNode(arr[i]); \\n\\nroot = temp; \\n\\n\\n\\n\\n\\n\\nroot.left = insertLevelOrder(arr, root.left, \\n\\n2\\n* i + \\n1\\n); \\n\\n\\n\\n\\n\\n\\nroot.right = insertLevelOrder(arr, root.right, \\n\\n2\\n* i + \\n2\\n); \\n\\n} \\n\\nreturn\\nroot; \\n\\n} \\n\\n\\n\\npublic\\nvoid\\ninOrder(Node root) \\n\\n{ \\n\\nif\\n(root != \\nnull\\) { \\n\\ninOrder(root.left); \\n\\nSystem.out.print(root.data + \\n\" \"\\); \\n\\ninOrder(root.right); \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nTree t2 = \\nnew\\nTree(); \\n\\nint\\narr[] = { \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n6\\n, \\n6\\n, \\n6\\n, \\n6\\n}; \\n\\nt2.root = t2.insertLevelOrder(arr, t2.root, \\n0\\); \\n\\nt2.inOrder(t2.root); \\n\\n} \\n}', 'complexity': '1', 'index': 200}", "src": "public\nclass\nTree { \n\nNode root; \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n\n} \n\n\n\n\npublic\nNode insertLevelOrder(\nint\n[] arr, Node root, \n\nint\ni) \n\n{ \n\n\n\nif\n(i < arr.length) { \n\nNode temp = \nnew\nNode(arr[i]); \n\nroot = temp; \n\n\n\n\nroot.left = insertLevelOrder(arr, root.left, \n\n2\n* i + \n1\n); \n\n\n\n\nroot.right = insertLevelOrder(arr, root.right, \n\n2\n* i + \n2\n); \n\n} \n\nreturn\nroot; \n\n} \n\n\n\n\npublic\nvoid\ninOrder(Node root) \n\n{ \n\nif\n(root != \nnull\n) { \n\ninOrder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninOrder(root.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nTree t2 = \nnew\nTree(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n6\n, \n6\n, \n6\n}; \n\nt2.root = t2.insertLevelOrder(arr, t2.root, \n0\n); \n\nt2.inOrder(t2.root); \n\n} \n}", "index": 200, "complexity": "1"}
{"back-translation": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = len(arr); \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nprint(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nprint(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 201, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass Index:\n    def __init__(self):\n        self.index = 0\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n        self.myindex = Index()\n\n    def constructTreeUtil(self, pre, preLN, index_ptr, n, temp):\n        index = index_ptr.index\n        if index == n:\n            return None\n        temp = Node(pre[index])\n        index_ptr.index += 1\n        if preLN[index] == 'N':\n            temp.left = self.constructTreeUtil(pre, preLN, index_ptr, n, temp.left)\n            temp.right = self.constructTreeUtil(pre, preLN, index_ptr, n, temp.right)\n\n        return temp\n\n    def constructTree(self, pre, preLN, n, node):\n        index = 0\n        return self.constructTreeUtil(pre, preLN, self.myindex, n, node)\n\n    def printInorder(self, node):\n        if node is None:\n            return\n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\n\nif __name__ == '__main__':\n    tree = BinaryTree()\n    pre = [10, 30, 20, 5, 15]\n    preLN = ['N', 'N', 'L', 'L', 'L']\n    n = len(pre)\n    mynode = tree.constructTree(pre, preLN, n, tree.root)\n    print('Following is Inorder Traversal of the Constructed Binary Tree:', end=' ')\n    tree.printInorder(mynode)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nIndex \n{ \n\nint\nindex = \n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nIndex myindex = \nnew\nIndex(); \n\n\n\n\nNode constructTreeUtil(\nint\npre[], \nchar\npreLN[], Index index_ptr, \n\nint\nn, Node temp) \n\n{ \n\n\n\nint\nindex = index_ptr.index; \n\n\n\n\nif\n(index == n) \n\nreturn\nnull\n; \n\n\n\n\n\n\ntemp = \nnew\nNode(pre[index]); \n\n(index_ptr.index)++; \n\n\n\n\n\n\nif\n(preLN[index] == \n'N'\n) \n\n{ \n\ntemp.left = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.left); \n\ntemp.right = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.right); \n\n} \n\n\nreturn\ntemp; \n\n} \n\n\n\n\nNode constructTree(\nint\npre[], \nchar\npreLN[], \nint\nn, Node node) \n\n{ \n\n\n\n\n\nint\nindex = \n0\n; \n\n\nreturn\nconstructTreeUtil(pre, preLN, myindex, n, node); \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\npre[] = \nnew\nint\n[]{\n10\n, \n30\n, \n20\n, \n5\n, \n15\n}; \n\nchar\npreLN[] = \nnew\nchar\n[]{\n'N'\n, \n'N'\n, \n'L'\n, \n'L'\n, \n'L'\n}; \n\nint\nn = pre.length; \n\n\n\n\nNode mynode = tree.constructTree(pre, preLN, n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Following is Inorder Traversal of the\"\n\n+ \n\"Constructed Binary Tree: \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 202, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nBinaryTreeToDLL \\n{ \\n\\nstatic\\nclass\\nnode \\n\\n{ \\n\\nint\\ndata; \\n\\nnode left, right; \\n\\n\\npublic\\nnode(\\nint\\ndata) \\n\\n{ \\n\\nthis\\n.data = data; \\n\\n} \\n\\n} \\n\\n\\nstatic\\nnode prev; \\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\nfixPrevptr(node root) \\n\\n{ \\n\\nif\\n(root == \\nnull\\n) \\n\\nreturn\\n; \\n\\n\\nfixPrevptr(root.left); \\n\\nroot.left = prev; \\n\\nprev = root; \\n\\nfixPrevptr(root.right); \\n\\n\\n} \\n\\n\\n\\n\\nstatic\\nnode fixNextptr(node root) \\n\\n{ \\n\\n\\n\\n\\nwhile\\n(root.right != \\nnull\\n) \\n\\nroot = root.right; \\n\\n\\n\\n\\n\\n\\nwhile\\n(root != \\nnull\\n&& root.left != \\nnull\\n) \\n\\n{ \\n\\nnode left = root.left; \\n\\nleft.right = root; \\n\\nroot = root.left; \\n\\n} \\n\\n\\n\\nreturn\\nroot; \\n\\n} \\n\\n\\nstatic\\nnode BTTtoDLL(node root) \\n\\n{ \\n\\nprev = \\nnull\\n; \\n\\n\\n\\nfixPrevptr(root); \\n\\n\\n\\nreturn\\nfixNextptr(root); \\n\\n} \\n\\n\\n\\nstatic\\nvoid\\nprintlist(node root) \\n\\n{ \\n\\nwhile\\n(root != \\nnull\\n) \\n\\n{ \\n\\nSystem.out.print(root.data + \\n\" \"\\n); \\n\\nroot = root.right; \\n\\n} \\n\\n} \\n\\n\\n\\nstatic\\nvoid\\ninorder(node root) \\n\\n{ \\n\\nif\\n(root == \\nnull\\n) \\n\\nreturn\\n; \\n\\ninorder(root.left); \\n\\nSystem.out.print(root.data + \\n\" \"\\n); \\n\\ninorder(root.right); \\n\\n} \\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\n\\n\\nnode root = \\nnew\\nnode(\\n10\\n); \\n\\nroot.left = \\nnew\\nnode(\\n12\\n); \\n\\nroot.right = \\nnew\\nnode(\\n15\\n); \\n\\nroot.left.left = \\nnew\\nnode(\\n25\\n); \\n\\nroot.left.right = \\nnew\\nnode(\\n30\\n); \\n\\nroot.right.left = \\nnew\\nnode(\\n36\\n); \\n\\n\\nSystem.out.println(\\n\"Inorder Tree Traversal\"\\n); \\n\\ninorder(root); \\n\\n\\nnode head = BTTtoDLL(root); \\n\\n\\nSystem.out.println(\\n\"\\nDLL Traversal\"\\n); \\n\\nprintlist(head); \\n\\n} \\n}', 'complexity': '1', 'index': 203}", "src": "public\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n\n\n\n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n\n\n\n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n\n\n\n\n\n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n\n\nfixPrevptr(root); \n\n\n\n\nreturn\nfixNextptr(root); \n\n} \n\n\n\n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n}", "index": 203, "complexity": "1"}
{"back-translation": "{'src' : 'class\nNode \n{\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n}\n} \n\nclass\nBinaryTree \n{\nNode root; \n\n\n\n\nNode head;\n\n\n\n\n\n\n\n\nstatic\nNode prev = \nnull\n; \n\n\n\n\n\n\n\n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{\n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n\n\nif\n(prev == \nnull\n) \n\nhead = root;\nelse\n\n{\n\nroot.left = prev;\n\nprev.right = root;\n\n}\n\nprev = root;\n\n\n\n\nBinaryTree2DoubleLinkedList(root.right);\n\n}\n\n\n\n\nvoid\nprintList(Node node) \n\n{\n\nwhile\n(node != \nnull\n) \n\n{\n\nSystem.out.print(node.data + \n\" \"\n);\n\nnode = node.right;\n\n}\n\n}\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{\n\n\n\nBinaryTree tree = \nnew\nBinaryTree();\n\ntree.root = \nnew\nNode(\n10\n);\n\ntree.root.left = \nnew\nNode(\n12\n);\n\ntree.root.right = \nnew\nNode(\n15\n);\n\ntree.root.left.left = \nnew\nNode(\n25\n);\n\ntree.root.left.right = \nnew\nNode(\n30\n);\n\ntree.root.right.left = \nnew\nNode(\n36\n);\n\n\n\n\ntree.BinaryTree2DoubleLinkedList(tree.root);\n\n\n\n\ntree.printList(tree.head);\n\n\n}\n}', 'complexity': '1', 'index': 204}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode head; \n\n\n\n\n\n\n\n\nstatic\nNode prev = \nnull\n; \n\n\n\n\n\n\n\n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n\n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n\n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n\n\ntree.printList(tree.head); \n\n\n} \n}", "index": 204, "complexity": "1"}
{"back-translation": "class\nNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass\nBinaryTree:\n    def __init__(self):\n        self.root = None\n        self.head = None\n\n    def BToDLL(self, root):\n        if root == None:\n            return\n        self.BToDLL(root.right)\n        root.right = self.head\n        if self.head != None:\n            self.head.left = root\n        self.head = root\n        self.BToDLL(root.left)\n\n    def printList(self, head):\n        print(\"Extracted Double Linked List is : \")\n        while head != None:\n            print(head.data, end=\" \")\n            head = head.right\n\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(5)\n    tree.root.left = Node(3)\n    tree.root.right = Node(6)\n    tree.root.left.right = Node(4)\n    tree.root.left.left = Node(1)\n    tree.root.right.right = Node(8)\n    tree.root.left.left.right = Node(2)\n    tree.root.left.left.left = Node(0)\n    tree.root.right.right.left = Node(7)\n    tree.root.right.right.right = Node(9)\n\n    tree.BToDLL(tree.root)\n    tree.printList(tree.head)\n\nmain([])", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\n\n\n\n\nNode head; \n\n\n\n\n\n\nvoid\nBToDLL(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBToDLL(root.right); \n\n\n\n\nroot.right = head; \n\n\n\n\nif\n(head != \nnull\n) \n\n(head).left = root; \n\n\n\n\nhead = root; \n\n\n\n\nBToDLL(root.left); \n\n} \n\n\n\n\nvoid\nprintList(Node head) \n\n{ \n\nSystem.out.println(\n\"Extracted Double Linked List is : \"\n); \n\nwhile\n(head != \nnull\n) \n\n{ \n\nSystem.out.print(head.data + \n\" \"\n); \n\nhead = head.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n3\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.right = \nnew\nNode(\n4\n); \n\ntree.root.left.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left.left = \nnew\nNode(\n0\n); \n\ntree.root.right.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right.right = \nnew\nNode(\n9\n); \n\n\ntree.BToDLL(tree.root); \n\ntree.printList(tree.head); \n\n} \n}", "index": 205, "complexity": "1"}
{"back-translation": "class GFG { static class node { int key; node left, right; node(int key) { this.key = key; this.left = null; this.right = null; } } static void convert(node root) { if (root == null) return; convert(root.left); convert(root.right); if (root.left == null) root.left = root.right; else root.left.right = root.right; root.right = null; } static void downRightTraversal(node root) { if (root != null) { System.out.print(root.key + \" \"); downRightTraversal(root.right); downRightTraversal(root.left); } } static node newNode(int key) { node temp = new node(0); temp.key = key; temp.left = null; temp.right = null; return temp; } public static void main(String[] args) { node root = new node(1); root.left = newNode(2); root.right = newNode(3); root.right.left = newNode(4); root.right.right = newNode(5); root.right.left.left = newNode(6); root.right.right.left = newNode(7); root.right.right.right = newNode(8); convert(root); System.out.println(\"Traversal of the tree \" + \"converted to down-right form\"); downRightTraversal(root); } }", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nnode \n{ \n\nint\nkey; \n\nnode left, right; \n\nnode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n} \n\n\n\n\nstatic\nvoid\nconvert(node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nconvert(root.left); \n\nconvert(root.right); \n\n\n\n\n\n\nif\n(root.left == \nnull\n) \n\nroot.left = root.right; \n\n\n\n\n\n\nelse\n\nroot.left.right = root.right; \n\n\n\n\nroot.right = \nnull\n; \n} \n\n\n\nstatic\nvoid\ndownRightTraversal(node root) \n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.key + \n\" \"\n); \n\ndownRightTraversal(root.right); \n\ndownRightTraversal(root.left); \n\n} \n} \n\n\n\nstatic\nnode newNode(\nint\nkey) \n{ \n\nnode temp = \nnew\nnode(\n0\n); \n\ntemp.key = key; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\n\nnode root = \nnew\nnode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\nroot.right.left.left = newNode(\n6\n); \n\nroot.right.right.left = newNode(\n7\n); \n\nroot.right.right.right = newNode(\n8\n); \n\n\nconvert(root); \n\n\nSystem.out.println(\n\"Traversal of the tree \"\n+ \n\n\"converted to down-right form\"\n); \n\ndownRightTraversal(root); \n} \n}", "index": 206, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    class Node:\n        def __init__(self, item):\n            self.data = item\n            self.left = self.right = None\n\n    def toSumTree(self, node):\n        if node is None:\n            return 0\n        old_val = node.data\n        node.data = self.toSumTree(node.left) + self.toSumTree(node.right)\n        return node.data + old_val\n\n    def printInorder(self, node):\n        if node is None:\n            return\n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\nif __name__ == '__main__':\n    tree = BinaryTree()\n    tree.root = BinaryTree.Node(10)\n    tree.root.left = BinaryTree.Node(-2)\n    tree.root.right = BinaryTree.Node(6)\n    tree.root.left.left = BinaryTree.Node(8)\n    tree.root.left.right = BinaryTree.Node(-4)\n    tree.root.right.left = BinaryTree.Node(7)\n    tree.root.right.right = BinaryTree.Node(5)\n    tree.toSumTree(tree.root)\n    print('Inorder Traversal of the resultant tree is:')\n    tree.printInorder(tree.root)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\n\n\nint\ntoSumTree(Node node) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\nint\nold_val = node.data; \n\n\n\n\n\n\nnode.data = toSumTree(node.left) + toSumTree(node.right); \n\n\n\n\n\n\nreturn\nnode.data + old_val; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(-\n2\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.right = \nnew\nNode(-\n4\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n5\n); \n\n\ntree.toSumTree(tree.root); \n\n\n\n\n\n\nSystem.out.println(\n\"Inorder Traversal of the resultant tree is:\"\n); \n\ntree.printInorder(tree.root); \n\n} \n}", "index": 207, "complexity": "1"}
{"back-translation": "class GfG { static class node { int data; node left, right; } static int updatetree(node root) { if (root == null) return 0; if (root.left == null && root.right == null) return root.data; int leftsum = updatetree(root.left); int rightsum = updatetree(root.right); root.data += leftsum; return root.data + rightsum; } static void inorder(node node) { if (node == null) return; inorder(node.left); System.out.print(node.data + \" \"); inorder(node.right); } static node newNode(int data) { node node = new node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.right.right = newNode(6); updatetree(root); System.out.println(\"Inorder traversal of the modified tree is\"); inorder(root); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nnode \n{ \n\nint\ndata; \n\nnode left, right; \n} \n\n\n\n\nstatic\nint\nupdatetree(node root) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.data; \n\n\n\n\nint\nleftsum = updatetree(root.left); \n\nint\nrightsum = updatetree(root.right); \n\n\n\n\nroot.data += leftsum; \n\n\n\n\nreturn\nroot.data + rightsum; \n} \n\n\nstatic\nvoid\ninorder(node node) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\ninorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorder(node.right); \n} \n\n\nstatic\nnode newNode(\nint\ndata) \n{ \n\nnode node = \nnew\nnode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nnode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\nupdatetree(root); \n\n\n\nSystem.out.println(\n\"Inorder traversal of the modified tree is\"\n); \n\ninorder(root); \n} \n}", "index": 208, "complexity": "1"}
{"back-translation": "{'src': 'class\\nGFG \\n{ \\n\\nstatic\\nint\\nN = \\n12\\n,ans; \\n\\n\\nstatic\\nVector<Vector<Integer>> tree=\\nnew\\nVector<Vector<Integer>>(); \\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nint\\ndfs( \\nint\\nvisit[], \\nint\\nnode) \\n\\n{ \\n\\nint\\nnum = \\n0\\n, temp = \\n0\\n; \\n\\n\\n\\n\\nvisit[node] = \\n1\\n; \\n\\n\\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < tree.get(node).size(); i++) \\n\\n{ \\n\\n\\nif\\n(visit[tree.get(node).get(i)] == \\n0\\n) \\n\\n{ \\n\\n\\n\\n\\ntemp = dfs( visit, tree.get(node).get(i)); \\n\\n\\n\\n\\n\\n\\nif\\n(temp%\\n2\\n!=\\n0\\n) \\n\\nnum += temp; \\n\\nelse\\n\\nans++; \\n\\n} \\n\\n} \\n\\n\\nreturn\\nnum+\\n1\\n; \\n\\n} \\n\\n\\n\\n\\nstatic\\nint\\nminEdge( \\nint\\nn) \\n\\n{ \\n\\nint\\nvisit[] = \\nnew\\nint\\n[n+\\n2\\n]; \\n\\nans = \\n0\\n; \\n\\n\\ndfs( visit, \\n1\\n); \\n\\n\\nreturn\\nans; \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\nn = \\n10\\n; \\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n + \\n2\\ni++) \\n\\ntree.add(\\nnew\\nVector<Integer>()); \\n\\n\\ntree.get(\\n1\\n).add(\\n3\\n); \\n\\ntree.get(\\n3\\n).add(\\n1\\n); \\n\\n\\ntree.get(\\n1\\n).add(\\n6\\n); \\n\\ntree.get(\\n6\\n).add(\\n1\\n); \\n\\n\\ntree.get(\\n1\\n).add(\\n2\\n); \\n\\ntree.get(\\n2\\n).add(\\n1\\n); \\n\\n\\ntree.get(\\n3\\n).add(\\n4\\n); \\n\\ntree.get(\\n4\\n).add(\\n3\\n); \\n\\n\\ntree.get(\\n6\\n).add(\\n8\\n); \\n\\ntree.get(\\n8\\n).add(\\n6\\n); \\n\\n\\ntree.get(\\n2\\n).add(\\n7\\n); \\n\\ntree.get(\\n7\\n).add(\\n2\\n); \\n\\n\\ntree.get(\\n2\\n).add(\\n5\\n); \\n\\ntree.get(\\n5\\n).add(\\n2\\n); \\n\\n\\ntree.get(\\n4\\n).add(\\n9\\n); \\n\\ntree.get(\\n9\\n).add(\\n4\\n); \\n\\n\\ntree.get(\\n4\\n).add(\\n10\\n); \\n\\ntree.get(\\n10\\n).add(\\n4\\n); \\n\\n\\nSystem.out.println( minEdge( n)); \\n\\n} \\n}', 'complexity': '1', 'index': 209}", "src": "class\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n\n\n\n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n\n\nvisit[node] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n\n\n\n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n\n\n\n\n\n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n}", "index": 209, "complexity": "1"}
{"back-translation": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n\n    def convertExpression(self, expression, i):\n        if i >= len(expression):\n            return None\n        root = Node(expression[i])\n        i += 1\n        if i < len(expression) and expression[i] == '?':\n            root.left = self.convertExpression(expression, i+1)\n        elif i < len(expression):\n            root.right = self.convertExpression(expression, i+1)\n        return root\n\n    def printTree(self, root):\n        if root is None:\n            return\n        print(root.data, end=' ')\n        self.printTree(root.left)\n        self.printTree(root.right)\n\n\nif __name__ == '__main__':\n    exp = \"a?b?c:d:e\"\n    tree = BinaryTree()\n    expression = list(exp)\n    root = tree.convertExpression(expression, 0)\n    tree.printTree(root)", "src": "class\nNode \n{ \n\nchar\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTree \n{ \n\n\n\n\n\nNode convertExpression(\nchar\n[] expression, \nint\ni) \n\n{ \n\n\n\nif\n(i >= expression.length) \n\nreturn\nnull\n; \n\n\n\n\n\n\nNode root = \nnew\nNode(expression[i]); \n\n\n\n\n++i; \n\n\n\n\n\n\n\n\nif\n(i < expression.length && expression[i]==\n'?'\n) \n\nroot.left = convertExpression(expression, i+\n1\n); \n\n\n\n\n\n\nelse\nif\n(i < expression.length) \n\nroot.right = convertExpression(expression, i+\n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\npublic\nvoid\nprintTree( Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nSystem.out.print(root.data +\n\" \"\n); \n\nprintTree(root.left); \n\nprintTree(root.right); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString exp = \n\"a?b?c:d:e\"\n; \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\n[] expression=exp.toCharArray(); \n\nNode root = tree.convertExpression(expression, \n0\n); \n\ntree.printTree(root) ; \n\n} \n}", "index": 210, "complexity": "1"}
{"back-translation": "class FlipTree:\n\n    @staticmethod\n    def flipBinaryTree(root):\n        if root is None:\n            return root\n        if root.left is None and root.right is None:\n            return root\n\n        flippedRoot = FlipTree.flipBinaryTree(root.left)\n        root.left.left = root.right\n        root.left.right = root\n        root.left = root.right = None\n\n        return flippedRoot\n\n    @staticmethod\n    def printLevelOrder(root):\n        if root is None:\n            return\n\n        q = []\n        q.append(root)\n\n        while True:\n            nodeCount = len(q)\n            if nodeCount == 0:\n                break\n\n            while nodeCount > 0:\n                node = q.pop(0)\n                print(node.data, end=' ')\n\n                if node.left is not None:\n                    q.append(node.left)\n                if node.right is not None:\n                    q.append(node.right)\n\n                nodeCount -= 1\n\n            print()\n\n    @staticmethod\n    def main(args):\n        root = Node(1)\n        root.left = Node(2)\n        root.right = Node(1)\n        root.right.left = Node(4)\n        root.right.right = Node(5)\n\n        print('Level order traversal of given tree')\n        FlipTree.printLevelOrder(root)\n\n        root = FlipTree.flipBinaryTree(root)\n\n        print('Level order traversal of flipped tree')\n        FlipTree.printLevelOrder(root)\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None", "src": "public\nclass\nFlipTree { \n\n\n\n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n\n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n\n\n\n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n\n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 211, "complexity": "1"}
{"back-translation": "class GFG:\n    class Node:\n        def __init__(self):\n            self.data = None\n            self.left = None\n            self.right = None\n\n        @staticmethod\n        def newNode(data):\n            temp = GFG.Node()\n            temp.data = data\n            temp.left = temp.right = None\n            return temp\n\n        @staticmethod\n        def flipBinaryTree(root):\n            curr = root\n            next = None\n            temp = None\n            prev = None\n            while curr is not None:\n                next = curr.left\n                curr.left = temp\n                temp = curr.right\n                curr.right = prev\n                prev = curr\n                curr = next\n            return prev\n\n        @staticmethod\n        def printLevelOrder(root):\n            if root is None:\n                return\n            q = []\n            q.append(root)\n\n            while True:\n                nodeCount = len(q)\n                if nodeCount == 0:\n                    break\n                while nodeCount > 0:\n                    node = q[0]\n                    print(node.data, end=' ')\n                    q.pop(0)\n                    if node.left is not None:\n                        q.append(node.left)\n                    if node.right is not None:\n                        q.append(node.right)\n                    nodeCount -= 1\n                print()\n\n        @staticmethod\n        def main(args):\n            root = GFG.Node.newNode(1)\n            root.left = GFG.Node.newNode(2)\n            root.right = GFG.Node.newNode(3)\n            root.right.left = GFG.Node.newNode(4)\n            root.right.right = GFG.Node.newNode(5)\n\n            print('Level order traversal of given tree\\n')\n            GFG.printLevelOrder(root)\n\n            root = GFG.flipBinaryTree(root)\n\n            print('\\nLevel order traversal of the flipped tree\\n')\n            GFG.printLevelOrder(root)\n\n\nGFG.main([])", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode flipBinaryTree(Node root) \n{ \n\n\n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n\n\n\n\n\n\n\n\n\n\n\ncurr.left = temp; \n\n\n\n\ntemp = curr.right; \n\n\n\n\n\n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n\n\n\nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n\n\n\n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n}", "index": 212, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, d):\n        self.data = d\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def isSumProperty(self, node):\n        left_data = 0\n        right_data = 0\n        if node is None or (node.left is None and node.right is None):\n            return 1\n        else:\n            if node.left is not None:\n                left_data = node.left.data\n            if node.right is not None:\n                right_data = node.right.data\n            if (node.data == left_data + right_data) and (self.isSumProperty(node.left) != 0) and (self.isSumProperty(node.right) != 0):\n                return 1\n            else:\n                return 0\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(10)\n    tree.root.left = Node(8)\n    tree.root.right = Node(2)\n    tree.root.left.left = Node(3)\n    tree.root.left.right = Node(5)\n    tree.root.right.right = Node(2)\n    if tree.isSumProperty(tree.root) != 0:\n        print(\"The given tree satisfies children sum property\")\n    else:\n        print(\"The given tree does not satisfy children sum property\")\n\nmain([])", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nisSumProperty(Node node) \n\n{ \n\n\n\n\nint\nleft_data = \n0\n, right_data = \n0\n; \n\n\n\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\nelse\n\n{ \n\n\n\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n\n\nif\n((node.data == left_data + right_data) \n\n&& (isSumProperty(node.left)!=\n0\n) \n\n&& isSumProperty(node.right)!=\n0\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n2\n); \n\nif\n(tree.isSumProperty(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree satisfies children\"\n\n+ \n\" sum property\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree does not satisfy children\"\n\n+ \n\" sum property\"\n); \n\n} \n}", "index": 213, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = self.right = self.nextRight = None\n\nclass BinaryTree:\n    class Node:\n        def __init__(self, item):\n            self.data = item\n            self.left = self.right = self.nextRight = None\n\ndef isLeaf(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    return 0\n\ndef isSumTree(node):\n    def isLeaf(node):\n        if node is None:\n            return 1\n        if isLeaf(node.left) and isLeaf(node.right):\n            return 1\n        return 0\n    if node is None or isLeaf(node) == 1:\n        return 1\n    if isSumTree(node.left) and isSumTree(node.right):\n        if node.left is None:\n            ls = 0\n        else:\n            if isLeaf(node.left):\n                ls = node.left.data\n            else:\n                ls = 2 * (node.left.data)\n        if node.right is None:\n            rs = 0\n        else:\n            if isLeaf(node.right):\n                rs = node.right.data\n            else:\n                rs = 2 * (node.right.data)\n        if node.data == rs + ls:\n            return 1\n        else:\n            return 0\n    return 0\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(26)\n    tree.root.left = Node(10)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(6)\n    tree.root.right.right = Node(3)\n    if isSumTree(tree.root) == 1:\n        print('The given tree is a sum tree')\n    else:\n        print('The given tree is not a sum tree')\n\nmain([])", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nisLeaf(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\n1\n; \n\nreturn\n0\n; \n\n} \n\n\n\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls; \n\n\nint\nrs; \n\n\n\n\n\nif\n(node == \nnull\n|| isLeaf(node) == \n1\n) \n\nreturn\n1\n; \n\n\nif\n(isSumTree(node.left) != \n0\n&& isSumTree(node.right) != \n0\n) \n\n{ \n\n\n\nif\n(node.left == \nnull\n) \n\nls = \n0\n; \n\nelse\nif\n(isLeaf(node.left) != \n0\n) \n\nls = node.left.data; \n\nelse\n\nls = \n2\n* (node.left.data); \n\n\n\n\nif\n(node.right == \nnull\n) \n\nrs = \n0\n; \n\nelse\nif\n(isLeaf(node.right) != \n0\n) \n\nrs = node.right.data; \n\nelse\n\nrs = \n2\n* (node.right.data); \n\n\n\n\nif\n((node.data == rs + ls)) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n}", "index": 214, "complexity": "1"}
{"back-translation": "{'src': 'class Node {  int data;  Node left, right;  Node(int item)  {  data = item;  left = right = None;  } }  class BinaryTree {  Node root;      def isSibling(node, a, b):   if node is None:  return False;   return ((node.left == a and node.right == b) or  (node.left == b and node.right == a) or  isSibling(node.left, a, b) or  isSibling(node.right, a, b));   def level(node, ptr, lev):   if node is None:  return 0;   if node == ptr:  return lev;      l = level(node.left, ptr, lev + 1);   if l != 0:  return l;      return level(node.right, ptr, lev + 1);      def isCousin(node, a, b):       return ((level(node, a, 1) == level(node, b, 1)) and      (not isSibling(node, a, b)));       def main(args):   tree = BinaryTree();   tree.root = Node(1);   tree.root.left = Node(2);   tree.root.right = Node(3);   tree.root.left.left = Node(4);   tree.root.left.right = Node(5);   tree.root.left.right.right = Node(15);   tree.root.right.left = Node(6);   tree.root.right.right = Node(7);   tree.root.right.left.right = Node(8);      Node1, Node2;   Node1 = tree.root.left.left;   Node2 = tree.root.right.right;   if tree.isCousin(tree.root, Node1, Node2):   print(\"Yes\");   else  print(\"No\");  }', 'complexity': '1', 'index': 215}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\n\n\nboolean\nisSibling(Node node, Node a, Node b) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\nreturn\n((node.left == a && node.right == b) || \n\n(node.left == b && node.right == a) || \n\nisSibling(node.left, a, b) || \n\nisSibling(node.right, a, b)); \n\n} \n\n\n\n\n\n\nint\nlevel(Node node, Node ptr, \nint\nlev) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nif\n(node == ptr) \n\nreturn\nlev; \n\n\n\n\nint\nl = level(node.left, ptr, lev + \n1\n); \n\nif\n(l != \n0\n) \n\nreturn\nl; \n\n\n\n\nreturn\nlevel(node.right, ptr, lev + \n1\n); \n\n} \n\n\n\n\nboolean\nisCousin(Node node, Node a, Node b) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nreturn\n((level(node, a, \n1\n) == level(node, b, \n1\n)) && \n\n(!isSibling(node, a, b))); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.left.right.right = \nnew\nNode(\n15\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\ntree.root.right.left.right = \nnew\nNode(\n8\n); \n\n\nNode Node1, Node2; \n\nNode1 = tree.root.left.left; \n\nNode2 = tree.root.right.right; \n\nif\n(tree.isCousin(tree.root, Node1, Node2)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 215, "complexity": "1"}
{"back-translation": "class\nNode {\n    int\ndata;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = None;\n    }\n}\n\nclass Leaf {\n    int leaflevel = 0;\n}\n\nclass BinaryTree {\n    Node root;\n    Leaf mylevel = Leaf();\n\n    def checkUtil(self, node, level, leafLevel):\n        if node is None:\n            return True\n        if node.left is None and node.right is None:\n            if leafLevel.leaflevel == 0:\n                leafLevel.leaflevel = level;\n                return True\n            return level == leafLevel.leaflevel\n        return self.checkUtil(node.left, level + 1, leafLevel) and self.checkUtil(node.right, level + 1, leafLevel)\n\n    def check(self, node):\n        level = 0\n        return self.checkUtil(node, level, self.mylevel)\n\n\ndef main(args=[]):\n    tree = BinaryTree()\n    tree.root = Node(12)\n    tree.root.left = Node(5)\n    tree.root.left.left = Node(3)\n    tree.root.left.right = Node(9)\n    tree.root.left.left.left = Node(1)\n    tree.root.left.right.left = Node(1)\n\n\n    if tree.check(tree.root):\n        print(\"Leaves are at same level\")\n    else:\n        print(\"Leaves are not at the same level\")\n\nmain()", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nLeaf \n{ \n\nint\nleaflevel=\n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nLeaf mylevel = \nnew\nLeaf(); \n\n\n\n\nboolean\ncheckUtil(Node node, \nint\nlevel, Leaf leafLevel) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\n{ \n\n\n\nif\n(leafLevel.leaflevel == \n0\n) \n\n{ \n\n\n\nleafLevel.leaflevel = level; \n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nreturn\n(level == leafLevel.leaflevel); \n\n} \n\n\n\n\n\n\nreturn\ncheckUtil(node.left, level + \n1\n, leafLevel) \n\n&& checkUtil(node.right, level + \n1\n, leafLevel); \n\n} \n\n\n\n\nboolean\ncheck(Node node) \n\n{ \n\nint\nlevel = \n0\n; \n\nreturn\ncheckUtil(node, level, mylevel); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n12\n); \n\ntree.root.left = \nnew\nNode(\n5\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.left.left = \nnew\nNode(\n1\n); \n\ntree.root.left.right.left = \nnew\nNode(\n1\n); \n\nif\n(tree.check(tree.root)) \n\nSystem.out.println(\n\"Leaves are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaves are not at same level\"\n); \n\n} \n}", "index": 216, "complexity": "1"}
{"back-translation": "class Node:\n\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n\n\nclass GFG:\n\n    @staticmethod\n    def checkLevelLeafNode(root):\n        if root is None:\n            return True\n        q = []\n        q.append(root)\n        result = float('inf')\n        level = 0\n        while q:\n            size = len(q)\n            level += 1\n            while size > 0:\n                temp = q.pop(0)\n                if temp.left is not None:\n                    q.append(temp.left)\n                    if temp.left.left is None and temp.left.right is None:\n                        if result == float('inf'):\n                            result = level\n                        elif result != level:\n                            return False\n                if temp.right is not None:\n                    q.append(temp.right)\n                    if temp.right.left is None and temp.right.right is None:\n                        if result == float('inf'):\n                            result = level\n                        elif result != level:\n                            return False\n                size -= 1\n        return True\n\n    def main(args):\n        root = Node(1)\n        root.left = Node(2)\n        root.right = Node(3)\n        root.left.right = Node(4)\n        root.right.left = Node(5)\n        root.right.right = Node(6)\n        result = GFG.checkLevelLeafNode(root)\n        if result is True:\n            print('All leaf nodes are at same level')\n        else:\n            print('Leaf nodes not at same level')\n", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n\n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n\n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n\n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n\n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n\n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n}", "index": 217, "complexity": "1"}
{"back-translation": "class\nNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass Res:\n    def __init__(self):\n        self.res = False\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def count(self, node):\n        if node is None:\n            return 0\n        return self.count(node.left) + self.count(node.right) + 1\n\n    def checkRec(self, root, n, res):\n        if root is None:\n            return 0\n        c = self.checkRec(root.left, n, res) + 1 + self.checkRec(root.right, n, res)\n        if c == n - c:\n            res.res = True\n        return c\n\n    def check(self, root):\n        n = self.count(root)\n        res = Res()\n        self.checkRec(root, n, res)\n        return res.res\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(5)\n    tree.root.left = Node(1)\n    tree.root.right = Node(6)\n    tree.root.left.left = Node(3)\n    tree.root.right.left = Node(7)\n    tree.root.right.right = Node(4)\n    if tree.check(tree.root) == True:\n        print('YES')\n    else:\n        print('NO')\n\nmain([])", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nRes \n{ \n\nboolean\nres = \nfalse\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nint\ncheckRec(Node root, \nint\nn, Res res) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\nint\nc = checkRec(root.left, n, res) + \n1\n\n+ checkRec(root.right, n, res); \n\n\n\n\n\n\nif\n(c == n - c) \n\nres.res = \ntrue\n; \n\n\n\n\nreturn\nc; \n\n} \n\n\n\n\nboolean\ncheck(Node root) \n\n{ \n\n\n\nint\nn = count(root); \n\n\n\n\nRes res = \nnew\nRes(); \n\ncheckRec(root, n, res); \n\n\nreturn\nres.res; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root) == \ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n}", "index": 218, "complexity": "1"}
{"back-translation": "class GfG {\nstatic class Node {\nint key;\nNode left, right;\n}\nstatic int findADepth(Node node) {\nint d = 0;\nwhile (node != null) {\nd++;\nnode = node.left;\n}\nreturn d;\n}\nstatic boolean isPerfectRec(Node root, int d, int level) {\nif (root == null) return true;\nif (root.left == null && root.right == null) return (d == level + 1);\nif (root.left == null || root.right == null) return false;\nreturn isPerfectRec(root.left, d, level + 1) && isPerfectRec(root.right, d, level + 1);\n}\nstatic boolean isPerfect(Node root) {\nint d = findADepth(root);\nreturn isPerfectRec(root, d, 0);\n}\nstatic Node newNode(int k) {\nNode node = new Node();\nnode.key = k;\nnode.right = null;\nnode.left = null;\nreturn node;\n}\npublic static void main(String args[]) {\nNode root = null;\nroot = newNode(10);\nroot.left = newNode(20);\nroot.right = newNode(30);\nroot.left.left = newNode(40);\nroot.left.right = newNode(50);\nroot.right.left = newNode(60);\nroot.right.right = newNode(70);\nif (isPerfect(root) == true) System.out.println(\"Yes\");\nelse System.out.println(\"No\");\n}\n}", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n\n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n\nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n}", "index": 219, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def isFullTree(self, node):\n        if node is None:\n            return True\n        if node.left is None and node.right is None:\n            return True\n        if node.left and node.right:\n            return self.isFullTree(node.left) and self.isFullTree(node.right)\n        return False\n\ndef main():\n    tree = BinaryTree()\n    tree.root = Node(10)\n    tree.root.left = Node(20)\n    tree.root.right = Node(30)\n    tree.root.left.right = Node(40)\n    tree.root.left.left = Node(50)\n    tree.root.right.left = Node(60)\n    tree.root.left.left.left = Node(80)\n    tree.root.right.right = Node(70)\n    tree.root.left.left.right = Node(90)\n    tree.root.left.right.left = Node(80)\n    tree.root.left.right.right = Node(90)\n    tree.root.right.left.left = Node(80)\n    tree.root.right.left.right = Node(90)\n    tree.root.right.right.left = Node(80)\n    tree.root.right.right.right = Node(90)\n\n    if tree.isFullTree(tree.root):\n        print(\"The binary tree is full\")\n    else:\n        print(\"The binary tree is not full\")\n\nif __name__ == '__main__':\n    main()", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nboolean\nisFullTree(Node node) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n((node.left!=\nnull\n) && (node.right!=\nnull\n)) \n\nreturn\n(isFullTree(node.left) && isFullTree(node.right)); \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n20\n); \n\ntree.root.right = \nnew\nNode(\n30\n); \n\ntree.root.left.right = \nnew\nNode(\n40\n); \n\ntree.root.left.left = \nnew\nNode(\n50\n); \n\ntree.root.right.left = \nnew\nNode(\n60\n); \n\ntree.root.left.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right = \nnew\nNode(\n70\n); \n\ntree.root.left.left.right = \nnew\nNode(\n90\n); \n\ntree.root.left.right.left = \nnew\nNode(\n80\n); \n\ntree.root.left.right.right = \nnew\nNode(\n90\n); \n\ntree.root.right.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.left.right = \nnew\nNode(\n90\n); \n\ntree.root.right.right.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right.right = \nnew\nNode(\n90\n); \n\n\nif\n(tree.isFullTree(tree.root)) \n\nSystem.out.print(\n\"The binary tree is full\"\n); \n\nelse\n\nSystem.out.print(\n\"The binary tree is not full\"\n); \n\n} \n}", "index": 220, "complexity": "1"}
{"back-translation": "class CompleteBTree:\n\n    class Node:\n        def __init__(self, d):\n            self.data = d\n            self.left = None\n            self.right = None\n\n    @staticmethod\n    def isCompleteBT(root):\n        if root is None:\n            return True\n\n        queue = []\n        flag = False\n        queue.append(root)\n\n        while queue:\n            temp_node = queue.pop(0)\n            if temp_node.left:\n                if flag:\n                    return False\n                queue.append(temp_node.left)\n            else:\n                flag = True\n\n            if temp_node.right:\n                if flag:\n                    return False\n                queue.append(temp_node.right)\n            else:\n                flag = True\n\n        return True\n\n    @staticmethod\n    def main(args):\n        root = CompleteBTree.Node(1)\n        root.left = CompleteBTree.Node(2)\n        root.right = CompleteBTree.Node(3)\n        root.left.left = CompleteBTree.Node(4)\n        root.left.right = CompleteBTree.Node(5)\n        root.right.right = CompleteBTree.Node(6)\n\n        if CompleteBTree.isCompleteBT(root):\n            print(\"Complete Binary Tree\")\n        else:\n            print(\"NOT Complete Binary Tree\")\n", "src": "public\nclass\nCompleteBTree \n{ \n\n\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n\n\n\n\nboolean\nflag = \nfalse\n; \n\n\n\n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.left); \n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n\n\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.right); \n\n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n} \n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n}", "index": 221, "complexity": "1"}
{"back-translation": "class Node {\n    \n    char data;\n    Node left, right;\n    \n    Node(char item) {\n        data = item;\n        left = right = None;\n    }\n}\n\nclass Passing {\n    \n    int i;\n    int m = 0;\n    int n = 0;\n}\n\nclass BinaryTree {\n    \n    static Node root;\n    Passing p = Passing();\n    \n    def strstr(haystack, needle):\n        \n        if haystack == None or needle == None:\n            return None\n        \n        hLength = len(haystack)\n        nLength = len(needle)\n        \n        if hLength < nLength:\n            return None\n        \n        if nLength == 0:\n            return haystack\n        \n        for i in range(hLength - nLength + 1):\n            if haystack[i] == needle[0]:\n                j = 0\n                for j in range(nLength):\n                    if haystack[i + j] != needle[j]:\n                        break\n                if j == nLength:\n                    return haystack[i:]\n        \n        return None\n    \n    def storeInorder(node, arr, i):\n        \n        if node == None:\n            arr[i.i] = '$'\n            i.i += 1\n            return\n        \n        storeInorder(node.left, arr, i)\n        arr[i.i] = node.data\n        i.i += 1\n        storeInorder(node.right, arr, i)\n    \n    def storePreOrder(node, arr, i):\n        \n        if node == None:\n            arr[i.i] = '$'\n            i.i += 1\n            return\n        \n        arr[i.i] = node.data\n        i.i += 1\n        storePreOrder(node.left, arr, i)\n        storePreOrder(node.right, arr, i)\n    \n    def isSubtree(T, S):\n        \n        if S == None:\n            return True\n        if T == None:\n            return False\n        \n        inT = [''] * 100\n        op1 = ''.join(inT)\n        inS = [''] * 100\n        op2 = ''.join(inS)\n        storeInorder(T, inT, p)\n        storeInorder(S, inS, p)\n        inT[p.m] = '\\0'\n        inS[p.m] = '\\0'\n        \n        if strstr(op1, op2) != None:\n            return False\n        \n        p.m = 0\n        p.n = 0\n        preT = [''] * 100\n        preS = [''] * 100\n        op3 = ''.join(preT)\n        op4 = ''.join(preS)\n        storePreOrder(T, preT, p)\n        storePreOrder(S, preS, p)\n        preT[p.m] = '\\0'\n        preS[p.n] = '\\0'\n        \n        return strstr(op3, op4) != None\n    \n    def main(args):\n        \n        tree = BinaryTree()\n        T = Node('a')\n        T.left = Node('b')\n        T.right = Node('d')\n        T.left.left = Node('c')\n        T.right.right = Node('e')\n        \n        S = Node('a')\n        S.left = Node('b')\n        S.right = Node('d')\n        S.left.left = Node('c')\n        \n        if tree.isSubtree(T, S):\n            print(\"Yes, S is a subtree of T\")\n        else:\n            print(\"No, S is not a subtree of T\")\n        \n    main([])", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nPassing { \n\n\nint\ni; \n\nint\nm = \n0\n; \n\nint\nn = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nPassing p = \nnew\nPassing(); \n\n\nString strstr(String haystack, String needle) \n\n{ \n\nif\n(haystack == \nnull\n|| needle == \nnull\n) { \n\nreturn\nnull\n; \n\n} \n\nint\nhLength = haystack.length(); \n\nint\nnLength = needle.length(); \n\nif\n(hLength < nLength) { \n\nreturn\nnull\n; \n\n} \n\nif\n(nLength == \n0\n) { \n\nreturn\nhaystack; \n\n} \n\nfor\n(\nint\ni = \n0\n; i <= hLength - nLength; i++) { \n\nif\n(haystack.charAt(i) == needle.charAt(\n0\n)) { \n\nint\nj = \n0\n; \n\nfor\n(; j < nLength; j++) { \n\nif\n(haystack.charAt(i + j) != needle.charAt(j)) { \n\nbreak\n; \n\n} \n\n} \n\nif\n(j == nLength) { \n\nreturn\nhaystack.substring(i); \n\n} \n\n} \n\n} \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nvoid\nstoreInorder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\nstoreInorder(node.left, arr, i); \n\narr[i.i++] = node.data; \n\nstoreInorder(node.right, arr, i); \n\n} \n\n\n\n\n\n\nvoid\nstorePreOrder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\narr[i.i++] = node.data; \n\nstorePreOrder(node.left, arr, i); \n\nstorePreOrder(node.right, arr, i); \n\n} \n\n\n\n\nboolean\nisSubtree(Node T, Node S) \n\n{ \n\n\n\nif\n(S == \nnull\n) { \n\nreturn\ntrue\n; \n\n} \n\nif\n(T == \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\nchar\ninT[] = \nnew\nchar\n[\n100\n]; \n\nString op1 = String.valueOf(inT); \n\nchar\ninS[] = \nnew\nchar\n[\n100\n]; \n\nString op2 = String.valueOf(inS); \n\nstoreInorder(T, inT, p); \n\nstoreInorder(S, inS, p); \n\ninT[p.m] = \n'\\0'\n; \n\ninS[p.m] = \n'\\0'\n; \n\n\n\n\nif\n(strstr(op1, op2) != \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\np.m = \n0\n; \n\np.n = \n0\n; \n\nchar\npreT[] = \nnew\nchar\n[\n100\n]; \n\nchar\npreS[] = \nnew\nchar\n[\n100\n]; \n\nString op3 = String.valueOf(preT); \n\nString op4 = String.valueOf(preS); \n\nstorePreOrder(T, preT, p); \n\nstorePreOrder(S, preS, p); \n\npreT[p.m] = \n'\\0'\n; \n\npreS[p.n] = \n'\\0'\n; \n\n\n\n\n\n\nreturn\n(strstr(op3, op4) != \nnull\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode T = \nnew\nNode(\n'a'\n); \n\nT.left = \nnew\nNode(\n'b'\n); \n\nT.right = \nnew\nNode(\n'd'\n); \n\nT.left.left = \nnew\nNode(\n'c'\n); \n\nT.right.right = \nnew\nNode(\n'e'\n); \n\n\nNode S = \nnew\nNode(\n'a'\n); \n\nS.left = \nnew\nNode(\n'b'\n); \n\nS.right = \nnew\nNode(\n'd'\n); \n\nS.left.left = \nnew\nNode(\n'c'\n); \n\n\nif\n(tree.isSubtree(T, S)) { \n\nSystem.out.println(\n\"Yes, S is a subtree of T\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"No, S is not a subtree of T\"\n); \n\n} \n\n} \n}", "index": 222, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def areMirror(self, a, b):\n        if a is None and b is None:\n            return True\n        if a is None or b is None:\n            return False\n        return a.data == b.data and self.areMirror(a.left, b.right) and self.areMirror(a.right, b.left)\n\n    def main(self):\n        tree = BinaryTree()\n        a = Node(1)\n        b = Node(1)\n        a.left = Node(2)\n        a.right = Node(3)\n        a.left.left = Node(4)\n        a.left.right = Node(5)\n        b.left = Node(3)\n        b.right = Node(2)\n        b.right.left = Node(5)\n        b.right.right = Node(4)\n\n        if tree.areMirror(a, b) is True:\n            print('Yes')\n        else:\n            print('No')", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode a, b; \n\n\n\n\nboolean\nareMirror(Node a, Node b) \n\n{ \n\n\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(a == \nnull\n|| b == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\na.data == b.data \n\n&& areMirror(a.left, b.right) \n\n&& areMirror(a.right, b.left); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode a = \nnew\nNode(\n1\n); \n\nNode b = \nnew\nNode(\n1\n); \n\na.left = \nnew\nNode(\n2\n); \n\na.right = \nnew\nNode(\n3\n); \n\na.left.left = \nnew\nNode(\n4\n); \n\na.left.right = \nnew\nNode(\n5\n); \n\n\nb.left = \nnew\nNode(\n3\n); \n\nb.right = \nnew\nNode(\n2\n); \n\nb.right.left = \nnew\nNode(\n5\n); \n\nb.right.right = \nnew\nNode(\n4\n); \n\n\nif\n(tree.areMirror(a, b) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n\n} \n}", "index": 223, "complexity": "1"}
{"back-translation": "ERROR", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n\n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n\n} \n\n\n\n\n\nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n\n\n\n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n\n\n\n\n\n\n\n\n\nint\ni; \n\n\n\n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n\n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n\n\n\n\n\n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n\n\n\n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n\n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n\n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n\n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n\n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n\n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n\n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n}", "index": 224, "complexity": "1"}
{"back-translation": "class GfG: def __init__(self): self.data = 0 self.left = None self.right = None @staticmethod def newNode(data): temp = GfG() temp.data = data temp.left = None temp.right = None return temp @staticmethod def areMirrors(root1, root2): st1 = [] st2 = [] while True: while root1 is not None and root2 is not None: if root1.data != root2.data: return 'No' st1.append(root1) st2.append(root2) root1 = root1.left root2 = root2.right if not (root1 is None and root2 is None): return 'No' if st1 and st2: root1 = st1[-1] root2 = st2[-1] st1.pop() st2.pop() root1 = root1.right root2 = root2.left else: break return 'Yes' if __name__ == '__main__': root1 = GfG.newNode(1) root1.left = GfG.newNode(3) root1.right = GfG.newNode(2) root1.right.left = GfG.newNode(5) root1.right.right = GfG.newNode(4) root2 = GfG.newNode(1) root2.left = GfG.newNode(2) root2.right = GfG.newNode(3) root2.left.left = GfG.newNode(4) root2.left.right = GfG.newNode(5) print(GfG.areMirrors(root1, root2)", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\n\nstatic\nString areMirrors(Node root1, Node root2) \n{ \n\nStack<Node> st1 = \nnew\nStack<Node> (); \n\nStack<Node> st2 = \nnew\nStack<Node> (); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nwhile\n(root1 != \nnull\n&& root2 != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(root1.data != root2.data) \n\nreturn\n\"No\"\n; \n\n\nst1.push(root1); \n\nst2.push(root2); \n\nroot1 = root1.left; \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\n\n\n\n\nif\n(!(root1 == \nnull\n&& root2 == \nnull\n)) \n\nreturn\n\"No\"\n; \n\n\nif\n(!st1.isEmpty() && !st2.isEmpty()) \n\n{ \n\nroot1 = st1.peek(); \n\nroot2 = st2.peek(); \n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\nroot1 = root1.right; \n\n\n\n\nroot2 = root2.left; \n\n} \n\n\n\n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nreturn\n\"Yes\"\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root1 = newNode(\n1\n); \n\n\nroot1.left = newNode(\n3\n); \n\n\nroot1.right = newNode(\n2\n); \n\n\nroot1.right.left = newNode(\n5\n); \n\n\nroot1.right.right = newNode(\n4\n); \n\n\n\n\n\nNode root2 = newNode(\n1\n); \n\n\nroot2.left = newNode(\n2\n); \n\n\nroot2.right = newNode(\n3\n); \n\n\nroot2.left.left = newNode(\n4\n); \n\n\nroot2.left.right = newNode(\n5\n); \n\n\n\nSystem.out.println(areMirrors(root1, root2)); \n} \n}", "index": 225, "complexity": "1"}
{"back-translation": "class Node: def __init__(self, item): self.data = item self.left = self.right = None class BinaryTree: def identicalTrees(a, b): if a is None and b is None: return True if a is not None and b is not None: return (a.data == b.data and identicalTrees(a.left, b.left) and identicalTrees(a.right, b.right)) return False def main(args): tree = BinaryTree() tree.root1 = Node(1) tree.root1.left = Node(2) tree.root1.right = Node(3) tree.root1.left.left = Node(4) tree.root1.left.right = Node(5) tree.root2 = Node(1) tree.root2.left = Node(2) tree.root2.right = Node(3) tree.root2.left.left = Node(4) tree.root2.left.right = Node(5) if tree.identicalTrees(tree.root1, tree.root2): print(\"Both trees are identical\") else: print(\"Trees are not identical\") ", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root1, root2; \n\n\n\n\nboolean\nidenticalTrees(Node a, Node b) \n\n{ \n\n\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(a != \nnull\n&& b != \nnull\n) \n\nreturn\n(a.data == b.data \n\n&& identicalTrees(a.left, b.left) \n\n&& identicalTrees(a.right, b.right)); \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\ntree.root1 = \nnew\nNode(\n1\n); \n\ntree.root1.left = \nnew\nNode(\n2\n); \n\ntree.root1.right = \nnew\nNode(\n3\n); \n\ntree.root1.left.left = \nnew\nNode(\n4\n); \n\ntree.root1.left.right = \nnew\nNode(\n5\n); \n\n\ntree.root2 = \nnew\nNode(\n1\n); \n\ntree.root2.left = \nnew\nNode(\n2\n); \n\ntree.root2.right = \nnew\nNode(\n3\n); \n\ntree.root2.left.left = \nnew\nNode(\n4\n); \n\ntree.root2.left.right = \nnew\nNode(\n5\n); \n\n\nif\n(tree.identicalTrees(tree.root1, tree.root2)) \n\nSystem.out.println(\n\"Both trees are identical\"\n); \n\nelse\n\nSystem.out.println(\n\"Trees are not identical\"\n); \n\n\n} \n}", "index": 226, "complexity": "1"}
{"back-translation": "class CheckForPath: def existPath(self, root, arr, index): if root == None: return len(arr) == 0 if (root.left == None and root.right == None) and (root.data == arr[index] and root.data == arr[len(arr)-1]): return True return (index < len(arr) and (root.data == arr[index] and (self.existPath(root.left,arr,index+1) or self.existPath(root.right, arr, index+1)))) def main(self, args): arr = [5, 8, 6, 7] root = Node(5) root.left = Node(3) root.right = Node(8) root.left.left = Node(2) root.left.right = Node(4) root.left.left.left = Node(1) root.right.left = Node(6) root.right.left.right = Node(7) if self.existPath(root, arr, 0): print(\"Path Exists\") else: print(\"Path does not Exist\") class Node: def __init__(self, data): self.data = data self.left = None self.right = None", "src": "public\nclass\nCheckForPath { \n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nexistPath(Node root, \nint\narr[], \nint\nindex) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\n{ \n\nreturn\narr.length==\n0\n; \n\n} \n\n\n\n\n\n\nif\n((root.left==\nnull\n&& root.right==\nnull\n) && (root.data==arr[index] \n\n&& root.data==arr[arr.length-\n1\n])) \n\n{ \n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nreturn\n(index<arr.length && (root.data==arr[index] && \n\n(existPath(root.left,arr,index+\n1\n) || \n\nexistPath(root.right, arr, index+\n1\n)))); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\n\n\nint\narr[] = {\n5\n, \n8\n, \n6\n, \n7\n}; \n\nNode root=\nnew\nNode(\n5\n); \n\nroot.left=\nnew\nNode(\n3\n); \n\nroot.right=\nnew\nNode(\n8\n); \n\nroot.left.left = \nnew\nNode(\n2\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.left.left.left = \nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\n\nif\n(existPath(root, arr, \n0\n)) \n\n{ \n\nSystem.out.print(\n\"Path Exists\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.print(\n\"Path does not Exist\"\n); \n\n} \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 227, "complexity": "1"}
{"back-translation": "class GfG: def __init__(self, data): self.data = data self.left = None self.right = None @staticmethod def newNode(item): temp = GfG(item) temp.left = None temp.right = None return temp @staticmethod def getLevel(root, node, level): if root is None: return 0 if root == node: return level downlevel = GfG.getLevel(root.left, node, level+1) if downlevel != 0: return downlevel return GfG.getLevel(root.right, node, level+1) @staticmethod def printGivenLevel(root, node, level): if root is None or level < 2: return if level == 2: if root.left == node or root.right == node: return if root.left is not None: print(root.left.data, end=' ') if root.right is not None: print(root.right.data, end=' ') else: if level > 2: GfG.printGivenLevel(root.left, node, level-1) GfG.printGivenLevel(root.right, node, level-1) @staticmethod def printCousins(root, node): level = GfG.getLevel(root, node, 1) GfG.printGivenLevel(root, node, level) if __name__ == '__main__': root = GfG.newNode(1) root.left = GfG.newNode(2) root.right = GfG.newNode(3) root.left.left = GfG.newNode(4) root.left.right = GfG.newNode(5) root.left.right.right = GfG.newNode(15) root.right.left = GfG.newNode(6) root.right.right = GfG.newNode(7) root.right.left.right = GfG.newNode(8) GfG.printCousins(root, root.left.right)", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\ngetLevel(Node root, Node node, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root == node) \n\nreturn\nlevel; \n\n\n\n\nint\ndownlevel = getLevel(root.left, node, level+\n1\n); \n\nif\n(downlevel != \n0\n) \n\nreturn\ndownlevel; \n\n\n\n\nreturn\ngetLevel(root.right, node, level+\n1\n); \n} \n\n\nstatic\nvoid\nprintGivenLevel(Node root, Node node, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n|| level < \n2\n) \n\nreturn\n; \n\n\n\n\n\n\nif\n(level == \n2\n) \n\n{ \n\nif\n(root.left == node || root.right == node) \n\nreturn\n; \n\nif\n(root.left != \nnull\n) \n\nSystem.out.print(root.left.data + \n\" \"\n); \n\nif\n(root.right != \nnull\n) \n\nSystem.out.print(root.right.data + \n\" \"\n); \n\n} \n\n\n\n\nelse\nif\n(level > \n2\n) \n\n{ \n\nprintGivenLevel(root.left, node, level-\n1\n); \n\nprintGivenLevel(root.right, node, level-\n1\n); \n\n} \n} \n\n\nstatic\nvoid\nprintCousins(Node root, Node node) \n{ \n\n\n\nint\nlevel = getLevel(root, node, \n1\n); \n\n\n\n\nprintGivenLevel(root, node, level); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.left.right.right = newNode(\n15\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n7\n); \n\nroot.right.left.right = newNode(\n8\n); \n\n\nprintCousins(root, root.left.right); \n} \n}", "index": 228, "complexity": "1"}
{"back-translation": "class PrintPath: def hasPath(root, arr, x): if root is None: return False arr.append(root.data) if root.data == x: return True if hasPath(root.left, arr, x) or hasPath(root.right, arr, x): return True arr.remove(arr[-1]) return False def printPath(root, x): arr = [] if hasPath(root, arr, x): for i in range(len(arr) - 1): print(arr[i], '->', end='') print(arr[-1]) else: print('No Path') class Node: def __init__(self, data): self.data = data self.left = None self.right = None if __name__ == '__main__': root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) x = 5 printPath(root, x)", "src": "public\nclass\nPrintPath { \n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\narr.add(root.data); \n\n\n\n\n\n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n\n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n\n\n\n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n\n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 229, "complexity": "1"}
{"back-translation": "class GfG: def __init__(self): self.data = 0 self.left = None self.right = None @staticmethod def printOddNodes(root, isOdd): if root is None: return if isOdd: print(root.data, end=' ') GfG.printOddNodes(root.left, not isOdd) GfG.printOddNodes(root.right, not isOdd) @staticmethod def newNode(data): node = GfG() node.data = data node.left = None node.right = None return node if __name__ == '__main__': root = GfG.newNode(1) root.left = GfG.newNode(2) root.right = GfG.newNode(3) root.left.left = GfG.newNode(4) root.left.right = GfG.newNode(5) GfG.printOddNodes(root, True)", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\nstatic\nvoid\nprintOddNodes(Node root, \nboolean\nisOdd) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(root.data + \n\" \"\n); \n\n\n\n\n\n\nprintOddNodes(root.left, !isOdd); \n\nprintOddNodes(root.right, !isOdd); \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root, \ntrue\n); \n\n} \n}", "index": 230, "complexity": "1"}
{"back-translation": "class GfG: \n    class Node: \n        def __init__(self): \n            self.data = 0 \n            self.left = None \n            self.right = None \n    def printOddNodes(root): \n        if root is None: \n            return \n        q = [] \n        q.append(root) \n        isOdd = True \n        while True: \n            nodeCount = len(q) \n            if nodeCount == 0: \n                break \n            while nodeCount > 0: \n                node = q[0] \n                if isOdd == True: \n                    print(node.data, end=' ') \n                q.pop(0) \n                if node.left is not None: \n                    q.append(node.left) \n                if node.right is not None: \n                    q.append(node.right) \n                nodeCount -= 1 \n            isOdd = not isOdd \n    def newNode(data): \n        node = Node() \n        node.data = data \n        node.left = None \n        node.right = None \n        return node \n    def main(args): \n        root = newNode(1) \n        root.left = newNode(2) \n        root.right = newNode(3) \n        root.left.left = newNode(4) \n        root.left.right = newNode(5) \n        printOddNodes(root) \n    main([])", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n\n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n}", "index": 231, "complexity": "1"}
{"back-translation": "class FullNodes: def findFullNode(root): if root is not None: findFullNode(root.left) if root.left is not None and root.right is not None: print(root.data, end=' ') findFullNode(root.right) def main(args): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.right = Node(7) root.right.right.right = Node(8) root.right.left.right.left = Node(9) findFullNode(root) class Node: def __init__(self, data): self.data = data self.left = None self.right = None", "src": "public\nclass\nFullNodes { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nfindFullNode(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nfindFullNode(root.left); \n\nif\n(root.left != \nnull\n&& root.right != \nnull\n) \n\nSystem.out.print(root.data+\n\" \"\n); \n\nfindFullNode(root.right); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\nroot.right.right.right = \nnew\nNode(\n8\n); \n\nroot.right.left.right.left = \nnew\nNode(\n9\n); \n\nfindFullNode(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nleft=right=\nnull\n; \n\nthis\n.data=data; \n\n} \n};", "index": 232, "complexity": "1"}
{"back-translation": "class GFG: static int sum = 0; static class Node: int data; Node left, right; @staticmethod def getNode(data): newNode = Node(); newNode.data = data; newNode.left = newNode.right = None; return newNode; @staticmethod def sumOfParentOfX(root, x): if root == None: return; if (root.left != None and root.left.data == x) or (root.right != None and root.right.data == x): sum += root.data; sumOfParentOfX(root.left, x); sumOfParentOfX(root.right, x); @staticmethod def sumOfParentOfXUtil(root, x): sum = 0; sumOfParentOfX(root, x); return sum; def main(args): root = getNode(4); root.left = getNode(2); root.right = getNode(5); root.left.left = getNode(7); root.left.right = getNode(2); root.right.left = getNode(2); root.right.right = getNode(3); x = 2; print('Sum = ' + str(sumOfParentOfXUtil(root, x));", "src": "class\nGFG \n{ \n\nstatic\nint\nsum = \n0\n; \n\n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\nstatic\nNode getNode(\nint\ndata) \n{ \n\n\n\nNode newNode = \nnew\nNode(); \n\n\n\n\nnewNode.data = data; \n\nnewNode.left = newNode.right = \nnull\n; \n\nreturn\nnewNode; \n} \n\n\n\nstatic\nvoid\nsumOfParentOfX(Node root, \nint\nx) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\n\nif\n((root.left != \nnull\n&& root.left.data == x) || \n\n(root.right != \nnull\n&& root.right.data == x)) \n\nsum += root.data; \n\n\n\n\n\n\n\n\nsumOfParentOfX(root.left, x); \n\nsumOfParentOfX(root.right, x); \n\n} \n\n\n\n\nstatic\nint\nsumOfParentOfXUtil(Node root, \n\nint\nx) \n{ \n\nsum = \n0\n; \n\nsumOfParentOfX(root, x); \n\n\n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root = getNode(\n4\n); \n\n\nroot.left = getNode(\n2\n); \n\n\nroot.right = getNode(\n5\n); \n\n\nroot.left.left = getNode(\n7\n); \n\n\nroot.left.right = getNode(\n2\n); \n\n\nroot.right.left = getNode(\n2\n); \n\nroot.right.right = getNode(\n3\n); \n\n\nint\nx = \n2\n; \n\n\nSystem.out.println( \n\"Sum = \"\n+ \n\nsumOfParentOfXUtil(root, x)); \n} \n}", "index": 233, "complexity": "1"}
{"back-translation": "{'src': 'class\\nLinkedList { \\n\\n\\nstatic\\nLNode head; \\n\\n\\nclass\\nLNode \\n\\n{ \\n\\nint\\ndata; \\n\\nLNode next, prev; \\n\\n\\nLNode(\\nint\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nnext = prev = \\nNone\\; \\n\\n} \\n\\n} \\n\\n\\n\\nclass\\nTNode \\n\\n{ \\n\\nint\\ndata; \\n\\nTNode left, right; \\n\\n\\nTNode(\\nint\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nleft = right = \\nNone\\; \\n\\n} \\n\\n} \\n\\n\\n\\nTNode sortedListToBST() \\n\\n{ \\n\\n\\n\\nint\\nn = countNodes(head); \\n\\n\\n\\nreturn\\nsortedListToBSTRecur(n); \\n\\n} \\n\\n\\n\\nTNode sortedListToBSTRecur(\\nint\\nn) \\n\\n{ \\n\\n\\n\\nif\\n(n <= \\n0\\n) \\n\\nreturn\\nNone\\; \\n\\n\\n\\nTNode left = sortedListToBSTRecur(n / \\n2\\n); \\n\\n\\n\\nTNode root = \\nTNode(head.data); \\n\\n\\n\\nroot.left = left; \\n\\n\\n\\nhead = head.next; \\n\\n\\n\\nroot.right = sortedListToBSTRecur(n - n / \\n2\\n- \\n1\\n); \\n\\nreturn\\nroot; \\n\\n} \\n\\n\\n\\n\\n\\nint\\ncountNodes(LNode head) \\n\\n{ \\n\\nint\\ncount = \\n0\\; \\n\\nLNode temp = head; \\n\\nwhile\\n(temp != \\nNone\\) \\n\\n{ \\n\\ntemp = temp.next; \\n\\ncount++; \\n\\n} \\n\\nreturn\\ncount; \\n\\n} \\n\\n\\n\\nvoid\\npush(\\nint\\nnew_data) \\n\\n{ \\n\\n\\n\\nLNode new_node = \\nLNode(new_data); \\n\\n\\n\\nnew_node.prev = \\nNone\\; \\n\\n\\n\\nnew_node.next = head; \\n\\n\\n\\nif\\n(head != \\nNone\\) \\n\\nhead.prev = new_node; \\n\\n\\n\\nhead = new_node; \\n\\n} \\n\\n\\n\\nvoid\\nprintList(LNode node) \\n\\n{ \\n\\nwhile\\n(node != \\nNone\\) \\n\\n{ \\n\\nSystem.out.print(node.data + \\n\\\" \\\"\\); \\n\\nnode = node.next; \\n\\n} \\n\\n} \\n\\n\\n\\nvoid\\npreOrder(TNode node) \\n\\n{ \\n\\nif\\n(node == \\nNone\\) \\n\\nreturn\\; \\n\\nSystem.out.print(node.data + \\n\\\" \\\"\\); \\n\\npreOrder(node.left); \\n\\npreOrder(node.right); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) { \\n\\nLinkedList llist = \\nLinkedList(); \\n\\n\\n\\nllist.push(\\n7\\); \\n\\nllist.push(\\n6\\); \\n\\nllist.push(\\n5\\); \\n\\nllist.push(\\n4\\); \\n\\nllist.push(\\n3\\); \\n\\nllist.push(\\n2\\); \\n\\nllist.push(\\n1\\); \\n\\n\\nSystem.out.println(\\n\\\"Given Linked List \\\"\\); \\n\\nllist.printList(head); \\n\\n\\n\\nTNode root = llist.sortedListToBST(); \\n\\nSystem.out.println(\\n\\\"\\\"\\); \\n\\nSystem.out.println(\\n\\\"Pre-Order Traversal of constructed BST \\\"\\); \\n\\nllist.preOrder(root); \\n\\n} \\n}', 'complexity': '1', 'index': 234}", "src": "class\nLinkedList { \n\n\n\n\nstatic\nLNode head; \n\n\n\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n\n\nTNode sortedListToBST() \n\n{ \n\n\n\nint\nn = countNodes(head); \n\n\n\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n\n\nTNode root = \nnew\nTNode(head.data); \n\n\n\n\nroot.left = left; \n\n\n\n\nhead = head.next; \n\n\n\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n\n\nnew_node.prev = \nnull\n; \n\n\n\n\nnew_node.next = head; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n}", "index": 234, "complexity": "1"}
{"back-translation": "class Test: \n    arr = [10, 324, 45, 90, 9808] \n    @staticmethod \n    def largest(): \n        max = Test.arr[0] \n        for i in range(1, len(Test.arr)): \n            if Test.arr[i] > max: \n                max = Test.arr[i] \n        return max \n    @staticmethod \n    def main(args): \n        print('Largest in given array is ' + str(Test.largest())) \nTest.main([])", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n\n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n\n\nint\nmax = arr[\n0\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n}", "index": 235, "complexity": "1"}
{"back-translation": "{\"src\": \"class Node { \\n\\nint data; \\n\\nNode left, right; \\n\\n\\nNode(\\nint d) { \\n\\ndata = d; \\n\\nleft = right = \\nnull\\; \\n\\} \\n} \\n\\nclass BinaryTree { \\n\\n\\nstatic Node root; \\n\\n\\n\\nNode sortedArrayToBST(\\nint arr[], \\nint start, \\nint end) { \\n\\n\\nif (start > end) { \\n\\nreturn null; \\n\\} \\n\\n\\nint mid = (start + end) / 2; \\n\\nNode node = new Node(arr[mid]); \\n\\n\\nnode.left = sortedArrayToBST(arr, start, mid - 1); \\n\\n\\nnode.right = sortedArrayToBST(arr, mid + 1, end); \\n\\n\\nreturn node; \\n\\} \\n\\n\\nvoid preOrder(Node node) { \\n\\nif (node == null) { \\n\\nreturn; \\n\\} \\n\\nSystem.out.print(node.data + \\\" \\\\n\\\" ); \\n\\npreOrder(node.left); \\n\\npreOrder(node.right); \\n\\} \\n\\n\\npublic static void main(String[] args) { \\n\\nBinaryTree tree = new BinaryTree(); \\n\\nint arr[] = new int[]{1, 2, 3, 4, 5, 6, 7}; \\n\\nint n = arr.length; \\n\\nroot = tree.sortedArrayToBST(arr, 0, n - 1); \\n\\nSystem.out.println(\\\"Preorder traversal of constructed BST\\\" ); \\n\\ntree.preOrder(root); \\n\\n} \\n}\", \"complexity\": \"1\", \"index\": 236}", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\n\n\nNode sortedArrayToBST(\nint\narr[], \nint\nstart, \nint\nend) { \n\n\n\n\nif\n(start > end) { \n\nreturn\nnull\n; \n\n} \n\n\n\n\nint\nmid = (start + end) / \n2\n; \n\nNode node = \nnew\nNode(arr[mid]); \n\n\n\n\nnode.left = sortedArrayToBST(arr, start, mid - \n1\n); \n\n\n\n\nnode.right = sortedArrayToBST(arr, mid + \n1\n, end); \n\n\nreturn\nnode; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn = arr.length; \n\nroot = tree.sortedArrayToBST(arr, \n0\n, n - \n1\n); \n\nSystem.out.println(\n\"Preorder traversal of constructed BST\"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 236, "complexity": "1"}
{"back-translation": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nNone\n; \n\n} \n} \n\nclass\nSum { \n\n\nint\nsum = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nSum summ = \nSum()\n; \n\n\n\n\n\n\n\n\ndef\naddGreaterUtil(node, sum_ptr): \n\nif\n(node == \nNone\n): \n\nreturn\n; \n\n\n\n\n\naddGreaterUtil(node.right, sum_ptr); \n\n\n\n\nsum_ptr.sum = sum_ptr.sum + node.data; \n\n\n\n\nnode.data = sum_ptr.sum; \n\n\n\n\n\n\naddGreaterUtil(node.left, sum_ptr); \n\n\n\n\n\n\ndef\naddGreater(node): \n\naddGreaterUtil(node, summ); \n\nreturn\nnode; \n\n\n\n\ndef\nprintInorder(node): \n\nif\n(node == \nNone\n): \n\nreturn\n; \n\nprintInorder(node.left); \n\nprint(node.data + \n' '\n, end = ''); \n\nprintInorder(node.right); \n\n\n\n\nif\n__name__ == \n'__main__': \n\n\ntree = BinaryTree(); \n\ntree.root = Node(\n5\n); \n\ntree.root.left = Node(\n2\n); \n\ntree.root.right = Node(\n13\n); \n\n\nprint(\n'Inorder traversal of given tree '\n); \n\ntree.printInorder(root); \n\nnode = tree.addGreater(root); \n\nprint(\n''\n); \n\nprint(\n'Inorder traversal of modified tree '\n); \n\ntree.printInorder(node); \n\n}", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nSum { \n\n\nint\nsum = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nSum summ = \nnew\nSum(); \n\n\n\n\n\n\nvoid\naddGreaterUtil(Node node, Sum sum_ptr) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\n\n\naddGreaterUtil(node.right, sum_ptr); \n\n\n\n\nsum_ptr.sum = sum_ptr.sum + node.data; \n\n\n\n\nnode.data = sum_ptr.sum; \n\n\n\n\n\n\naddGreaterUtil(node.left, sum_ptr); \n\n} \n\n\n\n\n\n\nNode addGreater(Node node) { \n\naddGreaterUtil(node, summ); \n\nreturn\nnode; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n13\n); \n\n\nSystem.out.println(\n\"Inorder traversal of given tree \"\n); \n\ntree.printInorder(root); \n\nNode node = tree.addGreater(root); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder traversal of modified tree \"\n); \n\ntree.printInorder(node); \n\n} \n}", "index": 237, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    head = None\n\n    def insert(self, node, data):\n        if node is None:\n            return Node(data)\n        else:\n            if data <= node.data:\n                node.left = self.insert(node.left, data)\n            else:\n                node.right = self.insert(node.right, data)\n            return node\n\n    def minvalue(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.data\n\n    @staticmethod\n    def main(args):\n        tree = BinaryTree()\n        root = None\n        root = tree.insert(root, 4)\n        tree.insert(root, 2)\n        tree.insert(root, 1)\n        tree.insert(root, 3)\n        tree.insert(root, 6)\n        tree.insert(root, 5)\n        print('Minimum value of BST is ' + str(tree.minvalue(root)))\n", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n\n\nNode insert(Node node, \nint\ndata) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n\n\nreturn\nnode; \n\n} \n\n} \n\n\n\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n}", "index": 238, "complexity": "1"}
{"back-translation": "class Solution: class NodeDetails: data = 0 min = max = 0 @staticmethod def levelOrderIsOfBST(arr, n): if n == 0: return True q = [] i = 0 newNode = NodeDetails() newNode.data = arr[i] i += 1 newNode.min, newNode.max = float('-inf'), float('inf') q.append(newNode) while i < n and len(q) > 0: temp = q.pop(0) newNode = NodeDetails() if i < n and arr[i] < temp.data and arr[i] > temp.min: newNode.data = arr[i] i += 1 newNode.min, newNode.max = temp.min, temp.data q.append(newNode) newNode = NodeDetails() if i < n and arr[i] > temp.data and arr[i] < temp.max: newNode.data = arr[i] i += 1 newNode.min, newNode.max = temp.data, temp.max q.append(newNode) if i == n: return True return False @staticmethod def main(args): arr = [7, 4, 12, 3, 6, 8, 1, 5, 10] n = len(arr) if NodeDetails.levelOrderIsOfBST(arr, n): print('Yes') else: print('No') NodeDetails.main([])", "src": "class\nSolution \n{ \n\n\n\n\n\nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n\n\n\nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n\n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n\n\nint\ni = \n0\n; \n\n\n\n\n\n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n\n\n\n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n\n\n\n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n\n\n\n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nreturn\nfalse\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n}", "index": 239, "complexity": "1"}
{"back-translation": "class GfG: def __init__(self): self.data = 0 self.left = None self.right = None @staticmethod def newNode(data): temp = GfG() temp.data = data temp.right = None temp.left = None return temp @staticmethod def KthLargestUsingMorrisTraversal(root, k): curr = root Klargest = None count = 0 while curr: if not curr.right: if count += 1 == k: Klargest = curr curr = curr.left else: succ = curr.right while succ.left and succ.left != curr: succ = succ.left if not succ.left: succ.left = curr curr = curr.right else: succ.left = None if count += 1 == k: Klargest = curr curr = curr.left return Klargest def main(args): root = GfG.newNode(4) root.left = GfG.newNode(2) root.right = GfG.newNode(7) root.left.left = GfG.newNode(1) root.left.right = GfG.newNode(3) root.right.left = GfG.newNode(6) root.right.right = GfG.newNode(10) print('Finding K-th largest Node in BST : ' + str(GfG.KthLargestUsingMorrisTraversal(root, 2).data)", "src": "class\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n\n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n\n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n\n\n\n\nsucc.left = curr; \n\n\n\n\ncurr = curr.right; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n}", "index": 240, "complexity": "1"}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinarySearchTree {\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    void insert(int data) {\n        this.root = this.insertRec(this.root, data);\n    }\n\n    Node insertRec(Node node, int data) {\n        if (node == null) {\n            this.root = new Node(data);\n            return this.root;\n        }\n\n        if (data < node.data) {\n            node.left = this.insertRec(node.left, data);\n        } else {\n            node.right = this.insertRec(node.right, data);\n        }\n\n        return node;\n    }\n\n    class count {\n        int c = 0;\n    }\n\n    void secondLargestUtil(Node node, count C) {\n        if (node == null || C.c >= 2) \n            return;\n\n        this.secondLargestUtil(node.right, C);\n\n        C.c++;\n\n        if (C.c == 2) {\n            System.out.print(\"2nd largest element is \" + node.data);\n            return;\n        }\n\n        this.secondLargestUtil(node.left, C);\n    }\n\n    void secondLargest(Node node) {\n        count C = new count();\n        this.secondLargestUtil(this.root, C);\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        tree.secondLargest(tree.root);\n    }\n}", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n\n\nif\n(data < node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n\n\npublic\nclass\ncount { \n\nint\nc = \n0\n; \n\n} \n\n\n\n\nvoid\nsecondLargestUtil(Node node, count C) \n\n{ \n\n\n\n\n\nif\n(node == \nnull\n|| C.c >= \n2\n) \n\nreturn\n; \n\n\n\n\n\n\nthis\n.secondLargestUtil(node.right, C); \n\n\n\n\nC.c++; \n\n\n\n\nif\n(C.c == \n2\n) { \n\nSystem.out.print(\n\"2nd largest element is \"\n+ \n\nnode.data); \n\nreturn\n; \n\n} \n\n\n\n\nthis\n.secondLargestUtil(node.left, C); \n\n} \n\n\n\n\nvoid\nsecondLargest(Node node) \n\n{ \n\n\n\ncount C = \nnew\ncount(); \n\nthis\n.secondLargestUtil(\nthis\n.root, C); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.secondLargest(tree.root); \n\n} \n}", "index": 241, "complexity": "1"}
{"back-translation": "class GfG: \n    class Node: \n        def __init__(self): \n            self.key = None \n            self.left = None \n            self.right = None \n\n    @staticmethod \n    def KSmallestUsingMorris(root, k): \n        count = 0 \n        ksmall = float('-inf') \n        curr = root \n        while curr is not None: \n            if curr.left is None: \n                count += 1 \n                if count == k: \n                    ksmall = curr.key \n                curr = curr.right \n            else: \n                pre = curr.left \n                while pre.right is not None and pre.right is not curr: \n                    pre = pre.right \n                if pre.right is None: \n                    pre.right = curr \n                    curr = curr.left \n                else: \n                    pre.right = None \n                    count += 1 \n                    if count == k: \n                        ksmall = curr.key \n                    curr = curr.right \n        return ksmall \n\n    @staticmethod \n    def newNode(item): \n        temp = GfG().Node() \n        temp.key = item \n        temp.left = None \n        temp.right = None \n        return temp \n\n    @staticmethod \n    def insert(node, key): \n        if node is None: \n            return GfG().newNode(key) \n        if key < node.key: \n            node.left = GfG().insert(node.left, key) \n        elif key > node.key: \n            node.right = GfG().insert(node.right, key) \n        return node \n\n    @staticmethod \n    def main(args): \n        root = None \n        root = GfG().insert(root, 50) \n        GfG().insert(root, 30) \n        GfG().insert(root, 20) \n        GfG().insert(root, 40) \n        GfG().insert(root, 70) \n        GfG().insert(root, 60) \n        GfG().insert(root, 80) \n        for k in range(1, 8): \n            print(GfG().KSmallestUsingMorris(root, k), end=' ') \n", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nKSmallestUsingMorris(Node root, \nint\nk) \n{ \n\n\n\n\n\nint\ncount = \n0\n; \n\n\nint\nksmall = Integer.MIN_VALUE; \n\n\nNode curr = root; \n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nif\n(curr.left == \nnull\n) \n\n{ \n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\n\n\ncurr = curr.right; \n\n} \n\nelse\n\n{ \n\n\n\n\n\nNode pre = curr.left; \n\nwhile\n(pre.right != \nnull\n&& pre.right != curr) \n\npre = pre.right; \n\n\n\n\nif\n(pre.right== \nnull\n) \n\n{ \n\n\n\npre.right = curr; \n\ncurr = curr.left; \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\n\n\npre.right = \nnull\n; \n\n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\ncurr = curr.right; \n\n} \n\n} \n\n} \n\nreturn\nksmall; \n\n} \n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node node, \nint\nkey) \n{ \n\n\n\nif\n(node == \nnull\n) \nreturn\nnewNode(key); \n\n\n\n\nif\n(key < node.key) \n\nnode.left = insert(node.left, key); \n\nelse\nif\n(key > node.key) \n\nnode.right = insert(node.right, key); \n\n\n\n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root = \nnull\n; \n\nroot = insert(root, \n50\n); \n\ninsert(root, \n30\n); \n\ninsert(root, \n20\n); \n\ninsert(root, \n40\n); \n\ninsert(root, \n70\n); \n\ninsert(root, \n60\n); \n\ninsert(root, \n80\n); \n\n\nfor\n(\nint\nk=\n1\n; k<=\n7\n; k++) \n\nSystem.out.print(KSmallestUsingMorris(root, k) + \n\" \"\n); \n\n} \n}", "index": 242, "complexity": "1"}
{"back-translation": "class GFG: def isInorder(arr, n): if n == 0 or n == 1: return True for i in range(1, n): if arr[i - 1] > arr[i]: return False return True def main(args): arr = [19, 23, 25, 30, 45] n = len(arr) if isInorder(arr, n): print('Yes') else: print('Non')", "src": "class\nGFG { \n\n\n\n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n\n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n}", "index": 243, "complexity": "1"}
{"back-translation": "class\nPrintLargest:\n    @staticmethod\n    def print_3_largest(arr, arr_size):\n        if arr_size < 3:\n            print(\"Invalid Input\")\n            return\n        third = first = second = float('-inf')\n        for i in range(arr_size):\n            if arr[i] > first:\n                third, second, first = second, first, arr[i]\n            elif arr[i] > second:\n                third, second = second, arr[i]\n            elif arr[i] > third:\n                third = arr[i]\n        print(\"Three largest elements are \", first, second, third)\n\n    @staticmethod\n    def main(args):\n        arr = [12, 13, 1, 10, 34, 1]\n        n = len(arr)\n        PrintLargest.print_3_largest(arr, n)\n", "src": "class\nPrintLargest \n{ \n\n\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n}", "index": 244, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\n\\nstatic\\nclass\\nNode { \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\n\\n\\n\\n\\npublic\\nNode(\\nint\\ndata) { \\n\\nthis\\n.data = data; \\n\\nleft = \\nnull\\n; \\n\\nright = \\nnull\\n; \\n\\n} \\n\\n} \\n\\n\\nstatic\\nNode root1; \\n\\nstatic\\nNode root2; \\n\\n\\n\\n\\nstatic\\nint\\ncountPairs(Node root1, Node root2, \\n\\nint\\nx) \\n\\n{ \\n\\n\\n\\nif\\n(root1 == \\nnull\\n|| root2 == \\nnull\\n) \\n\\nreturn\\n0\\n; \\n\\n\\n\\n\\n\\n\\n\\n\\nStack<Node> st1 = \\nnew\\nStack<>(); \\n\\nStack<Node> st2 = \\nnew\\nStack<>(); \\n\\nNode top1, top2; \\n\\n\\n\\nint\\ncount = \\n0\\n; \\n\\n\\n\\n\\nwhile\\n(\\ntrue\\n) { \\n\\n\\n\\n\\n\\nwhile\\n(root1 != \\nnull\\n) { \\n\\nst1.push(root1); \\n\\nroot1 = root1.left; \\n\\n} \\n\\n\\n\\n\\nwhile\\n(root2 != \\nnull\\n) { \\n\\nst2.push(root2); \\n\\nroot2 = root2.right; \\n\\n} \\n\\n\\n\\n\\nif\\n(st1.empty() || st2.empty()) \\n\\nbreak\\n; \\n\\n\\ntop1 = st1.peek(); \\n\\ntop2 = st2.peek(); \\n\\n\\n\\nif\\n((top1.data + top2.data) == x) { \\n\\n\\n\\ncount++; \\n\\n\\nst1.pop(); \\n\\nst2.pop(); \\n\\n\\n\\n\\nroot1 = top1.right; \\n\\nroot2 = top2.left; \\n\\n} \\n\\n\\n\\n\\n\\nelse\\nif\\n((top1.data + top2.data) < x) { \\n\\nst1.pop(); \\n\\nroot1 = top1.right; \\n\\n} \\n\\n\\n\\n\\nelse\\n{ \\n\\nst2.pop(); \\n\\nroot2 = top2.left; \\n\\n} \\n\\n} \\n\\n\\n\\nreturn\\ncount; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\n\\n\\nroot1 = \\nnew\\nNode(\\n5\\n); \\n\\n\\nroot1.left = \\nnew\\nNode(\\n3\\n); \\n\\n\\nroot1.right = \\nnew\\nNode(\\n7\\n); \\n\\n\\nroot1.left.left = \\nnew\\nNode(\\n2\\n); \\n\\n\\nroot1.left.right = \\nnew\\nNode(\\n4\\n); \\n\\n\\nroot1.right.left = \\nnew\\nNode(\\n6\\n); \\n\\nroot1.right.right = \\nnew\\nNode(\\n8\\n); \\n\\n\\n\\nroot2 = \\nnew\\nNode(\\n10\\n); \\n\\n\\nroot2.left = \\nnew\\nNode(\\n6\\n); \\n\\n\\nroot2.right = \\nnew\\nNode(\\n15\\n); \\n\\n\\nroot2.left.left = \\nnew\\nNode(\\n3\\n); \\n\\n\\nroot2.left.right = \\nnew\\nNode(\\n8\\n); \\n\\n\\nroot2.right.left = \\nnew\\nNode(\\n11\\n); \\n\\nroot2.right.right = \\nnew\\nNode(\\n18\\n); \\n\\n\\nint\\nx = \\n16\\n; \\n\\nSystem.out.println(\\n\"Pairs = \"\\n\\n+ countPairs(root1, root2, x)); \\n\\n} \\n}', 'complexity': '1', 'index': 245}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n\n\n\n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n\n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nwhile\n(\ntrue\n) { \n\n\n\n\n\n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n\n\n\n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n\n\nif\n((top1.data + top2.data) == x) { \n\n\n\ncount++; \n\n\n\n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\n\n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n\n\n\n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n\n\n\n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nroot1 = \nnew\nNode(\n5\n); \n\n\nroot1.left = \nnew\nNode(\n3\n); \n\n\nroot1.right = \nnew\nNode(\n7\n); \n\n\nroot1.left.left = \nnew\nNode(\n2\n); \n\n\nroot1.left.right = \nnew\nNode(\n4\n); \n\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n\n\nroot2 = \nnew\nNode(\n10\n); \n\n\nroot2.left = \nnew\nNode(\n6\n); \n\n\nroot2.right = \nnew\nNode(\n15\n); \n\n\nroot2.left.left = \nnew\nNode(\n3\n); \n\n\nroot2.left.right = \nnew\nNode(\n8\n); \n\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n}", "index": 245, "complexity": "1"}
{"back-translation": "class Node:\n\n    def __init__(self):\n        self.key = None\n        self.left = None\n        self.right = None\n\n\nclass GFG:\n\n    @staticmethod\n    def removeOutsideRange(root, min_val, max_val):\n        if root is None:\n            return None\n        root.left = GFG.removeOutsideRange(root.left, min_val, max_val)\n        root.right = GFG.removeOutsideRange(root.right, min_val, max_val)\n        if root.key < min_val:\n            rchild = root.right\n            root = None\n            return rchild\n        if root.key > max_val:\n            lchild = root.left\n            root = None\n            return lchild\n        return root\n\n    @staticmethod\n    def newNode(num):\n        temp = GFG.Node()\n        temp.key = num\n        temp.left = None\n        temp.right = None\n        return temp\n\n    @staticmethod\n    def insert(root, key):\n        if root is None:\n            return GFG.newNode(key)\n        if root.key > key:\n            root.left = GFG.insert(root.left, key)\n        else:\n            root.right = GFG.insert(root.right, key)\n        return root\n\n    @staticmethod\n    def inorderTraversal(root):\n        if root is not None:\n            GFG.inorderTraversal(root.left)\n            print(root.key, end=' ')\n            GFG.inorderTraversal(root.right)\n\n    @staticmethod\n    def main(args):\n        root = None\n        root = GFG.insert(root, 6)\n        root = GFG.insert(root, -13)\n        root = GFG.insert(root, 14)\n        root = GFG.insert(root, -8)\n        root = GFG.insert(root, 15)\n        root = GFG.insert(root, 13)\n        root = GFG.insert(root, 7)\n        print('Inorder Traversal of the given tree is:', end=' ')\n        GFG.inorderTraversal(root)\n        root = GFG.removeOutsideRange(root, -10, 13)\n        print('\\nInorder traversal of the modified tree:', end=' ')\n        GFG.inorderTraversal(root)\n", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left; \n\nNode right; \n} \n\nclass\nGFG \n{ \n\n\n\n\n\n\n\nprivate\nstatic\nNode removeOutsideRange(Node root, \n\nint\nmin, \nint\nmax) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nroot.left = removeOutsideRange(root.left, \n\nmin, max); \n\nroot.right = removeOutsideRange(root.right, \n\nmin, max); \n\n\n\n\n\n\n\n\n\n\nif\n(root.key < min) \n\n{ \n\nNode rchild = root.right; \n\nroot = \nnull\n; \n\nreturn\nrchild; \n\n} \n\n\n\n\n\n\nif\n(root.key > max) \n\n{ \n\nNode lchild = root.left; \n\nroot = \nnull\n; \n\nreturn\nlchild; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\npublic\nstatic\nNode newNode(\nint\nnum) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = num; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\npublic\nstatic\nNode insert(Node root, \n\nint\nkey) \n\n{ \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnewNode(key); \n\n} \n\nif\n(root.key > key) \n\n{ \n\nroot.left = insert(root.left, key); \n\n} \n\nelse\n\n{ \n\nroot.right = insert(root.right, key); \n\n} \n\nreturn\nroot; \n\n} \n\n\nprivate\nstatic\nvoid\ninorderTraversal(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\ninorderTraversal(root.left); \n\nSystem.out.print(root.key + \n\" \"\n); \n\ninorderTraversal(root.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nNode root = \nnull\n; \n\nroot = insert(root, \n6\n); \n\nroot = insert(root, -\n13\n); \n\nroot = insert(root, \n14\n); \n\nroot = insert(root, -\n8\n); \n\nroot = insert(root, \n15\n); \n\nroot = insert(root, \n13\n); \n\nroot = insert(root, \n7\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of \"\n+ \n\n\"the given tree is: \"\n); \n\ninorderTraversal(root); \n\n\nroot = removeOutsideRange(root, -\n10\n, \n13\n); \n\n\nSystem.out.print(\n\"\\nInorder traversal of \"\n+ \n\n\"the modified tree: \"\n); \n\ninorderTraversal(root); \n\n} \n}", "index": 246, "complexity": "1"}
{"back-translation": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def inorder(self):\n        self.inorderUtil(self.root)\n\n    def inorderUtil(self, node):\n        if node is None:\n            return\n        self.inorderUtil(node.left)\n        print(node.data, end=' ')\n        self.inorderUtil(node.right)\n\n    def insert(self, key):\n        self.root = self.insertRec(self.root, key)\n\n    def insertRec(self, root, data):\n        if root is None:\n            root = Node(data)\n            return root\n        if data < root.data:\n            root.left = self.insertRec(root.left, data)\n        elif data > root.data:\n            root.right = self.insertRec(root.right, data)\n        return root\n\n    def treeToList(self, node, lst):\n        if node is None:\n            return lst\n        self.treeToList(node.left, lst)\n        lst.append(node.data)\n        self.treeToList(node.right, lst)\n        return lst\n\n    def isPairPresent(self, node, target):\n        a1 = []\n        a2 = self.treeToList(node, a1)\n        start = 0\n        end = len(a2) - 1\n        while start < end:\n            if a2[start] + a2[end] == target:\n                print(\"Pair Found: {} + {} = {}\".format(a2[start], a2[end], target))\n                return True\n            if a2[start] + a2[end] > target:\n                end -= 1\n            if a2[start] + a2[end] < target:\n                start += 1\n        print(\"No such values are found!\")\n        return False\n\n\ndef main(args):\n    tree = BinarySearchTree()\n    tree.insert(15)\n    tree.insert(10)\n    tree.insert(20)\n    tree.insert(8)\n    tree.insert(12)\n    tree.insert(16)\n    tree.insert(25)\n    tree.isPairPresent(tree.root, 33)\n\nmain([])", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n\n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n\n\n\n\n\n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n\n\n\n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n\n\n\nint\nend = a2.size() - \n1\n; \n\n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n\n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n\n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n\n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n}", "index": 247, "complexity": "1"}
{"back-translation": "class Solution: def createNode(x): p = Node(); p.data = x; p.left = p.right = None; return p; def insertNode(root, x): p, q = root, None; while p != None: q = p; if p.data < x: p = p.right; else: p = p.left; if q == None: p = createNode(x); else: if q.data < x: q.right = createNode(x); else: q.left = createNode(x); def maxelpath(q, x): p = q; mx = -1; while p.data != x: if p.data > x: mx = max(mx, p.data); p = p.left; else: mx = max(mx, p.data); p = p.right; return max(mx, x); def maximumElement(root, x, y): p = root; while (x < p.data and y < p.data) or (x > p.data and y > p.data): if x < p.data and y < p.data: p = p.left; else: if x > p.data and y > p.data: p = p.right; return max(maxelpath(p, x), maxelpath(p, y)); arr = [18, 36, 9, 6, 12, 10, 1, 8]; a, b = 1, 10; n = len(arr); root = createNode(arr[0]); for i in range(1, n): insertNode(root, arr[i]); print(maximumElement(root, a, b); ", "src": "class\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n\nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n\nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n\n\nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n\n\n\n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n\n\nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n\n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n\n\n\n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n\n\n\n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n\n\nNode root = createNode(arr[\n0\n]); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n}", "index": 248, "complexity": "1"}
{"back-translation": "class\nsolution \n{ \nstatic\nclass\nNode \n{ \nint\ndata; \nNode left, right; \n}; \nstatic\nNode newNode(\nint\nnum) \n{ \nNode temp = \nnew\nNode(); \ntemp.data = num; \ntemp.left = temp.right = \nnull\n; \nreturn\ntemp; \n} \nstatic\nNode insert(Node root, \nint\nkey) \n{ \nif\n(root == \nnull\n) \nreturn\nnewNode(key); \nif\n(root.data > key) \nroot.left = insert(root.left, key); \nelse\nroot.right = insert(root.right, key); \nreturn\nroot; \n} \nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \nif\n(ptr == \nnull\n) \nreturn\n; \nstoreInorder(ptr.left, vect); \nvect.add(ptr.data); \nstoreInorder(ptr.right, vect); \n} \nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \nint\nsum) \n{ \nint\nleft = \n0\n; \nint\nright = vect2.size() - \n1\n; \nwhile\n(left < vect1.size() && right >= \n0\n) \n{ \nif\n(vect1.get(left) + vect2.get(right) == sum) \n{ \nSystem.out.print( \n\"(\" + vect1.get(left) + \", \" + vect2.get(right) + \"), \"); \nleft++; \nright--; \n} \nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \nleft++; \nelse\nright--; \n} \n} \nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \nVector<Integer> vect1 = \nnew\nVector<Integer>(), vect2 = \nnew\nVector<Integer>(); \nstoreInorder(root1, vect1); \nstoreInorder(root2, vect2); \npairSumUtil(vect1, vect2, sum); \n} \npublic\nstatic\nvoid\nmain(String args[]) \n{ \nNode root1 = \nnull\n; \nroot1 = insert(root1, \n8\n); \nroot1 = insert(root1, \n10\n); \nroot1 = insert(root1, \n3\n); \nroot1 = insert(root1, \n6\n); \nroot1 = insert(root1, \n1\n); \nroot1 = insert(root1, \n5\n); \nroot1 = insert(root1, \n7\n); \nroot1 = insert(root1, \n14\n); \nroot1 = insert(root1, \n13\n); \nNode root2 = \nnull\n; \nroot2 = insert(root2, \n5\n); \nroot2 = insert(root2, \n18\n); \nroot2 = insert(root2, \n2\n); \nroot2 = insert(root2, \n1\n); \nroot2 = insert(root2, \n3\n); \nroot2 = insert(root2, \n4\n); \nint\nsum = \n10\n; \npairSum(root1, root2, sum); \n} \n}", "src": "class\nsolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n\nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n\n\n\nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n\n\n\n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n\n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n\n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n\n\n\n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n\n\n\n\nelse\n\nright--; \n\n} \n} \n\n\n\n\nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n\n\n\n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n\n\n\n\n\n\npairSumUtil(vect1, vect2, sum); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n\n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n}", "index": 249, "complexity": "1"}
{"back-translation": "class Node:\n    def __init__(self, d):\n        self.data = d\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def inorder(self):\n        self.inorderUtil(self.root)\n\n    def inorderUtil(self, node):\n        if node is None:\n            return\n        self.inorderUtil(node.left)\n        print(node.data, end=' ')\n        self.inorderUtil(node.right)\n\n    def insert(self, data):\n        self.root = self.insertRec(self.root, data)\n\n    def insertRec(self, node, data):\n        if node is None:\n            self.root = Node(data)\n            return self.root\n        if data <= node.data:\n            node.left = self.insertRec(node.left, data)\n        else:\n            node.right = self.insertRec(node.right, data)\n        return node\n\nclass Sum:\n    def __init__(self):\n        self.sum = 0\n\n    def modifyBSTUtil(self, node, S):\n        if node is None:\n            return\n        self.modifyBSTUtil(node.right, S)\n        S.sum += node.data\n        node.data = S.sum\n        self.modifyBSTUtil(node.left, S)\n\n    def modifyBST(self, node):\n        S = Sum()\n        self.modifyBSTUtil(node, S)\n\nif __name__ == '__main__':\n    tree = BinarySearchTree()\n    tree.insert(50)\n    tree.insert(30)\n    tree.insert(20)\n    tree.insert(40)\n    tree.insert(70)\n    tree.insert(60)\n    tree.insert(80)\n    tree.modifyBST(tree.root)\n    tree.inorder()", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n\n\npublic\nclass\nSum { \n\nint\nsum = \n0\n; \n\n} \n\n\n\n\n\n\nvoid\nmodifyBSTUtil(Node node, Sum S) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nthis\n.modifyBSTUtil(node.right, S); \n\n\n\n\n\n\nS.sum = S.sum + node.data; \n\nnode.data = S.sum; \n\n\n\n\nthis\n.modifyBSTUtil(node.left, S); \n\n} \n\n\n\n\nvoid\nmodifyBST(Node node) \n\n{ \n\nSum S = \nnew\nSum(); \n\nthis\n.modifyBSTUtil(node, S); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.modifyBST(tree.root); \n\n\n\n\ntree.inorder(); \n\n} \n}", "index": 250, "complexity": "1"}
{"back-translation": "class GFG: static int n, p; static int rd[] = [0]*1100; static int wt[] = [0]*1100; static int cd[] = [0]*1100; static List<Integer> a = []; static List<Integer> b = []; static List<Integer> c = []; static int ans; static int dfs(int w): if cd[w] == 0: return w; if wt[w] < ans: ans = wt[w]; return dfs(cd[w]); static void solve(int arr[][]): i = 0; while i < p: q = arr[i][0]; h = arr[i][1]; t = arr[i][2]; cd[q] = h; wt[q] = t; rd[h] = q; i += 1; a = []; b = []; c = []; for j in range(1, n + 1): if rd[j] == 0 and cd[j] > 0: ans = 1000000000; w = dfs(j); a.append(j); b.append(w); c.append(ans); print(len(a)); for j in range(len(a)): print(a[j], b[j], c[j]); public static void main(String args[]): n = 9; p = 6; for i in range(1100): rd[i] = cd[i] = wt[i] = 0; arr = [[7, 4, 98], [5, 9, 72], [4, 6, 10], [2, 8, 22], [9, 7, 17], [3, 1, 66]]; solve(arr);", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nn, p; \n\n\n\n\n\n\nstatic\nint\nrd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\nwt[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\ncd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nList <Integer> a = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> b = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> c = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nint\nans; \n\n\nstatic\nint\ndfs(\nint\nw) \n\n{ \n\nif\n(cd[w] == \n0\n) \n\nreturn\nw; \n\nif\n(wt[w] < ans) \n\nans = wt[w]; \n\n\nreturn\ndfs(cd[w]); \n\n} \n\n\n\n\nstatic\nvoid\nsolve(\nint\narr[][]) \n\n{ \n\nint\ni = \n0\n; \n\n\nwhile\n(i < p) \n\n{ \n\n\nint\nq = arr[i][\n0\n]; \n\nint\nh = arr[i][\n1\n]; \n\nint\nt = arr[i][\n2\n]; \n\n\ncd[q] = h; \n\nwt[q] = t; \n\nrd[h] = q; \n\ni++; \n\n} \n\n\na=\nnew\nArrayList<Integer>(); \n\nb=\nnew\nArrayList<Integer>(); \n\nc=\nnew\nArrayList<Integer>(); \n\n\nfor\n(\nint\nj = \n1\n; j <= n; ++j) \n\n\n\n\nif\n(rd[j] == \n0\n&& cd[j]>\n0\n) { \n\nans = \n1000000000\n; \n\nint\nw = dfs(j); \n\n\n\n\n\n\n\n\na.add(j); \n\nb.add(w); \n\nc.add(ans); \n\n} \n\n\nSystem.out.println(a.size()); \n\n\nfor\n(\nint\nj = \n0\n; j < a.size(); ++j) \n\nSystem.out.println(a.get(j) + \n\" \"\n\n+ b.get(j) + \n\" \"\n+ c.get(j)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nn = \n9\n; \n\np = \n6\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n1100\n; i++) \n\nrd[i] = cd[i] = wt[i] = \n0\n; \n\n\nint\narr[][] = { { \n7\n, \n4\n, \n98\n}, \n\n{ \n5\n, \n9\n, \n72\n}, \n\n{ \n4\n, \n6\n, \n10\n}, \n\n{ \n2\n, \n8\n, \n22\n}, \n\n{ \n9\n, \n7\n, \n17\n}, \n\n{ \n3\n, \n1\n, \n66\n} }; \n\nsolve(arr); \n\n} \n}", "index": 251, "complexity": "1"}
{"back-translation": "class\nGFG\n{\n\n\nstatic\nint\npoliceThief(char\narr[], int\nn, int\nk)\n{\n\nint\nres = 0;\nArrayList<Integer> thi = new\nArrayList<Integer>();\nArrayList<Integer> pol = new\nArrayList<Integer>();\n\nfor\n(int\ni = 0;\ni < n; i++){\n\nif\n(arr[i] == 'P')\npol.add(i);\nelse\nif\n(arr[i] == 'T')\nthi.add(i);\n}\n\nint\nl = 0, r = 0;\nwhile\n(l < thi.size() && r < pol.size()){\n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k){\nres++;\nl++;\nr++;\n}\nelse\nif\n(thi.get(l) < pol.get(r))\nl++;\nelse\nr++;\n}\nreturn\nres;\n}\n\npublic\nstatic\nvoid\nmain(String args[])\n{\n\nint\nk, n;\nchar\narr1[] = new\nchar[]{'P', 'T', 'T', 'P', 'T'};\nk = 2;\nn = arr1.length;\nSystem.out.println(\"Maximum thieves caught: \"+policeThief(arr1, n, k));\n\nchar\narr2[] = new\nchar[]{'T', 'T', 'P', 'P', 'T', 'P'};\nk = 2;\nn = arr2.length;\nSystem.out.println(\"Maximum thieves caught: \"+policeThief(arr2, n, k));\n\nchar\narr3[] = new\nchar[]{'P', 'T', 'P', 'T', 'T', 'P'};\nk = 3;\nn = arr3.length;\nSystem.out.println(\"Maximum thieves caught: \"+policeThief(arr3, n, k));\n}\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n\n\n\n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n\n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n\n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n}", "index": 252, "complexity": "1"}
{"back-translation": "class GFG: def minProductSubset(a, n): if n == 1: return a[0] negmax = float('-inf') posmin = float('inf') count_neg, count_zero = 0, 0 product = 1 for i in range(n): if a[i] == 0: count_zero += 1 continue if a[i] < 0: count_neg += 1 negmax = max(negmax, a[i]) if a[i] > 0 and a[i] < posmin: posmin = a[i] product *= a[i] if count_zero == n or (count_neg == 0 and count_zero > 0): return 0 if count_neg == 0: return posmin if count_neg % 2 == 0 and count_neg != 0: product /= negmax return product def main(): a = [-1, -1, -2, 4, 3] n = 5 print(minProductSubset(a, n)) if __name__ == '__main__': main()", "src": "class\nGFG { \n\n\nstatic\nint\nminProductSubset(\nint\na[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\na[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\n\nint\nnegmax = Integer.MIN_VALUE; \n\nint\nposmin = Integer.MAX_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nproduct = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(a[i] == \n0\n){ \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) \n\n{ \n\ncount_neg++; \n\nnegmax = Math.max(negmax, a[i]); \n\n} \n\n\n\n\nif\n(a[i] > \n0\n&& a[i] < posmin) \n\nposmin = a[i]; \n\n\nproduct *= a[i]; \n\n} \n\n\n\n\n\n\n\n\nif\n(count_zero == n || \n\n(count_neg == \n0\n&& count_zero > \n0\n)) \n\nreturn\n0\n; \n\n\n\n\nif\n(count_neg == \n0\n) \n\nreturn\nposmin; \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n0\n&& count_neg != \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nproduct = product / negmax; \n\n} \n\n\nreturn\nproduct; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\na[] = { -\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = \n5\n; \n\n\nSystem.out.println(minProductSubset(a, n)); \n\n} \n}", "index": 253, "complexity": "1"}
{"back-translation": "class GFG: def maxProductSubset(a, n): if n == 1: return a[0] max_neg = min(a) count_neg, count_zero = 0, 0 prod = 1 for i in range(n): if a[i] == 0: count_zero += 1 continue if a[i] < 0: count_neg += 1 max_neg = max(max_neg, a[i]) prod *= a[i] if count_zero == n: return 0 if count_neg % 2 == 1: if count_neg == 1 and count_zero > 0 and count_zero + count_neg == n: return 0 prod = prod // max_neg return prod def main(args): a = [-1, -1, -2, 4, 3] n = len(a) print(maxProductSubset(a, n)) if __name__ == '__main__': import sys main(sys.argv) ", "src": "class\nGFG { \n\n\nstatic\nint\nmaxProductSubset(\nint\na[], \nint\nn) { \n\nif\n(n == \n1\n) { \n\nreturn\na[\n0\n]; \n\n} \n\n\n\n\n\n\n\n\nint\nmax_neg = Integer.MIN_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nprod = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(a[i] == \n0\n) { \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) { \n\ncount_neg++; \n\nmax_neg = Math.max(max_neg, a[i]); \n\n} \n\n\nprod = prod * a[i]; \n\n} \n\n\n\n\nif\n(count_zero == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n1\n) { \n\n\n\n\n\n\nif\n(count_neg == \n1\n\n&& count_zero > \n0\n\n&& count_zero + count_neg == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\n\n\nprod = prod / max_neg; \n\n} \n\n\nreturn\nprod; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\na[] = {-\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(maxProductSubset(a, n)); \n\n\n} \n}", "index": 254, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\nstatic\\nint\\nminSum(\\nint\\n[] A, \\nint\\nn) { \\nint\\nmin_val = Arrays.stream(A).min().getAsInt(); \\nreturn\\n(min_val * (n - \\n1\\n)); \\n} \\nstatic\\npublic\\nvoid\\nmain(String[] args) { \\nint\\n[] A = {\\n3\\n, \\n6\\n, \\n2\\n, \\n8\\n, \\n7\\n, \\n5\\n}; \\nint\\nn = A.length; \\nSystem.out.println((minSum(A, n))); \\n} \\n}', 'complexity': '1', 'index': 255}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nint\nminSum(\nint\n[] A, \nint\nn) { \n\nint\nmin_val = Arrays.stream(A).min().getAsInt(); \n\nreturn\n(min_val * (n - \n1\n)); \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nint\n[] A = {\n3\n, \n6\n, \n2\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = A.length; \n\nSystem.out.println((minSum(A, n))); \n\n\n} \n}", "index": 255, "complexity": "1"}
{"back-translation": "class GFG: def MinOperation(a, n, k): result = 0 for i in range(n): if a[i] != 1 and a[i] > k: result += min(a[i] % k, k - a[i] % k) else: result += k - a[i] return result def main(args): arr = [4, 5, 6] n = len(arr) k = 5 print(MinOperation(arr, n, k))", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nn, \nint\nk) \n{ \n\n\nint\nresult = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(a[i] != \n1\n&& a[i] > k) \n\n{ \n\nresult = result + \n\nMath.min(a[i] % k, \n\nk - a[i] % k); \n\n} \n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\nresult = result + k - a[i]; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr[] = {\n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n5\n; \n\nSystem.out.println(MinOperation(arr, n, k)); \n} \n}", "index": 256, "complexity": "1"}
{"back-translation": "class GFG: def maxSum(stack1, stack2, stack3, n1, n2, n3): sum1, sum2, sum3 = 0, 0, 0 for i in range(n1): sum1 += stack1[i] for i in range(n2): sum2 += stack2[i] for i in range(n3): sum3 += stack3[i] top1, top2, top3 = 0, 0, 0 ans = 0 while True: if top1 == n1 or top2 == n2 or top3 == n3: return 0 if sum1 == sum2 == sum3: return sum1 if sum1 >= sum2 and sum1 >= sum3: sum1 -= stack1[top1] top1 += 1 elif sum2 >= sum3 and sum2 >= sum1: sum2 -= stack2[top2] top2 += 1 elif sum3 >= sum2 and sum3 >= sum1: sum3 -= stack3[top3] top3 += 1 def main(): stack1 = [3, 2, 1, 1, 1] stack2 = [4, 3, 2] stack3 = [1, 1, 4, 1] n1 = len(stack1) n2 = len(stack2) n3 = len(stack3) print(maxSum(stack1, stack2, stack3, n1, n2, n3)) main()}", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\nstack1[], \nint\nstack2[], \n\nint\nstack3[], \nint\nn1, \nint\nn2, \n\nint\nn3) \n\n{ \n\nint\nsum1 = \n0\n, sum2 = \n0\n, sum3 = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n1; i++) \n\nsum1 += stack1[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n2; i++) \n\nsum2 += stack2[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n3; i++) \n\nsum3 += stack3[i]; \n\n\n\n\n\n\nint\ntop1 =\n0\n, top2 = \n0\n, top3 = \n0\n; \n\nint\nans = \n0\n; \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\nif\n(top1 == n1 || top2 == n2 || top3 == n3) \n\nreturn\n0\n; \n\n\n\n\nif\n(sum1 == sum2 && sum2 == sum3) \n\nreturn\nsum1; \n\n\n\n\n\n\nif\n(sum1 >= sum2 && sum1 >= sum3) \n\nsum1 -= stack1[top1++]; \n\nelse\nif\n(sum2 >= sum3 && sum2 >= sum3) \n\nsum2 -= stack2[top2++]; \n\nelse\nif\n(sum3 >= sum2 && sum3 >= sum1) \n\nsum3 -= stack3[top3++]; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nstack1[] = { \n3\n, \n2\n, \n1\n, \n1\n, \n1\n}; \n\nint\nstack2[] = { \n4\n, \n3\n, \n2\n}; \n\nint\nstack3[] = { \n1\n, \n1\n, \n4\n, \n1\n}; \n\n\nint\nn1 = stack1.length; \n\nint\nn2 = stack2.length; \n\nint\nn3 = stack3.length; \n\n\nSystem.out.println(maxSum(stack1, stack2, \n\nstack3, n1, n2, n3)); \n\n} \n\n}", "index": 257, "complexity": "1"}
{"back-translation": "class GFG: def printVector(v): print(len(v)) for i in range(len(v)): print(v[i], end=' ') print() def findTwoGroup(n): total_sum = n * (n + 1) // 2 group1_sum = total_sum // 2 group1 = [] group2 = [] for i in range(n, 0, -1): if group1_sum - i >= 0: group1.append(i) group1_sum -= i else: group2.append(i) printVector(group1) printVector(group2) def main(): n = 5 findTwoGroup(n) if __name__ == '__main__': main()", "src": "class\nGFG \n{ \n\n\n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n\n\nSystem.out.println(v.size()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n\n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n\n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n\n\n\n\n\n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n\n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n\n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n}", "index": 258, "complexity": "1"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\n\\n\\nstatic\\nint\\ncost(\\nint\\n[]a, \\nint\\nn) \\n\\n{ \\n\\nint\\nmin = a[\\n0\\]; \\n\\n\\n\\n\\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n1\\; i< a.length; i++) \\n\\n{ \\n\\nif\\n(a[i] < min) \\n\\nmin = a[i]; \\n\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nreturn\\n(n - \\n1\\) * min; \\n\\n} \\n\\n\\n\\n\\nstatic\\npublic\\nvoid\\nmain (String[] args) \\n\\n{ \\n\\n\\nint\\n[]a = { \\n4\\n, \\n3\\n, \\n2\\}; \\n\\nint\\nn = a.length; \\n\\n\\nSystem.out.println(cost(a, n)); \\n\\n} \\n}', 'complexity': '1', 'index': 259}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n\n\n\n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n}", "index": 259, "complexity": "1"}
{"back-translation": "class GFG: def digitsNum(N): if N == 0: print('0') if N % 9 != 0: print((N % 9), end='') for i in range(1, (N // 9) + 1): print('9', end='') for i in range(1, N + 1): print('0', end='') print('') def main(args): N = 5 print('The number is : ', end='') digitsNum(N)", "src": "class\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n\n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n\n\n\n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n}", "index": 260, "complexity": "1"}
{"back-translation": "class GFG: def findSmallest(m, s): if s == 0: print('Smallest number is 0' if m == 1 else 'Not possible'); return; if s > 9 * m: print('Not possible'); return; res = [0] * m; s -= 1; for i in range(m-1, 0, -1): if s > 9: res[i] = 9; s -= 9; else: res[i] = s; s = 0; res[0] = s + 1; print('Smallest number is ', end=''); print(''.join(map(str, res))); def main(args): s, m = 9, 2; findSmallest(m, s); main(None)", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n\n\n\n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n\n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nint\n[] res = \nnew\nint\n[m]; \n\n\n\n\n\n\n\n\ns -= \n1\n; \n\n\n\n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\nres[\n0\n] = s + \n1\n; \n\n\n\n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n}", "index": 261, "complexity": "1"}
{"back-translation": "class KeyComparator:\n    def compare(self, k1, k2):\n        if k1.freq < k2.freq:\n            return 1\n        elif k1.freq > k2.freq:\n            return -1\n        return 0\n\nclass Key:\n    def __init__(self, val, c):\n        self.freq = val\n        self.ch = c\n\nclass GFG:\n    MAX_CHAR = 26\n    @staticmethod\n    def rearrangeString(str):\n        n = len(str)\n        count = [0] * GFG.MAX_CHAR\n        for i in range(n):\n            count[ord(str[i]) - ord('a')] += 1\n        pq = []\n        for c in range(ord('a'), ord('z')+1):\n            val = c - ord('a')\n            if count[val] > 0:\n                pq.append(Key(count[val], chr(c)))\n        str = ''\n        prev = Key(-1, '#')\n        while pq:\n            k = min(pq, key=lambda x: (x.freq, x.ch))\n            pq.remove(k)\n            str += k.ch\n            if prev.freq > 0:\n                pq.append(prev)\n            prev.freq -= 1\n            prev = k\n        if n != len(str):\n            print('Not valid String')\n        else:\n            print(str)\n\n    @staticmethod\n    def main(args):\n        str = 'bbbaa'\n        GFG.rearrangeString(str)\n", "src": "class\nKeyComparator \nimplements\nComparator<Key> { \n\n\n\n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n\n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n\n\n\n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n\n\nstr = \n\"\"\n; \n\n\n\n\n\n\n\n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n\n\nwhile\n(pq.size() != \n0\n) { \n\n\n\n\n\n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n\n\n\n\n\n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n\n\n\n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n\n\n\n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n}", "index": 262, "complexity": "1"}
{"back-translation": "class GfG:\n    def noAdjacentDup(s1):\n        n = len(s1)\n        s = list(s1)\n        i = 1\n        while i < n:\n            if s[i] == s[i - 1]:\n                s[i] = 'a'\n                while s[i] == s[i - 1] or (i + 1 < n and s[i] == s[i + 1]):\n                    s[i] += 1\n                i += 1\n            i += 1\n        return ''.join(map(str, s))\n\n    def main(argc):\n        s = 'geeksforgeeks'\n        print(noAdjacentDup(s))\n\nGfG.main([])", "src": "public\nclass\nGfG{ \n\n\n\n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n\n\ns[i] = \n'a'\n; \n\n\n\n\n\n\n\n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n}", "index": 263, "complexity": "1"}
{"back-translation": "class Test: static arr = [12, 34, 54, 2, 3] @staticmethod def recSearch(arr, l, r, x): if r < l: return -1 if arr[l] == x: return l if arr[r] == x: return r return Test.recSearch(arr, l+1, r-1, x) @staticmethod def main(args): x = 3 index = Test.recSearch(arr, 0, len(arr)-1, x) if index != -1: print('Element ' + str(x) + ' is present at index ' + str(index)) else: print('Element ' + str(x) + ' is not present')", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n12\n, \n34\n, \n54\n, \n2\n, \n3\n}; \n\n\n\n\nstatic\nint\nrecSearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\nif\n(arr[l] == x) \n\nreturn\nl; \n\nif\n(arr[r] == x) \n\nreturn\nr; \n\nreturn\nrecSearch(arr, l+\n1\n, r-\n1\n, x); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nx = \n3\n; \n\n\n\n\nint\nindex = recSearch(arr, \n0\n, arr.length-\n1\n, x); \n\nif\n(index != -\n1\n) \n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is present at index \"\n+ \n\nindex); \n\nelse\n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is not present\"\n); \n\n} \n\n}", "index": 264, "complexity": "1"}
{"back-translation": "class Main: def getMissingNo(a, n): total = (n + 1) * (n + 2) // 2 for i in range(n): total -= a[i] return total def main(args): a = [1, 2, 4, 5, 6] miss = getMissingNo(a, 5) print(miss)", "src": "class\nMain { \n\n\n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n}", "index": 265, "complexity": "1"}
{"back-translation": "class SecondSmallest:\n    @staticmethod\n    def print2Smallest(arr):\n        arr_size = len(arr)\n        if arr_size < 2:\n            print(\" Invalid Input \")\n            return\n        first = second = float('inf')\n        for i in range(arr_size):\n            if arr[i] < first:\n                second = first\n                first = arr[i]\n            elif arr[i] < second and arr[i] != first:\n                second = arr[i]\n        if second == float('inf'):\n            print('There is no second smallest element')\n        else:\n            print('The smallest element is ' + str(first) + ' and second Smallest element is ' + ' ' + str(second))\n\n    @staticmethod\n    def main(args):\n        arr = [12, 13, 1, 10, 34, 1]\n        SecondSmallest.print2Smallest(arr)\n", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 266, "complexity": "1"}
{"back-translation": "class Main: def ceilSearch(arr, low, high, x): i = 0 if x <= arr[low]: return low for i in range(low, high): if arr[i] == x: return i if arr[i] < x and arr[i+1] >= x: return i+1 return -1 def main(args): arr = [1, 2, 8, 10, 10, 12, 19] n = len(arr) x = 3 index = ceilSearch(arr, 0, n-1, x) if index == -1: print(\"Ceiling of \"+str(x)+\" doesn't exist in array\") else: print(\"ceiling of \"+str(x)+\" is \"+str(arr[index]))", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\ni; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nfor\n(i = low; i < high; i++) \n\n{ \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\n\n\n\nif\n(arr[i] < x && arr[i+\n1\n] >= x) \n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 267, "complexity": "1"}
{"back-translation": "class Main: def countOccurrences(arr, n, x): res = 0 for i in range(n): if x == arr[i]: res += 1 return res def main(args): arr = [1, 2, 2, 2, 2, 3, 4, 7, 8, 8] n = len(arr) x = 2 print(countOccurrences(arr, n, x)) ", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n}", "index": 268, "complexity": "1"}
{"back-translation": "class GFG: def printTwoElements(arr, size): i = 0; print('The repeating element is '); while i < size: abs_val = abs(arr[i]); if arr[abs_val - 1] > 0: arr[abs_val - 1] = -arr[abs_val - 1]; else: print(abs_val); i += 1; print('And the missing element is '); i = 0; while i < size: if arr[i] > 0: print(i + 1); i += 1; def main(args): arr = [7, 3, 4, 5, 5, 6, 2]; n = len(arr); printTwoElements(arr, n); if __name__ == '__main__': import sys; main(sys.argv[1:])", "src": "class\nGFG { \n\n\nstatic\nvoid\nprintTwoElements(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nSystem.out.print(\n\"The repeating element is \"\n); \n\n\nfor\n(i = \n0\n; i < size; i++) { \n\nint\nabs_val = Math.abs(arr[i]); \n\nif\n(arr[abs_val - \n1\n] > \n0\n) \n\narr[abs_val - \n1\n] = -arr[abs_val - \n1\n]; \n\nelse\n\nSystem.out.println(abs_val); \n\n} \n\n\nSystem.out.print(\n\"And the missing element is \"\n); \n\nfor\n(i = \n0\n; i < size; i++) { \n\nif\n(arr[i] > \n0\n) \n\nSystem.out.println(i + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n7\n, \n3\n, \n4\n, \n5\n, \n5\n, \n6\n, \n2\n}; \n\nint\nn = arr.length; \n\nprintTwoElements(arr, n); \n\n} \n}", "index": 269, "complexity": "1"}
{"back-translation": "class\nGFG: \n    x = 0\n    y = 0\n    def getTwoElements(arr, n): \n        xor1 = arr[0] \n        for i in range(1, n): \n            xor1 = xor1 ^ arr[i] \n        for i in range(1, n+1): \n            xor1 = xor1 ^ i \n        set_bit_no = xor1 & ~(xor1 - 1) \n        for i in range(n): \n            if (arr[i] & set_bit_no) != 0: \n                x = x ^ arr[i] \n            else: \n                y = y ^ arr[i] \n        for i in range(1, n+1): \n            if (i & set_bit_no) != 0: \n                x = x ^ i \n            else: \n                y = y ^ i \n\n    def main(args): \n        arr = [1, 3, 4, 5, 1, 6, 2] \n        n = len(arr) \n        getTwoElements(arr, n) \n        print(' The missing element is ' + str(x) + 'and the ' + 'repeating number is ' + str(y)) \n", "src": "class\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nxor1; \n\n\n\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n\n\nx = x ^ arr[i]; \n\n\nelse\n\n\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n\n\nx = x ^ i; \n\n\nelse\n\n\n\ny = y ^ i; \n\n} \n\n\n\n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n}", "index": 270, "complexity": "1"}
{"back-translation": "class\nMain:\n\n    @staticmethod\n    def linearSearch(arr, n):\n        for i in range(n):\n            if arr[i] == i:\n                return i\n        return -1\n\n    def main(args):\n        arr = [-10, -1, 0, 3, 10, 11, 30, 50, 100]\n        n = len(arr)\n        print('Fixed Point is ' + str(Main.linearSearch(arr, n))\n", "src": "class\nMain \n{ \n\nstatic\nint\nlinearSearch(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == i) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ linearSearch(arr, n)); \n\n} \n}", "index": 271, "complexity": "1"}
{"back-translation": "class Main: def findMaximum(arr, low, high): max_val = arr[low] for i in range(low, high+1): if arr[i] > max_val: max_val = arr[i] return max_val def main(args): arr = [1, 30, 40, 50, 60, 70, 23, 20] n = len(arr) print('The maximum element is ' + str(findMaximum(arr, 0, n-1)))", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni; \n\nfor\n(i = low; i <= high; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n} \n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 272, "complexity": "1"}
{"back-translation": "class PairDifference: def findPair(arr, n): size = len(arr) i, j = 0, 1 while i < size and j < size: if i != j and arr[j] - arr[i] == n: print('Pair Found: (', arr[i], ', ', arr[j], ' )') return True elif arr[j] - arr[i] < n: j += 1 else: i += 1 print('No such pair') return False def main(): arr = [1, 8, 30, 40, 100] n = 60 findPair(arr, n) if __name__ == '__main__': main()", "src": "class\nPairDifference \n{ \n\n\n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n\n\nint\ni = \n0\n, j = \n1\n; \n\n\n\n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n}", "index": 273, "complexity": "1"}
{"back-translation": "class GFG: def print2largest(arr, arr_size): if arr_size < 2: print(' Invalid Input ') return first = second = float('-inf') for i in range(arr_size): if arr[i] > first: second = first first = arr[i] elif arr[i] > second and arr[i] != first: second = arr[i] if second == float('-inf'): print('There is no second largest element\\n') else: print('The second largest element is ' + str(second)) def main(args): arr = [12, 35, 1, 10, 34, 1] n = len(arr) print2largest(arr, n) if __name__ == '__main__': import sys ret=main(sys.argv)", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n}", "index": 274, "complexity": "1"}
{"back-translation": "class\nMain:\n    \n    @staticmethod\n    def printFirstRepeating(arr):\n        min = -1\n        set = set()\n        for i in range(len(arr) - 1, -1, -1):\n            if arr[i] in set:\n                min = i\n            else:\n                set.add(arr[i])\n        if min != -1:\n            print(\"The first repeating element is \", arr[min])\n        else:\n            print(\"There are no repeating elements\")\n\n    if __name__ == '__main__':\n        arr = [10, 5, 3, 4, 3, 5, 6]\n        Main.printFirstRepeating(arr)", "src": "class\nMain \n{ \n\n\n\nstatic\nvoid\nprintFirstRepeating(\nint\narr[]) \n\n{ \n\n\n\nint\nmin = -\n1\n; \n\n\n\n\nHashSet<Integer> set = \nnew\nHashSet<>(); \n\n\n\n\nfor\n(\nint\ni=arr.length-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nif\n(set.contains(arr[i])) \n\nmin = i; \n\n\nelse\n\n\nset.add(arr[i]); \n\n} \n\n\n\n\nif\n(min != -\n1\n) \n\nSystem.out.println(\n\"The first repeating element is \"\n+ arr[min]); \n\nelse\n\nSystem.out.println(\n\"There are no repeating elements\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \nthrows\njava.lang.Exception \n\n{ \n\nint\narr[] = {\n10\n, \n5\n, \n3\n, \n4\n, \n3\n, \n5\n, \n6\n}; \n\nprintFirstRepeating(arr); \n\n} \n}", "index": 275, "complexity": "1"}
{"back-translation": "class FindCommon: def findCommon(self, ar1, ar2, ar3): i, j, k = 0, 0, 0 while i < len(ar1) and j < len(ar2) and k < len(ar3): if ar1[i] == ar2[j] == ar3[k]: print(ar1[i], end=' ') i += 1 j += 1 k += 1 elif ar1[i] < ar2[j]: i += 1 elif ar2[j] < ar3[k]: j += 1 else: k += 1 def main(args): ob = FindCommon() ar1 = [1, 5, 10, 20, 40, 80] ar2 = [6, 7, 20, 80, 100] ar3 = [3, 4, 15, 20, 30, 70, 80, 120] print('Common elements are ', end='') ob.findCommon(ar1, ar2, ar3) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nFindCommon \n{ \n\n\n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n\n\n\n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n\n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n\n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n\n\nelse\n\nk++; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n}", "index": 276, "complexity": "1"}
{"back-translation": "class CloseSum: def printClosest(arr, n, x): res_l, res_r = 0, 0\nl, r, diff = 0, n-1, float('inf')\nwhile r > l: if abs(arr[l] + arr[r] - x) < diff: res_l = l\nres_r = r\ndiff = abs(arr[l] + arr[r] - x)\nif arr[l] + arr[r] > x: r -= 1\nelse: l += 1\nprint(' The closest pair is '+str(arr[res_l])+' and '+str(arr[res_r]))\ndef main(args): arr = [10, 22, 28, 29, 30, 40]\nx = 54\nn = len(arr)\nprintClosest(arr, n, x)\nmain([])", "src": "class\nCloseSum { \n\n\n\n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n\n\n\n\n\n\n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n\n\nwhile\n(r > l) \n\n{ \n\n\n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n\n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n}", "index": 277, "complexity": "1"}
{"back-translation": "class ClosestPair: def printClosest(ar1, ar2, m, n, x): diff = float('inf') res_l, res_r = 0, 0 l, r = 0, n-1 while l<m and r>=0: if abs(ar1[l] + ar2[r] - x) < diff: res_l = l res_r = r diff = abs(ar1[l] + ar2[r] - x) if ar1[l] + ar2[r] > x: r -= 1 else: l += 1 print(f'The closest pair is [{ar1[res_l]}, {ar2[res_r]}]') if __name__ == '__main__': ob = ClosestPair() ar1 = [1, 4, 5, 7] ar2 = [10, 20, 30, 40] m = len(ar1) n = len(ar2) x = 38 ob.printClosest(ar1, ar2, m, n, x)", "src": "class\nClosestPair \n{ \n\n\n\n\n\n\n\n\n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n\n\n\n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n\n\n\n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\n\n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n}", "index": 278, "complexity": "1"}
{"back-translation": "class PairInSortedRotated:\n    @staticmethod\n    def pairInSortedRotated(arr, n, x):\n        i = 0\n        for i in range(n - 1):\n            if arr[i] > arr[i + 1]:\n                break\n        l = (i + 1) % n\n        r = i\n        while l != r:\n            if arr[l] + arr[r] == x:\n                return True\n            if arr[l] + arr[r] < x:\n                l = (l + 1) % n\n            else:\n                r = (n + r - 1) % n\n        return False\n    @staticmethod\n    def main(args):\n        arr = [11, 15, 6, 8, 9, 10]\n        sum = 16\n        n = len(arr)\n        if PairInSortedRotated.pairInSortedRotated(arr, n, sum):\n            print(\"Array has two elements\" + \" with sum 16\")\n        else:\n            print(\"Array doesn't have two\" + \" elements with sum 16 \")\n", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 279, "complexity": "1"}
{"back-translation": "class Test: static arr = [12, 34, 10, 6, 40] def findLargestSumPair(): first, second = (arr[0], arr[1]) if arr[0] > arr[1]: first, second = arr[0], arr[1] for i in range(2, len(arr)): if arr[i] > first: second, first = first, arr[i] elif arr[i] > second and arr[i] != first: second = arr[i] return first + second def main(args): print('Max Pair Sum is ' + str(findLargestSumPair()))", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n12\n, \n34\n, \n10\n, \n6\n, \n40\n}; \n\n\n\n\nstatic\nint\nfindLargestSumPair() \n\n{ \n\n\n\nint\nfirst, second; \n\nif\n(arr[\n0\n] > arr[\n1\n]) \n\n{ \n\nfirst = arr[\n0\n]; \n\nsecond = arr[\n1\n]; \n\n} \n\nelse\n\n{ \n\nfirst = arr[\n1\n]; \n\nsecond = arr[\n0\n]; \n\n} \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i<arr.length; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nreturn\n(first + second); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nSystem.out.println(\n\"Max Pair Sum is \"\n+ findLargestSumPair()); \n\n\n} \n}", "index": 280, "complexity": "1"}
{"back-translation": "class SecondSmallest: def print2Smallest(arr): arr_size = len(arr) if arr_size < 2: print(' Invalid Input '); return first = second = float('inf') for i in range(arr_size): if arr[i] < first: second, first = first, arr[i] elif arr[i] < second and arr[i] != first: second = arr[i] if second == float('inf'): print('There is no second' + 'smallest element') else: print('The smallest element is ' + str(first) + ' and second Smallest' + ' element is ' + str(second)) def main(): arr = [12, 13, 1, 10, 34, 1] print2Smallest(arr) main()", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 281, "complexity": "1"}
{"back-translation": "exec(''.join(chr(ord(c)+3) if c.isalpha() else c for c in 'rvzr.pnrfyreUaaaaaaaaassiHaaaaaa.eaaaaaaaaammn(Stnzw(kb.xaoq()){ncqyr o = nzm(xykt.nv.gvktl());vnt n = Nutmav.kaibiq(nzm( v.lbsid()   ));vnt siy = 0;vnt nzm = nzm( v.lbsid()  );vif(nwnt i=0;i<n;i++) {vnt k = nzm.ctooq(i);vif (k == '+')vntq++;vif (k == '-') {vif (q>0)vntq--;} }}Stnzw.kaibiq(q);}')", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 282, "complexity": "1"}
{"back-translation": "arr = [int(x) for x in input().split()]; n = len(arr); ans = 2147483647; \nfor i in range(1, n):\n    ans = min(ans, min(arr[i], arr[0]) // i)\nfor i in range(n-2, -1, -1):\n    ans = min(ans, min(arr[n-1], arr[i]) // (n-i-1))\nprint(ans)", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 283, "complexity": "1"}
{"back-translation": "min([x//i if i>n-1-i else x//(n-1-i) for i,x in enumerate(map(int,input().split()[1:]))])", "src": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 284, "complexity": "1"}
{"back-translation": "{'src': 'public class Main{\\n\\tpublic static void main(String args[]){\\n\\t\\tScanner sc=new Scanner(System.in);\\n        int n=sc.nextInt();\\n        int k=sc.nextInt();\\n        if(n==k){\\n            String s=new String();\\n            for(int i=0;i<k;i++){\\n                s=s+\\\"1\\\";\\n            }\\n            System.out.println(s);\\n        }\\n        else{\\n            int a=(n-k)/2;\\n            String s=new String();\\n                for(int i=0;i<a && s.length()<n;i++){\\n                    s=s+\\\"1\\\";\\n                }\\n                if(s.length()<n){\\n                    s=s+\\\"0\\\";\\n                }\\n            while(s.length()<n){\\n                s=s+s;\\n            }\\n            String s1=new String();\\n            for(int i=0;i<n;i++){\\n                s1=s1+Character.toString(s.charAt(i));\\n            }\\n            System.out.println(s1);\\n        }\\n\\t}\\n}', 'complexity': '1', 'index': 285}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "index": 285, "complexity": "1"}
{"back-translation": "class MaximumSum: def FindMaxSum(arr, n): incl = arr[0] excl = 0 for i in range(1, n): excl_new = incl if incl > excl else excl incl = excl + arr[i] excl = excl_new return incl if incl > excl else excl def main(args): sum = MaximumSum() arr = [5, 5, 10, 100, 10, 5] print(sum.FindMaxSum(arr, len(arr))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nMaximumSum \n{ \n\n\n\nint\nFindMaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nincl = arr[\n0\n]; \n\nint\nexcl = \n0\n; \n\nint\nexcl_new; \n\nint\ni; \n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\n\n\nexcl_new = (incl > excl) ? incl : excl; \n\n\n\n\nincl = excl + arr[i]; \n\nexcl = excl_new; \n\n} \n\n\n\n\nreturn\n((incl > excl) ? incl : excl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMaximumSum sum = \nnew\nMaximumSum(); \n\nint\narr[] = \nnew\nint\n[]{\n5\n, \n5\n, \n10\n, \n100\n, \n10\n, \n5\n}; \n\nSystem.out.println(sum.FindMaxSum(arr, arr.length)); \n\n} \n}", "index": 286, "complexity": "1"}
{"back-translation": "{'src': 'public class Main{\\n\\tpublic static void main(String args[]){\\n\\t\tScanner sc=new Scanner(System.in);\\n        int n=sc.nextInt();\\n        int k=sc.nextInt();\\n        if(n==k){\\n            String s=new String();\\n            for(int i=0;i<k;i++){\\n                s=s+\"1\";\\n            }\\n            System.out.println(s);\\n        }\\n        else{\\n            int a=(n-k)/2;\\n            String s=new String();\\n            while(s.length()<n){\\n                for(int i=0;i<a && s.length()<n;i++){\\n                    s=s+\"1\";\\n                }\\n                if(s.length()<n){\\n                    s=s+\"0\";\\n                }\\n            }\\n            System.out.println(s);\\n        }\\n\\t}\\n}', 'complexity': '1', 'index': 287}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            while(s.length()<n){\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "index": 287, "complexity": "1"}
{"back-translation": "{'src': 'public class helloWorld \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\t\\t\\n\\t\\t\\tScanner in = new Scanner(System.in);\\n\\t\\t\\tint n = in.nextInt();\\n\\t\\t\\tint m = in.nextInt();\\n\\t\\t\\tString str = in.next();\\n\\t\\t\\tboolean[] exist = new boolean[200];\\n\\t\\t\\tint dn[][] = new int[200][m+1];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tint a = str.charAt(i);\\n\\t\\t\\t\\texist[a] = true;\\n\\t\\t\\t\\tdn[a][1] = a - 'a' + 1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int k = 2; k <= m; k++) \\n\\t\\t\\t\\tfor(int i = 'a'; i <= 'z'; i++)\\n\\t\\t\\t\\t\\tif(exist[i]) {\\n\\t\\t\\t\\t\\tint a = 0;\\n\\t\\t\\t\\t\\tfor(int j = i+2; j <= 'z'; j++)\\n\\t\\t\\t\\t\\t\\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \\n\\t\\t\\t\\t\\t\\t\\ta = dn[j][k-1];\\n\\t\\t\\t\\t\\tif(a > 0)\\n\\t\\t\\t\\t\\t\\tdn[i][k] = a + i - 'a' + 1; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\tfor(int i = 'a'; i <= 'z'; i++)\\n\\t\\t\\t\\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\\n\\t\\t\\t\\t\\tans = dn[i][m];\\n\\t\\t\\t\\n\\t\\t\\tSystem.out.println(ans);\\n\\t\\t\\t\\n\\t\\t\\tin.close();\\n\\t\\t}\\n}', 'complexity': '1', 'index': 288}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 288, "complexity": "1"}
{"back-translation": "class helloWorld: \n    def main(self):\n        n = int(input())\n        cnt = 0\n        ans = 'Yes'\n        \n        for i in range(n):\n            cnt += int(input())\n        for i in range(n):\n            cnt -= int(input())\n        \n        if cnt < 0:\n            ans = 'No'\n        \n        print(ans)", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 289, "complexity": "1"}
{"back-translation": "{'src': 'public class Piles {\\n\\tstatic int summation(int arr[]) {\\n\\t\\tint k, sum=0;\\n\\t\\tfor(k=0;k<arr.length;k++) {\\n\\t\\t\\tsum = sum + arr[k];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\tint n = sc.nextInt();\\n\\t\\tif(n>=1 && n<=50) {\\n\\t\\t\\tint x[] = new int[n];\\n\\t\\t\\tint y[] = new int[n];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tx[i] = sc.nextInt();\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j=0;j<n;j++) {\\n\\t\\t\\t\\ty[j] = sc.nextInt();\\n\\t\\t\\t}\\n\\t\\t\\tint xsum = summation(x);\\n\\t\\t\\tint ysum = summation(y);\\n\\t\\t\\tif(xsum>=ysum) {\\n\\t\\t\\t\\tSystem.out.println('Yes');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tSystem.out.println('No');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t}\\n\\n}', 'complexity': '1', 'index': 290}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 290, "complexity": "1"}
{"back-translation": "class GFG: def findFrequency(arr, n, left, right, element): count = 0 for i in range(left - 1, right): if arr[i] == element: count += 1 return count def main(args): arr = [2, 8, 6, 9, 8, 6, 8, 2, 11] n = len(arr) print('Frequency of 2 from 1 to 6 = ' + str(findFrequency(arr, n, 1, 6, 2))) print('Frequency of 8 from 4 to 9 = ' + str(findFrequency(arr, n, 4, 9, 8)))", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n\n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n\n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n}", "index": 291, "complexity": "1"}
{"back-translation": "{'src': 'public class Stones {\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tScanner input=new Scanner(System.in);\\n\\t\\tint n=input.nextInt();\\n\\t\\tint s1=0;\\n\\t\\tint s2=0;\\n\\t\\tfor (int i=0;i<n;++i)\\n\\t\\t\\ts1+=input.nextInt();\\n\\t\\tfor (int i=0;i<n;++i)\\n\\t\\t\\ts2+=input.nextInt();\\n\\t\\tif (s1 >= s2)\\n\\t\\t\\tSystem.out.println(\"Yes\");\\n\\t\\telse\\n\\t\\t\\tSystem.out.println(\"No\");\\n\\t}\\n}', 'complexity': '1', 'index': 292}", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 292, "complexity": "1"}
{"back-translation": "{'src': 'public class Piles {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\tScanner scan = new Scanner(System.in);\\n\\t\tint[] a = new int[2]; int x = scan.nextInt();\\n\\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\\n\\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\\n\\n\\t}\\n\\n}', 'complexity': '1', 'index': 293}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 293, "complexity": "1"}
{"back-translation": "{'src': 'public class SolutionB {\\n       \\n      public static void main(String args[])throws IOException{\\n              Scanner sc = new Scanner(System.in);\\n              int n = sc.nextInt();\\n              int k = sc.nextInt();\\n              Set<Integer> set1 = new HashSet<Integer>();\\n              Set<Integer> set2 = new HashSet<Integer>();\\n              int a[] = new int[n];\\n              for(int i = 0; i < n; i++){\\n                     a[i] = sc.nextInt();\\n                     if(!set1.contains(a[i])){\\n                            set1.add(a[i]);\\n                     }else{\\n                            System.out.println(0);\\n                            return;\\n                     }\\n              }\\n              for(int i = 0; i < n; i++){\\n                     int b = a[i] & k;\\n                     if(b != a[i] && set1.contains(b)){\\n                            System.out.println(1);\\n                            return;\\n                     }\\n                     \\n                            \\n                     \\n                       \\n                         \\n                     \\n              }\\n              for(int i = 0; i < n; i++){\\n                     int b = a[i] & k;\\n                     if(b != a[i] && set2.contains(b)){\\n                            System.out.println(2);\\n                            return;\\n                     }else{\\n                            set2.add(b);\\n                     }\\n              }\\n              System.out.println(-1);\\n      }\\n}', 'complexity': '1', 'index': 294}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 294, "complexity": "1"}
{"back-translation": "{'src': 'public class B {\\n    public static void main(String[] args)throws Exception {\\n        FastReader in = new FastReader(System.in);\\n        PrintWriter pw = new PrintWriter(System.out);\\n\\n        int ans = -1;\\n        int f[] = new int[(int)2e5+50];\\n        int g[] = new int[(int)2e5+50];\\n\\n        int n = in.nextInt(), x = in.nextInt();\\n\\n        int arr[] = new int[n+1];\\n        for (int i = 1; i <= n && ans == -1; i++) {\\n            int a = in.nextInt();\\n            if(f[a] > 0){\\n                ans = 0; break;\\n            }\\n            f[a]++;\\n            arr[i] = a;\\n        }\\n\\n        for (int i = 1; i <= n && ans == -1; i++) {\\n            int a = arr[i] & x;\\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\\n                ans = 1; break;\\n            }\\n            \\n            g[a]++;\\n        }\\n\\n        for (int i = 1; i <= n && ans == -1; i++) {\\n            int a = arr[i] & x;\\n            if(g[a] > 1){\\n                ans = 2; break;\\n            }\\n            \\n        }\\n\\n        pw.println(ans);\\n\\n\\n\\n        pw.close();\\n    }\\n\\n    static void debug(Object...obj) {\\n        System.err.println(Arrays.deepToString(obj));\\n    }\\n\\n    static class FastReader {\\n        InputStream is;\\n        private byte[] inbuf = new byte[1024];\\n        private int lenbuf = 0, ptrbuf = 0;\\n        static final int ints[] = new int[128];\\n\\n        public FastReader(InputStream is){\\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\\n            this.is = is;\\n        }\\n\\n        public int readByte(){\\n            if(lenbuf == -1)throw new InputMismatchException();\\n            if(ptrbuf >= lenbuf){\\n                ptrbuf = 0;\\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\\n                if(lenbuf <= 0)return -1;\\n            }\\n            return inbuf[ptrbuf++];\\n        }\\n\\n        public boolean isSpaceChar(int c) {\\n            return !(c >= 33 && c <= 126);\\n        }\\n        public int skip() {\\n            int b;\\n            while((b = readByte()) != -1 && isSpaceChar(b));\\n            return b;\\n        }\\n\\n        public String next(){\\n            int b = skip();\\n            StringBuilder sb = new StringBuilder();\\n            while(!(isSpaceChar(b))){ \\n                sb.appendCodePoint(b);\\n                b = readByte();\\n            }\\n            return sb.toString();\\n        }\\n\\n        public int nextInt(){\\n            int num = 0, b;\\n            boolean minus = false;\\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\\n            if(b == '-'){\\n                minus = true;\\n                b = readByte();\\n            }\\n\\n            while(true){\\n                if(b >= '0' && b <= '9'){\\n                    num = (num<<3) + (num<<1) + ints[b];\\n                }else{\\n                    return minus ? -num : num;\\n                }\\n                b = readByte();\\n            }\\n        }\\n\\n        public long nextLong() {\\n            long num = 0;\\n            int b;\\n            boolean minus = false;\\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\\n            if(b == '-'){\\n                minus = true;\\n                b = readByte();\\n            }\\n\\n            while(true){\\n                if(b >= '0' && b <= '9'){\\n                    num = (num<<3) + (num<<1) + ints[b];\\n                }else{\\n                    return minus ? -num : num;\\n                }\\n                b = readByte();\\n            }\\n        }\\n\\n        public double nextDouble() {\\n            return Double.parseDouble(next());\\n        }\\n       \\n\\n        public char[] next(int n){\\n            char[] buf = new char[n];\\n            int b = skip(), p = 0;\\n            while(p < n && !(isSpaceChar(b))){\\n                buf[p++] = (char)b;\\n                b = readByte();\\n            }\\n            return n == p ? buf : Arrays.copyOf(buf, p);\\n        }\\n\\n        \\n    }\\n}', 'complexity': '1', 'index': 295}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 295, "complexity": "1"}
{"back-translation": "class Test:\n    arr = [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    @staticmethod\n    def maxSum():\n        arrSum = 0\n        currVal = 0\n        for i in range(len(Test.arr)):\n            arrSum += Test.arr[i]\n            currVal += i * Test.arr[i]\n        maxVal = currVal\n        for j in range(1, len(Test.arr)):\n            currVal += arrSum - len(Test.arr) * Test.arr[len(Test.arr) - j]\n            if currVal > maxVal:\n                maxVal = currVal\n        return maxVal\n\n    @staticmethod\n    def main(args):\n        print('Max sum is', Test.maxSum())", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n\n\nstatic\nint\nmaxSum() \n\n{ \n\n\n\nint\narrSum = \n0\n; \n\n\nint\ncurrVal = \n0\n; \n\n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n\n\nint\nmaxVal = currVal; \n\n\n\n\n\n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n\n\nreturn\nmaxVal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n}", "index": 296, "complexity": "1"}
{"back-translation": "{'src': 'public class TaskA {\\n\\tpublic static void main(String[] args) throws Exception {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\n\\n\\t\\tlong i = sc.nextInt();\\n\\t\\tlong goal = sc.nextLong();\\n\\nif(i>goal) {\\n\\ti=goal;\\n}\\n\\t\\tint count = 0;\\n\\t\\twhile (goal >= 0) {\\n\\t\\t\\tif (goal - i >= 0) {\\n\\t\\t\\t\\tgoal = goal - i;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti--;\\n\\t\\t\\tif (goal == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tout.print(count);\\n\\n\\t\\tout.flush();\\n\\n\\t}\\n\\n\\tstatic class Scanner {\\n\\t\\tStringTokenizer st;\\n\\t\\tBufferedReader br;\\n\\n\\t\\tpublic Scanner(InputStream system) {\\n\\t\\t\\tbr = new BufferedReader(new InputStreamReader(system));\\n\\t\\t}\\n\\n\\t\\tpublic Scanner(String file) throws Exception {\\n\\t\\t\\tbr = new BufferedReader(new FileReader(file));\\n\\t\\t}\\n\\n\\t\\tpublic String next() throws IOException {\\n\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\tst = new StringTokenizer(br.readLine());\\n\\t\\t\\treturn st.nextToken();\\n\\t\\t}\\n\\n\\t\\tpublic String nextLine() throws IOException {\\n\\t\\t\\treturn br.readLine();\\n\\t\\t}\\n\\n\\t\\tpublic int nextInt() throws IOException {\\n\\t\\t\\treturn Integer.parseInt(next());\\n\\t\\t}\\n\\n\\t\\tpublic double nextDouble() throws IOException {\\n\\t\\t\\treturn Double.parseDouble(next());\\n\\t\\t}\\n\\n\\t\\tpublic char nextChar() throws IOException {\\n\\t\\t\\treturn next().charAt(0);\\n\\t\\t}\\n\\n\\t\\tpublic Long nextLong() throws IOException {\\n\\t\\t\\treturn Long.parseLong(next());\\n\\t\\t}\\n\\n\\t\\tpublic boolean ready() throws IOException {\\n\\t\\t\\treturn br.ready();\\n\\t\\t}\\n\\n\\t\\tpublic void waitForInput() throws InterruptedException {\\n\\t\\t\\tThread.sleep(3000);\\n\\t\\t}\\n\\t}\\n}', 'complexity': '1', 'index': 297}", "src": "public class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 297, "complexity": "1"}
{"back-translation": "{'src': 'public class CoinsTask {\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\tint n = in.nextInt();\\n\\t\tint S = in.nextInt();\\n\\t\tint mCoins = 0;\\n\\t\twhile(S/n != 0) {\\n\\t\\t\\tmCoins+=1;\\n\\t\\t\\tS-=n;\\n\\t\\t}\\n\\t\\tmCoins = S == 0? mCoins : mCoins+1;\\n\\t\\tSystem.out.print(mCoins);\\n\\t}\\n\\n}', 'complexity': '1', 'index': 298}", "src": "public class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "index": 298, "complexity": "1"}
{"back-translation": "{'src': 'public class P1075A\\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t Scanner scan=new Scanner(System.in);\\n\\t long n,x,y;\\n\\t n=scan.nextLong();\\n\\t x=scan.nextLong();\\n\\t y=scan.nextLong();\\n\\t boolean flag=true,flag1=false,flag2=false;\\n\\t long w1,w2,b1,b2;\\n\\t long W=0l,B=0l;\\n\\t w1=w2=1;\\t\\t b1=b2=n;\\n\\t while(w1<n)\\n\\t\\t{\\n\\t\\t if(w1==x)\\n\\t\\t\\t{flag1=true;\\tbreak;}\\n\\t\\t if(w2==y)\\n\\t\\t\\tbreak;\\n\\t\\t ++w1;\\t++w2;\\t++W;\\n\\t\\t}\\n\\t if(flag1)\\n\\t\\tW+=(y-w2);\\n\\t else\\n\\t\\tW+=(x-w1);\\n\\t while(b1>1)\\n\\t\\t{\\n\\t\\t if(b1==x)\\n\\t\\t\\t{flag2=true;\\tbreak;}\\n\\t\\t if(b2==y)\\n\\t\\t\\tbreak;\\n\\t\\t --b1;\\t--b2;\\t++B;\\n\\t\\t}\\n\\t if(flag2)\\n\\t\\tB+=(b2-y);\\n\\t else\\n\\t\\tB+=(b1-x);\\n\\t if(B<W)\\n\\t\\tSystem.out.println('Black');\\n\\t else\\n\\t\\tSystem.out.println('White');\\n\\t}\\n}', 'complexity': '1', 'index': 299}", "src": "public class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "index": 299, "complexity": "1"}
{"back-translation": "class kingrace:\n    def main(args):\n        input = Scanner(System.in)\n        a = input.nextLong()\n        input.nextLine()\n        coo = input.nextLine().split(' ')\n        xcoin = Long.parseLong(coo[0])\n        ycoin = Long.parseLong(coo[1])\n        first = coordinates(1, 1, a)\n        second = coordinates(a, a, a)\n        x = float(Math.sqrt(abs((xcoin-1)*(xcoin-1) + (ycoin-1)*(ycoin-1))))\n        y = float(Math.sqrt(abs((xcoin-a)*(xcoin-a) + (ycoin-a)*(ycoin-a)))\n        c = 0\n        d = 0\n        if x > y:\n            print('Black')\n        elif x < y:\n            print('White')\n        else:\n            c = first.Distance(coordinates(xcoin, ycoin, a))\n            d = second.Distance(coordinates(xcoin, ycoin, a))\n        if d != 0 and c != 0:\n            if d < c:\n                print('Black')\n            else:\n                print('White')\n        input.close()\nclass coordinates:\n    def __init__(self, x, y, dimensions):\n        self.xcoord = x\n        self.ycoord = y\n        self.dim = dimensions\n    def setCoordinates(self, x, y):\n        self.xcoord = x\n        self.ycoord = y\n    def Distance(self, num):\n        distance = 0\n        while self.xcoord != num.xcoord or self.ycoord != num.ycoord:\n            if num.xcoord - self.xcoord == 1 and num.ycoord == self.ycoord:\n                distance += 1\n                self.setCoordinates(self.xcoord + 1, self.ycoord)\n            elif num.xcoord - self.xcoord == -1 and num.ycoord == self.ycoord:\n                distance += 1\n                self.setCoordinates(self.xcoord - 1, self.ycoord)\n            elif num.xcoord - self.xcoord == 0 and num.ycoord - self.ycoord == 1:\n                distance += 1\n                self.setCoordinates(self.xcoord, self.ycoord + 1)\n            elif num.xcoord - self.xcoord == 0 and num.ycoord - self.ycoord == -1:\n                distance += 1\n                self.setCoordinates(self.xcoord, self.ycoord - 1)\n            elif num.xcoord - self.xcoord >= 0 and num.ycoord - self.ycoord <= 0:\n                distance += 1\n                self.setCoordinates(self.xcoord + 1, self.ycoord - 1)\n            elif num.xcoord - self.xcoord >= 0 and num.ycoord - self.ycoord >= 0:\n                distance += 1\n                self.setCoordinates(self.xcoord + 1, self.ycoord + 1)\n            elif num.xcoord - self.xcoord <= 0 and num.ycoord - self.ycoord <= 0:\n                distance += 1\n                self.setCoordinates(self.xcoord - 1, self.ycoord - 1)\n            elif num.xcoord - self.xcoord <= 0 and num.ycoord - self.ycoord >= 0:\n                distance += 1\n                self.setCoordinates(self.xcoord - 1, self.ycoord + 1)\n        return distance", "src": "public class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  \n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}", "index": 300, "complexity": "1"}
{"back-translation": "class GFG: def answer_query(a, n, l, r): count = 0 for i in range(l, r): if a[i] == a[i + 1]: count += 1 return count def main(args): a = [1, 2, 2, 2, 3, 3, 4, 4, 4] n = len(a) L, R = 1, 8 print(answer_query(a, n, L, R)) L, R = 0, 4 print(answer_query(a, n, L, R))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n\n\n\n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n\n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n}", "index": 301, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "index": 302, "complexity": "1"}
{"back-translation": "class GFG: def repeated_digit(n): s = set() while n != 0: d = n % 10 if d in s: return 0 s.add(d) n = n // 10 return 1 def calculate(L, R): answer = 0 for i in range(L, R + 1): answer += repeated_digit(i) return answer if __name__ == '__main__': L, R = 1, 100 print(calculate(L, R))", "src": "class\nGFG \n{ \n\n\nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n\n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n\n\n\n\n\n\nif\n(s.contains(d)) \n\n{ \n\n\n\n\n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n\n\n\n\nreturn\n1\n; \n} \n\n\n\n\nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n\n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n\n\n\n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n\n\nSystem.out.println(calculate(L, R)); \n} \n}", "index": 303, "complexity": "1"}
{"back-translation": "class GFG: def initializeDiffArray(A, D): n = len(A) D[0] = A[0] D[n] = 0 for i in range(1, n): D[i] = A[i] - A[i - 1] def update(D, l, r, x): D[l] += x D[r + 1] -= x def printArray(A, D): for i in range(len(A)): A[i] = D[i] if i == 0 else D[i] + A[i - 1] print(A[i], end=' ') print() return 0 def main(args): A = [10, 5, 20, 40] n = len(A) D = [0] * (n + 1) initializeDiffArray(A, D) update(D, 0, 1, 10) printArray(A, D) update(D, 1, 3, 20) update(D, 2, 2, 30) printArray(A, D) main([])", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n\n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n\n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n\n\n\n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n\n\n\n\n\n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n\n\n\n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n\n\n\n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n}", "index": 304, "complexity": "1"}
{"back-translation": "{'src': 'public class Cf1003A {\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        int n = Integer.parseInt(br.readLine());\\n        StringTokenizer stk = new StringTokenizer(br.readLine());\\n        int[] arr = new int[100];\\n        int max = 0;\\n        int tmp;\\n        for (int i = 0; i < n; i++) {\\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\\n           max = Math.max(max, ++arr[tmp]);\\n        }\\n        System.out.println(max);\\n    }\\n}', 'complexity': '1', 'index': 305}", "src": "public class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "index": 305, "complexity": "1"}
{"back-translation": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = InputReader(inputStream)\n        out = PrintWriter(outputStream)\n        solver = contest1()\n        solver.solve(1, in, out)\n        out.close()\n\n\nclass contest1:\n    def solve(testNumber, in, out):\n        a = in.nextInt()\n        b = in.nextInt()\n        x = in.nextInt()\n        s = \"\"\n        count = 0\n\n        copya = a\n        copyb = b\n        change = 0\n\n        if x == 1:\n            if copya > copyb:\n                while a > 0:\n                    s += '0'\n                    a -= 1\n                while b > 0:\n                    s += '1'\n                    b -= 1\n            else:\n                while b > 0:\n                    s += '1'\n                    b -= 1\n                while a > 0:\n                    s += '0'\n                    a -= 1\n        else:\n\n            if copya > copyb:\n                while change <= x - 1:\n                    if change % 2 == 0:\n                        s += '0'\n                        change += 1\n                        a -= 1\n                    else:\n                        s += '1'\n                        change += 1\n                        b -= 1\n\n            elif copyb >= copya:\n\n                while change <= x - 1:\n\n                    if change % 2 == 0:\n                        s += '1'\n                        change += 1\n                        b -= 1\n                    else:\n                        s += '0'\n                        change += 1\n                        a -= 1\n\n            z = s[-1]\n\n            if z == '0':\n                while a > 0:\n                    s += '0'\n                    a -= 1\n                while b > 0:\n                    s += '1'\n                    b -= 1\n            else:\n                while b > 0:\n                    s += '1'\n                    b -= 1\n                while a > 0:\n                    s += '0'\n                    a -= 1\n\n        out.println(s)\n\n\nclass InputReader:\n    def __init__(stream):\n        stream = stream\n\n    def read():\n        if numChars == -1:\n            raise InputMismatchException()\n        if curChar >= numChars:\n            curChar = 0\n            try:\n                numChars = stream.read(buf)\n            except IOException as e:\n                raise InputMismatchException()\n            if numChars <= 0:\n                return -1\n        return buf[curChar++]\n\n    def nextInt():\n        c = read()\n        while isSpaceChar(c):\n            c = read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = read()\n        res = 0\n        while not isSpaceChar(c):\n            if c < '0' or c > '9':\n                raise InputMismatchException()\n            res *= 10\n            res += c - '0'\n            c = read()\n        return res * sgn\n\n    def isSpaceChar(c):\n        if filter:\n            return filter.isSpaceChar(c)\n        return isWhitespace(c)\n\n    def isWhitespace(c):\n        return c == ' ' or c == '\n' or c == '\r' or c == '\t' or c == -1\n\n\nclass SpaceCharFilter:\n    def isSpaceChar(ch):\n        pass\n", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                \n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    \n                    while (change <= x - 1) {\n                        \n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                \n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 306, "complexity": "1"}
{"back-translation": "{'src': 'public class programA {\\n   \\tpublic static void main(String[] args)throws IOException {\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\n\\t\\tint n = Integer.parseInt(st.nextToken());\\n\\t\\tint d = Integer.parseInt(st.nextToken());\\n\\t\tint arr[] = new int[n];\\n\\t\tst = new StringTokenizer(br.readLine());\\n\\t\tfor(int i=0;i<n;i++){\\n\\t\\t\\tarr[i] = Integer.parseInt(st.nextToken());\\n\\t\\t}\\n\\t\tint s= 2;\\n\\t\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\tlong dis = (long)2*d;\\n\\t\\t\\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\\n\\t\\t\\tif(dis2 == dis)s++;\\n\\t\\t\\telse if (dis2 > dis)s+=2;\\n\\t\\t}\\n\\t\\tSystem.out.println(s);\\n   \\t\\t}\\n}', 'complexity': '1', 'index': 307}", "src": "public class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long)2*d;\n\t\t\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\n\t\t\tif(dis2 == dis)s++;\n\t\t\telse if (dis2 > dis)s+=2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "index": 307, "complexity": "1"}
{"back-translation": "{'src': 'public class Cf1005A { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int numberOfStairs = 0; StringBuilder result = new StringBuilder(\"\"); StringTokenizer stk = new StringTokenizer(br.readLine()); int previousNum = 0; int tmp = 0; for (int i = 0; i < n; i++) { tmp = Integer.parseInt(stk.nextToken()); if (tmp == 1) { ++numberOfStairs; if (previousNum != 0) result.append(previousNum + \" \"); } previousNum = tmp; } result.append(previousNum); System.out.println(numberOfStairs); System.out.println(result); } }', 'complexity': '1', 'index': 308}", "src": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "index": 308, "complexity": "1"}
{"back-translation": "class\nProfit\n{\n\n\n\n\n\nstatic\nint\nmaxProfit(\nint\nprice[],\nint\nn)\n\n{\n\n\n\nint\nprofit[] =\n[n];\n\nfor\n(\nint\ni=\n0; i<n; i++)\n\nprofit[i] =\n0;\n\n\n\n\nint\nmax_price = price[n-\n1];\n\nfor\n(\nint\ni=n-\n2;i>=\n0;i--)\n\n{\n\n\n\nif\n(price[i] > max_price)\n\nmax_price = price[i];\n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i+\n1], max_price-price[i]);\n\n}\n\n\n\n\nint\nmin_price = price[\n0];\n\nfor\n(\nint\ni=\n1; i<n; i++)\n\n{\n\n\n\nif\n(price[i] < min_price)\n\nmin_price = price[i];\n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i-\n1], profit[i] +\n(price[i]-min_price));\n\n}\n\nint\nresult = profit[n-\n1];\n\nreturn\nresult;\n\n}\n\n\n\npublic\nstatic\nvoid\nmain(String args[])\n\n{\n\nint\nprice[] = {\n2,\n30,\n15,\n10,\n8,\n25,\n80};\n\nint\nn = price.length;\n\nSystem.out.println(\n\"Maximum Profit = \" + maxProfit(price, n));\n\n}\n\n}", "src": "class\nProfit \n{ \n\n\n\n\n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n\n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n\n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n\n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}", "index": 309, "complexity": "1"}
{"back-translation": "{'src': 'public class CodeForce {\\n    \\n    \\n        public static void main(String[] args) {\\n            Scanner sc=new Scanner(System.in);\\n            String s=sc.next();\\n            String t=sc.next();\\n            int count=s.length()+t.length();\\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\\n                else break;\\n            }\\n            System.out.println(count);\\n            \\n            \\n            \\n            \\n           \\n            \\n                \\n        }    \\n    }', 'complexity': '1', 'index': 310}", "src": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "index": 310, "complexity": "1"}
{"back-translation": "{'src': 'public class Codeforces {\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter pw = new PrintWriter(System.out);\\n        int n = Integer.parseInt(br.readLine());\\n        int[] arr = new int[n];\\n        StringTokenizer st = new StringTokenizer(br.readLine());\\n        for(int i = 0; i < n; i++){\\n            arr[i] = Integer.parseInt(st.nextToken());\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(arr[i] % 2 == 0){\\n                arr[i]--;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            pw.print(arr[i] + \\' \\'');\\n        }\\n        pw.flush();\\n        pw.close();\\n    }\\n}', 'complexity': '1', 'index': 311}", "src": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "index": 311, "complexity": "1"}
{"back-translation": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = FastScanner(inputStream)\n        out = FastPrinter(outputStream)\n        solver = TaskC()\n        solver.solve(1, in, out)\n        out.close()\n    \n    class TaskC:\n        def solve(testNumber, in, out):\n            n = in.nextInt()\n            a = [0] * n\n            b = [0] * n\n            for i in range(n):\n                b[i] = a[i] = in.nextInt()\n                if i > 0:\n                    a[i] += a[i-1]\n            for i in range(n-2, -1, -1):\n                b[i] += b[i+1]\n            \n            sum1 = 0\n            sum3 = 0\n            result = 0\n            i = 0\n            j = n-1\n            while i < j:\n                sum1 = a[i]\n                sum3 = b[j]\n                if sum1 == sum3:\n                    result = max(result, sum1)\n                    i += 1\n                    j -= 1\n                elif sum1 < sum3:\n                    i += 1\n                else:\n                    j -= 1\n            out.println(result)\n        \n    class FastScanner:\n        def __init__(is):\n            br = BufferedReader(InputStreamReader(is))\n            st = None\n        \n        def next():\n            while st is None or not st.hasMoreElements():\n                s = None\n                try:\n                    s = br.readLine()\n                except IOException e:\n                    e.printStackTrace()\n                if s is None:\n                    return None\n                st = StringTokenizer(s)\n            return st.nextToken()\n        \n        def nextInt():\n            return int(next())\n        \n    class FastPrinter(PrintWriter):\n        def __init__(out):\n            super(out)\n        \n        def Writer(out):\n            super(out)\n        \n}", "src": "public class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}", "index": 312, "complexity": "1"}
{"back-translation": "import sys\nn, ans = input(), 0\na, b = raw_input(), raw_input()\nans = 0\nfor i in range(n):\n    if i == n//2:\n        if a[i] != b[i]:\n            ans += 1\n        continue\n    vis = [0]*28\n    vis[ord(a[i])-ord('a')] += 1\n    vis[ord(b[i])-ord('a')] += 1\n    vis[ord(a[n-1-i])-ord('a')] += 1\n    vis[ord(b[n-1-i])-ord('a')] += 1\n    num, ans1, ans2 = 0, 0, 0\n    for j in range(26):\n        if vis[j] != 0:\n            num += 1\n            if num == 1:\n                ans1 = vis[j]\n            else:\n                ans2 = vis[j]\n    if num == 2:\n        if ans1 == 1 or ans2 == 1:\n            ans += 1\n    elif num == 3:\n        if a[i] == a[n-i-1]:\n            ans += 2\n        else:\n            ans += 1\n    elif num == 4:\n        ans += 2\n    a[i] = b[i]\n    a[n-1-i] = b[n-1-i]\nprint(ans)", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 313, "complexity": "1"}
{"back-translation": "class Main:\n    def main(args):\n        inputStream = System.in\n        outputStream = System.out\n        in = FastScanner(inputStream)\n        out = PrintWriter(outputStream)\n        solver = EMilitaryProblem()\n        solver.solve(1, in, out)\n        out.close()\n\nclass EMilitaryProblem:\n    def solve(testNumber, br, pw):\n        n = br.nextInt()\n        q = br.nextInt()\n        preorder = [0] * n\n        sz = [0] * n\n        pos = [0] * n\n        curPos = 0\n        adj = [0] * n\n        for i in range(n):\n            adj[i] = []\n        for i in range(1, n):\n            u = br.nextInt()\n            u -= 1\n            adj[u].append(i)\n        dfs(0)\n        for i in range(n):\n            pos[preorder[i]] = i\n        for i in range(q):\n            u = br.nextInt()\n            k = br.nextInt()\n            u -= 1\n            if sz[u] < k:\n                pw.println(\"-1\")\n            else:\n                pw.println(preorder[pos[u] + k - 1] + 1)\n        pw.close()\n\n    def dfs(u):\n        preorder[curPos] = u\n        curPos += 1\n        sz[u] += 1\n        for e in adj[u]:\n            sz[u] += dfs(e)\n        return sz[u]\n\nclass FastScanner:\n    def read():\n        if numChars == -1:\n            raise InputMismatchException()\n        if curChar >= numChars:\n            curChar = 0\n            try:\n                numChars = stream.read(buf)\n            except IOException as e:\n                raise InputMismatchException()\n            if numChars <= 0:\n                return -1\n        return buf[curChar++]\n\n    def nextInt():\n        c = read()\n        while isSpaceChar(c):\n            c = read()\n        sgn = 1\n        if c == '-':\n            sgn = -1\n            c = read()\n        res = 0\n        while not isSpaceChar(c):\n            if c < '0' or c > '9':\n                raise InputMismatchException()\n            else:\n                res *= 10\n                res += c - '0'\n                c = read()\n        return res * sgn\n\n    def isSpaceChar(c):\n        if filter != None:\n            return filter.isSpaceChar(c)\n        return isWhitespace(c)\n\n    @staticmethod\n    def isWhitespace(c):\n        return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n\n    class SpaceCharFilter:\n        def isSpaceChar(ch):\n            ", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 314, "complexity": "1"}
{"back-translation": "class Test: \n\n    arr = [3, 7, 90, 20, 10, 50, 40] \n\n    @staticmethod \n    def findMinAvgSubarray(n, k): \n        if n < k: \n            return \n        res_index = 0 \n        curr_sum = 0 \n        for i in range(k): \n            curr_sum += Test.arr[i] \n        min_sum = curr_sum \n        for i in range(k, n): \n            curr_sum += Test.arr[i] - Test.arr[i-k] \n            if curr_sum < min_sum: \n                min_sum = curr_sum \n                res_index = i - k + 1 \n        print(f\"Subarray between [{res_index}, {res_index + k - 1}] has minimum average\") \n\n    @staticmethod \n    def main(args): \n        k = 3 \n        Test.findMinAvgSubarray(len(Test.arr), k) \n", "src": "class\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n\n\n\n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n\n\nif\n(n < k) \n\nreturn\n; \n\n\n\n\nint\nres_index = \n0\n; \n\n\n\n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n\n\nint\nmin_sum = curr_sum; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n\n\n\n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n\n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n\n\nfindMinAvgSubarray(arr.length, k); \n\n} \n}", "index": 315, "complexity": "1"}
{"back-translation": "print(max([ord(chr) - ord('a') + 1 for chr in input() if ord(chr) >= ord('a')]) if 'a' in input() else -1)", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 316, "complexity": "1"}
{"back-translation": "class MinimumDistance:\n    def minDist(self, arr, n, x, y):\n        i = 0\n        min_dist = float('inf')\n        prev = 0\n        for i in range(n):\n            if arr[i] == x or arr[i] == y:\n                prev = i\n                break\n        for i in range(i, n):\n            if arr[i] == x or arr[i] == y:\n                if arr[prev] != arr[i] and (i - prev) < min_dist:\n                    min_dist = i - prev\n                    prev = i\n                else:\n                    prev = i\n        return min_dist\n\n    def main(self, args):\n        min = MinimumDistance()\n        arr = [3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3]\n        n = len(arr)\n        x = 3\n        y = 6\n        print(\"Minimum distance between \", x, \" and \", y, \" is \", min.minDist(arr, n, x, y))\n\nmin = MinimumDistance()\nmin.main([])", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 317, "complexity": "1"}
{"back-translation": "{'src': 'public class helloWorld \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\t\\t\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tint n = in.nextInt();\\n\\t\\tint cnt = 0;\\n\\t\\tString ans = \\", "\\": "Yes\\", "\\n\\t\\t\\n\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\tcnt += in.nextInt();\\n\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\tcnt -= in.nextInt();\\n\\t\\t\\n\\t\\tif(cnt < 0)\\n\\t\\t\\tans = \\": "No\\", "\\n\\t\\t\\n\\t\\tSystem.out.println(ans);\\n\\t\\t\\t\\t\\n\\t\\tin.close();\\n\\t}\\n}', 'complexity': '1', 'index': 318}": "1", "index": 318, "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "complexity": "1"}
{"back-translation": "{'src': 'public class Piles {\\n\\tstatic int summation(int arr[]) {\\n\\t\\tint k, sum=0;\\n\\t\\tfor(k=0;k<arr.length;k++) {\\n\\t\\t\\tsum = sum + arr[k];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\tint n = sc.nextInt();\\n\\t\\tif(n>=1 && n<=50) {\\n\\t\\t\\tint x[] = new int[n];\\n\\t\\t\\tint y[] = new int[n];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tx[i] = sc.nextInt();\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j=0;j<n;j++) {\\n\\t\\t\\t\\ty[j] = sc.nextInt();\\n\\t\\t\\t}\\n\\t\\t\\tint xsum = summation(x);\\n\\t\\t\\tint ysum = summation(y);\\n\\t\\t\\tif(xsum>=ysum) {\\n\\t\\t\\t\\tSystem.out.println(\\\"Yes\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tSystem.out.println(\\\"No\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t}\\n\\n}', 'complexity': '1', 'index': 319}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 319, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 320, "complexity": "1"}
{"back-translation": "{'src': 'public class Piles {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\tScanner scan = new Scanner(System.in);\\n\\t\tint[] a = new int[2]; int x = scan.nextInt();\\n\\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\\n\\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\\n\\n\\t}\\n\\n}', 'complexity': '1', 'index': 321}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 321, "complexity": "1"}
{"back-translation": "{'src': 'public class SolutionB {\\n       \\n      public static void main(String args[])throws IOException{\\n              Scanner sc = new Scanner(System.in);\\n              int n = sc.nextInt();\\n              int k = sc.nextInt();\\n              Set<Integer> set1 = new HashSet<Integer>();\\n              Set<Integer> set2 = new HashSet<Integer>();\\n              int a[] = new int[n];\\n              for(int i = 0; i < n; i++){\\n                     a[i] = sc.nextInt();\\n                     if(!set1.contains(a[i])){\\n                            set1.add(a[i]);\\n                     }else{\\n                            System.out.println(0);\\n                            return;\\n                     }\\n              }\\n              for(int i = 0; i < n; i++){\\n                     int b = a[i] & k;\\n                     if(b != a[i] && set1.contains(b)){\\n                            System.out.println(1);\\n                            return;\\n                     }\\n                     \\n                            \\n                     \\n                       \\n                         \\n                     \\n              }\\n              for(int i = 0; i < n; i++){\\n                     int b = a[i] & k;\\n                     if(b != a[i] && set2.contains(b)){\\n                            System.out.println(2);\\n                            return;\\n                     }else{\\n                            set2.add(b);\\n                     }\\n              }\\n              System.out.println(-1);\\n      }\\n}', 'complexity': '1', 'index': 322}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 322, "complexity": "1"}
{"back-translation": "def solve():\n    ans = -1\n    f = [0] * (2*10**5 + 50)\n    g = [0] * (2*10**5 + 50)\n    n, x = map(int, input().split())\n    arr = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a = int(input())\n        if f[a] > 0:\n            ans = 0\n            break\n        f[a] += 1\n        arr[i] = a\n    for i in range(1, n + 1):\n        a = arr[i] & x\n        if (a == arr[i] and f[a] > 1) or (a != arr[i] and f[a] > 0):\n            ans = 1\n            break\n        g[a] += 1\n    for i in range(1, n + 1):\n        a = arr[i] & x\n        if g[a] > 1:\n            ans = 2\n            break\n    print(ans)\n\nsolve()", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 323, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "index": 324, "complexity": "1"}
{"back-translation": "class DeathNote:\n    in = BufferedReader(InputStreamReader(System.in))\n    out = PrintWriter(BufferedOutputStream(System.out))\n    \n    @staticmethod\n    def main(args):\n        n = DeathNote.nextInt()\n        m = DeathNote.nextInt()\n        a = DeathNote.intArray(n)\n        \n        sb = StringBuffer()\n        x = 0\n        for i in range(n):\n            x += a[i]\n            sb.append(' ' + str(x // m))\n            x %= m\n        \n        print(sb.toString()[1:])\n    \n    @staticmethod\n    def nextLine():\n        return in.readLine()\n\n    @staticmethod\n    def nextString():\n        while st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readLine())\n        return st.nextToken()\n    \n    @staticmethod\n    def nextInt():\n        return int(DeathNote.nextString())\n\n    @staticmethod\n    def nextLong():\n        return int(DeathNote.nextString())\n    \n    @staticmethod\n    def intArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = DeathNote.nextInt()\n        return a\n    \n    @staticmethod\n    def intArray(n, m):\n        a = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                a[i][j] = DeathNote.nextInt()\n        return a\n    \n    @staticmethod\n    def longArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = DeathNote.nextLong()\n        return a", "src": "public class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 325, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n\\n    static String S;\\n\\n    public static void main(String[] args) {\\n        FastScanner sc = new FastScanner(System.in);\\n        S = sc.next();\\n\\n        System.out.println(solve());\\n    }\\n\\n    static int solve() {\\n        int ans = -1;\\n        int time = 1;\\n        int n = S.length();\\n        for (int i = 1; i < n*2; i++) {\\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\\n                time++;\\n            } else {\\n                ans = Math.max(time, ans);\\n                time = 1;\\n            }\\n        }\\n        ans = Math.max(time, ans);\\n\\n        if( ans == n*2 ) {\\n            return n;\\n        } else {\\n            return ans;\\n        }\\n    }\\n\\n    @SuppressWarnings(\"unused\")\\n    static class FastScanner {\\n        private BufferedReader reader;\\n        private StringTokenizer tokenizer;\\n\\n        FastScanner(InputStream in) {\\n            reader = new BufferedReader(new InputStreamReader(in));\\n            tokenizer = null;\\n        }\\n\\n        String next() {\\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\\n                try {\\n                    tokenizer = new StringTokenizer(reader.readLine());\\n                } catch (IOException e) {\\n                    throw new RuntimeException(e);\\n                }\\n            }\\n            return tokenizer.nextToken();\\n        }\\n\\n        String nextLine() {\\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\\n                try {\\n                    return reader.readLine();\\n                } catch (IOException e) {\\n                    throw new RuntimeException(e);\\n                }\\n            }\\n            return tokenizer.nextToken(\"\\n\");\\n            }\\n\\n        long nextLong() {\\n            return Long.parseLong(next());\\n        }\\n\\n        int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n        int[] nextIntArray(int n) {\\n            int[] a = new int[n];\\n            for (int i = 0; i < n; i++)\\n                a[i] = nextInt();\\n            return a;\\n        }\\n\\n        int[] nextIntArray(int n, int delta) {\\n            int[] a = new int[n];\\n            for (int i = 0; i < n; i++)\\n                a[i] = nextInt() + delta;\\n            return a;\\n        }\\n\\n        long[] nextLongArray(int n) {\\n            long[] a = new long[n];\\n            for (int i = 0; i < n; i++)\\n                a[i] = nextLong();\\n            return a;\\n        }\\n    }\\n\\n    static <A> void writeLines(A[] as, Function<A, String> f) {\\n        PrintWriter pw = new PrintWriter(System.out);\\n        for (A a : as) {\\n            pw.println(f.apply(a));\\n        }\\n        pw.flush();\\n    }\\n\\n    static void writeLines(int[] as) {\\n        PrintWriter pw = new PrintWriter(System.out);\\n        for (int a : as) pw.println(a);\\n        pw.flush();\\n    }\\n\\n    static void writeLines(long[] as) {\\n        PrintWriter pw = new PrintWriter(System.out);\\n        for (long a : as) pw.println(a);\\n        pw.flush();\\n    }\\n\\n    static int max(int... as) {\\n        int max = Integer.MIN_VALUE;\\n        for (int a : as) max = Math.max(a, max);\\n        return max;\\n    }\\n\\n    static int min(int... as) {\\n        int min = Integer.MAX_VALUE;\\n        for (int a : as) min = Math.min(a, min);\\n        return min;\\n    }\\n\\n    static void debug(Object... args) {\\n        StringJoiner j = new StringJoiner(\" \");\\n        for (Object arg : args) {\\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\\n            else j.add(arg.toString());\\n        }\\n        System.err.println(j.toString());\\n    }\\n}', 'complexity': '1', 'index': 326}", "src": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "index": 326, "complexity": "1"}
{"back-translation": "{'src': 'public class Cheast {\\n\\n    public static void main(String[] args) throws IOException {\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt();\\n        int[] l = new int[n];\\n        l[0] = sc.nextInt();\\n        int x=1;\\n        int c=1;\\n        for (int i=1;i<n;i++) {\\n            l[i] = sc.nextInt();\\n            if (l[i] <= l[i-1]*2) {\\n                c++;\\n                x = Math.max(x,c);\\n            }\\n            else\\n                c = 1;\\n        }\\n        System.out.println(x);\\n\\n\\n\\n    }\\n}', 'complexity': '1', 'index': 327}", "src": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "index": 327, "complexity": "1"}
{"back-translation": "{'src': 'public class vasyaarray{\\npublic static void main(String[] args)throws IOException {\\n    FastReader in=new FastReader(System.in);\\n        int n=in.nextInt();\\n        long arr1[]=new long[n];\\n        long pre1[]=new long[n];\\n        int i,j;\\n        arr1[0]=in.nextLong();\\n        pre1[0]=arr1[0];\\n        for(i=1;i<n;i++)\\n        {\\n            arr1[i]=in.nextLong();\\n            pre1[i]=pre1[i-1]+arr1[i];\\n        }\\n        int m=in.nextInt();\\n        long arr2[]=new long[m];\\n        long pre2[]=new long[m];\\n        arr2[0]=in.nextInt();\\n        pre2[0]=arr2[0];\\n        for(i=1;i<m;i++)\\n        {\\n            arr2[i]=in.nextInt();\\n            pre2[i]=pre2[i-1]+arr2[i];\\n        }\\n        \\n         \\n        if(pre1[n-1]!=pre2[m-1])\\n        System.out.println(\\\"-1\\\");\\n        else\\n        {\\n            long s1=0,s2=0;\\n            i=j=0;\\n            int k=0;\\n            while(true)\\n            {\\n                if(s1==s2)\\n                {\\n                    if(s1==0)\\n                    {\\n                        s1=arr1[i++];\\n                        s2=arr2[j++];\\n                        \\n                    }\\n                    else\\n                    {\\n                        k++;\\n                        s1=s2=0;\\n                        \\n                        if(i==n && j==m)\\n                        break;\\n                    }\\n                }\\n                else if(s1>s2)\\n                {\\n                    s2+=arr2[j++];\\n                    \\n                }\\n                else\\n                {\\n                    s1+=arr1[i++];\\n                    \\n                }\\n            }\\n            System.out.println(k);\\n        }\\n    }\\n}\\nclass FastReader {\\n \\n    byte[] buf = new byte[2048];\\n    int index, total;\\n    InputStream in;\\n \\n    FastReader(InputStream is) {\\n        in = is;\\n    }\\n \\n    int scan() throws IOException {\\n        if (index >= total) {\\n            index = 0;\\n            total = in.read(buf);\\n            if (total <= 0) {\\n                return -1;\\n            }\\n        }\\n        return buf[index++];\\n    }\\n \\n    String next() throws IOException {\\n        int c;\\n        for (c = scan(); c <= 32; c = scan());\\n        StringBuilder sb = new StringBuilder();\\n        for (; c > 32; c = scan()) {\\n            sb.append((char) c);\\n        }\\n        return sb.toString();\\n    }\\n    String nextLine() throws IOException {\\n        int c;\\n        for (c = scan(); c <= 32; c = scan());\\n        StringBuilder sb = new StringBuilder();\\n        for (; c !=10; c = scan()) {\\n            sb.append((char) c);\\n        }\\n        return sb.toString();\\n    }\\n    char nextChar() throws IOException{\\n        int c;\\n         for (c = scan(); c <= 32; c = scan());\\n         return (char)c;\\n        }\\n \\n    int nextInt() throws IOException {\\n        int c, val = 0;\\n        for (c = scan(); c <= 32; c = scan());\\n        boolean neg = c == \\'-\\';\\n        if (c == \\'-\\' || c == \\'+\\') {\\n            c = scan();\\n        }\\n        for (; c >= \\'0\\' && c <= \\'9\\'; c = scan()) {\\n            val = (val << 3) + (val << 1) + (c & 15);\\n        }\\n        return neg ? -val : val;\\n    }\\n \\n    long nextLong() throws IOException {\\n        int c;\\n        long val = 0;\\n        for (c = scan(); c <= 32; c = scan());\\n        boolean neg = c == \\'-\\';\\n        if (c == \\'-\\' || c == \\'+\\') {\\n            c = scan();\\n        }\\n        for (; c >= \\'0\\' && c <= \\'9\\'; c = scan()) {\\n            val = (val << 3) + (val << 1) + (c & 15);\\n        }\\n        return neg ? -val : val;\\n    }\\n}', 'complexity': '1', 'index': 328}", "src": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        \n         \n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        \n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        \n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    \n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    \n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "index": 328, "complexity": "1"}
{"back-translation": "{'src': 'class helloWorld:\\n    ar = []\\n    def main(args):\\n        n = int(input())\\n        ans = ''\\n        if n <= 2:\\n            ans += 'No'\\n        elif n == 4:\\n            ans += 'Yes\\n1 2\\n3 1 3 4\\n'\\n        else:\\n            ans += 'Yes\\n'\\n            if n % 2 == 1:\\n                a = (n+1)//2\\n                ans += '1 ' + str(a) + '\\n'\\n                ans += str(n-1)\\n                for i in range(1, a):\\n                    ans += ' ' + str(i)\\n                for i in range(a+1, n+1):\\n                    ans += ' ' + str(i)\\n            else:\\n                a = n//2\\n                ans += '2 ' + str(a) + ' ' + str(a+1) + ' \\n'\\n                ans += str(n-2)\\n                for i in range(1, a):\\n                    ans += ' ' + str(i)\\n                for i in range(a+2,n+1):\\n                    ans += ' ' + str(i)\\n        print(ans)\\n', 'complexity': '1', 'index': 329}", "src": "public class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 329, "complexity": "1"}
{"back-translation": "class SmallestSubArraySum: def smallestSubWithSum(arr, n, x): curr_sum, min_len = 0, n + 1; start, end = 0, 0; while end < n: while curr_sum <= x and end < n: curr_sum += arr[end]; end += 1; while curr_sum > x and start < n: if end - start < min_len: min_len = end - start; curr_sum -= arr[start]; start += 1; return min_len; def main(args): arr1 = [1, 4, 45, 6, 10, 19]; x = 51; n1 = len(arr1); res1 = smallestSubWithSum(arr1, n1, x); if res1 == n1 + 1: print('Not Possible'); else: print(res1); arr2 = [1, 10, 5, 2, 7]; n2 = len(arr2); x = 9; res2 = smallestSubWithSum(arr2, n2, x); if res2 == n2 + 1: print('Not Possible'); else: print(res2); arr3 = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250]; n3 = len(arr3); x = 280; res3 = smallestSubWithSum(arr3, n3, x); if res3 == n3 + 1: print('Not Possible'); else: print(res3);", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\ncurr_sum += arr[end++]; \n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 330, "complexity": "1"}
{"back-translation": "{'src': 'class A:\\n    def main():\\n        infile = input()\\n        N, L, A = map(int, input().split())\\n        arr1 = []\\n        arr2 = []\\n        for i in range(N):\\n            x, y = map(int, input().split())\\n            arr1.append(x)\\n            arr2.append(y)\\n        res = 0\\n        for i in range(1, N):\\n            res += (arr1[i] - arr2[i-1]) // A\\n        if N > 0:\\n            res += (L - arr2[N-1]) // A + arr1[0] // A\\n        else:\\n            res += L // A\\n        print(res)\\n'}", "src": "public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n         }\n         int res = 0;\n         for(int i=1; i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "index": 331, "complexity": "1"}
{"back-translation": "exec(''.join([chr(123), chr(39), chr(98), chr(97), chr(99), chr(107), chr(45), chr(116), chr(114), chr(97), chr(110), chr(115), chr(108), chr(97), chr(116), chr(101), chr(39), chr(58), chr(32), chr(39), chr(39), chr(39), chr(44), chr(39), chr(112), chr(117), chr(98), chr(108), chr(105), chr(99), chr(32), chr(99), chr(108), chr(97), chr(115), chr(115), chr(32), chr(67), chr(111), chr(100), chr(101), chr(70), chr(111), chr(114), chr(99), chr(101), chr(115), chr(92), chr(110), chr(92), chr(116), chr(92), chr(112), chr(117), chr(98), chr(108), chr(105), chr(99), chr(32), chr(115), chr(116), chr(97), chr(116), chr(105), chr(99), chr(32), chr(118), chr(111), chr(105), chr(100), chr(32), chr(109), chr(97), chr(105), chr(110), chr(40), chr(83), chr(116), chr(114), chr(105), chr(110), chr(103), chr(91), chr(93), chr(32), chr(97), chr(114), chr(103), chr(115), chr(41), chr(58), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(105), chr(110), chr(116), chr(32), chr(110), chr(32), chr(61), chr(32), chr(105), chr(110), chr(112), chr(117), chr(116), chr(40), chr(41), chr(46), chr(110), chr(101), chr(120), chr(116), chr(40), chr(41), chr(59), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(83), chr(116), chr(114), chr(105), chr(110), chr(103), chr(32), chr(115), chr(32), chr(61), chr(32), chr(105), chr(110), chr(112), chr(117), chr(116), chr(40), chr(41), chr(46), chr(110), chr(101), chr(120), chr(116), chr(40), chr(41), chr(59), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(98), chr(111), chr(111), chr(108), chr(101), chr(97), chr(110), chr(32), chr(100), chr(111), chr(110), chr(101), chr(32), chr(61), chr(32), chr(70), chr(97), chr(108), chr(115), chr(101), chr(59), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(102), chr(111), chr(114), chr(32), chr(40), chr(105), chr(110), chr(116), chr(32), chr(105), chr(32), chr(61), chr(32), chr(48), chr(59), chr(32), chr(105), chr(32), chr(60), chr(32), chr(115), chr(46), chr(108), chr(101), chr(110), chr(103), chr(116), chr(104), chr(41), chr(32), chr(45), chr(32), chr(49), chr(59), chr(32), chr(105), chr(43), chr(43), chr(41), chr(58), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(105), chr(102), chr(32), chr(40), chr(115), chr(46), chr(99), chr(104), chr(97), chr(114), chr(40), chr(105), chr(41), chr(32), chr(33), chr(61), chr(32), chr(115), chr(46), chr(99), chr(104), chr(97), chr(114), chr(40), chr(105), chr(32), chr(43), chr(32), chr(49), chr(41), chr(41), chr(58), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(83), chr(121), chr(115), chr(116), chr(101), chr(109), chr(46), chr(111), chr(117), chr(116), chr(40), chr(34), chr(78), chr(79), chr(34), chr(41), chr(59), chr(92), chr(110), chr(92), chr(110), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(92), chr(116), chr(41)])", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "index": 332, "complexity": "1"}
{"back-translation": "class GFG: def findMaxAverage(arr, n, k): if k > n: return -1 csum = [0] * n csum[0] = arr[0] for i in range(1, n): csum[i] = csum[i - 1] + arr[i] max_sum, max_end = csum[k - 1], k - 1 for i in range(k, n): curr_sum = csum[i] - csum[i - k] if curr_sum > max_sum: max_sum = curr_sum max_end = i return max_end - k + 1 def main(args): arr = [1, 12, -5, -6, 50, 3] k = 4 n = len(arr) print('The maximum average subarray of length ' + str(k) + ' begins at index ' + str(findMaxAverage(arr, n, k)))", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nint\n[]csum = \nnew\nint\n[n]; \n\n\ncsum[\n0\n] = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ncsum[i] = csum[i - \n1\n] + arr[i]; \n\n\n\n\n\n\nint\nmax_sum = csum[k - \n1\n], \n\nmax_end = k - \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nint\ncurr_sum = csum[i] - \n\ncsum[i - k]; \n\nif\n(curr_sum > max_sum) \n\n{ \n\nmax_sum = curr_sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"The maximum \"\n\n+ \n\"average subarray of length \"\n\n+ k + \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 333, "complexity": "1"}
{"back-translation": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 334, "complexity": "1"}
{"back-translation": "class ehab3:\n    def main(args):\n        n = int(input())\n        a = [int(input()) for _ in range(n)]\n        print(n + 1)\n        c = 0\n        for i in range(n-1, -1, -1):\n            cd = n + i - ((a[i] + c) % n)\n            print('1 ' + str(i + 1) + ' ' + str(cd))\n            c += cd\n        print('2 ' + str(n) + ' ' + str(n))", "src": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "index": 335, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint num=sc.nextInt();\\n\\t\\tlong sum1=0,sum2=0;\\n\\t\\tfor(int i=0;i<num*2;i++){\\n\\t\\t\\tsum1+=sc.nextInt();\\n\\t\\t\\tsum2+=sc.nextInt();\\n\\t\\t}\\n\\t\\tSystem.out.println(sum1/num+\" \"+sum2/num);\\n\\t}\\n}', 'complexity': '1', 'index': 336}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tfor(int i=0;i<num*2;i++){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}", "index": 336, "complexity": "1"}
{"back-translation": "class UniformString:\n    in = BufferedReader(InputStreamReader(System.in))\n    out = PrintWriter(BufferedOutputStream(System.out))\n    st = None\n    \n    def main(args):\n        t = nextInt()\n        for i in range(t):\n            n = nextInt()\n            k = nextInt()\n            s = ''\n            for j in range(n):\n                s += chr(ord('a') + (j % k))\n            print(s)\n    \n    def nextLine():\n        return in.readLine()\n\n    def nextString():\n        while st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readLine())\n        return st.nextToken()\n\n    def nextInt():\n        return int(nextString())\n    \n    def nextLong():\n        return int(nextString())\n    \n    def intArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextInt()\n        return a\n\n    def intArray(n, m):\n        a = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                a[i][j] = nextInt()\n        return a\n\n    def longArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextLong()\n        return a\n", "src": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 337, "complexity": "1"}
{"back-translation": "class\narr_rot \n{ \n\n\n\n\n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n\n\nint\nmod = k % n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn=arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "src": "class\narr_rot \n{ \n\n\n\n\n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n\n\nint\nmod = k % n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "index": 338, "complexity": "1"}
{"back-translation": "class\nGFG: \n    @staticmethod \n    def findMinOps(arr, n): \n        ans = 0 \n        i, j = 0, n-1 \n        while i <= j: \n            if arr[i] == arr[j]: \n                i += 1 \n                j -= 1 \n            elif arr[i] > arr[j]: \n                j -= 1 \n                arr[j] += arr[j+1] \n                ans += 1 \n            else: \n                i += 1 \n                arr[i] += arr[i-1] \n                ans += 1 \n        return ans \n\n    @staticmethod \n    def main(args): \n        arr = [1, 4, 5, 9, 1] \n        print('Count of minimum operations is ' + str(GFG.findMinOps(arr, len(arr))))", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMinOps(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\nans = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n,j=n-\n1\n; i<=j;) \n\n{ \n\n\n\n\n\nif\n(arr[i] == arr[j]) \n\n{ \n\ni++; \n\nj--; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > arr[j]) \n\n{ \n\n\n\nj--; \n\narr[j] += arr[j+\n1\n] ; \n\nans++; \n\n} \n\n\n\n\nelse\n\n{ \n\ni++; \n\narr[i] += arr[i-\n1\n]; \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n4\n, \n5\n, \n9\n, \n1\n} ; \n\nSystem.out.println(\n\"Count of minimum operations is \"\n+ \n\nfindMinOps(arr, arr.length)); \n\n\n} \n}", "index": 339, "complexity": "1"}
{"back-translation": "{'src': 'public class GennadyAndACardGame {\\n\\tpublic static void main(String[] args) throws IOException {\\n\\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\\n\\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\\n\\t\tString line =null;\\n\\t\tString[] n={};\\n\\t\tString s=\"NO\";\\n\\t\twhile((line=bufr.readLine())!=null)    {\\n\\t\\t\\tif(\"over\".equals(line))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tn=bufr.readLine().split(\" \");\\n\\t\\t\\tfor(int i=0;i<n.length;i++){\n\\t\\t\\t\\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\\n\\t\\t\\t\\t\\ts=\"YES\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tSystem.out.println(s);\\n\\t\\t\\ts=\"NO\";\\n\\t\\t\\tbufw.flush();\\n\\t\\t}\\n\\t\\tbufw.close();                          \\n\\t}\\n}', 'complexity': '1', 'index': 340}", "src": "public class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tn=bufr.readLine().split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();                          \n\t}\n}", "index": 340, "complexity": "1"}
{"back-translation": "class FindSmallestInteger: def findSmallest(arr, n): res = 1 for i in range(n): if arr[i] <= res: res += arr[i] return res def main(args): small = FindSmallestInteger() arr1 = [1, 3, 4, 5] n1 = len(arr1) print(small.findSmallest(arr1, n1)) arr2 = [1, 2, 6, 10, 11, 15] n2 = len(arr2) print(small.findSmallest(arr2, n2)) arr3 = [1, 1, 1, 1] n3 = len(arr3) print(small.findSmallest(arr3, n3)) arr4 = [1, 1, 3, 4] n4 = len(arr4) print(small.findSmallest(arr4, n4))", "src": "class\nFindSmallestInteger \n{ \n\n\n\n\n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n}", "index": 341, "complexity": "1"}
{"back-translation": "{'src': 'public class CodeForces {\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tint d = in.nextInt(), sum = in.nextInt();\\n\\t\\tList<Data> data = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < d; ++i) {\\n\\t\\t\\tint min = in.nextInt(), max = in.nextInt();\\n\\t\\t\\tint centre = (min + max) / 2;\\n\\t\\t\\tdata.add(new Data(centre - min, max - centre, centre));\\n\\t\\t\\tsum -= centre;\\n\\t\\t}\\n\\t\\t\\n\\t\\tIterator<Data> it = data.iterator();\\n\\t\\t\\n\\t\\twhile (sum != 0) {\\n\\t\\t\\tif (!it.hasNext()) {\\n\\t\\t\\t\\tSystem.out.println(\\", "src": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "index": 342, "complexity": "1"}
{"back-translation": "{'src': 'class Main:\\n    \\n    class Scanner:\\n        def __init__(self):\\n            self.br = sys.stdin\\n            self.st = ''\\n\\n        def next(self):\\n            if not self.st:\\n                self.st = input()\\n            return self.st\\n\\n        def nextLine(self):\\n            while not self.st:\\n                self.st = input()\\n            r = self.st\\n            self.st = input()\\n            return r\\n\\n        def nextInt(self):\\n            return int(self.next())\\n\\n    in_ = Scanner()\\n    out = sys.stdout\\n\\n    def main():\\n        n = in_.nextInt()\\n        l = [0]*n\\n        p = -1000000\\n        d_min = 1000000\\n        min_ = 1000000000\\n        for i in range(n):\\n            l[i] = in_.nextInt()\\n            min_ = min(min_, l[i])\\n        for i in range(n):\\n            if l[i] == min_:\\n                d_min = min(d_min, i - p)\\n                p = i\\n        out.write(str(d_min))\\n\\n    if __name__ == '__main__':\\n        main()", "complexity": "1", "index": 343, "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}"}
{"back-translation": "{'src': 'public class Codechef {\\n     \\n\\n  public static void main(String[] args) throws IOException {\\n\\tScanner sc=new Scanner(System.in);\\n    int n=sc.nextInt();\\n    int a=sc.nextInt();\\n    int b=sc.nextInt();\\n      int res=0;\\n     for(int i=1;i<n;i++)\\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\\n     System.out.println(res);\\n  }\\n\\n   }', 'complexity': '1', 'index': 344}", "src": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }", "index": 344, "complexity": "1"}
{"back-translation": "{'src': 'public class practise {\\n    static final int N = 31;\\n    static Scanner sc = new Scanner(System.in);\\n    static PrintWriter out = new PrintWriter(System.out,true);\\n    static long c[] = new long[N];\\n    static int w[] = new int[N];\\n    public static void main(String[] args) {\\n        w[0] = 1;\\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\\n        int n = sc.nextInt(); int l = sc.nextInt();\\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\\n        for(int i=1;i<N;i++) {\\n            c[i] = min(c[i-1]*2,c[i]);\\n        }\\n        long ans = 0;\\n        for(int i=0;i<N;i++) {\\n            if( (l&w[i])!=0) {\\n                ans += c[i];\\n            }\\n        }\\n        long m = 0;\\n        for(int i=N - 1;i>=0;i--) {\\n            if((l&w[i])!=0) {\\n                m += c[i];\\n            } else {\\n                ans = min(ans,m+c[i]);\\n            }\\n        }\\n        out.println(ans);\\n    }\\n\\n    static long min(long a,long b) {\\n        return a<b?a:b;\\n    }\\n}', 'complexity': '1', 'index': 345}", "src": "public class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}", "index": 345, "complexity": "1"}
{"back-translation": "exec(\"from array import *\\nfrom java.util import *\\nscan=Scanner(System.in)\\nn=scan.nextInt()\\nc=array('c', ['o']*n)\\nx=1\\ny=1\\nwhile(y<=n):\\n    c[y-1]='O'\\n    z=x+y\\n    x=y\\n    y=z\\nans=c.tostring()\\nprint(ans)\\n\")", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "index": 346, "complexity": "1"}
{"back-translation": "{'src': 'public class java{\\n          public static void main(String[]arg) {\\n        \\t Scanner sc=new Scanner(System.in); \\n        \\t int x=sc.nextInt();\\n        \\t String s=sc.next();\\n        \\t boolean f=true;\\n        \\t boolean f2=true;\\n        \\t boolean f3=true;\\n        \\t boolean f4=true;\\n        \\t int v=0;\\n        \\t for(int i=0;i<s.length()-1;i++) {\\n        \\t\\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\\n        \\t\\t\\t f=false;\\n        \\t\\t\\t break;\\n        \\t\\t }else {\\n        \\t\\t\\t f=true;\\n        \\t\\t }\\n        \\t }\\n        \\t\\n        \\t \\n        \\t for(int i=0;i<s.length();i++) {\\n        \\t\\t if(s.charAt(i)=='?') {\\n        \\t\\t\\t \\n        \\t\\t\\t if(i==0||i==s.length()-1) {\\n        \\t\\t\\t\\t f2=true; \\n        \\t\\t\\t\\t v++;\\n        \\t\\t\\t }else if(s.charAt(i)==s.charAt(i+1)) {\\n        \\t\\t\\t\\t\\t f2=true;\\n        \\t\\t\\t\\t\\t v++;\\n        \\t\\t\\t          }\\n        \\t\\t\\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\\n        \\t\\t\\t\\t\\t f2=true;\\n        \\t\\t\\t\\t\\t v++;\\n        \\t\\t\\t         }\\n        \\t\\t\\t }else {\\n        \\t\\t\\t\\t if(v>0) f2=true;\\n        \\t\\t\\t\\t else f2=false;\\n        \\t\\t\\t }\\n        \\t\\t }\\n        \\t \\n        \\tif(f&&f2) {\\n        \\t\\tSystem.out.println(\"YES\");\\n        \\t}else {\\n        \\t\\tSystem.out.println(\"NO\");\\n        \\t}\\n          }\\n          \\n}', 'complexity': '1', 'index': 347}", "src": "public class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}", "index": 347, "complexity": "1"}
{"back-translation": "class Test:\n    @staticmethod\n    def longestCommonSum(n):\n        maxLen = 0\n        preSum1 = 0\n        preSum2 = 0\n        diff = [-1] * (2*n + 1)\n        for i in range(len(diff)):\n            diff[i] = -1\n        for i in range(n):\n            preSum1 += arr1[i]\n            preSum2 += arr2[i]\n            curr_diff = preSum1 - preSum2\n            diffIndex = n + curr_diff\n            if curr_diff == 0:\n                maxLen = i + 1\n            elif diff[diffIndex] == -1:\n                diff[diffIndex] = i\n            else:\n                len = i - diff[diffIndex]\n                if len > maxLen:\n                    maxLen = len\n        return maxLen\n\n    @staticmethod\n    def main(args):\n        print(\"Length of the longest common span with same sum is \", end='')\n        print(Test.longestCommonSum(len(arr1)))\n\nTest.arr1 = [0, 1, 0, 1, 1, 1, 1]\nTest.arr2 = [1, 1, 1, 1, 1, 0, 1]", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n\n\n\n\n\n\n\n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n\n\n\n\n\n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n\n\n\n\n\n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n\n\n\n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n\n\nelse\n\n{ \n\n\n\nint\nlen = i - diff[diffIndex]; \n\n\n\n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 348, "complexity": "1"}
{"back-translation": "{'src': 'public class HackerRank {\\n\\tpublic static void main(String[] args) {\\n\\t\tScanner in = new Scanner(System.in);\\n\\t\tint n, f[], c=0;\\n\\t\tn = in.nextInt();\\n\\t\tf = new int[n];\\n\\t\twhile (--n>0){\\n\\t\t\tf[in.nextInt()-1] ++;\\n\\t\t\tf[in.nextInt()-1]++;\\n\\t\t\tin.nextLine();\\n\\t\t}\\n\\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\\n\\t\tSystem.out.println(c);\\n\\t}\\n\\n}', 'complexity': '1', 'index': 349}", "src": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}", "index": 349, "complexity": "1"}
{"back-translation": "{'src': 'public class loser\\n{\\n    static class InputReader {\\n        public BufferedReader br;\\n        public StringTokenizer token;\\n        public InputReader(InputStream stream)\\n        {\\n            br=new BufferedReader(new InputStreamReader(stream),32768);\\n            token=null;\\n        }\\n\\n        public String next()\\n        {\\n            while(token==null || !token.hasMoreTokens())\\n            {\\n                try\\n                {\\n                    token=new StringTokenizer(br.readLine());\\n                }\\n                catch(IOException e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            }\\n            return token.nextToken();\\n        }\\n\\n        public int nextInt()\\n        {\\n            return Integer.parseInt(next());\\n        }\\n\\n        public long nextLong()\\n        {\\n            return Long.parseLong(next());\\n        }\\n    }\\n    static class card{\\n        long a;\\n        int i;\\n        public card(long a,int i)\\n        {\\n            this.a=a;\\n            this.i=i;\\n        }\\n    }\\n    static class sort implements Comparator<pair>\\n    {\\n        public int compare(pair o1,pair o2)\\n        {\\n            if(o1.a!=o2.a)\\n                return (int)(o1.a-o2.a);\\n            else\\n                return (int)(o1.b-o2.b);\\n        }\\n    }\\n    static void shuffle(long a[])\\n    {\\n        List<Long> l=new ArrayList<>();\\n        for(int i=0;i<a.length;i++)\\n            l.add(a[i]);\\n        Collections.shuffle(l);\\n        for(int i=0;i<a.length;i++)\\n            a[i]=l.get(i);\\n    }\\n\\n    \\n    \\n    static class pair{\\n        int a,b;\\n        public pair(int a,int b)\\n        {\\n            this.a=a;\\n            this.b=b;\\n        }\\n    }\\n    public  static void main(String[] args) \\n    {\\n        InputReader sc=new InputReader(System.in);\\n        char c[]=sc.next().toCharArray();\\n        int l=c.length;\\n        int a[]=new int[3];\\n        for(int i=0;i<l;i++)\\n        {\\n            a[c[i]-'a']++;\\n           if(i>0 && c[i]<c[i-1])\\n           {\\n               System.out.println('NO');\\n               System.exit(0);\\n           }\\n        }\\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\\n        System.out.println('YES');\\n        else\\n        System.out.println('NO');\\n    }\\n}', 'complexity': '1', 'index': 350}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    \n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        for(int i=0;i<l;i++)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "index": 350, "complexity": "1"}
{"back-translation": "{'src': 'public class GFG {\\n\\tpublic static void main(String[] args) {\\n\\t    Scanner sc = new Scanner(System.in);\\n\\t    int n = sc.nextInt();\\n\\t    int a = sc.nextInt();\\n\\t    int b = sc.nextInt();\\n\\t    int c = sc.nextInt();\\n\\t    int ans = 0;\\n\\t    int t = sc.nextInt();\\n\\t    int[] arr = new int[n];\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int nn = sc.nextInt();\\n\\t        ans += a;\\n\\t        if (b < c) {\\n\\t            ans += (t - nn) * (c - b);\\n\\t        }\\n\\t    }\\n\\t    System.out.println(ans);\\n\\t}\\n}', 'complexity': '1', 'index': 351}", "src": "public class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "index": 351, "complexity": "1"}
{"back-translation": "{'src': 'public class C {\\n\\tpublic static void main(String[] args) throws IOException {\\n\\n\\t\\t\\n\\t\\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\\n\\t\\t\\n\\t\\t\\n\\t\\tint n = sc.nextInt();\\n\\t\\tint[] counts = new int[60];\\n\\t\\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < 60; i++) {\\n\\t\\t\\tnums.add(new ArrayDeque<>());\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tlong num = sc.nextLong();\\n\\t\\t\\tfor (int j = 1; j <= 60; ++j) {\\n\\t\\t\\t\\tif (num < (1L<<j)) {\\n\\t\\t\\t\\t\\tnums.get(j-1).add(num);\\n\\t\\t\\t\\t\\t++counts[j-1];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong curr = 0;\\n\\t\\tStringBuilder ans = new StringBuilder();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j <= 60; ++j) {\\n\\t\\t\\t\\tif (j==60) {\\n\\t\\t\\t\\t\\tSystem.out.println(\\\"No\\\");\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (counts[j]==0||(curr&(1L<<j))!=0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tlong num = nums.get(j).removeFirst();\\n\\t\\t\\t\\t--counts[j];\\n\\t\\t\\t\\tcurr ^= num;\\n\\t\\t\\t\\tif (i>0)\\n\\t\\t\\t\\t\\tans.append(\\\" \\\");\\n\\t\\t\\t\\tans.append(num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(\\\"Yes\\\");\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}', 'complexity': '1', 'index': 352}", "src": "public class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 352, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "index": 353, "complexity": "1"}
{"back-translation": "print('Enter the number of elements:')\nn = int(input())\n\nf = [0] * 1001\na = list(map(int, input().split()))\n\nh = []\ncounter = 0\nfor i in range(n):\n    if f[a[i]] == 0:\n        counter += 1\n        h.append(a[i])\n        f[a[i]] = 1\n    \nprint(counter)\nfor num in h:\n    print(num, end=' ')", "src": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "index": 354, "complexity": "1"}
{"back-translation": "class MergeArrays: def moveToEnd(mPlusN, size): i, j = size - 1 for i in range(size - 1, -1, -1): if mPlusN[i] != -1: mPlusN[j] = mPlusN[i] j -= 1 def merge(mPlusN, N, m, n): i = n j = 0 k = 0 while k < (m + n): if (i < (m + n) and mPlusN[i] <= N[j]) or (j == n): mPlusN[k] = mPlusN[i] k += 1 i += 1 else: mPlusN[k] = N[j] k += 1 j += 1 def printArray(arr, size): for i in range(0, size): print(arr[i], end=' ') print('') def main(args): mergearray = MergeArrays() mPlusN = [2, 8, -1, -1, -1, 13, -1, 15, 20] N = [5, 7, 9, 25] n = len(N) m = len(mPlusN) - n mergearray.moveToEnd(mPlusN, m + n) mergearray.merge(mPlusN, N, m, n) mergearray.printArray(mPlusN, m + n) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nMergeArrays \n{ \n\n\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n\n\nint\nj = \n0\n; \n\n\n\n\nint\nk = \n0\n; \n\n\n\n\nwhile\n(k < (m + n)) \n\n{ \n\n\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n\n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n}", "index": 355, "complexity": "1"}
{"back-translation": "{'src': 'public class Practice {\\n\\t\\n\\t    \\n\\n\\t\\tpublic static void main(String []args)\\n\\t\\t{\\n\\t\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tString s=sc.nextLine();\\n\\t\\t\\tint n=0;\\n\\t\\t\\tint m=0;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.charAt(i)=='-')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tn++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(m==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.println(\"YES\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\tif(n//m==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.println(\"YES\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.println(\"NO\");\\n\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\n}', 'complexity': '1', 'index': 356}", "src": "public class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 356, "complexity": "1"}
{"back-translation": "class Geeks: def rvereseArray(arr, start, end): while start < end: temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start += 1; end -= 1; def printArray(arr, size): for i in range(0, size): print(arr[i], end=' '); def splitArr(arr, k, n): rvereseArray(arr, 0, n - 1); rvereseArray(arr, 0, n - k - 1); rvereseArray(arr, n - k, n - 1); if __name__ == '__main__': arr = [12, 10, 5, 6, 52, 36]; n = len(arr); k = 2; splitArr(arr, k, n); printArray(arr, n);", "src": "class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n\n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n}", "index": 357, "complexity": "1"}
{"back-translation": "arr = [i + 1 for i in range(n)]\n\nprint(' '.join(map(str, arr)))", "src": "public\nclass\nGFG { \n\n\n\n\n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nsortit(arr, n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 358, "complexity": "1"}
{"back-translation": "{'src': 'public def mohamedy23():\\n\\tdef main(args):\\n\\t\\tsc=Scanner(System.in)\\n\\t\\tn=sc.nextInt()\\n\\t\\ts=sc.next()\\n\\t\\ti=len(s)-1\\n\\t\\t\\n\\t\\tif n==1:\\n\\t\\t\\tif s[0]==\\'1\\\t\t:\\n\\t\\t\\t\\tprint(\"YES\")\\n\\t\\t\\t\\treturn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(\"NO\")\\n\\t\\t\\t\\treturn\\n\\t\\telif n==2:\\n\\t\\t\\tif \\\"00\\\" in s or \\\"11\\\" in s:\\n\\t\\t\\t\\tprint(\"NO\")\\n\\t\\t\\t\\treturn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(\"Yes\")\\n\\t\\t\\t\\treturn\\n\\t\\telif \\\"000\\\" in s or \\\"11\\\" in s:\\n\\t\\t\\tprint(\"NO\")\\n\\t\\t\\treturn\\n\\t\\telif s[0]==\\'0\\' and s[1]==\\'0\\' and s[2]==\\'1\\':\\n\\t\\t\\tprint(\"NO\")\\n\\t\\t\\treturn\\n\\t\\telif s[-1]==\\'0\\' and s[-2]==\\'0\\':\\n\\t\\t\\tprint(\"NO\")\\n\\t\\t\\treturn\\n\\t\\tprint(\"YES\")\\n'", "src": "public class mohamedy23\n\t\t{\n\t      public static void main (String args[])\n\t\t    {\n\t\t    \tScanner sc=new Scanner(System.in);\n\t\t    \tint n=sc.nextInt();String s=sc.next();int i=s.length()-1;\n\t\t    \t\n\t\t    \tif(n==1) {\n\t\t    \t\tif(s.charAt(0)=='1') {\n\t\t    \t\t\tSystem.out.print(\"YES\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}\n\t\t    \t}else if(n==2) {\n\t\t    \t\tif(s.contains(\"00\")||s.contains(\"11\")) {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"Yes\");return;\n\t\t    \t\t}\n\t\t    \t}\n\t\t    \telse if(s.contains(\"000\")||s.contains(\"11\")) {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(0)=='0'&&s.charAt(1)=='0'&&s.charAt(2)=='1') {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(i)=='0'&&s.charAt(i-1)=='0') {\n\t\t    \t\tSystem.out.print(\"NO\");\n\t\t    \t\treturn;\n\t\t    \t\t}\n\t\t    \t System.out.print(\"YES\");\n\t\t    }\n\t\t}", "index": 359, "complexity": "1"}
{"back-translation": "", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "index": 360, "complexity": "1"}
{"back-translation": "class\nGFG: \n    @staticmethod\n    def sortedAfterSwap(A, B, n): \n        i, j = 0, 0\n        while i < n - 1: \n            if B[i]: \n                j = i\n                while B[j]: \n                    j += 1\n                A[i:j+1] = sorted(A[i:j+1]) \n                i = j\n            i += 1\n        for i in range(n): \n            if A[i] != i + 1: \n                return False\n        return True\n\n    @staticmethod\n    def main(args): \n        A = [1, 2, 5, 3, 4, 6]\n        B = [False, True, True, True, False]\n        n = len(A)\n        if GFG.sortedAfterSwap(A, B, n): \n            print(\"A can be sorted\")\n        else: \n            print(\"A can not be sorted\")\n\nGFG.main([])", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n\n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n}", "index": 361, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n\\n    static StringBuilder data = new StringBuilder();\\n    final static FastReader in = new FastReader();\\n\\n\\n    public static void main(String[] args) {\\n        int n = in.nextInt(), k = in.nextInt(), t;\\n        int[] a = new int[101];\\n        int answ = 0;\\n        for (long i = 0; i < n; i++) {\\n            t = in.nextInt();\\n            a[t]++;\\n            if (a[t] < 2) {\\n                if (answ < k) {\\n                    data.append(i + 1).append(\\", ",\\n                    ''.join(map(str, [i + 1 for i in range(n) if i not in dicts])) + '   ' if len(dicts) < k else '').split()[:k] = []\\n                }\\n            }\\n        }\\n        if (len(dicts) == k) {\\n            print('YES')\\n            print(data)\\n        } else {\\n            print('NO')\\n        }\\n    }\\n}', 'complexity': '1', 'index': 610}": "", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 362, "complexity": "1"}
{"back-translation": "class Main:\n    def main(args):\n        io = IO()\n        s = io.nextLine()\n        if len(s) < 3:\n            io.println('No')\n        else:\n            b = [0] * 200\n            for i in range(2, len(s)):\n                b['.'] = b['A'] = b['B'] = b['C'] = 0\n                b[s[i - 2]] = 1\n                b[s[i - 1]] = 1\n                b[s[i]] = 1\n                if b['A'] + b['B'] + b['C'] == 3:\n                    io.println('Yes')\n                    return\n            io.println('No')\n\nclass IO:\n    def __init__(self):\n        self.din = BufferedInputStream(System.in)\n        self.BUFFER_SIZE = 1 << 16\n        self.buffer = bytearray()\n        self.byteRead = 0\n        self.bufferPoint = 0\n        self.builder = ''\n        self.pw = PrintWriter(BufferedWriter(OutputStreamWriter(System.out)))\n\n    def read(self):\n        if self.bufferPoint >= self.byteRead:\n            try:\n                self.byteRead = self.din.read(self.buffer, self.bufferPoint, self.BUFFER_SIZE)\n            except IOException as e:\n                e.printStackTrace()\n            if self.byteRead == -1:\n                self.buffer[0] = -1\n        return self.buffer[self.bufferPoint++]\n\n    def peek(self):\n        if self.byteRead == -1:\n            return -1\n        if self.bufferPoint >= self.byteRead:\n            try:\n                self.byteRead = self.din.read(self.buffer, self.bufferPoint, self.BUFFER_SIZE)\n            except IOException as e:\n                return -1\n            if self.byteRead <= 0:\n                return -1\n        return self.buffer[self.bufferPoint]\n\n    def hasNext(self):\n        c = self.peek()\n        while c != -1 and c <= ' ':\n            self.read()\n            c = self.peek()\n        return c != -1\n\n    def nextChar(self):\n        c = self.read()\n        while c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1:\n            c = self.read()\n        return chr(c)\n\n    def nextDouble(self):\n        ret = 0\n        div = 1\n        c = self.read()\n        while c <= ' ':\n            c = self.read()\n        neg = (c == '-')\n        if neg:\n            c = self.read()\n        while True:\n            ret = ret * 10 + c - '0'\n            if '0' <= (c = self.read()) <= '9':\n                break\n        if c == '.':\n            while '0' <= (c = self.read()) <= '9':\n                ret += (c - '0') / (div *= 10)\n        if neg:\n            return -ret\n        return ret\n\n    def nextLine(self):\n        strBuf = bytearray(64)\n        cnt = 0\n        c = 0\n        while (c = self.read()) != -1:\n            if c == '\\n':\n                if cnt == 0:\n                    continue\n                else:\n                    break\n            if len(strBuf) == cnt:\n                strBuf.extend([0] * len(strBuf))\n            strBuf[cnt] = c\n            cnt += 1\n        return str(strBuf, 0, cnt)\n\n    def next(self):\n        strBuf = bytearray(64)\n        cnt = 0\n        c = 0\n        while (c = self.read()) != -1:\n            if c.isspace():\n                if cnt == 0:\n                    continue\n                else:\n                    break\n            if len(strBuf) == cnt:\n                strBuf.extend([0] * len(strBuf))\n            strBuf[cnt] = c\n            cnt += 1\n        return str(strBuf, 0, cnt)\n\n    def nextInt(self):\n        ans = 0\n        c = self.read()\n        while c <= ' ':\n            c = self.read()\n        neg = (c == '-')\n        if neg:\n            c = self.read()\n        while True:\n            ans = ans * 10 + c - '0'\n            if '0' <= (c = self.read()) <= '9':\n                break\n        self.bufferPoint -= 1\n        return -ans if neg else ans\n\n    def nextLong(self):\n        ans = 0\n        c = self.read()\n        while c <= ' ':\n            c = self.read()\n        neg = (c == '-')\n        if neg:\n            c = self.read()\n        while True:\n            ans = ans * 10 + c - '0'\n            if '0' <= (c = self.read()) <= '9':\n                break\n        self.bufferPoint -= 1\n        return -ans if neg else ans\n\n    def println(self, o):\n        self.pw.println(o)\n\n    def print(self, o):\n        self.pw.print(o)\n\n    def printf(self, format, objects):\n        self.pw.printf(format, objects)\n\n    def close(self):\n        self.pw.close()\n\n    def done(self, o):\n        self.print(o)\n        self.close()", "src": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "index": 363, "complexity": "1"}
{"back-translation": "class icpc:\n    def main(self):\n\n        s1 = input().split(\" \")\n        n = int(s1[0])\n        p = int(s1[1])\n        s = input()\n        stringBuilder = list(s)\n        flag = False\n        for i in range(n):\n            if i + p < n:\n                if s[i] != '.' and s[i + p] != '.' and s[i] != s[i + p]:\n                    flag = True\n                    break\n                elif s[i] == '.' and s[i + p] != '.':\n                    x = int(s[i + p]) - ord('0')\n                    ch = chr((x + 1) % 2 + 48)\n                    stringBuilder[i] = ch\n                    flag = True\n                    break\n                elif s[i] != '.' and s[i + p] == '.':\n                    x = int(s[i]) - ord('0')\n                    ch = chr((x + 1) % 2 + 48)\n                    stringBuilder[i + p] = ch\n                    flag = True\n                    break\n                elif s[i] == '.' and s[i + p] == '.':\n                    stringBuilder[i] = '1'\n                    stringBuilder[i + p] = '0'\n                    flag = True\n                    break\n        if flag:\n            for i in range(len(stringBuilder)):\n                if stringBuilder[i] == '.':\n                    stringBuilder[i] = '0'\n            print(''.join(stringBuilder))\n        else:\n            print(\"No\")\n\n\nclass StringAlgorithms:\n    def calculateZ(self, inputList):\n        Z = [0] * len(inputList)\n        left = 0\n        right = 0\n        for k in range(1, len(inputList)):\n            if k > right:\n                left = right = k\n                while right < len(inputList) and inputList[right] == inputList[right - left]:\n                    right += 1\n                Z[k] = right - left\n                right -= 1\n            else:\n                k1 = k - left\n                if Z[k1] < right - k + 1:\n                    Z[k] = Z[k1]\n                else:\n                    left = k\n                    while right < len(inputList) and inputList[right] == inputList[right - left]:\n                        right += 1\n                    Z[k] = right - left\n                    right -= 1\n        return Z\n\n    def matchPattern(self, text, pattern):\n        newString = [''] * (len(text) + len(pattern) + 1)\n        i = 0\n        for ch in pattern:\n            newString[i] = ch\n            i += 1\n        newString[i] = '$'\n        i += 1\n        for ch in text:\n            newString[i] = ch\n            i += 1\n        result = []\n        Z = self.calculateZ(newString)\n\n        for i in range(len(Z)):\n            if Z[i] == len(pattern):\n                result.append(i - len(pattern) - 1)\n        return result\n\n\nclass BasicFunctions:\n    def min(self, A):\n        minVal = float('inf')\n        for i in range(len(A)):\n            minVal = min(minVal, A[i])\n        return minVal\n\n    def max(self, A):\n        maxVal = float('-inf')\n        for i in range(len(A)):\n            maxVal = max(maxVal, A[i])\n        return maxVal\n\n\nclass Name:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def compareTo(self, ob):\n        if self.x < ob.x:\n            return -1\n        elif self.x > ob.x:\n            return 1\n        return 0\n\n\nclass Matrix:\n    def __init__(self, a, b, c, d):\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n\nclass Game:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def compareTo(self, ob):\n        if self.x < ob.x:\n            return -1\n        elif self.x > ob.x:\n            return 1\n        else:\n            if self.y < ob.y:\n                return -1\n            elif self.y > ob.y:\n                return 1\n            else:\n                return 0\n\n\nclass MergeSortInt:\n    def merge(self, arr, l, m, r):\n        n1 = m - l + 1\n        n2 = r - m\n\n        L = [0] * n1\n        R = [0] * n2\n\n        for i in range(n1):\n            L[i] = arr[l + i]\n        for j in range(n2):\n            R[j] = arr[m + 1 + j]\n\n        i = 0\n        j = 0\n        k = l\n        while i < n1 and j < n2:\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n    def sort(self, arr, l, r):\n        if l < r:\n            m = (l + r) // 2\n            self.sort(arr, l, m)\n            self.sort(arr, m + 1, r)\n            self.merge(arr, l, m, r)\n\n\nclass MergeSortLong:\n    def merge(self, arr, l, m, r):\n        n1 = m - l + 1\n        n2 = r - m\n\n        L = [0] * n1\n        R = [0] * n2\n\n        for i in range(n1):\n            L[i] = arr[l + i]\n        for j in range(n2):\n            R[j] = arr[m + 1 + j]\n\n        i = 0\n        j = 0\n        k = l\n        while i < n1 and j < n2:\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n    def sort(self, arr, l, r):\n        if l < r:\n            m = (l + r) // 2\n            self.sort(arr, l, m)\n            self.sort(arr, m + 1, r)\n            self.merge(arr, l, m, r)\n\n\nclass Node:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def equals(self, ob):\n        if ob is None:\n            return False\n        if not isinstance(ob, Node):\n            return False\n        if ob is self:\n            return True\n        if self.a == ob.a and self.b == ob.b:\n            return True\n        return False\n\n    def hashCode(self):\n        return len(self.a)\n\n\nclass Reader:\n    def __init__(self):\n        self.BUFFER_SIZE = 1 << 16\n        self.din = sys.stdin\n        self.buffer = [0] * self.BUFFER_SIZE\n        self.bufferPointer = 0\n        self.bytesRead = 0\n\n    def readLine(self):\n        buf = [0] * 64\n        cnt = 0\n        while True:\n            c = self.read()\n            if c == -1:\n                break\n            if c == ord('\\n'):\n                break\n            buf[cnt] = c\n            cnt += 1\n        return ''.join(map(chr, buf[:cnt]))\n\n    def nextInt(self):\n        ret = 0\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = c == ord('-')\n        if neg:\n            c = self.read()\n        while True:\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n            if not (c >= ord('0') and c <= ord('9')):\n                break\n        if neg:\n            return -ret\n        return ret\n\n    def nextLong(self):\n        ret = 0\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = c == ord('-')\n        if neg:\n            c = self.read()\n        while True:\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n            if not (c >= ord('0') and c <= ord('9')):\n                break\n        if neg:\n            return -ret\n        return ret\n\n    def nextDouble(self):\n        ret = 0\n        div = 1\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = c == ord('-')\n        if neg:\n            c = self.read()\n        while True:\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n            if c >= ord('0') and c <= ord('9'):\n                continue\n            if c != ord('.'):break\n            while True:\n                c = self.read()\n                if c >= ord('0') and c <= ord('9'):\n                    ret += (c - ord('0')) / div\n                    div *= 10\n                else:\n                    break\n        if neg:\n            return -ret\n        return ret\n\n    def fillBuffer(self):\n        self.bytesRead = sys.stdin.read(self.buffer, self.bufferPointer = 0, self.BUFFER_SIZE)\n        if self.bytesRead == -1:\n            self.buffer[0] = -1\n\n    def read(self):\n        if self.bufferPointer == self.bytesRead:\n            self.fillBuffer()\n        return self.buffer[self.bufferPointer]\n\n    def close(self):\n        if self.din is None:\n            return\n        self.din.close()\n\n\nclass FenwickTree:\n    def update(self, fenwickTree, delta, index):\n        index += 1\n        while index < len(fenwickTree):\n            fenwickTree[index] += delta\n            index += index & (-index)\n\n    def prefixSum(self, fenwickTree, index):\n        sumVal = 0\n        index += 1\n        while index > 0:\n            sumVal += fenwickTree[index]\n            index -= index & (-index)\n        return sumVal\n\n\nclass SegmentTree:\n    def nextPowerOfTwo(self, num):\n        if num == 0:\n            return 1\n        if num > 0 and (num & (num - 1)) == 0:\n            return num\n        while num & (num - 1) > 0:\n            num = num & (num - 1)\n        return num << 1\n\n    def createSegmentTree(self, inputList):\n        np2 = self.nextPowerOfTwo(len(inputList))\n        segmentTree = [float('-inf')] * (np2 * 2 - 1)\n\n        self.constructSegmentTree(segmentTree, inputList, 0, len(inputList) - 1, 0)\n        return segmentTree\n\n    def constructSegmentTree(self, segmentTree, inputList, low, high, pos):\n        if low == high:\n            segmentTree[pos] = inputList[low]\n            return\n        mid = (low + high) // 2\n        self.constructSegmentTree(segmentTree, inputList, low, mid, 2 * pos + 1)\n        self.constructSegmentTree(segmentTree, inputList, mid + 1, high, 2 * pos + 2)\n        segmentTree[pos] = max(segmentTree[2 * pos + 1], segmentTree[2 * pos + 2])\n\n    def rangeMinimumQuery(self, segmentTree, qlow, qhigh, length):\n        return self.rangeMinimumQuery(segmentTree, 0, length - 1, qlow, qhigh, 0)\n\n    def rangeMinimumQuery(self, segmentTree, low, high, qlow, qhigh, pos):\n        if qlow <= low and qhigh >= high:\n            return segmentTree[pos]\n        if qlow > high or qhigh < low:\n            return float('-inf')\n        mid = (low + high) // 2\n        return max(self.rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1), self.rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2))", "src": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for(int i=0;i<n;i++)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag)\n        {\n            for(int i=0;i<stringBuilder.length();i++)\n            {\n                if(stringBuilder.charAt(i) == '.')\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                \n                int k1 = k - left;\n                \n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    \n    \n    \n    void merge(int arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    \n    \n    \n    void merge(long arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; \n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "index": 364, "complexity": "1"}
{"back-translation": "class Fingerprints:\n    in = BufferedReader(InputStreamReader(System.in))\n    out = PrintWriter(BufferedOutputStream(System.out))\n    st = None\n    \n    def main(args):\n        n = nextInt()\n        m = nextInt()\n        a = intArray(n)\n        set = HashSet()\n        for i in range(m):\n            set.add(nextInt())\n        \n        s = ''\n        for i in range(n):\n            if a[i] in set:\n                s += ' ' + str(a[i])\n        \n        print(s if len(s) == 0 else s[1:])\n    \n    def nextLine():\n        return in.readLine()\n\n    def nextString():\n        while st is None or not st.hasMoreTokens():\n            st = StringTokenizer(in.readLine())\n        return st.nextToken()\n\n    def nextInt():\n        return int(nextString())\n\n    def nextLong():\n        return int(nextString())\n\n    def intArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextInt()\n        return a\n\n    def intArray(n, m):\n        a = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                a[i][j] = nextInt()\n        return a\n\n    def longArray(n):\n        a = [0] * n\n        for i in range(n):\n            a[i] = nextLong()\n        return a", "src": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 365, "complexity": "1"}
{"back-translation": "print('hello world')", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0;; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 366, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n\\n    static StringBuilder data = new StringBuilder();\\n    final static FastReader in = new FastReader();\\n\\n\\n    public static void main(String[] args) {\\n        int n = in.nextInt(), m = in.nextInt();\\n        int[] a = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = in.nextInt();\\n        }\\n        int h=0,t=n-1,answ=0;\\n        while (h<n&&t>=0){\\n            if(a[h]<=m){\\n                answ++;\\n                h++;\\n            }else if(a[t]<=m){\\n                t--;\\n                answ++;\\n            }else{\\n                break;\\n            }\\n        }\\n        System.out.println(answ);\\n    }\\n\\n\\n    static void fileOut(String s) {\\n        File out = new File(\"output.txt\");\\n        try {\\n            FileWriter fw = new FileWriter(out);\\n            fw.write(s);\\n            fw.flush();\\n            fw.close();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n\\n    }\\n\\n    static class FastReader {\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastReader() {\\n            br = new BufferedReader(new\\n                    InputStreamReader(System.in));\\n        }\\n\\n        public FastReader(String path) {\\n            try {\\n                br = new BufferedReader(new\\n                        InputStreamReader(new FileInputStream(path)));\\n            } catch (FileNotFoundException e) {\\n                e.printStackTrace();\\n            }\\n        }\\n\\n        String next() {\\n            while (st == null || !st.hasMoreElements()) {\\n                try {\\n                    st = new StringTokenizer(br.readLine());\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n            return st.nextToken();\\n        }\\n\\n        int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() {\\n            return Long.parseLong(next());\\n        }\\n\\n        float nextFloat() {\\n            return Float.parseFloat(next());\\n        }\\n\\n        double nextDouble() {\\n            return Double.parseDouble(next());\\n        }\\n\\n\\n        String nextLine() {\\n            String str = \"\";\\n            try {\\n                str = br.readLine();\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            }\\n            return str;\\n        }\\n    }\\n\\n}', 'complexity': '1', 'index': 367}", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 367, "complexity": "1"}
{"back-translation": "def Solution():\n    n, k = map(int, input().split())\n    st = input()\n    arr = list(st)\n    b = False\n    for j in range(ord('a'), ord('z')+1):\n        for i in range(len(arr)):\n            if arr[i] == chr(j):\n                arr[i] = '*'\n                k -= 1\n            if k == 0:\n                b = True\n                prin(arr)\n                return\n\ndef prin(arr):\n    sb = []\n    for i in range(len(arr)):\n        if arr[i] != '*':\n            sb.append(arr[i])\n    if sb:\n        print(''.join(sb))\n", "src": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "index": 368, "complexity": "1"}
{"back-translation": "{'src': 'class loser:\\n    class InputReader:\\n        def __init__(self, stream):\\n            self.br = BufferedReader(InputStreamReader(stream), 32768)\\n            self.token = None\\n        def next(self):\\n            while self.token is None or not self.token.hasMoreTokens():\\n                try:\\n                    self.token = StringTokenizer(self.br.readLine())\\n                except IOException as e:\\n                    raise RuntimeException(e)\\n            return self.token.nextToken()\\n        def nextInt(self):\\n            return int(self.next())\\n        def nextLong(self):\\n            return int(self.next())\\n    class card:\\n        def __init__(self, s, i):\\n            self.s = s\\n            self.l = i\\n    class sort(Comparator):\\n        def compare(self, o1, o2):\\n            if o1.l != o2.l:\\n                return o1.l - o2.l\\n            else:\\n                return ord(o1.s) - ord(o2.s)\\n    def shuffle(a):\\n        l = []\\n        for i in a:\\n            l.append(i)\\n        shuffle(l)\\n        for i in range(len(a)):\\n            a[i] = l[i]\\n    class Pair:\\n        def __init__(self, a, b):\\n            self.a = a\\n            self.b = b\\n    def main(args):\\n        n = int(sys.stdin.readline())\\n        m = {}\\n        for i in range(n):\\n            t = sys.stdin.readline().strip()\\n            if t in m:\\n                m[t] += 1\\n            else:\\n                m[t] = 1\\n        ans = 0\\n        for i in range(n):\\n            t = sys.stdin.readline().strip()\\n            if t in m and m[t] > 0:\\n                m[t] -= 1\\n                ans += 1\\n        print(n - ans)\\n', 'complexity': '1', 'index': 369}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 369, "complexity": "1"}
{"back-translation": "class pr902A:\n    in = Scanner(System.in)\n\n    def main(args):\n        out = PrintWriter(System.out)\n\n        n = in.nextInt()\n        m = in.nextInt()\n\n        out.println(solve(n, m))\n        out.flush()\n        out.close()\n\n    def solve(n, m):\n        grid = [0] * (m + 1)\n        for i in range(n):\n            start = in.nextInt()\n            end = in.nextInt()\n\n            grid[start] += 1\n            grid[end] -= 1\n\n        sum_val = 0\n        for i in range(m):\n            sum_val += grid[i]\n            if sum_val == 0:\n                return 'NO'\n\n        return 'YES'", "src": "public class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "index": 370, "complexity": "1"}
{"back-translation": "{'src': 'public class ErrorCorrectSystem { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String a = scan.next(); String b = scan.next(); int[][] mismatch = new int[26][26]; for(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1); int[][] pair = new int[2][26]; for(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1); int hd = 0; for(int i = 0; i < n; i++) { if(a.charAt(i) != b.charAt(i)) { hd++; mismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i; pair[0][a.charAt(i)-'a'] = i; pair[1][b.charAt(i)-'a'] = i; } } for(int i = 0; i < 26; i++) { for(int j = i+1; j < 26; j++) { if(mismatch[i][j] > -1 && mismatch[j][i] > -1) { System.out.println(hd-2); System.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1)); return; } } } for(int i = 0; i < n; i++) { if(a.charAt(i) != b.charAt(i)) { if(pair[0][b.charAt(i)-'a'] > -1) { System.out.println(hd-1); System.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1)); return; } } } System.out.println(hd); System.out.println(\"-1 -1\"); } }', 'complexity': '1', 'index': 371}", "src": "public class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}", "index": 371, "complexity": "1"}
{"back-translation": "class Solution1:\n    MAX = 1000000007\n\n    class InputReader:\n        def __init__(self, stream):\n            self.stream = stream\n            self.buf = bytearray(1024)\n            self.curChar = 0\n            self.numChars = 0\n            self.filter = None\n            self.br = BufferedReader(InputStreamReader(System.in))\n\n        def read(self):\n            if self.numChars == -1:\n                raise InputMismatchException()\n            if self.curChar >= self.numChars:\n                self.curChar = 0\n                try:\n                    self.numChars = self.stream.read(self.buf)\n                except IOException as e:\n                    raise InputMismatchException()\n                if self.numChars <= 0:\n                    return -1\n            return self.buf[self.curChar]\n\n        def nextLine(self):\n            try:\n                return self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n\n        def nextInt(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == '-':\n                sgn = -1\n                c = self.read()\n            res = 0\n            while c>= '0' and c <= '9':\n                res *= 10\n                res += ord(c) - ord('0')\n                c = self.read()\n            return res * sgn\n\n        def nextLong(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == '-':\n                sgn = -1\n                c = self.read()\n            res = 0\n            while c>= '0' and c <= '9':\n                res *= 10\n                res += ord(c) - ord('0')\n                c = self.read()\n            return res * sgn\n\n        def nextDouble(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == '-':\n                sgn = -1\n                c = self.read()\n            res = 0.0\n            while not self.isSpaceChar(c) and c!= '.' and c!='e' and c!='E':\n                if c >= '0' and c <= '9':\n                    res *= 10\n                    res += ord(c) - ord('0')\n                    c = self.read()\n            return res * sgn\n\n        def readString(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = ''\n            while not self.isSpaceChar(c):\n                res += c\n                c = self.read()\n            return res\n\n        def isSpaceChar(self, c):\n            return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n\n        def next(self):\n            return self.readString()\n\n        class SpaceCharFilter:\n            def isSpaceChar(self, ch):\n                if self.filter:\n                    return self.filter.isSpaceChar(ch)\n                return ch == ' ' or ch == '\\n' or ch == '\\r' or ch == '\\t' or ch == -1\n\n    def main(self, args):\n        Thread(target=None, args=(Solution1(), 'Solution1', 1<<26)).start()\n\n    def gcd(self, a, b):\n        if a == 0:\n            return b\n        return self.gcd(b % a, a)\n\n    def lcm(self, a, b):\n        return (a * b) // self.gcd(a, b)\n\n    def root(self, a):\n        while self.arr[a] != a:\n            self.arr[a] = self.arr[self.arr[a]]\n            a = self.arr[a]\n        return a\n\n    def union(self, a, b):\n        xroot = self.root(a)\n        yroot = self.root(b)\n        if self.arr[xroot] < self.arr[yroot]:\n            self.arr[xroot] = yroot\n        else:\n            self.arr[yroot] = xroot\n\n    def find(self, a, b):\n        roota = self.root(a)\n        rootb = self.root(b)\n        return roota == rootb\n\n    def run(self):\n        sc = self.InputReader(System.in)\n        w = PrintWriter(System.out)\n        n = sc.nextInt()\n        ch = [''] * n\n        ch2 = [''] * n\n        ch = list(sc.next())\n        ch2 = list(sc.next())\n        hset = [set() for _ in range(26)]\n        count = 0\n        for i in range(len(ch)):\n            if ch[i] != ch2[i]:\n                hset[ord(ch[i]) - 97].add(ord(ch2[i]) - 97)\n                count += 1\n        flag = False\n        swap1 = -1\n        swap2 = -1\n        rem = -1\n        for i in range(len(ch)):\n            if ch[i] != ch2[i]:\n                if len(hset[ord(ch2[i]) - 97]) != 0:\n                    swap1 = i\n                    flag = True\n                    if ord(ch[i]) - 97 in hset[ord(ch2[i]) - 97]:\n                        rem = i\n                        count -= 2\n                        flag = False\n                        break\n        if flag:\n            count -= 1\n            w.println(count)\n            for i in range(n):\n                if i != swap1 and ch[i] == ch2[swap1] and ch[i] != ch2[i]:\n                    w.println(str(swap1 + 1) + ' ' + str(i + 1))\n                    w.close()\n                    exit()\n        else:\n            if rem == -1:\n                w.println(count)\n                w.println('-1 -1')\n            else:\n                w.println(count)\n                for i in range(n):\n                    if i != rem and ch[i] == ch2[rem] and ch[rem] == ch2[i] and ch[i] != ch2[i]:\n                        w.println(str(rem + 1) + ' ' + str(i + 1))\n                        w.close()\n                        exit()\n        w.close()\n\n    def fun(self, prefix, mid, temp, arr):\n        if temp >= prefix[int(mid)]:\n            return True\n        return False\n\n    class Pair:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n        def compareTo(self, p):\n            return self.x - p.x\n\n\nclass InputMismatchException(Exception):\n    pass\n\nclass IOException(Exception):\n    pass\n\nclass Thread:\n    def __init__(self, target, args=None, name=None, x=0):\n        pass\n\n\nclass BufferedReader:\n    def __init__(self, stream):\n        pass\n\n\nclass InputStreamReader:\n    def __init__(self, stream):\n        pass\n\n\nclass PrintWriter:\n    def __init__(self, stream):\n        pass\n\n\ndef ord(char):\n    return 0\n\ndef exit():\n    pass", "src": "public class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "index": 372, "complexity": "1"}
{"back-translation": "class Main:\n    class Reader:\n        def __init__(self, is_=System.in):\n            self.mIs = is_\n            self.buf = bytearray(1024)\n            self.curChar = 0\n            self.numChars = 0\n        def read(self):\n            if self.numChars == -1:\n                raise InputMismatchException()\n            if self.curChar >= self.numChars:\n                self.curChar = 0\n                try:\n                    self.numChars = self.mIs.read(self.buf)\n                except IOException as e:\n                    raise InputMismatchException()\n                if self.numChars <= 0:\n                    return -1\n            return self.buf[self.curChar]\n        def nextLine(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = []\n            while not self.isEndOfLine(c):\n                res.append(c)\n                c = self.read()\n            return ''.join(res)\n        def s(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = []\n            while not self.isSpaceChar(c):\n                res.append(c)\n                c = self.read()\n            return ''.join(res)\n        def l(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == '-':\n                sgn = -1\n                c = self.read()\n            res = 0\n            while not self.isSpaceChar(c):\n                if c < '0' or c > '9':\n                    raise InputMismatchException()\n                res *= 10\n                res += ord(c) - ord('0')\n                c = self.read()\n            return res * sgn\n        def i(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            sgn = 1\n            if c == '-':\n                sgn = -1\n                c = self.read()\n            res = 0\n            while not self.isSpaceChar(c):\n                if c < '0' or c > '9':\n                    raise InputMismatchException()\n                res *= 10\n                res += ord(c) - ord('0')\n                c = self.read()\n            return res * sgn\n        def d(self):\n            return float(self.s())\n        def isSpaceChar(self, c):\n            return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n        def isEndOfLine(self, c):\n            return c == '\\n' or c == '\\r' or c == -1\n\n    def main(args):\n        sc = Main.Reader()\n        out = PrintWriter(System.out)\n        n = sc.i()\n        s1 = sc.s()\n        s2 = sc.s()\n        pos1 = -1\n        pos2 = -1\n        arr = [[[0 for _ in range(2)] for _ in range(100)] for _ in range(100)]\n        for i in range(n):\n            if s1[i] != s2[i]:\n                if arr[ord(s2[i]) - 97][ord(s1[i]) - 97][0] == 1:\n                    pos2 = i\n                    pos1 = arr[ord(s2[i]) - 97][ord(s1[i]) - 97][1]\n                    break\n                arr[ord(s1[i]) - 97][ord(s2[i]) - 97][0] = 1\n                arr[ord(s1[i]) - 97][ord(s2[i]) - 97][1] = i\n        ham = 0\n        for i in range(n):\n            if s1[i] != s2[i]:\n                ham += 1\n        if pos1 != -1 and pos2 != -1:\n            print(ham - 2)\n            print(str(pos1 + 1) + ' ' + str(pos2 + 1))\n            exit(0)\n        arr1 = [[0 for _ in range(2)] for _ in range(100)]\n        arr2 = [[0 for _ in range(2)] for _ in range(100)]\n        for i in range(n):\n            if s1[i] != s2[i]:\n                if arr1[ord(s1[i]) - 97][0] == 1:\n                    pos2 = i\n                    pos1 = arr1[ord(s1[i]) - 97][1]\n                    break\n                if arr2[ord(s2[i]) - 97][0] == 1:\n                    pos2 = i\n                    pos1 = arr2[ord(s2[i]) - 97][1]\n                    break\n                arr1[ord(s2[i]) - 97][0] = 1\n                arr1[ord(s2[i]) - 97][1] = i\n                arr2[ord(s1[i]) - 97][0] = 1\n                arr2[ord(s1[i]) - 97][1] = i\n        if pos1 != -1 and pos2 != -1:\n            print(ham - 1)\n            print(str(pos1 + 1) + ' ' + str(pos2 + 1))\n            exit(0)\n        print(ham)\n        print(str(pos1) + ' ' + str(pos2)\n", "src": "public class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    \n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                    break;\n                }\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n            }\n        }\n        int ham=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        \n        int arr1[][]=new int[100][2];\n        int arr2[][]=new int[100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr1[s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr1[s1.charAt(i)-97][1];\n                    break;\n                }\n                if(arr2[s2.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr2[s2.charAt(i)-97][1];\n                    break;\n                }\n                arr1[s2.charAt(i)-97][0]=1;\n                arr1[s2.charAt(i)-97][1]=i;\n                arr2[s1.charAt(i)-97][0]=1;\n                arr2[s1.charAt(i)-97][1]=i;\n            }\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-1);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        System.out.println(ham);\n        System.out.println(pos1+\" \"+pos2);\n    }\n}", "index": 373, "complexity": "1"}
{"back-translation": "{'src': 'public class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\n\\t\\tint n = sc.nextInt();\\n\\t\\tint s = sc.nextInt();\\n\\t\\tint[] f = new int[n];\\n\\t\\tint[] t = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tf[i] = sc.nextInt();\\n\\t\\t\\tt[i] = sc.nextInt();\\n\\t\\t}\\n\\t\\tSystem.out.println(solve(f, t, s));\\n\\n\\t\\tsc.close();\\n\\t}\\n\\n\\tstatic int solve(int[] f, int[] t, int s) {\\n\\t\\tint[] maxTimes = new int[s + 1];\\n\\t\\tfor (int i = 0; i < f.length; i++) {\\n\\t\\t\\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\\n\\t\\t}\\n\\n\\t\\tint time = 0;\\n\\t\\tfor (int i = s; i > 0; i--) {\\n\\t\\t\\ttime = Math.max(time, maxTimes[i]);\\n\\n\\t\\t\\ttime++;\\n\\t\\t}\\n\\t\\treturn time;\\n\\t}\\n}', 'complexity': '1', 'index': 374}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "index": 374, "complexity": "1"}
{"back-translation": "def reverse(a):\n    b = [0] * len(a)\n    j = 0\n    for i in range(len(a)-1, -1, -1):\n        b[i] = a[j]\n        j += 1\n    return b\n\n\npas = int(input())\ntop = int(input())\na = [0] * pas\nb = [0] * pas\n\nfor i in range(pas):\n    a[i] = int(input())\n    b[i] = int(input())\n\na = reverse(a)\nb = reverse(b)\n\nftime = 0\nt = 0\npo = top\n\nfor i in range(pas):\n    ftime += (po - a[i])\n    t = max(b[i] - ftime, 0)\n    ftime += t\n    po = a[i]\n\nif po != 0:\n    ftime += po\n\nprint(ftime)", "src": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "index": 375, "complexity": "1"}
{"back-translation": "class FindUnion: def find_union(arr1, arr2, m, n): i, j = 0, 0 while i < m and j < n: if arr1[i] < arr2[j]: print(arr1[i], end=' ') i += 1 elif arr2[j] < arr1[i]: print(arr2[j], end=' ') j += 1 else: print(arr2[j], end=' ') i += 1 while i < m: print(arr1[i], end=' ') i += 1 while j < n: print(arr2[j], end=' ') j += 1 return 0 arr1 = [1, 2, 4, 5, 6] arr2 = [2, 3, 5, 7] m = len(arr1) n = len(arr2) find_union(arr1, arr2, m, n)", "src": "class\nFindUnion \n{ \n\n\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n}", "index": 376, "complexity": "1"}
{"back-translation": "class Main2:\n    def __init__(self):\n        self.scanner = self.FastScanner()\n\n    def main(self):\n        self.solve()\n\n    def solve(self):\n        a, b = self.scanner.nextLine(), self.scanner.nextLine()\n        n, m = len(b), len(a)\n        p = [0] * n\n        p[0] = ord(b[0]) - ord('0')\n        for i in range(1, n):\n            p[i] = p[i - 1] + (ord(b[i]) - ord('0'))\n        ans = 0\n        for i in range(m):\n            cur = ord(a[i]) - ord('0')\n            cnt = p[n - m + i] - p[i - 1] if i > 0 else 0\n            ans += cnt if cur == 0 else n - m + 1 - cnt\n        print(ans)\n\n    class Pair:\n        def __init__(self):\n            self.c = 0\n            self.f = 0\n\n    class FastScanner:\n        def __init__(self):\n            import sys\n            self.reader = sys.stdin\n\n        def next(self):\n            return next(self.reader)\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextA(self, n):\n            return [self.nextInt() for _ in range(n)]\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            return next(self.reader)", "src": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 377, "complexity": "1"}
{"back-translation": "class Codef8:\n    def main(args):\n        num = int(input())\n        beacon = [0] * 1000001\n        for i in range(num):\n            beacon[int(input())] = int(input())\n        dp = [0] * 1000001\n        max_val = 1\n        if beacon[0] > 0:\n            dp[0] = 1\n        for i in range(1, 1000001):\n            if beacon[i] == 0:\n                dp[i] = dp[i-1]\n            else:\n                b = beacon[i]\n                if i <= b:\n                    dp[i] = 1\n                else:\n                    dp[i] = dp[i-b-1] + 1\n            max_val = max(max_val, dp[i])\n        print(num - max_val)\nmain([])", "src": "public class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}", "index": 378, "complexity": "1"}
{"back-translation": "class FindUnion: def UnionArray(arr1: list, arr2: list): m = arr1[len(arr1) - 1] n = arr2[len(arr2) - 1] ans = 0 if m > n: ans = m else: ans = n newtable = [0] * (ans + 1) print(arr1[0], end=' ') newtable[arr1[0]] += 1 for i in range(1, len(arr1)): if arr1[i] != arr1[i - 1]: print(arr1[i], end=' ') newtable[arr1[i]] += 1 for j in range(len(arr2)): if newtable[arr2[j]] == 0: print(arr2[j], end=' ') newtable[arr2[j]] += 1 @staticmethod def main(args): arr1 = [1, 2, 2, 2, 3] arr2 = [2, 3, 4, 5] FindUnion.UnionArray(arr1, arr2)", "src": "class\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n\n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n\n\n\n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n\n\n\n\n++newtable[arr1[\n0\n]]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n\n\n\n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n\n\n\n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n}", "index": 379, "complexity": "1"}
{"back-translation": "class round569d2a:\n\n    def main(args):\n        in_fastscanner = FastScanner(System.in)\n        n = in_fastscanner.nextInt()\n        sum_value = 1\n        tracker = 4\n        while n > 1:\n            sum_value += tracker\n            tracker += 4\n            n -= 1\n        print(sum_value)\n\n    def greatestDivisor(n):\n        limit = int(Math.sqrt(n))\n        max_value = 1\n        for i in range(2, limit+1):\n            if n % i == 0:\n                max_value = max(max_value, i)\n                max_value = max(max_value, n // i)\n        return max_value\n\n    def sieveOfEratosthenes(n):\n        prime = [True] * (n + 1)\n        prime[0] = False\n        prime[1] = False\n        for i in range(2, n + 1):\n            if prime[i] == True:\n                for j in range(i * i, n + 1, i):\n                    prime[j] = False\n        return prime\n\n    def bin_gteq(a, key):\n        low = 0\n        high = len(a)\n        max_limit = high\n        while low < high:\n            mid = low + (high - low) // 2\n            if a[mid] < key:\n                low = mid + 1\n            else:\n                high = mid\n        return -1 if high == max_limit else high\n\n    def gcd(a, b):\n        return b if a == 0 else gcd(b % a, a)\n\n    class Tuple:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n        def __str__(self):\n            return \"(\" + str(self.x) + \",\" + str(self.y) + \")\"\n\n    class Tuple3:\n        def __init__(self, x, y, z):\n            self.x = x\n            self.y = y\n            self.z = z\n\n        def __str__(self):\n            return \"(\" + str(self.x) + \",\" + str(self.y) + \",\" + str(self.z) + \")\"\n\n    def gcdExtended(a, b, x, y):\n        if a == 0:\n            x = 0\n            y = 1\n            return Tuple3(0, 1, b)\n        x1 = 1\n        y1 = 1\n        tuple_value = gcdExtended(b % a, a, x1, y1)\n        gcd_value = tuple_value.z\n        x1 = tuple_value.x\n        y1 = tuple_value.y\n        x = y1 - (b // a) * x1\n        y = x1\n        return Tuple3(x, y, gcd_value)\n\n    def inv(a, m):\n        m0 = m\n        t\n        q\n        x0 = 0\n        x1 = 1\n        if m == 1:\n            return 0\n        while a > 1:\n            q = a // m\n            t = m\n            m = a % m\n            a = t\n            t = x0\n            x0 = x1 - q * x0\n            x1 = t\n        if x1 < 0:\n            x1 += m0\n        return x1\n\n    def findMinX(num, rem, k):\n        prod = 1\n        for i in range(k):\n            prod *= num[i]\n        result = 0\n        for i in range(k):\n            pp = prod // num[i]\n            result += rem[i] * inv(pp, num[i]) * pp\n        return result % prod\n\n    class FastScanner:\n        def __init__(self, stream):\n            self.stream = stream\n            self.buf = [0] * 1024\n            self.curChar = 0\n            self.chars = 0\n\n        def read(self):\n            if self.chars == -1:\n                raise InputMismatchException()\n            if self.curChar >= self.chars:\n                self.curChar = 0\n                try:\n                    self.chars = self.stream.read(self.buf)\n                except IOException as e:\n                    raise InputMismatchException()\n                if self.chars <= 0:\n                    return -1\n            return self.buf[self.curChar]\n\n        def isSpaceChar(self, c):\n            return c == ' ' or c == '\\n' or c == '\\r' or c == '\\t' or c == -1\n\n        def isEndline(self, c):\n            return c == '\\n' or c == '\\r' or c == -1\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def next(self):\n            c = self.read()\n            while self.isSpaceChar(c):\n                c = self.read()\n            res = ''\n            while not self.isSpaceChar(c):\n                res += chr(c)\n                c = self.read()\n            return res\n\n        def nextLine(self):\n            c = self.read()\n            while self.isEndline(c):\n                c = self.read()\n            res = ''\n            while not self.isEndline(c):\n                res += chr(c)\n                c = self.read()\n            return res\n", "src": "public class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 380, "complexity": "1"}
{"back-translation": "class Main:\n\n    def __init__(self):\n        self.oo = 1000000000000\n        self.memo = [[]]\n\n    def main(self):\n        cnt = [0] * 101\n        cnt[1] = 1\n        for i in range(2, 101):\n            cnt[i] = cnt[i - 1] + 4 * (i - 1)\n        n = int(input())\n        print(cnt[n])\n\n    def max_hit(self, a, p, i):\n        if i == len(a):\n            return 0\n        if self.memo[p][i] != -1:\n            return self.memo[p][i]\n        ret = self.max_hit(a, p, i + 1)\n        if p == -1 or a[p] < a[i]:\n            ret = max(ret, self.max_hit(a, i, i + 1))\n        self.memo[p][i] = ret\n        return ret\n\n    def lcm(self, a, b):\n        return a * b // self.gcd(a, b)\n\n    def next_permutation(self, a):\n        for i in range(len(a) - 2, -1, -1):\n            if a[i] < a[i + 1]:\n                for j in range(len(a) - 1, -1, -1):\n                    if a[i] < a[j]:\n                        a[i], a[j] = a[j], a[i]\n                        i += 1\n                        j = len(a) - 1\n                        while i < j:\n                            a[i], a[j] = a[j], a[i]\n                            i += 1\n                            j -= 1\n                        return True\n        return False\n\n    def shuffle(self, a):\n        import random\n        for i in range(len(a) - 1, 0, -1):\n            si = random.randint(0, i)\n            a[si], a[i] = a[i], a[si]\n\n    def lower_bound(self, a, n, k):\n        s, e = 0, n\n        while e - s > 0:\n            m = (s + e) // 2\n            if a[m] < k:\n                s = m + 1\n            else:\n                e = m\n        return e\n\n    def gcd(self, a, b):\n        return a if b == 0 else self.gcd(b, a % b)\n\n    class Pair:\n\n        def __init__(self, first, second):\n            self.first = first\n            self.second = second\n\n        def __lt__(self, other):\n            return self.first != other.first or self.second != other.second\n\n        def __hash__(self):\n            return hash((self.first, self.second))\n\n        def __eq__(self, other):\n            return self.first == other.first and self.second == other.second\n\nif __name__ == '__main__':\n    main_instance = Main()\n    main_instance.main()", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 381, "complexity": "1"}
{"back-translation": "print(sum(4*i for i in range(1, n)) + 1)", "src": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "index": 382, "complexity": "1"}
{"back-translation": "class GFG: def findRepeating(arr, n): res = 0 for i in range(n - 1): res = res ^ (i + 1) ^ arr[i] res = res ^ arr[n - 1] return res def main(args): arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7] n = len(arr) print(findRepeating(arr, n))", "src": "class\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n}", "index": 383, "complexity": "1"}
{"back-translation": "class MajorityElement: def findMajority(arr): map = {} for i in range(len(arr)): if arr[i] in map: count = map[arr[i]] + 1 if count > len(arr) / 2: print('Majority found :- ' + str(arr[i])) return else: map[arr[i]] = count else: map[arr[i]] = 1 print(' No Majority element') def main(args): a = [2, 2, 2, 2, 5, 5, 2, 3, 3] findMajority(a) ", "src": "class\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n}", "index": 384, "complexity": "1"}
{"back-translation": "class GFG: def maxTripletSum(arr, n): maxA, maxB, maxC = -100000000, -100000000, -100000000 for i in range(n): if arr[i] > maxA: maxC, maxB, maxA = maxB, maxA, arr[i] elif arr[i] > maxB: maxC, maxB = maxB, arr[i] elif arr[i] > maxC: maxC = arr[i] return maxA + maxB + maxC def main(args): arr = [1, 0, 8, 6, 4, 2] n = len(arr) print(maxTripletSum(arr, n))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmaxA = -\n100000000\n, maxB = -\n100000000\n; \n\nint\nmaxC = -\n100000000\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(arr[i] > maxA) \n\n{ \n\nmaxC = maxB; \n\nmaxB = maxA; \n\nmaxA = arr[i]; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > maxB) \n\n{ \n\nmaxC = maxB; \n\nmaxB = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > maxC) \n\nmaxC = arr[i]; \n\n} \n\n\nreturn\n(maxA + maxB + maxC); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 385, "complexity": "1"}
{"back-translation": "{'src': 'class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n'->'\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n'NULL'\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n'Is Palindrome'\n); \n\nSystem.out.println(\n''\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n'Not Palindrome'\n); \n\nSystem.out.println(\n''\n); \n\n} \n\n} \n\n} \n}'", "src": "class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n}", "index": 386, "complexity": "1"}
{"back-translation": "class GFG: def maxSum(arr, n): sum = 0 pivot = findPivot(arr, n) diff = n - 1 - pivot for i in range(n): sum += ((i + diff) % n) * arr[i] return sum def findPivot(arr, n): for i in range(n): if arr[i] > arr[(i + 1) % n]: return i return 0 arr = [8, 3, 1, 2] n = len(arr) max = maxSum(arr, n) print(max)", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n\n\n\n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n}", "index": 387, "complexity": "1"}
{"back-translation": "class GFG:\n    MAX_CHAR = 26\n\n    def countSubstringWithEqualEnds(s):\n        result = 0\n        n = len(s)\n        count = [0] * MAX_CHAR\n\n        for i in range(n):\n            count[ord(s[i]) - ord('a')] += 1\n\n        for i in range(MAX_CHAR):\n            result += (count[i] * (count[i] + 1) // 2)\n\n        return result\n\n    def main(args):\n        s = 'abcab'\n        print(countSubstringWithEqualEnds(s))\n\nmain([])", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 388, "complexity": "1"}
{"back-translation": "class GFG: def binomialCoeff(n, k): res = 1 if k > n - k: k = n - k for i in range(k): res *= (n - i) res //= (i + 1) return res def catalan(n): c = binomialCoeff(2 * n, n) return c // (n + 1) def main(args): for i in range(10): print(catalan(i), end=' ')", "src": "class\nGFG { \n\n\n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n\n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\nstatic\nlong\ncatalan(\nint\nn) { \n\n\n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n\n\nreturn\nc / (n + \n1\n); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n}", "index": 389, "complexity": "1"}
{"back-translation": "class GFG: def PermutationCoeff(n, k): Fn, Fk = 1, 1 for i in range(1, n + 1): Fn *= i if i == n - k: Fk = Fn coeff = Fn // Fk return coeff def main(args): n, k = 10, 2 print('Value of P( ' + str(n) + ',' + str(k) + ') is ' + str(PermutationCoeff(n, k)))", "src": "class\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n}", "index": 390, "complexity": "1"}
{"back-translation": "class GFG: def countFriendsPairings(n): a, b, c = 1, 2, 0 if (n <= 2): return n for i in range(3, n+1): c = b + (i - 1) * a a, b = b, c return c def main(args): n = 4 print(countFriendsPairings(n))", "complexity": "1", "index": 391, "src": "class\nGFG { \n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}"}
{"back-translation": "class GFG : def countSeq(n) : nCr, res = 1, 1 for r in range(1, n+1) : nCr = (nCr * (n + 1 - r)) / r res += (nCr * nCr) return res  def main(args) : n = 2 print('Count of sequences is ', end='') print(countSeq(n)) main('')", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n\n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n\n\n\n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n}", "index": 392, "complexity": "1"}
{"back-translation": "class GFG: def rearrange(arr, n): for i in range(n): arr[arr[i] % n] += i * n; for i in range(n): arr[i] /= n; def printArray(arr, n): for i in range(n): print(arr[i], end=' '); print(); if __name__ == '__main__': arr = [2, 0, 1, 4, 5, 3] n = len(arr) print('Given array is : ') printArray(arr, n) rearrange(arr, n) print('Modified array is :') printArray(arr, n)", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\narr[i] /= n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 393, "complexity": "1"}
{"back-translation": "class GFG: def findElements(arr, n): first = min(arr) second = max(arr) for i in range(n): if arr[i] > first: second = first first = arr[i] elif arr[i] > second: second = arr[i] for i in range(n): if arr[i] < second: print(arr[i], end=' ') def main(args): arr = [2, -6, 3, 5, 1] n = len(arr) findElements(arr, n) if __name__ == '__main__': import sys; main(sys.argv)", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n}", "index": 394, "complexity": "1"}
{"back-translation": "class GFG: def smallestSubWithSum(arr, n, x): curr_sum, min_len = 0, n + 1; start, end = 0, 0; while end < n: while curr_sum <= x and end < n: if curr_sum <= 0 and x > 0: start = end; curr_sum = 0; curr_sum += arr[end]; end += 1; while curr_sum > x and start < n: if end - start < min_len: min_len = end - start; curr_sum -= arr[start]; start += 1; return min_len; def main(args): arr1 = [-8, 1, 4, 2, -6]; x = 6; n1 = len(arr1); res1 = smallestSubWithSum(arr1, n1, x); if res1 == n1 + 1: print(\"Not possible\"); else: print(res1);", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n\n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n\n\n\n\n\n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n}", "index": 395, "complexity": "1"}
{"back-translation": "class FindIntersection: def printIntersection(arr1, arr2, m, n): i, j = 0, 0 while i < m and j < n: if arr1[i] < arr2[j]: i += 1 elif arr2[j] < arr1[i]: j += 1 else: print(arr2[j], end=' ') j += 1 i += 1 def main(args): arr1 = [1, 2, 4, 5, 6] arr2 = [2, 3, 5, 7] m = len(arr1) n = len(arr2) printIntersection(arr1, arr2, m, n) if __name__ == '__main__': import sys ret=main(sys.argv[1:])", "src": "class\nFindIntersection \n{ \n\n\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n}", "index": 396, "complexity": "1"}
{"back-translation": "class RotateArray:\n    def leftRotate(self, arr, d, n):\n        for i in range(d):\n            self.leftRotatebyOne(arr, n)\n\n    def leftRotatebyOne(self, arr, n):\n        temp = arr[0]\n        for i in range(n - 1):\n            arr[i] = arr[i + 1]\n        arr[n - 1] = temp\n\n    def printArray(self, arr, n):\n        for i in range(n):\n            print(arr[i], end=' ')\n\n\nrotate = RotateArray()\narr = [1, 2, 3, 4, 5, 6, 7]\nrotate.leftRotate(arr, 2, 7)\nrotate.printArray(arr, 7)", "src": "class\nRotateArray { \n\n\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n}", "index": 397, "complexity": "3"}
{"back-translation": "class\nCountTriangles:\n\n    @staticmethod\n    def findNumberOfTriangles(arr):\n        n = len(arr)\n        arr.sort()\n        count = 0\n\n        for i in range(n-2):\n            k = i + 2\n            for j in range(i+1, n):\n                while k < n and arr[i] + arr[j] > arr[k]:\n                    k += 1\n                if k > j:\n                    count += k - j - 1\n\n        return count\n\n    @staticmethod\n    def main(args):\n        arr = [10, 21, 22, 100, 101, 200, 300]\n        print(\"Total number of triangles is \" + str(CountTriangles.findNumberOfTriangles(arr)))", "src": "class\nCountTriangles \n{ \n\n\n\n\n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n\n\nint\nk = i + \n2\n; \n\n\n\n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n}", "index": 398, "complexity": "3"}
{"back-translation": "class GFG:\n\n    @staticmethod\n    def countPairsWithDiffK(arr, n, k):\n        count = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\n                    count += 1\n\n        return count\n\n    @staticmethod\n    def main():\n        arr = [1, 5, 3, 4, 2]\n        n = len(arr)\n        k = 3\n        print(f\"Count of pairs with given diff is {GFG.countPairsWithDiffK(arr, n, k)}\")", "src": "class\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k) \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n}", "index": 399, "complexity": "3"}
{"back-translation": "class Test:\n\n    arr1 = [1, 5, 9, 10, 15, 20]\n    arr2 = [2, 3, 8, 13]\n\n    def merge(m, n):\n        for i in range(n-1, -1, -1):\n            j, last = m-1, arr1[m-1]\n            while j >= 0 and arr1[j] > arr2[i]:\n                arr1[j+1] = arr1[j]\n                j -= 1\n            if j != m-2 or last > arr2[i]:\n                arr1[j+1] = arr2[i]\n                arr2[i] = last\n\n    @staticmethod\n    def main(args):\n        Test.merge(len(Test.arr1), len(Test.arr2))\n        print('After Merging nFirst Array: ', Test.arr1)\n        print('Second Array: ', Test.arr2)", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n\n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n}", "index": 400, "complexity": "3"}
{"back-translation": "class GFG: def isPresent(B, m, x): for i in range(m): if B[i] == x: return True return False def findMaxSubarraySumUtil(A, B, n, m): max_so_far, curr_max = -2147483648, 0 for i in range(n): if isPresent(B, m, A[i]): curr_max = 0 continue curr_max = max(A[i], curr_max + A[i]) max_so_far = max(max_so_far, curr_max) return max_so_far def findMaxSubarraySum(A, B, n, m): maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m) if maxSubarraySum == -2147483648: print('Maximum Subarray Sum can\\'t be found') else: print('The Maximum Subarray Sum =', maxSubarraySum) def main(args): A = [3, 4, 5, -4, 6] B = [1, 8, 5] n = len(A) m = len(B) findMaxSubarraySum(A, B, n, m)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 401, "complexity": "3"}
{"back-translation": "class GFG: def findMaxSum(arr, n): res = float('-inf') for i in range(n): prefix_sum = arr[i] for j in range(i): prefix_sum += arr[j] suffix_sum = arr[i] for j in range(n - 1, i, -1): suffix_sum += arr[j] if prefix_sum == suffix_sum: res = max(res, prefix_sum) return res def main(args): arr = [-2, 5, 3, 1, 2, 6, -4, 2] n = len(arr) print(findMaxSum(arr, n)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n}", "index": 402, "complexity": "3"}
{"back-translation": "class EquilibriumIndex:\n\n    def equilibrium(self, arr, n):\n        for i in range(n):\n            leftsum = sum(arr[j] for j in range(i))\n            rightsum = sum(arr[j] for j in range(i + 1, n))\n            if leftsum == rightsum:\n                return i\n        return -1\n\n\nequi = EquilibriumIndex()\narr = [-7, 1, 5, 2, -4, 3, 0]\narr_size = len(arr)\nprint(equi.equilibrium(arr, arr_size))", "src": "class\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n}", "index": 403, "complexity": "3"}
{"back-translation": "class LeadersInArray: def printLeaders(arr, size): for i in range(size): j = i + 1 for j in range(i + 1, size): if arr[i] <= arr[j]: break if j == size: print(arr[i], end=' ') def main(args): lead = LeadersInArray() arr = [16, 17, 4, 3, 5, 2] n = len(arr) lead.printLeaders(arr, n)", "src": "class\nLeadersInArray \n{ \n\n\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n\n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n}", "index": 404, "complexity": "3"}
{"back-translation": "ERROR", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n\n\n\n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n\n\n\n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nfindMajority(arr, n); \n\n} \n\n}", "index": 405, "complexity": "3"}
{"back-translation": "class SubarraySum:\n    def subArraySum(self, arr, n, sum):\n        for i in range(n):\n            curr_sum = arr[i]\n            for j in range(i + 1, n + 1):\n                if curr_sum == sum:\n                    p = j - 1\n                    print(\"Sum found between indexes \" + str(i) + \" and \" + str(p))\n                    return 1\n                if curr_sum > sum or j == n:\n                    break\n                curr_sum = curr_sum + arr[j]\n        print(\"No subarray found\")\n        return 0\n\n    def main(self):\n        arraysum = SubarraySum()\n        arr = [15, 2, 4, 8, 9, 5, 10, 23]\n        n = len(arr)\n        sum_val = 23\n        arraysum.subArraySum(arr, n, sum_val)\n\nSubarraySum().main()", "src": "class\nSubarraySum \n{ \n\n\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n\n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n}", "index": 406, "complexity": "3"}
{"back-translation": "class FindTriplet {\n    boolean find3Numbers(int A[], int arr_size, int sum) {\n        int l, r;\n        quickSort(A, 0, arr_size - 1);\n        for (int i = 0; i < arr_size - 2; i++) {\n            l = i + 1;\n            r = arr_size - 1;\n            while (l < r) {\n                if (A[i] + A[l] + A[r] == sum) {\n                    System.out.print(\"Triplet is \" + A[i] + \", \" + A[l] + \", \" + A[r]);\n                    return true;\n                } else if (A[i] + A[l] + A[r] < sum)\n                    l++;\n                else\n                    r--;\n            }\n        }\n        return false;\n    }\n\n    int partition(int A[], int si, int ei) {\n        int x = A[ei];\n        int i = (si - 1);\n        int j;\n        for (j = si; j <= ei - 1; j++) {\n            if (A[j] <= x) {\n                i++;\n                int temp = A[i];\n                A[i] = A[j];\n                A[j] = temp;\n            }\n        }\n        int temp = A[i + 1];\n        A[i + 1] = A[ei];\n        A[ei] = temp;\n        return (i + 1);\n    }\n\n    void quickSort(int A[], int si, int ei) {\n        int pi;\n        if (si < ei) {\n            pi = partition(A, si, ei);\n            quickSort(A, si, pi - 1);\n            quickSort(A, pi + 1, ei);\n        }\n    }\n\n    public static void main(String[] args) {\n        FindTriplet triplet = new FindTriplet();\n        int A[] = {1, 4, 45, 6, 10, 8};\n        int sum = 22;\n        int arr_size = A.length;\n        triplet.find3Numbers(A, arr_size, sum);\n    }\n}", "src": "class\nFindTriplet { \n\n\n\n\n\n\nboolean\nfind3Numbers(\nint\nA[], \nint\narr_size, \nint\nsum) \n\n{ \n\nint\nl, r; \n\n\n\n\nquickSort(A, \n0\n, arr_size - \n1\n); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < arr_size - \n2\n; i++) { \n\n\n\n\n\n\n\n\nl = i + \n1\n; \n\n\nr = arr_size - \n1\n; \n\n\nwhile\n(l < r) { \n\nif\n(A[i] + A[l] + A[r] == sum) { \n\nSystem.out.print(\n\"Triplet is \"\n+ A[i] + \n\", \"\n+ A[l] + \n\", \"\n+ A[r]); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(A[i] + A[l] + A[r] < sum) \n\nl++; \n\n\nelse\n\n\nr--; \n\n} \n\n} \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\nint\npartition(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\nx = A[ei]; \n\nint\ni = (si - \n1\n); \n\nint\nj; \n\n\nfor\n(j = si; j <= ei - \n1\n; j++) { \n\nif\n(A[j] <= x) { \n\ni++; \n\nint\ntemp = A[i]; \n\nA[i] = A[j]; \n\nA[j] = temp; \n\n} \n\n} \n\nint\ntemp = A[i + \n1\n]; \n\nA[i + \n1\n] = A[ei]; \n\nA[ei] = temp; \n\nreturn\n(i + \n1\n); \n\n} \n\n\n\n\nvoid\nquickSort(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\npi; \n\n\n\n\nif\n(si < ei) { \n\npi = partition(A, si, ei); \n\nquickSort(A, si, pi - \n1\n); \n\nquickSort(A, pi + \n1\n, ei); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindTriplet triplet = \nnew\nFindTriplet(); \n\nint\nA[] = { \n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n8\n}; \n\nint\nsum = \n22\n; \n\nint\narr_size = A.length; \n\n\ntriplet.find3Numbers(A, arr_size, sum); \n\n} \n}", "index": 407, "complexity": "3"}
{"back-translation": "class GFG: def findTriplets(arr, n): found = False for i in range(n - 1): s = set() for j in range(i + 1, n): x = -(arr[i] + arr[j]) if x in s: print(f'{x} {arr[i]} {arr[j}') found = True else: s.add(arr[j]) if not found: print(' No Triplet Found') def main(args): arr = [0, -1, 2, -3, 1] n = len(arr) findTriplets(arr, n) ", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n\n\n\n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n}", "index": 408, "complexity": "3"}
{"back-translation": "class GFG: def spiralPrint(m, n, a): i, k, l = 0, 0, 0 while k < m and l < n: for i in range(l, n): print(a[k][i], end=' ') k += 1 for i in range(k, m): print(a[i][n - 1], end=' ') n -= 1 if k < m: for i in range(n - 1, l - 1, -1): print(a[m - 1][i], end=' ') m -= 1 if l < n: for i in range(m - 1, k - 1, -1): print(a[i][l], end=' ') l += 1 def main(args): R, C = 3, 6 a = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18]] spiralPrint(R, C, a) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\nwhile\n(k < m && l < n) { \n\n\n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n\n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n\n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n\n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n}", "index": 409, "complexity": "3"}
{"back-translation": "class GFG: def clockwiseSpiralPrint(R, C, arr): i, k, l, cnt, total = 0, 0, 0, 0, R * C while k < R and l < C: if cnt == total: break for i in range(k, R): print(arr[i][l], end=\" \") cnt += 1 l += 1 if cnt == total: break for i in range(l, C): print(arr[R - 1][i], end=\" \") cnt += 1 R -= 1 if cnt == total: break if k < R: for i in range(R - 1, k - 1, -1): print(arr[i][C - 1], end=\" \") cnt += 1 C -= 1 if cnt == total: break if l < C: for i in range(C - 1, l - 1, -1): print(arr[k][i], end=\" \") cnt += 1 k += 1", "direction": "clockwise", "src": "class\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n\n\n\n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\n\n\n\nint\ncnt = \n0\n; \n\n\n\n\n\n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n\n\ncounterClockspiralPrint(R, C, arr); \n} \n}", "index": 410, "complexity": "3"}
{"back-translation": "class GFG: public static int N = 4, M = 6; static int findMaxPath(int mat[][]): res = -1; for i in range(M): res = max(res, mat[0][i]); for i in range(1, N): res = -1; for j in range(M): if j > 0 and j < M - 1: mat[i][j] += max(mat[i - 1][j], max(mat[i - 1][j - 1], mat[i - 1][j + 1])); elif j > 0: mat[i][j] += max(mat[i - 1][j], mat[i - 1][j - 1]); elif j < M - 1: mat[i][j] += max(mat[i - 1][j], mat[i - 1][j + 1]); res = max(mat[i][j], res); return res; public static void main (String[] args): mat = [[10, 10, 2, 0, 20, 4], [1, 0, 0, 30, 2, 5], [0, 10, 4, 0, 2, 0], [1, 0, 2, 20, 0, 4]]; System.out.println(findMaxPath(mat));", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n\n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n\n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n\n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n\n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n\n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n\n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n}", "index": 411, "complexity": "3"}
{"back-translation": "class LinkedList: def __init__(self): self.head = None class Node: def __init__(self, data): self.data = data self.next = None def remove_duplicates(self): ptr1, ptr2, dup = None, None, None ptr1 = self.head while ptr1 is not None and ptr1.next is not None: ptr2 = ptr1 while ptr2.next is not None: if ptr1.data == ptr2.next.data: dup = ptr2.next ptr2.next = ptr2.next.next else: ptr2 = ptr2.next ptr1 = ptr1.next def printList(self, node): while node is not None: print(node.data, end=' ') node = node.next if __name__ == '__main__': list = LinkedList() list.head = Node(10) list.head.next = Node(12) list.head.next.next = Node(11) list.head.next.next.next = Node(11) list.head.next.next.next.next = Node(12) list.head.next.next.next.next.next = Node(11) list.head.next.next.next.next.next.next = Node(10) print('Linked List before removing duplicates : \\n', end='') list.printList(list.head) list.remove_duplicates() print('') print('Linked List after removing duplicates : \\n', end='') list.printList(list.head)", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nvoid\nremove_duplicates() { \n\nNode ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n; \n\nptr1 = head; \n\n\n\n\nwhile\n(ptr1 != \nnull\n&& ptr1.next != \nnull\n) { \n\nptr2 = ptr1; \n\n\n\n\nwhile\n(ptr2.next != \nnull\n) { \n\n\n\n\nif\n(ptr1.data == ptr2.next.data) { \n\n\n\n\ndup = ptr2.next; \n\nptr2.next = ptr2.next.next; \n\nSystem.gc(); \n\n} \nelse\n\n{ \n\nptr2 = ptr2.next; \n\n} \n\n} \n\nptr1 = ptr1.next; \n\n} \n\n} \n\n\nvoid\nprintList(Node node) { \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next.next.next = \nnew\nNode(\n10\n); \n\n\nSystem.out.println(\n\"Linked List before removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n\nlist.remove_duplicates(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Linked List after removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n} \n}", "index": 412, "complexity": "3"}
{"back-translation": "class GFG:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next = None\n    def getJosephusPosition(m, n):\n        class Node:\n            def __init__(self, data):\n                self.data = data\n                self.next = None\n        head = Node(1)\n        prev = head\n        for i in range(2, n+1):\n            prev.next = Node(i)\n            prev = prev.next\n        prev.next = head\n        ptr1 = head\n        ptr2 = head\n        while ptr1.next != ptr1:\n            count = 1\n            while count != m:\n                ptr2 = ptr1\n                ptr1 = ptr1.next\n                count += 1\n            ptr2.next = ptr1.next\n            ptr1 = ptr2.next\n        print('Last person left standing (Josephus Position) is', ptr1.data)\n    def main(args=None):\n        n = 14\n        m = 2\n        getJosephusPosition(m, n)\n    if __name__ == '__main__':\n        import sys\n        main(sys.argv[1:])", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode next; \n\npublic\nNode( \nint\ndata ) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ngetJosephusPosition(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nNode head = \nnew\nNode(\n1\n); \n\nNode prev = head; \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\n{ \n\nprev.next = \nnew\nNode(i); \n\nprev = prev.next; \n\n} \n\n\n\n\nprev.next = head; \n\n\n\n\nNode ptr1 = head, ptr2 = head; \n\n\nwhile\n(ptr1.next != ptr1) \n\n{ \n\n\n\n\nint\ncount = \n1\n; \n\nwhile\n(count != m) \n\n{ \n\nptr2 = ptr1; \n\nptr1 = ptr1.next; \n\ncount++; \n\n} \n\n\n\n\nptr2.next = ptr1.next; \n\nptr1 = ptr2.next; \n\n} \n\nSystem.out.println (\n\"Last person left standing \"\n+ \n\n\"(Josephus Position) is \"\n+ ptr1.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n14\n, m = \n2\n; \n\ngetJosephusPosition(m, n); \n\n} \n}", "index": 413, "complexity": "3"}
{"back-translation": "class GFG: def maxSum(arr, n): res = float('-inf') for i in range(n): curr_sum = 0 for j in range(n): index = (i + j) % n curr_sum += j * arr[index] res = max(res, curr_sum) return res def main(args): arr = [8, 3, 1, 2] n = len(arr) print(maxSum(arr, n))", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 414, "complexity": "3"}
{"back-translation": "class GFG:\n\n    @staticmethod\n    def calculateSpan(price, n, S):\n        S[0] = 1\n        for i in range(1, n):\n            S[i] = 1\n            for j in range(i - 1, -1, -1):\n                if price[i] >= price[j]:\n                    S[i] += 1\n\n    @staticmethod\n    def printArray(arr):\n        print(str(arr))\n\n\nif __name__ == '__main__':\n    price = [10, 4, 5, 90, 120, 80]\n    n = len(price)\n    S = [0] * n\n\n    GFG.calculateSpan(price, n, S)\n\n    GFG.printArray(S)", "src": "class\nGFG { \n\n\n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n\n\nS[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n\n\ncalculateSpan(price, n, S); \n\n\n\n\nprintArray(S); \n\n} \n}", "index": 415, "complexity": "3"}
{"back-translation": "class\nGFG\n{\n\nstatic\nStack<Integer> sortStack(Stack<Integer> input)\n{\n\nStack<Integer> tmpStack = new Stack<Integer>();\n\nwhile(!input.empty())\n{\nint tmp = input.peek();\ninput.pop();\nwhile(!tmpStack.empty() && tmpStack.peek() < tmp)\n{\ninput.push(tmpStack.peek());\ntmpStack.pop();\n}\ntmpStack.push(tmp);\n}\nreturn tmpStack;\n}\n\nstatic\nvoid\nsortArrayUsingStacks(int[] arr, int n)\n{\nStack<Integer> input = new Stack<Integer>();\nfor(int i = 0; i < n; i++)\ninput.push(arr[i]);\nStack<Integer> tmpStack = sortStack(input);\nfor(int i = 0; i < n; i++)\n{\narr[i] = tmpStack.peek();\ntmpStack.pop();\n}\n}\n\npublic static void main(String args[])\n{\nint[] arr = {10, 5, 15, 45};\nint n = arr.length;\nsortArrayUsingStacks(arr, n);\nfor(int i = 0; i < n; i++)\nSystem.out.print(arr[i] + \" \");\n}\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n\n\n\n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n\n\n\n\n\n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n\n\n\n\n\n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n\n\n\n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n\n\n\n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n\n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 416, "complexity": "3"}
{"back-translation": "class GFG { public static int minIndex(Queue<Integer> list, int sortIndex) { int min_index = -1; int min_value = Integer.MAX_VALUE; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (current <= min_value && i <= sortIndex) { min_index = i; min_value = current; } list.add(current); } return min_index; } public static void insertMinToRear(Queue<Integer> list, int min_index) { int min_value = 0; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (i != min_index) list.add(current); else min_value = current; } list.add(min_value); } public static void sortQueue(Queue<Integer> list) { for (int i = 1; i <= list.size(); i++) { int min_index = minIndex(list,list.size() - i); insertMinToRear(list, min_index); } } public static void main (String[] args) { Queue<Integer> list = new LinkedList<Integer>(); list.add(30); list.add(11); list.add(15); list.add(4); sortQueue(list); while (list.isEmpty()== false) { System.out.print(list.peek() + \" \"); list.poll(); } } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n\n\nlist.poll(); \n\n\n\n\n\n\n\n\n\n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n\n\n\n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n\n\nsortQueue(list); \n\n\n\n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n}", "index": 417, "complexity": "3"}
{"back-translation": "class Node: def __init__(self, data): self.data = data self.left = self.right = None class BinaryTree: def __init__(self): self.root = None def printSpiral(self, node): h = self.height(node) ltr = False for i in range(1, h+1): self.printGivenLevel(node, i, ltr) ltr = not ltr def height(self, node): if node is None: return 0 else: lheight = self.height(node.left) rheight = self.height(node.right) return lheight + 1 if lheight > rheight else rheight + 1 def printGivenLevel(self, node, level, ltr): if node is None: return if level == 1: print(node.data, end=' ') elif level > 1: if ltr: self.printGivenLevel(node.left, level - 1, ltr) self.printGivenLevel(node.right, level - 1, ltr) else: self.printGivenLevel(node.right, level - 1, ltr) self.printGivenLevel(node.left, level - 1, ltr) if __name__ == '__main__': tree = BinaryTree() tree.root = Node(1) tree.root.left = Node(2) tree.root.right = Node(3) tree.root.left.left = Node(7) tree.root.left.right = Node(6) tree.root.right.left = Node(5) tree.root.right.right = Node(4) print('Spiral order traversal of Binary Tree is') tree.printSpiral(tree.root)", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 418, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\n\\n\\nstatic\\nvoid\\nprintKMax(\\nint\\narr[], \\nint\\nmax\\n, \\nint\\nk) \\n\\n{ \\n\\nint\\nj, n; \\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i <= max - k; i++) { \\n\\n\\nint\\nresult = arr[i]; \\n\\n\\nfor\\n(j = \\n1\\n; j < k; j++) { \\n\\nif\\n(arr[i + j] > result) \\n\\nresult = arr[i + j]; \\n\\n} \\n\\nprint(result + \\n\" \"\\n); \\n\\n} \\n\\n} \\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nint\\narr[] = { \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n6\\n, \\n7\\n, \\n8\\n, \\n9\\n, \\n10\\n}; \\n\\nint\\nk = \\n3\\n; \\n\\nprintKMax(arr, arr.length, k); \\n\\n} \\n}', 'complexity': '3', 'index': 419}", "src": "public\nclass\nGFG { \n\n\n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n}", "index": 419, "complexity": "3"}
{"back-translation": "class Solution: def printFirstNegativeInteger(arr, n, k): for i in range(n-k+1): flag = False for j in range(k): if arr[i+j] < 0: print((arr[i+j]), end=' ') flag = True break if not flag: print('0', end=' ') def main(args): arr = [12, -1, -7, 8, -15, 30, 16, 28] n = len(arr) k = 3 printFirstNegativeInteger(arr, n, k) main([])", "src": "class\nsolution \n{ \n\n\n\nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n\n\n\n\nboolean\nflag; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n\n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n}", "index": 420, "complexity": "3"}
{"back-translation": "class GFG: def maxSubarrayXOR(arr, n): ans = float('-inf') for i in range(n): curr_xor = 0 for j in range(i, n): curr_xor = curr_xor ^ arr[j] ans = max(ans, curr_xor) return ans def main(args): arr = [8, 1, 2, 12] n = len(arr) print('Max subarray XOR is ' + str(maxSubarrayXOR(arr, n)))", "src": "class\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\ncurr_xor = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n}", "index": 421, "complexity": "3"}
{"back-translation": "class GFG: def splitArr(arr, n, k): for i in range(k): x = arr[0] for j in range(n - 1): arr[j] = arr[j + 1] arr[n - 1] = x def main(): arr = [12, 10, 5, 6, 52, 36] n = len(arr) position = 2 splitArr(arr, 6, position) for i in range(n): print(arr[i], end=' ')", "complexity": "3", "index": 422, "src": "class\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n\n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}"}
{"back-translation": "class CountKSubStr: def countkDist(str, k): res = 0 n = len(str) cnt = [0] * 26 for i in range(n): dist_count = 0 cnt = [0] * 26 for j in range(i, n): if cnt[ord(str[j]) - ord('a')] == 0: dist_count += 1 cnt[ord(str[j]) - ord('a')] += 1 if dist_count == k: res += 1 return res if __name__ == '__main__': ob = CountKSubStr() ch = 'abcbaa' k = 3 print('Total substrings with exactly ' + str(k) + ' distinct characters : ' + str(ob.countkDist(ch, k)))", "src": "public\nclass\nCountKSubStr \n{ \n\n\n\n\n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n\n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n\n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n\n\nArrays.fill(cnt, \n0\n); \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\n\n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n\n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n\n\n\n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n}", "index": 423, "complexity": "3"}
{"back-translation": "class GFG: \n    MAX_CHAR = 26 \n\n    @staticmethod \n    def check(freq, k): \n        for i in range(0, GFG.MAX_CHAR): \n            if freq[i] != 0 and freq[i] != k: \n                return False \n        return True \n\n    @staticmethod \n    def substrings(s, k): \n        res = 0 \n        for i in range(0, len(s)): \n            freq = [0] * GFG.MAX_CHAR \n            for j in range(i, len(s)): \n                index = ord(s[j]) - ord('a') \n                freq[index] += 1 \n                if freq[index] > k: \n                    break \n                elif freq[index] == k and GFG.check(freq, k) == True: \n                    res += 1 \n        return res \n\n    if __name__ == '__main__': \n        s = 'aabbcc' \n        k = 2 \n        print(GFG.substrings(s, k)) \n\n        s = 'aabbc' \n        k = 2 \n        print(GFG.substrings(s, k))", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n\n\nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n\n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n\n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n\n\n\n\n\n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n\n\n\n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n}", "index": 424, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\nstatic\\nint\\ncountNonEmptySubstr(String str) \\n\\n{ \\n\\nint\\nn = str.length(); \\n\\nreturn\\nn * (n + \\n1\\n) / \\n2\\n; \\n\\n} \\n\\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString s = \\n\"abcde\"\\n; \\n\\nSystem.out.println( \\n\\ncountNonEmptySubstr(s)); \\n\\n} \\n}', 'complexity': '3', 'index': 425}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountNonEmptySubstr(String str) \n\n{ \n\nint\nn = str.length(); \n\nreturn\nn * (n + \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcde\"\n; \n\nSystem.out.println( \n\ncountNonEmptySubstr(s)); \n\n} \n}", "index": 425, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \n\\n\\nstatic\\nboolean\\ncheckEquality(String s) \\n{ \\nreturn\\n(s.charAt(0) == s.charAt(s.length() - 1)); \\n} \\n\\nstatic\\nint\\ncountSubstringWithEqualEnds(String s) \\n{ \\nint\\nresult = 0; \\nint\\nn = s.length(); \\nfor\\n(int\\ni = 0; i < n; i++) \\nfor\\n(int\\nlen = 1; len <= n-i; len++) \\nif\\n(checkEquality(s.substring(i, i + len))) \\nresult++; \\nreturn\\nresult; \\n} \\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n{ \\nString s = \\\"abcab\\\"; \\nSystem.out.println(countSubstringWithEqualEnds(s)); \\n} \\n}', 'complexity': '3', 'index': 426}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckEquality(String s) \n\n{ \n\nreturn\n(s.charAt(\n0\n) == s.charAt(s.length() - \n1\n)); \n\n} \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nlen = \n1\n; len <= n-i; len++) \n\n\n\n\n\n\nif\n(checkEquality(s.substring(i, i + len))) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 426, "complexity": "3"}
{"back-translation": "class Solution:\n    def countSubstringWithEqualEnds(s):\n        result = 0\n        n = len(s)\n        for i in range(n):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    result += 1\n        return result\n    \n    def main(args):\n        s = 'abcab'\n        print(countSubstringWithEqualEnds(s))\n\nSolution.main([])", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i; j < n; j++) \n\nif\n(s.charAt(i) == s.charAt(j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 427, "complexity": "3"}
{"back-translation": "class\nGFG:\n    \n    def SplitAndAdd(A, length, rotation):\n        tmp = [0] * (length * 2)\n        tmp[:length] = A\n        tmp[length:] = A\n        for i in range(rotation, rotation + length):\n            A[i - rotation] = tmp[i]\n\n    def main():\n        arr = [12, 10, 5, 6, 52, 36]\n        n = len(arr)\n        position = 2\n        SplitAndAdd(arr, n, position)\n        for i in range(n):\n            print(arr[i], end=' ')\n\nmain()", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n\n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n\n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 428, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\nstatic\\nfinal\\nint\\nMAX_CHAR = \\n26\\n; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nstatic\\nString getKey(String str) \\n\\n{ \\n\\nboolean\\n[] visited = \\nnew\\nboolean\\n[MAX_CHAR]; \\n\\nArrays.fill(visited, \\nfalse\\n); \\n\\n\\n\\n\\nfor\\n(\\nint\\nj = \\n0\\n; j < str.length(); j++) \\n\\nvisited[str.charAt(j) - \\n'a'\\n] = \\ntrue\\n; \\n\\nString key = \\n''\\n; \\n\\nfor\\n(\\nint\\nj=\\n0\\n; j < MAX_CHAR; j++) \\n\\nif\\n(visited[j]) \\n\\nkey = key + (\\nchar\\n)(\\n'a'\\n+j); \\n\\nreturn\\nkey; \\n\\n} \\n\\n\\n\\nstatic\\nvoid\\nwordsWithSameCharSet(String words[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\n\\nHashMap<String, ArrayList<Integer>> Hash = \\nnew\\nHashMap<>(); \\n\\n\\n\\nfor\\n(\\nint\\ni=\\n0\\n; i<n; i++) \\n\\n{ \\n\\nString key = getKey(words[i]); \\n\\n\\n\\n\\n\\n\\nif\\n(Hash.containsKey(key)) \\n\\n{ \\n\\nArrayList<Integer> get_al = Hash.get(key); \\n\nget_al.add(i); \\n\nHash.put(key, get_al); \\n\n} \\n\\n\\n\\n\\n\\n\\nelse\\n\\n{ \\n\\nArrayList<Integer> new_al = \\nnew\\nArrayList<>(); \\n\nnew_al.add(i); \\n\nHash.put(key, new_al); \\n\n} \\n\\n} \\n\\n\\n\\nfor\\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \\n\\n{ \\n\\nArrayList<Integer> get =it.getValue(); \\n\nfor\\n(Integer v:get) \\n\nSystem.out.print( words[v] + \\n', '\\n); \\n\nSystem.out.println(); \\n\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString words[] = { \\n'may'\\n, \\n'student'\\n, \\n'students'\\n, \\n'dog'\\n, \\n\\n'studentssess'\\n, \\n'god'\\n, \\n'cat'\\n, \\n'act'\\n, \\n'tab'\\n, \\n\\n'bat'\\n, \\n'flow'\\n, \\n'wolf'\\n, \\n'lambs'\\n, \\n'amy'\\n, \\n'yam'\\n, \\n\\n'balms'\\n, \\n'looped'\\n, \\n'poodle'\\n}; \\n\nint\\nn = words.length; \\n\nwordsWithSameCharSet(words, n); \\n\n} \\n}', 'complexity': '3', 'index': 429}", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\n\n\nstatic\nString getKey(String str) \n\n{ \n\nboolean\n[] visited = \nnew\nboolean\n[MAX_CHAR]; \n\nArrays.fill(visited, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str.length(); j++) \n\nvisited[str.charAt(j) - \n'a'\n] = \ntrue\n; \n\nString key = \n\"\"\n; \n\nfor\n(\nint\nj=\n0\n; j < MAX_CHAR; j++) \n\nif\n(visited[j]) \n\nkey = key + (\nchar\n)(\n'a'\n+j); \n\nreturn\nkey; \n\n} \n\n\n\n\nstatic\nvoid\nwordsWithSameCharSet(String words[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nHashMap<String, ArrayList<Integer>> Hash = \nnew\nHashMap<>(); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\nString key = getKey(words[i]); \n\n\n\n\n\n\n\n\nif\n(Hash.containsKey(key)) \n\n{ \n\nArrayList<Integer> get_al = Hash.get(key); \n\nget_al.add(i); \n\nHash.put(key, get_al); \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\nArrayList<Integer> new_al = \nnew\nArrayList<>(); \n\nnew_al.add(i); \n\nHash.put(key, new_al); \n\n} \n\n} \n\n\n\n\nfor\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \n\n{ \n\nArrayList<Integer> get =it.getValue(); \n\nfor\n(Integer v:get) \n\nSystem.out.print( words[v] + \n\", \"\n); \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString words[] = { \n\"may\"\n, \n\"student\"\n, \n\"students\"\n, \n\"dog\"\n, \n\n\"studentssess\"\n, \n\"god\"\n, \n\"cat\"\n, \n\"act\"\n, \n\"tab\"\n, \n\n\"bat\"\n, \n\"flow\"\n, \n\"wolf\"\n, \n\"lambs\"\n, \n\"amy\"\n, \n\"yam\"\n, \n\n\"balms\"\n, \n\"looped\"\n, \n\"poodle\"\n}; \n\nint\nn = words.length; \n\nwordsWithSameCharSet(words, n); \n\n} \n}", "index": 429, "complexity": "3"}
{"back-translation": "class CountSubString { int countSubStr(char str[], int n) { int res = 0; for (int i = 0; i < n; i++) { if (str[i] == '1') { for (int j = i + 1; j < n; j++) { if (str[j] == '1') res++; } } } return res; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n\n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n}", "index": 430, "complexity": "3"}
{"back-translation": "def printMinIndexChar(str, patt):\n    minIndex = float('inf')\n    m = len(str)\n    n = len(patt)\n    for i in range(n):\n        for j in range(m):\n            if patt[i] == str[j] and j < minIndex:\n                minIndex = j\n                break\n    if minIndex != float('inf'):\n        print('Minimum Index Character = {}'.format(str[minIndex]))\n    else:\n        print('No character present')\ndef main():\n    str = 'geeksforgeeks'\n    patt = 'set'\n    printMinIndexChar(str, patt)\n\nmain()", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) { \n\n\n\n\n\n\n\n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\n} \n\n} \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 431, "complexity": "3"}
{"back-translation": "class Test: def countPairs(str): result = 0 n = len(str) for i in range(n): for j in range(i + 1, n): if abs(ord(str[i]) - ord(str[j])) == abs(i - j): result += 1 return result def main(args): str = 'geeksforgeeks' print(countPairs(str)) if __name__ == '__main__': main(None)", "src": "class\nTest { \n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n\n\n\n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 432, "complexity": "3"}
{"back-translation": "class GFG: def findSubsequenceCount(S, T): m = len(T) n = len(S) if m > n: return 0 mat = [[0 for i in range(n + 1)] for j in range(m + 1)] for i in range(1, m + 1): mat[i][0] = 0 for j in range(n + 1): mat[0][j] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if T[i - 1] != S[j - 1]: mat[i][j] = mat[i][j - 1] else: mat[i][j] = mat[i][j - 1] + mat[i - 1][j - 1] return mat[m][n] def main(args): T = 'ge' S = 'geeksforgeeks' print(findSubsequenceCount(S, T)) if __name__ == '__main__': import sys ret=main(sys.argv) sys.exit(ret)", "src": "class\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n\n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n\n\n\n\n\n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n\n\n\n\n\n\n\n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\nmat[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n}", "index": 433, "complexity": "3"}
{"back-translation": "class GFG: def bellNumber(n): bell = [[0 for _ in range(n+1)] for _ in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0] if __name__ == '__main__': for n in range(6): print('Bell Number ' + str(n) + ' is ' + str(bellNumber(n)))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n\n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n}", "index": 434, "complexity": "3"}
{"back-translation": "class GFG:\n    @staticmethod\n    def catalanDP(n):\n        catalan = [0] * (n + 2)\n        catalan[0] = 1\n        catalan[1] = 1\n        for i in range(2, n + 1):\n            catalan[i] = 0\n            for j in range(i):\n                catalan[i] += catalan[j] * catalan[i - j - 1]\n        return catalan[n]\n\n    @staticmethod\n    def main(args):\n        for i in range(10):\n            print(GFG.catalanDP(i), end=' ')\n\nGFG.main([])", "src": "class\nGFG{ \n\n\n\n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n\n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n\n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ncatalan[n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n}", "index": 435, "complexity": "3"}
{"back-translation": "class BinomialCoefficient: def binomialCoeff(n, k): C = [[0 for x in range(k+1)] for x in range(n+1)] for i in range(n+1): for j in range(min(i, k)+1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k] def min(a, b): return a if a < b else b n, k = 5, 2 print(f\"Value of C({n},{k}) is {binomialCoeff(n, k)}\")", "src": "class\nBinomialCoefficient \n{ \n\n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n\n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n\n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n\n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n}", "index": 436, "complexity": "3"}
{"back-translation": "class GFG: def permutationCoeff(n, k): P = [[0 for _ in range(k + 2)] for _ in range(n + 2)] for i in range(n + 1): for j in range(min(i, k) + 1): if j == 0: P[i][j] = 1 else: P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1]) P[i][j + 1] = 0 return P[n][k] def main(args): n, k = 10, 2 print('Value of P(', n, ',', k, ') is', permutationCoeff(n, k)) ", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n\n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n\n\n\n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n\n\n\n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 437, "complexity": "3"}
{"back-translation": "class GFG:\n\n    MAX = 100\n\n    @staticmethod\n    def getMaxGold(gold, m, n):\n        goldTable = [[0 for _ in range(n)] for _ in range(m)]\n        for col in range(n-1, -1, -1):\n            for row in range(m):\n                right = 0 if col == n-1 else goldTable[row][col+1]\n                right_up = 0 if row == 0 or col == n-1 else goldTable[row-1][col+1]\n                right_down = 0 if row == m-1 or col == n-1 else goldTable[row+1][col+1]\n                goldTable[row][col] = gold[row][col] + max(right, max(right_up, right_down))\n        res = goldTable[0][0]\n        for i in range(1, m):\n            res = max(res, goldTable[i][0])\n        return res\n\n    @staticmethod\n    def main(arg):\n        gold = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n        m = 4\n        n = 4\n        print(GFG.getMaxGold(gold, m, n))\n", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n\n\n\n\n\n\n\n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n\n\n\n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n\n\n\n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n\n\n\n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n\n\n\n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n\n\n\n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n}", "index": 438, "complexity": "3"}
{"back-translation": "class GFG: def merge(arr, l, m, r): n1 = m - l + 1 n2 = r - m L = [0] * n1 R = [0] * n2 for i in range(n1): L[i] = arr[l + i] for j in range(n2): R[j] = arr[m + 1 + j] i = 0 j = 0 k = l while i < n1 and L[i] < 0: arr[k] = L[i] k += 1 i += 1 while j < n2 and R[j] < 0: arr[k] = R[j] k += 1 j += 1 while i < n1: arr[k] = L[i] k += 1 i += 1 while j < n2: arr[k] = R[j] k += 1 def RearrangePosNeg(arr, l, r): if l < r: m = l + (r - l) // 2 RearrangePosNeg(arr, l, m) RearrangePosNeg(arr, m + 1, r) merge(arr, l, m, r) def printArray(A, size): for i in range(size): print(A[i], end=' ') print() arr = [-12, 11, -13, -5, 6, -7, 5, -3, -6] arr_size = len(arr) RearrangePosNeg(arr, 0, arr_size - 1) printArray(arr, arr_size)", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni, j, k; \n\nint\nn1 = m - l + \n1\n; \n\nint\nn2 = r - m; \n\n\n\n\nint\nL[] = \nnew\nint\n[n1]; \n\nint\nR[] = \nnew\nint\n[n2]; \n\n\n\n\nfor\n(i = \n0\n; i < n1; i++) \n\nL[i] = arr[l + i]; \n\nfor\n(j = \n0\n; j < n2; j++) \n\nR[j] = arr[m + \n1\n+ j]; \n\n\n\n\n\n\ni = \n0\n; \n\n\n\n\nj = \n0\n; \n\n\n\n\nk = l; \n\n\n\n\n\n\n\n\n\n\n\nwhile\n(i < n1 && L[i] < \n0\n) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2 && R[j] < \n0\n) \n\narr[k++] = R[j++]; \n\n\n\n\nwhile\n(i < n1) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2) \n\narr[k++] = R[j++]; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\nprintArray(arr, arr_size); \n\n} \n}", "index": 439, "complexity": "3"}
{"back-translation": "class GFG: def isSubsetSum(set, n, sum): subset = [[False for i in range(n + 1)] for j in range(sum + 1)] for i in range(n + 1): subset[0][i] = True for i in range(1, sum + 1): subset[i][0] = False for i in range(1, sum + 1): for j in range(1, n + 1): subset[i][j] = subset[i][j - 1] if i >= set[j - 1] else subset[i][j - 1] or subset[i - set[j - 1]][j - 1] return subset[sum][n] def main(args): set = [3, 34, 4, 12, 5, 2] sum = 9 n = len(set) if isSubsetSum(set, n, sum): print(\"Found a subset\" + \" with given sum\") else: print(\"No subset with\" + \" given sum\") if __name__ == \"__main__\": import sys main(sys.argv)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n\n\n\n\n\n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n}", "index": 440, "complexity": "3"}
{"back-translation": "class GFG: def modularSum(arr, n, m): if n > m: return True DP = [False] * m for i in range(n): if DP[0]: return True temp = [False] * m for j in range(m): if DP[j]: if not DP[(j + arr[i]) % m]: temp[(j + arr[i]) % m] = True for j in range(m): if temp[j]: DP[j] = True DP[arr[i] % m] = True return DP[0] def main(arg): arr = [1, 7] n = len(arr) m = 5 if modularSum(arr, n, m): print('YES') else: print('NO') if __name__ == '__main__': import numpy as np main(np.array([])) ", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nmodularSum(\nint\narr[], \n\nint\nn, \nint\nm) \n\n{ \n\nif\n(n > m) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\nboolean\nDP[]=\nnew\nboolean\n[m]; \n\n\nArrays.fill(DP, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(DP[\n0\n]) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\nboolean\ntemp[] = \nnew\nboolean\n[m]; \n\nArrays.fill(temp, \nfalse\n); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\n{ \n\n\n\n\n\n\nif\n(DP[j] == \ntrue\n) \n\n{ \n\nif\n(DP[(j + arr[i]) % m] == \nfalse\n) \n\n\n\n\n\n\ntemp[(j + arr[i]) % m] = \ntrue\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\nif\n(temp[j]) \n\nDP[j] = \ntrue\n; \n\n\n\n\n\n\n\n\n\nDP[arr[i] % m] = \ntrue\n; \n\n} \n\n\nreturn\nDP[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {\n1\n, \n7\n}; \n\nint\nn = arr.length; \n\nint\nm = \n5\n; \n\n\nif\n(modularSum(arr, n, m)) \n\nSystem.out.print(\n\"YES\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"NO\\n\"\n); \n\n} \n}", "index": 441, "complexity": "3"}
{"back-translation": "class GFG:\n    @staticmethod\n    def largestSubset(a, n):\n        a.sort()\n        dp = [0] * n\n        dp[n - 1] = 1\n        for i in range(n - 2, -1, -1):\n            mxm = 0\n            for j in range(i + 1, n):\n                if a[j] % a[i] == 0:\n                    mxm = max(mxm, dp[j])\n            dp[i] = 1 + mxm\n        return max(dp)\n\n    def main(args):\n        a = [1, 3, 6, 13, 17, 18]\n        n = len(a)\n        print(GFG.largestSubset(a, n))\n", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nlargestSubset(\nint\n[] a, \nint\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[n - \n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) { \n\n\n\n\n\n\n\n\nint\nmxm = \n0\n; \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) { \n\nif\n(a[j] % a[i] == \n0\n) { \n\nmxm = Math.max(mxm, dp[j]); \n\n} \n\n} \n\n\ndp[i] = \n1\n+ mxm; \n\n} \n\n\n\n\nreturn\nArrays.stream(dp).max().getAsInt(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] a = { \n1\n, \n3\n, \n6\n, \n13\n, \n17\n, \n18\n}; \n\nint\nn = a.length; \n\nSystem.out.println(largestSubset(a, n)); \n\n} \n}", "index": 442, "complexity": "3"}
{"back-translation": "class RodCutting: def cutRod(price, n): val = [0] * (n + 1) for i in range(1, n + 1): max_val = float('-inf') for j in range(0, i): max_val = max(max_val, price[j] + val[i - j - 1]) val[i] = max_val return val[n] def main(args): arr = [1, 5, 8, 9, 10, 17, 17, 20] size = len(arr) print(\"Maximum Obtainable Value is \" + str(cutRod(arr, size))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nRodCutting \n{ \n\n\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i<=n; i++) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n}", "index": 443, "complexity": "3"}
{"back-translation": "class GFG: lookup = [[-1 for _ in range(1000)] for _ in range(1000)] def countSeqUtil(n, dif): if abs(dif) > n: return 0 if n == 1 and dif == 0: return 2 if n == 1 and abs(dif) == 1: return 1 if lookup[n][n+dif] != -1: return lookup[n][n+dif] res = countSeqUtil(n-1, dif+1) + 2*countSeqUtil(n-1, dif) + countSeqUtil(n-1, dif-1) lookup[n][n+dif] = res return res def countSeq(n): for k in range(len(lookup)): for j in range(len(lookup)): lookup[k][j] = -1 return countSeqUtil(n, 0) def main(args): n = 2 print('Count of sequences is', countSeq(2))", "src": "class\nGFG { \n\n\n\nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n\n\n\nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n\n\n\n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n\n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n\n\n\n\n\n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n\n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n\n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n\n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n\n\n\n\nreturn\nlookup[n][n+dif] = res; \n} \n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n\n\n\n\n\n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n\n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n}", "index": 444, "complexity": "3"}
{"back-translation": "class Sequences:\n    @staticmethod\n    def getTotalNumberOfSequences(m, n):\n        T = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0 or j == 0:\n                    T[i][j] = 0\n                elif i < j:\n                    T[i][j] = 0\n                elif j == 1:\n                    T[i][j] = i\n                else:\n                    T[i][j] = T[i-1][j] + T[i//2][j-1]\n        return T[m][n]\n\n    @staticmethod\n    def main(args):\n        m = 10\n        n = 4\n        print(\"Total number of possible sequences \" + str(Sequences.getTotalNumberOfSequences(m, n)))\n\nSequences.main([])", "src": "class\nSequences \n{ \n\n\n\n\n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n\n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n}", "index": 445, "complexity": "3"}
{"back-translation": "class GFG:\n    @staticmethod\n    def MaxSumBS(arr, n):\n        max_sum = float('-inf')\n        MSIBS = [arr[i] for i in range(n)]\n        MSDBS = [arr[i] for i in range(n)]\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]:\n                    MSIBS[i] = MSIBS[j] + arr[i]\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[i] > arr[j] and MSDBS[i] < MSDBS[j] + arr[i]:\n                    MSDBS[i] = MSDBS[j] + arr[i]\n        for i in range(n):\n            max_sum = max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i]))\n        return max_sum\n    @staticmethod\n    def main(args):\n        arr = [1, 15, 51, 45, 33, 100, 12, 18, 9]\n        n = len(arr)\n        print('Maximum Sum : ' + str(GFG.MaxSumBS(arr, n)))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n\n\n\n\nreturn\nmax_sum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n}", "index": 446, "complexity": "3"}
{"back-translation": "class GFG: def maxSumIS(arr, n): i, j, max = 0 msis = [0]*n for i in range(n): msis[i] = arr[i] for i in range(1, n): for j in range(i): if(arr[i] > arr[j] and msis[i] < msis[j] + arr[i]): msis[i] = msis[j] + arr[i] for i in range(n): if(max < msis[i]): max = msis[i] return max def main(args): arr = [1, 101, 2, 3, 100, 4, 5] n = len(arr) print(\"Sum of maximum sum \" + \"increasing subsequence is \" + str(maxSumIS(arr, n)))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 447, "complexity": "3"}
{"back-translation": "class GFG: def lis(arr, n): mpis = [0] * n max = float('-inf') for i in range(n): mpis[i] = arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and mpis[i] < (mpis[j] * arr[i]): mpis[i] = mpis[j] * arr[i] for k in range(len(mpis)): if mpis[k] > max: max = mpis[k] return max def main(args): arr = [3, 100, 4, 5, 150, 6] n = len(arr) print(lis(arr, n)) if __name__ == '__main__': import sys sys.exit(main(sys.argv))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n}", "index": 448, "complexity": "3"}
{"back-translation": "class GFG: def longestSubseqWithDiffOne(arr, n): dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] == arr[j] + 1 or arr[i] == arr[j] - 1: dp[i] = max(dp[i], dp[j] + 1) result = 1 for i in range(n): if result < dp[i]: result = dp[i] return result def main(args): arr = [1, 2, 3, 4, 5, 3, 2] n = len(arr) print(longestSubseqWithDiffOne(arr, n)) main(None)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n\n\n\n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n}", "index": 449, "complexity": "3"}
{"back-translation": "class\nGFG:\n\n    @staticmethod\n    def maxLenSub(arr, n):\n        mls = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1:\n                    mls[i] = mls[j] + 1\n        max_val = 0\n        for i in range(n):\n            if max_val < mls[i]:\n                max_val = mls[i]\n        return max_val\n\n    @staticmethod\n    def main(args):\n        arr = [2, 5, 6, 3, 7, 6, 5, 8]\n        n = len(arr)\n        print('Maximum length subsequence = ' + str(GFG.maxLenSub(arr, n)))\n", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n}", "index": 450, "complexity": "3"}
{"back-translation": "class GFG: def pre_compute(a, n, index, k): dp = [[0 for i in range(n)] for j in range(n)] for i in range(n): if a[i] > a[0]: dp[0][i] = a[i] + a[0] else: dp[0][i] = a[i] for i in range(1, n): for j in range(n): if a[j] > a[i] and j > i: if dp[i - 1][i] + a[j] > dp[i - 1][j]: dp[i][j] = dp[i - 1][i] + a[j] else: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[index][k] def main(args): a = [1, 101, 2, 3, 100, 4, 5] n = len(a) index = 4 k = 6 print(pre_compute(a, n, index, k)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG { \n\n\nstatic\nint\npre_compute(\nint\na[], \nint\nn, \n\nint\nindex, \nint\nk) \n\n{ \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(a[i] > a[\n0\n]) \n\ndp[\n0\n][i] = a[i] + a[\n0\n]; \n\nelse\n\ndp[\n0\n][i] = a[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(a[j] > a[i] && j > i) \n\n{ \n\nif\n(dp[i - \n1\n][i] + a[j] > \n\ndp[i - \n1\n][j]) \n\ndp[i][j] = dp[i - \n1\n][i] \n\n+ a[j]; \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[index][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = a.length; \n\nint\nindex = \n4\n, k = \n6\n; \n\nSystem.out.println( \n\npre_compute(a, n, index, k)); \n\n} \n}", "index": 451, "complexity": "3"}
{"back-translation": "class Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    @staticmethod\n    def maxChainLength(arr, n):\n        mcl = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i].a > arr[j].b and mcl[i] < mcl[j] + 1:\n                    mcl[i] = mcl[j] + 1\n        max = 0\n        for i in range(n):\n            if max < mcl[i]:\n                max = mcl[i]\n        return max\n\n    @staticmethod\n    def main(args):\n        arr = [Pair(5, 24), Pair(15, 25), Pair(27, 40), Pair(50, 60)]\n        print(\"Length of maximum size chain is \" + str(Pair.maxChainLength(arr, len(arr))))\n", "src": "class\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n\n\n\n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n\n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n}", "index": 452, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintMaxSubSquare(\\nint\\nM[][]) \\n\\n{ \\n\\nint\\ni,j; \\n\\nint\\nR = M.length; \\n\\n\\nint\\nC = M[\\n0\\n].length; \\n\\n\\nint\\nS[][] = \\nnew\\nint\\n[R][C]; \\n\\n\\nint\\nmax_of_s, max_i, max_j; \\n\\n\\n\\nfor\\n(i = \\n0\\n; i < R; i++) \\n\\nS[i][\\n0\\n] = M[i][\\n0\\n]; \\n\\n\\n\\nfor\\n(j = \\n0\\n; j < C; j++) \\n\\nS[\\n0\\n][j] = M[\\n0\\n][j]; \\n\\n\\n\\nfor\\n(i = \\n1\\n; i < R; i++) \\n\\n{ \\n\\nfor\\n(j = \\n1\\n; j < C; j++) \\n\\n{ \\n\\nif\\n(M[i][j] == \\n1\\n) \\n\\nS[i][j] = Math.min(S[i][j-\\n1\\n], \\n\\nMath.min(S[i-\\n1\\n][j], S[i-\\n1\\n][j-\\n1\\n])) + \\n1\\n; \\n\\nelse\\n\\nS[i][j] = \\n0\\n; \\n\\n} \\n\\n} \\n\\n\\n\\nmax_of_s = S[\\n0\\n][\\n0\\n]; max_i = \\n0\\n; max_j = \\n0\\n; \\n\\nfor\\n(i = \\n0\\n; i < R; i++) \\n\\n{ \\n\\nfor\\n(j = \\n0\\n; j < C; j++) \\n\\n{ \\n\\nif\\n(max_of_s < S[i][j]) \\n\\n{ \\n\\nmax_of_s = S[i][j]; \\n\\nmax_i = i; \\n\\nmax_j = j; \\n\\n} \\n\\n} \\n\\n} \\n\\n\\nSystem.out.println(\\n\\", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMaxSubSquare(\nint\nM[][]) \n\n{ \n\nint\ni,j; \n\nint\nR = M.length; \n\n\nint\nC = M[\n0\n].length; \n\n\nint\nS[][] = \nnew\nint\n[R][C]; \n\n\nint\nmax_of_s, max_i, max_j; \n\n\n\n\nfor\n(i = \n0\n; i < R; i++) \n\nS[i][\n0\n] = M[i][\n0\n]; \n\n\n\n\nfor\n(j = \n0\n; j < C; j++) \n\nS[\n0\n][j] = M[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i < R; i++) \n\n{ \n\nfor\n(j = \n1\n; j < C; j++) \n\n{ \n\nif\n(M[i][j] == \n1\n) \n\nS[i][j] = Math.min(S[i][j-\n1\n], \n\nMath.min(S[i-\n1\n][j], S[i-\n1\n][j-\n1\n])) + \n1\n; \n\nelse\n\nS[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nmax_of_s = S[\n0\n][\n0\n]; max_i = \n0\n; max_j = \n0\n; \n\nfor\n(i = \n0\n; i < R; i++) \n\n{ \n\nfor\n(j = \n0\n; j < C; j++) \n\n{ \n\nif\n(max_of_s < S[i][j]) \n\n{ \n\nmax_of_s = S[i][j]; \n\nmax_i = i; \n\nmax_j = j; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\"Maximum size sub-matrix is: \"\n); \n\nfor\n(i = max_i; i > max_i - max_of_s; i--) \n\n{ \n\nfor\n(j = max_j; j > max_j - max_of_s; j--) \n\n{ \n\nSystem.out.print(M[i][j] + \n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nM[][] = {{\n0\n, \n1\n, \n1\n, \n0\n, \n1\n}, \n\n{\n1\n, \n1\n, \n0\n, \n1\n, \n0\n}, \n\n{\n0\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n}}; \n\n\nprintMaxSubSquare(M); \n\n} \n\n}", "index": 453, "complexity": "3"}
{"back-translation": "class GFG: def maxCost(mat, N): dp = [[0 for _ in range(N)] for _ in range(N)] dp[0][0] = mat[0][0] for i in range(1, N): dp[i][0] = mat[i][0] + dp[i-1][0] for i in range(1, N): for j in range(1, i+1 if i+1 < N else N): dp[i][j] = mat[i][j] + max(dp[i-1][j-1], dp[i-1][j]) result = 0 for i in range(N): if result < dp[N-1][i]: result = dp[N-1][i] return result def main(args): mat = [[4, 1, 5, 6, 1], [2, 9, 2, 11, 10], [15, 1, 3, 15, 2], [16, 92, 41, 4, 3], [8, 142, 6, 4, 8]] N = 5 print('Maximum Path Sum : ' + str(maxCost(mat, N)))", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n\n\n\n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n}", "index": 454, "complexity": "3"}
{"back-translation": "class GFG:\n    N = 4\n    @staticmethod\n    def MaximumPath(Mat):\n        result = 0\n        dp = [[0 for _ in range(N + 2)] for _ in range(N)]\n        for rows in dp:\n            rows = [0] * (N + 2)\n        for i in range(N):\n            dp[0][i + 1] = Mat[0][i]\n        for i in range(1, N):\n            for j in range(1, N + 1):\n                dp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i - 1][j + 1])) + Mat[i][j - 1]\n        for i in range(N + 1):\n            result = max(result, dp[N - 1][i])\n        return result\n    @staticmethod\n    def main(arg):\n        Mat = [[4, 2, 3, 4], [2, 9, 1, 10], [15, 1, 3, 0], [16, 92, 41, 44]]\n        print(GFG.MaximumPath(Mat))\n", "src": "class\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n\n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n\n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n}", "index": 455, "complexity": "3"}
{"back-translation": "class MinimumCostPath: private static def min(x, y, z): return x if x < y else y if y < z else z private static def minCost(cost, m, n): tc = [[0 for _ in range(n+1)] for _ in range(m+1)] tc[0][0] = cost[0][0] for i in range(1, m+1): tc[i][0] = tc[i-1][0] + cost[i][0] for j in range(1, n+1): tc[0][j] = tc[0][j-1] + cost[0][j] for i in range(1, m+1): for j in range(1, n+1): tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] return tc[m][n] def main(args): cost = [[1, 2, 3], [4, 8, 2], [1, 5, 3]] print(minCost(cost, 2, 2)) if __name__ == '__main__': import sys sys.exit(main(sys.argv))", "src": "class\nMinimumCostPath \n{ \n\n\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n}", "index": 456, "complexity": "3"}
{"back-translation": "class GFG{ private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if (n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; for (i = 1; i < n; i++) { jumps[i] = Integer.MAX_VALUE; for (j = 0; j < i; j++) { if (i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } } } return jumps[n-1]; } public static void main(String[] args) { int arr[] = {1, 3, 6, 1, 0, 9}; System.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr,arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 457, "complexity": "3"}
{"back-translation": "class GFG: static MAX=100 static dp=[[-1 for i in range(MAX)] for j in range(MAX)] def countRemovals(a, i, j, k): if i >= j: return 0 if a[j] - a[i] <= k: return 0 if dp[i][j] != -1: return dp[i][j] if a[j] - a[i] > k: dp[i][j] = 1 + min(countRemovals(a, i + 1, j, k), countRemovals(a, i, j - 1, k)) return dp[i][j] def removals(a, n, k): a.sort() for row in dp: for i in range(len(row)): row[i] = -1 if n == 1: return 0 else: return countRemovals(a, 0, n - 1, k) def main(args): a = [1, 3, 4, 9, 10, 11, 12, 17, 20] n = len(a) k = 4 print(removals(a, n, k)) if __name__ == '__main__': import sys main(sys.argv[1:])", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX=\n100\n; \n\nstatic\nint\ndp[][]=\nnew\nint\n[MAX][MAX]; \n\n\n\n\n\n\nstatic\nint\ncountRemovals(\nint\na[], \nint\ni, \nint\nj, \nint\nk) \n\n{ \n\n\n\nif\n(i >= j) \n\nreturn\n0\n; \n\n\n\n\n\n\nelse\nif\n((a[j] - a[i]) <= k) \n\nreturn\n0\n; \n\n\n\n\nelse\nif\n(dp[i][j] != -\n1\n) \n\nreturn\ndp[i][j]; \n\n\n\n\nelse\nif\n((a[j] - a[i]) > k) { \n\n\n\n\n\n\n\n\ndp[i][j] = \n1\n+ Math.min(countRemovals(a, i + \n1\n, j, k), \n\ncountRemovals(a, i, j - \n1\n, k)); \n\n} \n\nreturn\ndp[i][j]; \n\n} \n\n\n\n\nstatic\nint\nremovals(\nint\na[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nfor\n(\nint\n[] rows:dp) \n\nArrays.fill(rows,-\n1\n); \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\nelse\n\nreturn\ncountRemovals(a, \n0\n, n - \n1\n, k); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n3\n, \n4\n, \n9\n, \n10\n, \n11\n, \n12\n, \n17\n, \n20\n}; \n\nint\nn = a.length; \n\nint\nk = \n4\n; \n\nSystem.out.print(removals(a, n, k)); \n\n} \n}", "index": 458, "complexity": "3"}
{"back-translation": "class EDIST: def min(x, y, z): if x <= y and x <= z: return x if y <= x and y <= z: return y else: return z def editDistDP(str1, str2, m, n): dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][n] def main(args): str1 = 'sunday' str2 = 'saturday' print(editDistDP(str1, str2, len(str1), len(str2))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}", "index": 459, "complexity": "3"}
{"back-translation": "class LongestCommonSubSequence:\n\n    @staticmethod\n    def LCSubStr(X, Y, m, n):\n        LCStuff = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        result = 0\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 or j == 0:\n                    LCStuff[i][j] = 0\n                elif X[i - 1] == Y[j - 1]:\n                    LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1\n                    result = max(result, LCStuff[i][j])\n                else:\n                    LCStuff[i][j] = 0\n        return result\n\n    @staticmethod\n    def main(args):\n        X = \"OldSite:GeeksforGeeks.org\"\n        Y = \"NewSite:GeeksQuiz.com\"\n        m = len(X)\n        n = len(Y)\n        print(\"Length of Longest Common Substring is \" + str(LongestCommonSubSequence.LCSubStr(list(X), list(Y), m, n)))\n\nLongestCommonSubSequence.main([])", "src": "public\nclass\nLongestCommonSubSequence \n{ \n\n\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n}", "index": 460, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nLCSubStr(String X, String Y) \\n\\n{ \\n\\n\\n\\nint\\nm = X.length(); \\n\\nint\\nn = Y.length(); \\n\\n\\n\\n\\nint\\nresult = \\n0\\n; \\n\\n\\n\\n\\nint\\n[][]len = \\nnew\\nint\\n[\\n2\\n][n]; \\n\\n\\n\\n\\nint\\ncurrRow = \\n0\\n; \\n\\n\\n\\n\\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < m; i++) { \\n\\nfor\\n(\\nint\\nj = \\n0\\n; j < n; j++) { \\n\\nif\\n(i == \\n0\\n|| j == \\n0\\n) { \\n\\nlen[currRow][j] = \\n0\\n; \\n\\n} \\n\\nelse\\nif\\n(X.charAt(i - \\n1\\n) == \\n\\nY.charAt(j - \\n1\\n)) \\n\\n{ \\n\\nlen[currRow][j] = \\n\\nlen[(\\n1\\n- currRow)][(j - \\n1\\n)] \\n\\n+ \\n1\\n; \\n\\nresult = max(result, \\n\\nlen[currRow][j]); \\n\\n} \\n\\nelse\\n\\n{ \\n\\nlen[currRow][j] = \\n0\\n; \\n\\n} \\n\\n} \\n\\n\\n\\n\\n\\n\\ncurrRow = \\n1\\n- currRow; \\n\\n} \\n\\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString X = \\n\"GeeksforGeeks\"\\n; \\n\\nString Y = \\n\"GeeksQuiz\"\\n; \\n\\n\\nSystem.out.print(LCSubStr(X, Y)); \\n\\n} \\n}', 'complexity': '3', 'index': 461}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n\n\n\n\nint\ncurrRow = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n}", "index": 461, "complexity": "3"}
{"back-translation": "class GFG: def offeringNumber(n, templeHeight): sum = 0 for i in range(n): left, right = 0, 0 for j in range(i-1, -1, -1): if templeHeight[j] < templeHeight[j + 1]: left += 1 else: break for j in range(i+1, n): if templeHeight[j] < templeHeight[j - 1]: right += 1 else: break sum += max(right, left) + 1 return sum def main(args): arr1 = [1, 2, 2] print(offeringNumber(3, arr1)) arr2 = [1, 4, 3, 6, 2, 1] print(offeringNumber(6, arr2))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\n\n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n}", "index": 462, "complexity": "3"}
{"back-translation": "class GFG: def printEqualSumSets(arr, n): i, currSum, sum = 0, 0, 0 for i in range(0, len(arr)): sum += arr[i] if (sum & 1) == 1: print('-1') return k = sum >> 1 dp = [[False for _ in range(k + 1)] for _ in range(n + 1)] for i in range(1, k + 1): dp[0][i] = False for i in range(0, n + 1): dp[i][0] = True for i in range(1, n + 1): for currSum in range(1, k + 1): dp[i][currSum] = dp[i - 1][currSum] if arr[i - 1] <= currSum: dp[i][currSum] = dp[i][currSum] or dp[i - 1][currSum - arr[i - 1]] set1, set2 = [], [] if not dp[n][k]: print('-1\\n') return i, currSum = n, k while i > 0 and currSum >= 0: if dp[i - 1][currSum]: i -= 1 set2.append(arr[i]) elif dp[i - 1][currSum - arr[i - 1]]: i -= 1 currSum -= arr[i] set1.append(arr[i]) print('Set 1 elements: ', end='') for i in range(len(set1)): print(set1[i], end=' ') print('\\nSet 2 elements: ', end='') for i in range(len(set2)): print(set2[i], end=' ') if __name__ == '__main__': arr = [5, 5, 1, 11] n = len(arr) printEqualSumSets(arr, n)", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n\n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n\n\n\n\n\n\n\n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\nint\nk = sum >> \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n\n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n\n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n\n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n\n\n\n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n\n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n}", "index": 463, "complexity": "3"}
{"back-translation": "class LBS:\n    def lbs(arr, n):\n        lis = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n        lds = [1] * n\n        for i in range(n):\n            lds[i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[i] > arr[j] and lds[i] < lds[j] + 1:\n                    lds[i] = lds[j] + 1\n        max_val = lis[0] + lds[0] - 1\n        for i in range(1, n):\n            if lis[i] + lds[i] - 1 > max_val:\n                max_val = lis[i] + lds[i] - 1\n        return max_val\n    def main(args):\n        arr = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n        n = len(arr)\n        print(\"Length of LBS is \" + str(LBS.lbs(arr, n)))\nLBS.main([])", "src": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "index": 464, "complexity": "3"}
{"back-translation": "class\nGFG:\n    @staticmethod\n    def lps(s):\n        n = len(s)\n        a = [0] * n\n        for i in range(n-1, -1, -1):\n            back_up = 0\n            for j in range(i, n):\n                if j == i:\n                    a[j] = 1\n                elif s[i] == s[j]:\n                    temp = a[j]\n                    a[j] = back_up + 2\n                    back_up = temp\n                else:\n                    back_up = a[j]\n                    a[j] = max(a[j-1], a[j])\n        return a[n-1]\n\n    if __name__ == '__main__':\n        str = \"GEEKSFORGEEKS\"\n        print(lps(str))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nint\na[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n\n\n\n\n\n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n\n\n\n\n\n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n}", "index": 465, "complexity": "3"}
{"back-translation": "class GFG:\n    @staticmethod\n    def countPS(str):\n        N = len(str)\n        cps = [[0 for i in range(N + 1)] for j in range(N + 1)]\n        for i in range(N):\n            cps[i][i] = 1\n        for L in range(2, N + 1):\n            for i in range(N):\n                k = L + i - 1\n                if k < N:\n                    if str[i] == str[k]:\n                        cps[i][k] = cps[i][k - 1] + cps[i + 1][k] + 1\n                    else:\n                        cps[i][k] = cps[i][k - 1] + cps[i + 1][k] - cps[i + 1][k - 1]\n        return cps[0][N - 1]\n    @staticmethod\n    def main(args):\n        str = 'abcb'\n        print('Total palindromic ' + 'subsequence are : ' + str(GFG.countPS(str)))\n\nGFG.main([])", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n\n\n\n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n\n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n}", "index": 466, "complexity": "3"}
{"back-translation": "def print_substr(s, low, high):\n    print(s[low:high + 1])\n\n\ndef longest_pal_substr(s):\n    n = len(s)\n    table = [[False for _ in range(n)] for _ in range(n)]\n    max_length = 1\n    for i in range(n):\n        table[i][i] = True\n    start = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            table[i][i + 1] = True\n            start = i\n            max_length = 2\n    for k in range(3, n + 1):\n        for i in range(n - k + 1):\n            j = i + k - 1\n            if table[i + 1][j - 1] and s[i] == s[j]:\n                table[i][j] = True\n                if k > max_length:\n                    start = i\n                    max_length = k\n    print('Longest palindrome substring is:', end='')\n    print_substr(s, start, start + max_length - 1)\n    return max_length\n\n\ns = 'forgeeksskeegfor'\nprint('Length is:', longest_pal_substr(s))", "src": "public\nclass\nLongestPalinSubstring \n{ \n\n\n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n\n\n\n\n\n\n\n\n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n\n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n\n\n\n\nint\nj = i + k - \n1\n; \n\n\n\n\n\n\n\n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n}", "index": 467, "complexity": "3"}
{"back-translation": "def CountPS(str, n): \n dp = [[0 for i in range(n)] for j in range(n)] \n P = [[False for i in range(n)] for j in range(n)] \n for i in range(n): \n P[i][i] = True \n for i in range(n-1): \n if str[i] == str[i+1]: \n P[i][i+1] = True \n dp[i][i+1] = 1 \n for gap in range(2,n): \n for i in range(n-gap): \n j = gap + i \n if str[i] == str[j] and P[i+1][j-1]: \n P[i][j] = True \n if P[i][j]: \n dp[i][j] = dp[i][j-1] + dp[i+1][j] + 1 - dp[i+1][j-1] \n else: \n dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1] \n return dp[0][n-1] \n def main(str): \n str = \"abaab\" \n print(CountPS(list(str), len(str))) \n if __name__ == \"__main__\": \n main()", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n\n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n\n\nint\nj = gap + i; \n\n\n\n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n\n\n\n\n\n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n}", "index": 468, "complexity": "3"}
{"back-translation": "class GFG: def constructDp(dp, str): l = len(str) isPalin = [[0 for _ in range(l+1)] for _ in range(l+1)] for i in range(l+1): for j in range(l+1): isPalin[i][j] = dp[i][j] = 0 for i in range(l-1, -1, -1): isPalin[i][i] = 1 dp[i][i] = 1 for j in range(i+1, l): isPalin[i][j] = 1 if str[i] == str[j] and (i+1 > j-1 or isPalin[i+1][j-1] != 0) else 0 dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1] + isPalin[i][j] def countOfPalindromeInRange(dp, l, r): return dp[l][r] if __name__ == '__main__': MAX = 50 str = 'xyaabax' dp = [[0 for _ in range(MAX)] for _ in range(MAX)] constructDp(dp, str) l = 3 r = 5 print(countOfPalindromeInRange(dp, l, r))", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\n\n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n\n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n}", "index": 469, "complexity": "3"}
{"back-translation": "class GFG: def maxAlternateSum(arr, n): if n == 1: return arr[0] dec = [0] * n inc = [0] * n dec[0] = inc[0] = arr[0] flag = 0 for i in range(1, n): for j in range(0, i): if arr[j] > arr[i]: dec[i] = max(dec[i], inc[j] + arr[i]) flag = 1 elif arr[j] < arr[i] and flag == 1: inc[i] = max(inc[i], dec[j] + arr[i]) result = float('-inf') for i in range(n): if result < inc[i]: result = inc[i] if result < dec[i]: result = dec[i] return result def main(args): arr = [8, 2, 3, 5, 7, 9, 10] print('Maximum sum = ' + str(maxAlternateSum(arr, len(arr))))", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n\n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n\n\n\n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n\n\n\n\nflag = \n1\n; \n\n} \n\n\n\n\n\n\n\n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n\n\n\n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n\n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n}", "index": 470, "complexity": "3"}
{"back-translation": "class GFG: def zzis(arr, n): las = [[1, 1] for i in range(n)] res = 1 for i in range(1, n): for j in range(i): if arr[j] < arr[i] and las[i][0] < las[j][1] + 1: las[i][0] = las[j][1] + 1 if arr[j] > arr[i] and las[i][1] < las[j][0] + 1: las[i][1] = las[j][0] + 1 if res < max(las[i][0], las[i][1]): res = max(las[i][0], las[i][1]) return res def main(args): arr = [10, 22, 9, 33, 49, 50, 31, 60] n = len(arr) print('Length of Longest ') print('alternating subsequence is ') print(zzis(arr, n))", "src": "class\nGFG { \n\n\n\nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n\n\n\n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n}", "index": 471, "complexity": "3"}
{"back-translation": "class GFG: def search(arr, x, n): for i in range(n): if arr[i] == x: return i return -1 def printPostOrder(in1, pre, n): root = search(in1, pre[0], n) if root != 0: printPostOrder(in1, pre[1:n], root) if root != n - 1: printPostOrder(in1[root+1:n], pre[1+root:n], n - root - 1) print(pre[0], end=' ') def main(args): in1 = [4, 2, 5, 1, 3, 6] pre = [1, 2, 4, 5, 3, 6] n = len(in1) print('Postorder traversal ') printPostOrder(in1, pre, n)", "src": "class\nGFG \n{ \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nx, \nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\nreturn\n-\n1\n; \n} \n\n\n\nstatic\nvoid\nprintPostOrder(\nint\nin1[], \n\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\nint\nroot = search(in1, pre[\n0\n], n); \n\n\n\n\n\n\nif\n(root != \n0\n) \n\nprintPostOrder(in1, Arrays.copyOfRange(pre, \n1\n, n), root); \n\n\n\n\n\n\nif\n(root != n - \n1\n) \n\nprintPostOrder(Arrays.copyOfRange(in1, root+\n1\n, n), \n\nArrays.copyOfRange(pre, \n1\n+root, n), n - root - \n1\n); \n\n\n\n\nSystem.out.print( pre[\n0\n] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nin1[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nn = in1.length; \n\nSystem.out.println(\n\"Postorder traversal \"\n); \n\nprintPostOrder(in1, pre, n); \n} \n}", "index": 472, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nPrintPost { \\n\\nstatic\\nint\\npreIndex = \\n0\\n; \\n\\nvoid\\nprintPost(\\nint\\n[] in, \\nint\\n[] pre, \\nint\\ninStrt, \\nint\\ninEnd) \\n\\n{ \\n\\nif\\n(inStrt > inEnd) \\n\\nreturn\\n; \\n\\n\\n\\n\\n\\n\\n\\n\\nint\\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \\n\\n\\n\\nprintPost(in, pre, inStrt, inIndex - \\n1\\n); \\n\\n\\n\\nprintPost(in, pre, inIndex + \\n1\\n, inEnd); \\n\\n\\n\\nSystem.out.print(in[inIndex] + \\n\" \"\\n); \\n\\n} \\n\\n\\nint\\nsearch(\\nint\\n[] in, \\nint\\nstartIn, \\nint\\nendIn, \\nint\\ndata) \\n\\n{ \\n\\nint\\ni = \\n0\\n; \\n\\nfor\\n(i = startIn; i < endIn; i++) \\n\\nif\\n(in[i] == data) \\n\\nreturn\\ni; \\n\\nreturn\\ni; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String ars[]) \\n\\n{ \\n\\nint\\nin[] = { \\n4\\n, \\n2\\n, \\n5\\n, \\n1\\n, \\n3\\n, \\n6\\n}; \\n\\nint\\npre[] = { \\n1\\n, \\n2\\n, \\n4\\n, \\n5\\n, \\n3\\n, \\n6\\n}; \\n\\nint\\nlen = in.length; \\n\\nPrintPost tree = \\nnew\\nPrintPost(); \\n\\ntree.printPost(in, pre, \\n0\\n, len - \\n1\\n); \\n\\n} \\n}', 'complexity': '3', 'index': 473}", "src": "public\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n\n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n\n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n\n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n}", "index": 473, "complexity": "3"}
{"back-translation": "{'src': 'class\\nNode { \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\n\\npublic\\nNode(\\nint\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nleft = right = \\nnull\\; \\n\\n} \\n} \\n\\nclass\\nBinaryTree { \\n\\nNode root; \\n\\n\\n\\n\\nvoid\\nprintSpiral(Node node) \\n\\n{ \\n\\nint\\nh = height(node); \\n\\nint\\ni; \\n\\n\\n\\n\\nboolean\\nltr = \\nfalse\\; \\n\\nfor\\n(i = \\n1\\; i <= h; i++) { \\n\\nprintGivenLevel(node, i, ltr); \\n\\n\\n\\n\\nltr = !ltr; \\n\\n} \\n\\n} \\n\\n\\n\\n\\nint\\nheight(Node node) \\n\\n{ \\n\\nif\\n(node == \\nnull\\) \\n\\nreturn\\n0\\; \\n\\nelse\\n{ \\n\\n\\n\\n\\nint\\nlheight = height(node.left); \\n\\nint\\nrheight = height(node.right); \\n\\n\\n\\n\\nif\\n(lheight > rheight) \\n\\nreturn\\n(lheight + \\n1\\); \\n\\nelse\\n\\nreturn\\n(rheight + \\n1\\); \\n\\n} \\n\\n} \\n\\n\\n\\n\\nvoid\\nprintGivenLevel(Node node, \\nint\\nlevel, \\nboolean\\nltr) \\n\\n{ \\n\\nif\\n(node == \\nnull\\) \\n\\nreturn\\; \\n\\nif\\n(level == \\n1\\) \\n\\nSystem.out.print(node.data + \\n\" \"\\); \\n\\nelse\\nif\\n(level > \\n1\\) { \\n\\nif\\n(ltr != \\nfalse\\) { \\n\\nprintGivenLevel(node.left, level - \\n1\\, ltr); \\n\\nprintGivenLevel(node.right, level - \\n1\\, ltr); \\n\\n} \\n\\nelse\\n{ \\n\\nprintGivenLevel(node.right, level - \\n1\\, ltr); \\n\\nprintGivenLevel(node.left, level - \\n1\\, ltr); \\n\\n} \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nBinaryTree tree = \\nnew\\BinaryTree(); \\n\\ntree.root = \\nnew\\Node(\\n1\\); \\n\\ntree.root.left = \\nnew\\Node(\\n2\\); \\n\\ntree.root.right = \\nnew\\Node(\\n3\\); \\n\\ntree.root.left.left = \\nnew\\Node(\\n7\\); \\n\\ntree.root.left.right = \\nnew\\Node(\\n6\\); \\n\\ntree.root.right.left = \\nnew\\Node(\\n5\\); \\n\\ntree.root.right.right = \\nnew\\Node(\\n4\\); \\n\\nSystem.out.println(\\n\"Spiral order traversal of Binary Tree is \"\\); \\n\\ntree.printSpiral(tree.root); \\n\\n} \\n}', 'complexity': '3', 'index': 474}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 474, "complexity": "3"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def reverseLevelOrder(self, node):\n        h = self.height(node)\n        for i in range(h, 0, -1):\n            self.printGivenLevel(node, i)\n\n    def printGivenLevel(self, node, level):\n        if node is None:\n            return\n        if level == 1:\n            print(node.data, end=' ')\n        elif level > 1:\n            self.printGivenLevel(node.left, level - 1)\n            self.printGivenLevel(node.right, level - 1)\n\n    def height(self, node):\n        if node is None:\n            return 0\n        else:\n            lheight = self.height(node.left)\n            rheight = self.height(node.right)\n\n            if lheight > rheight:\n                return lheight + 1\n            else:\n                return rheight + 1\n\nif __name__ == '__main__':\n    tree = BinaryTree()\n\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(5)\n\n    print('Level Order traversal of binary tree is :')\n    tree.reverseLevelOrder(tree.root)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n\n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n}", "index": 475, "complexity": "3"}
{"back-translation": "class\nNode:\n\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\n\nclass\nBinaryTree:\n\n    def __init__(self):\n        self.root = None\n        self.preIndex = 0\n\n    def buildTree(self, _in, pre, inStrt, inEnd):\n\n        if inStrt > inEnd:\n            return None\n\n        tNode = Node(pre[self.preIndex])\n\n        if inStrt == inEnd:\n            return tNode\n\n        inIndex = self.search(_in, inStrt, inEnd, tNode.data)\n\n        tNode.left = self.buildTree(_in, pre, inStrt, inIndex - 1)\n        tNode.right = self.buildTree(_in, pre, inIndex + 1, inEnd)\n\n        return tNode\n\n\n    def search(self, arr, strt, end, value):\n\n        i = 0\n        for i in range(strt, end + 1):\n            if arr[i] == value:\n                return i\n\n        return i\n\n\n    def printInorder(self, node):\n\n        if node is None:\n            return\n\n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\n\ndef main(args):\n\n    tree = BinaryTree()\n    _in = ['D', 'B', 'E', 'A', 'F', 'C']\n    pre = ['A', 'B', 'D', 'E', 'C', 'F']\n    _len = len(_in)\n\n    root = tree.buildTree(_in, pre, 0, _len - 1)\n\n    print('Inorder traversal of constructed tree is : ')\n    tree.printInorder(root)\n\n\nmain([])\n", "src": "class\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex - \n1\n); \n\ntNode.right = buildTree(in, pre, inIndex + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n\n\n\n\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\ntree.printInorder(root); \n\n} \n}", "index": 476, "complexity": "3"}
{"back-translation": "class GFG { public static void ancestorMatrix(Node root , int matrix[][], int size) { if (root== null) return; ancestorMatrix(root.left, matrix, size); ancestorMatrix(root.right, matrix, size); if (root.left != null) { matrix[root.data][root.left.data] = 1; for (int i = 0; i < size; i++) { if (matrix[root.left.data][i] == 1) matrix[root.data][i] = 1; } } if (root.right != null) { matrix[root.data][root.right.data] = 1; for (int i = 0; i < size; i++) { if (matrix[root.right.data][i]== 1) matrix[root.data][i] = 1; } } } public static void main(String[] args) { Node tree_root = new Node(5); tree_root.left = new Node (1); tree_root.right = new Node(2); tree_root.left.left = new Node(0); tree_root.left.right = new Node(4); tree_root.right.left = new Node(3); int size = 6; int matrix [][] = new int[size][size]; ancestorMatrix(tree_root, matrix, size); for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { System.out.print(matrix[i][j]+", "src": "class\nGFG \n{ \n\n\n\npublic\nstatic\nvoid\nancestorMatrix(Node root , \n\nint\nmatrix[][],\nint\nsize) \n\n{ \n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nancestorMatrix(root.left, matrix, size); \n\n\n\n\nancestorMatrix(root.right, matrix, size); \n\n\n\n\n\n\n\nif\n(root.left != \nnull\n) \n\n{ \n\n\n\nmatrix[root.data][root.left.data] = \n1\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(matrix[root.left.data][i] == \n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n\nif\n(root.right != \nnull\n) \n\n{ \n\nmatrix[root.data][root.right.data] = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nif\n(matrix[root.right.data][i]==\n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nNode tree_root = \nnew\nNode(\n5\n); \n\ntree_root.left = \nnew\nNode (\n1\n); \n\ntree_root.right = \nnew\nNode(\n2\n); \n\ntree_root.left.left = \nnew\nNode(\n0\n); \n\ntree_root.left.right = \nnew\nNode(\n4\n); \n\ntree_root.right.left = \nnew\nNode(\n3\n); \n\n\n\n\nint\nsize = \n6\n; \n\nint\nmatrix [][] = \nnew\nint\n[size][size]; \n\n\nancestorMatrix(tree_root, matrix, size); \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < size; j++) \n\n{ \n\nSystem.out.print(matrix[i][j]+\n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode left ,right; \n\npublic\nNode (\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nthis\n.right = \nnull\n; \n\n} \n\n} \n}", "index": 477, "complexity": "3"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = self.right = None\n\nclass BinaryTree:\n    def buildTree(self, inorder, start, end, node):\n        if start > end:\n            return None\n        i = max(range(start, end + 1), key=lambda x: inorder[x])\n        node = Node(inorder[i])\n        if start == end:\n            return node\n        node.left = self.buildTree(inorder, start, i - 1, node.left)\n        node.right = self.buildTree(inorder, i + 1, end, node.right)\n        return node\n\n    def max(self, arr, start, end):\n        maxval, maxindex = arr[start], start\n        for i in range(start + 1, end + 1):\n            if arr[i] > maxval:\n                maxval = arr[i]\n                maxindex = i\n        return maxindex\n\n    def printInorder(self, node):\n        if node is None:\n            return\n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\ninorder = [5, 10, 40, 30, 28]\nlen_val = len(inorder)\ntree = BinaryTree()\nmynode = tree.buildTree(inorder, 0, len_val - 1, tree.root)\nprint('Inorder traversal of the constructed tree is ')\ntree.printInorder(mynode)", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n\n\nint\ni = max(inorder, start, end); \n\n\n\n\nnode = \nnew\nNode(inorder[i]); \n\n\n\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 478, "complexity": "3"}
{"back-translation": "class Node: def __init__(self, data): self.data = data self.left = None self.right = None class Index: def __init__(self): self.index = 0 class BinaryTree: def buildUtil(in_ord, post_ord, inStrt, inEnd, pIndex): if inStrt > inEnd: return None node = Node(post_ord[pIndex.index]) pIndex.index -= 1 if inStrt == inEnd: return node iIndex = search(in_ord, inStrt, inEnd, node.data) node.right = buildUtil(in_ord, post_ord, iIndex + 1, inEnd, pIndex) node.left = buildUtil(in_ord, post_ord, inStrt, iIndex - 1, pIndex) return node def buildTree(in_ord, post_ord, n): pIndex = Index() pIndex.index = n - 1 return buildUtil(in_ord, post_ord, 0, n - 1, pIndex) def search(arr, strt, end, value): for i in range(strt, end + 1): if arr[i] == value: break return i def preOrder(node): if node is None: return print(node.data, end=' ') preOrder(node.left) preOrder(node.right) if __name__ == '__main__': tree = BinaryTree() in_ord = [4, 8, 2, 5, 1, 6, 3, 7] post_ord = [8, 4, 5, 2, 6, 7, 3, 1] n = len(in_ord) root = tree.buildTree(in_ord, post_ord, n) print('Preorder of the constructed tree :', end=' ') preOrder(root)", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 479, "complexity": "3"}
{"back-translation": "class Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def convertTree(self, node):\n        left_data, right_data, diff = 0, 0, 0\n        if node is None or (node.left is None and node.right is None):\n            return\n        else:\n            self.convertTree(node.left)\n            self.convertTree(node.right)\n            if node.left is not None:\n                left_data = node.left.data\n            if node.right is not None:\n                right_data = node.right.data\n            diff = left_data + right_data - node.data\n            if diff > 0:\n                node.data = node.data + diff\n            if diff < 0:\n                self.increment(node, -diff)\n\n    def increment(self, node, diff):\n        if node.left is not None:\n            node.left.data = node.left.data + diff\n            self.increment(node.left, diff)\n        elif node.right is not None:\n            node.right.data = node.right.data + diff\n            self.increment(node.right, diff)\n\n    def printInorder(self, node):\n        if node is None:\n            return\n        self.printInorder(node.left)\n        print(node.data, end=' ')\n        self.printInorder(node.right)\n\n\ndef main(args):\n    tree = BinaryTree()\n    tree.root = Node(50)\n    tree.root.left = Node(7)\n    tree.root.right = Node(2)\n    tree.root.left.left = Node(3)\n    tree.root.left.right = Node(5)\n    tree.root.right.left = Node(1)\n    tree.root.right.right = Node(30)\n\n    print('Inorder traversal before conversion is :')\n    tree.printInorder(tree.root)\n\n    tree.convertTree(tree.root)\n\n    print('')\n    print('Inorder traversal after conversion is :')\n    tree.printInorder(tree.root)\n\n\nmain([])", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nconvertTree(Node node) \n\n{ \n\nint\nleft_data = \n0\n, right_data = \n0\n, diff; \n\n\n\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n; \n\nelse\n\n{ \n\n\n\nconvertTree(node.left); \n\nconvertTree(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n\n\ndiff = left_data + right_data - node.data; \n\n\n\n\nif\n(diff > \n0\n) \n\nnode.data = node.data + diff; \n\n\n\n\nif\n(diff < \n0\n) \n\n\n\n\nincrement(node, -diff); \n\n} \n\n} \n\n\n\n\nvoid\nincrement(Node node, \nint\ndiff) \n\n{ \n\n\n\nif\n(node.left != \nnull\n) \n\n{ \n\nnode.left.data = node.left.data + diff; \n\n\n\n\nincrement(node.left, diff); \n\n} \n\nelse\nif\n(node.right != \nnull\n) \n\n\n{ \n\nnode.right.data = node.right.data + diff; \n\n\n\n\nincrement(node.right, diff); \n\n} \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n50\n); \n\ntree.root.left = \nnew\nNode(\n7\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n30\n); \n\n\nSystem.out.println(\n\"Inorder traversal before conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\ntree.convertTree(tree.root); \n\nSystem.out.println(\n\"\"\n); \n\n\nSystem.out.println(\n\"Inorder traversal after conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\n} \n}", "index": 480, "complexity": "3"}
{"back-translation": "class Node: def __init__(self, item): self.data = item self.left = self.right = self.nextRight = None class BinaryTree: def __init__(self): self.root = None def sum(node): if node is None: return 0 return sum(node.left) + node.data + sum(node.right) def isSumTree(node): if node is None or (node.left is None and node.right is None): return 1 ls = sum(node.left) rs = sum(node.right) if node.data == ls + rs and isSumTree(node.left) != 0 and isSumTree(node.right) != 0: return 1 return 0 if __name__ == '__main__': tree = BinaryTree() tree.root = Node(26) tree.root.left = Node(10) tree.root.right = Node(3) tree.root.left.left = Node(4) tree.root.left.right = Node(6) tree.root.right.right = Node(3) if tree.isSumTree(tree.root) != 0: print('The given tree is a sum tree') else: print('The given tree is not a sum tree')", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nsum(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nreturn\nsum(node.left) + node.data + sum(node.right); \n\n} \n\n\n\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls, rs; \n\n\n\n\nif\n((node == \nnull\n) || (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\n\n\n\nls = sum(node.left); \n\nrs = sum(node.right); \n\n\n\n\nif\n((node.data == ls + rs) && (isSumTree(node.left) != \n0\n) \n\n&& (isSumTree(node.right)) != \n0\n) \n\nreturn\n1\n; \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n}", "index": 481, "complexity": "3"}
{"back-translation": "class Node: def __init__(self, key): self.key = key self.left = self.right = None class BinaryTree: def __init__(self): self.root = None def count(node): return count(node.left) + count(node.right) + 1 if node is not None else 0 def checkRec(node, n): return checkRec(node.left, n) or checkRec(node.right, n) if node is not None else False return True if count(node) == n - count(node) else False def check(node): n = count(node) return checkRec(node, n) if __name__ == '__main__': tree = BinaryTree() tree.root = Node(5) tree.root.left = Node(1) tree.root.right = Node(6) tree.root.left.left = Node(3) tree.root.right.left = Node(7) tree.root.right.right = Node(4) print('YES') if tree.check(tree.root) else print('NO')", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n\n\n\n\n\n\nboolean\ncheckRec(Node node, \nint\nn) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nif\n(count(node) == n - count(node)) \n\nreturn\ntrue\n; \n\n\n\n\nreturn\ncheckRec(node.left, n) \n\n|| checkRec(node.right, n); \n\n} \n\n\n\n\nboolean\ncheck(Node node) \n\n{ \n\n\n\nint\nn = count(node); \n\n\n\n\nreturn\ncheckRec(node, n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root)==\ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n}", "index": 482, "complexity": "3"}
{"back-translation": "class GfG: static preIndex = 0 static class Node: data left, right static Node newNode(data): temp = Node() temp.data = data temp.left = None temp.right = None return temp static search(arr, strt, end, value): for i in range(strt, end+1): if arr[i] == value: return i return -1 static buildTree(inOrder, preOrder, inStrt, inEnd): if inStrt > inEnd: return None tNode = newNode(preOrder[preIndex]); if inStrt == inEnd: return tNode inIndex = search(inOrder, inStrt, inEnd, tNode.data); tNode.left = buildTree(inOrder, preOrder, inStrt, inIndex-1); tNode.right = buildTree(inOrder, preOrder, inIndex+1, inEnd); return tNode static checkPostorder(node, postOrder, index): if node == None: return index index = checkPostorder(node.left, postOrder, index); index = checkPostorder(node.right, postOrder, index); if node.data == postOrder[index]: index += 1 else: return -1 return index def main(args): inOrder = [4, 2, 5, 1, 3] preOrder = [1, 2, 4, 5, 3] postOrder = [4, 5, 2, 3, 1] len = len(inOrder) root = buildTree(inOrder, preOrder, 0, len - 1) index = checkPostorder(root, postOrder, 0) if index == len: print('Yes') else: print('No')", "src": "class\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n\n\n\n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n\n\n\n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n\n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 483, "complexity": "3"}
{"back-translation": "{'src': 'class MST { private static final int V = 5; int minKey(int key[], Boolean mstSet[]) { int min = Integer.MAX_VALUE, min_index = -1; for (int v = 0; v < V; v++) if (mstSet[v] == false && key[v] < min) { min = key[v]; min_index = v; } return min_index; } void printMST(int parent[], int graph[][]) { System.out.println(\"Edge \\tWeight\"); for (int i = 1; i < V; i++) System.out.println(parent[i] + \" - \" + i + \"\\t\" + graph[i][parent[i]]); } void primMST(int graph[][]) { int parent[] = new int[V]; int key[] = new int[V]; Boolean mstSet[] = new Boolean[V]; for (int i = 0; i < V; i++) { key[i] = Integer.MAX_VALUE; mstSet[i] = false; } key[0] = 0; parent[0] = -1; for (int count = 0; count < V - 1; count++) { int u = minKey(key, mstSet); mstSet[u] = true; for (int v = 0; v < V; v++) if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { parent[v] = u; key[v] = graph[u][v]; } } printMST(parent, graph); } public static void main(String[] args) { MST t = new MST(); int graph[][] = new int[][] { { 0, 2, 0, 6, 0}, { 2, 0, 3, 8, 5}, { 0, 3, 0, 0, 7}, { 6, 8, 0, 0, 9}, { 0, 5, 7, 9, 0} }; t.primMST(graph); } }', 'complexity': '3', 'index': 484}", "src": "class\nMST { \n\n\n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n\n\n\n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\n\n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n\n\n\n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n\n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n\n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n\n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n\n\nkey[\n0\n] = \n0\n; \n\n\n\n\nparent[\n0\n] = -\n1\n; \n\n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n\n\n\n\nint\nu = minKey(key, mstSet); \n\n\n\n\nmstSet[u] = \ntrue\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n\n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n\n\nt.primMST(graph); \n\n} \n}", "index": 484, "complexity": "3"}
{"back-translation": "class ShortestPath: V = 9\n\n    def minDistance(self, dist, sptSet): \n        min = float('inf')\n        min_index = -1\n\n        for v in range(self.V): \n            if not sptSet[v] and dist[v] <= min: \n                min = dist[v]\n                min_index = v\n\n        return min_index\n\n    def printSolution(self, dist): \n        print(\"Vertex Distance \") \n        for i in range(self.V): \n            print(i + \" tt \" + str(dist[i])) \n\n    def dijkstra(self, graph, src): \n        dist = [float('inf')] * self.V\n        sptSet = [False] * self.V\n\n        dist[src] = 0\n\n        for _ in range(self.V-1): \n            u = self.minDistance(dist, sptSet)\n            sptSet[u] = True\n\n            for v in range(self.V): \n                if not sptSet[v] and graph[u][v] != 0 and dist[u] != float('inf') and dist[u] + graph[u][v] < dist[v]: \n                    dist[v] = dist[u] + graph[u][v]\n\n        self.printSolution(dist)\n\ngraph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], [4, 0, 8, 0, 0, 0, 0, 11, 0], [0, 8, 0, 7, 0, 4, 0, 0, 2], [0, 0, 7, 0, 9, 14, 0, 0, 0], [0, 0, 0, 9, 0, 10, 0, 0, 0], [0, 0, 4, 14, 10, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 6], [8, 11, 0, 0, 0, 0, 1, 0, 7], [0, 0, 2, 0, 0, 0, 6, 7, 0]]\n\nShortestPath().dijkstra(graph, 0)", "src": "class\nShortestPath \n{ \n\n\n\n\n\nstatic\nfinal\nint\nV=\n9\n; \n\nint\nminDistance(\nint\ndist[], Boolean sptSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index=-\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(sptSet[v] == \nfalse\n&& dist[v] <= min) \n\n{ \n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\nvoid\nprintSolution(\nint\ndist[], \nint\nn) \n\n{ \n\nSystem.out.println(\n\"Vertex Distance \"\n); \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\nSystem.out.println(i+\n\" tt \"\n+dist[i]); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndijkstra(\nint\ngraph[][], \nint\nsrc) \n\n{ \n\nint\ndist[] = \nnew\nint\n[V]; \n\n\n\n\n\n\n\n\n\nBoolean sptSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\n{ \n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = \nfalse\n; \n\n} \n\n\n\n\ndist[src] = \n0\n; \n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V-\n1\n; count++) \n\n{ \n\n\n\n\n\n\n\nint\nu = minDistance(dist, sptSet); \n\n\n\n\nsptSet[u] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(!sptSet[v] && graph[u][v]!=\n0\n&& \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\n} \n\n\n\n\nprintSolution(dist, V); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\nint\ngraph[][] = \nnew\nint\n[][]{{\n0\n, \n4\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n8\n, \n0\n}, \n\n{\n4\n, \n0\n, \n8\n, \n0\n, \n0\n, \n0\n, \n0\n, \n11\n, \n0\n}, \n\n{\n0\n, \n8\n, \n0\n, \n7\n, \n0\n, \n4\n, \n0\n, \n0\n, \n2\n}, \n\n{\n0\n, \n0\n, \n7\n, \n0\n, \n9\n, \n14\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n9\n, \n0\n, \n10\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n4\n, \n14\n, \n10\n, \n0\n, \n2\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n2\n, \n0\n, \n1\n, \n6\n}, \n\n{\n8\n, \n11\n, \n0\n, \n0\n, \n0\n, \n0\n, \n1\n, \n0\n, \n7\n}, \n\n{\n0\n, \n0\n, \n2\n, \n0\n, \n0\n, \n0\n, \n6\n, \n7\n, \n0\n} \n\n}; \n\nShortestPath t = \nnew\nShortestPath(); \n\nt.dijkstra(graph, \n0\n); \n\n} \n}", "index": 485, "complexity": "3"}
{"back-translation": "class GFG: def maximumSum(arr, n, k): for i in range(1, k+1): min = +2147483647; index = -1; for j in range(0, n): if arr[j] < min: min = arr[j]; index = j; if min == 0: break; arr[index] = -arr[index]; sum = 0; for i in range(0, n): sum += arr[i]; return sum; def main(arg): arr = [-2, 0, 5, -1, 2]; k = 4; n = len(arr); print(maximumSum(arr, n, k));", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nmaximumSum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nfor\n(\nint\ni = \n1\n; i <= k; i++) \n\n{ \n\nint\nmin = +\n2147483647\n; \n\nint\nindex = -\n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj=\n0\n; j<n; j++) \n\n{ \n\nif\n(arr[j] < min) \n\n{ \n\nmin = arr[j]; \n\nindex = j; \n\n} \n\n} \n\n\n\n\n\n\n\n\nif\n(min == \n0\n) \n\nbreak\n; \n\n\n\n\narr[index] = -arr[index]; \n\n} \n\n\n\n\nint\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\nreturn\nsum; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {-\n2\n, \n0\n, \n5\n, -\n1\n, \n2\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.print(maximumSum(arr, n, k)); \n\n} \n}", "index": 486, "complexity": "3"}
{"back-translation": "class GFG: def minimizeWithKSwaps(arr, n, k): for i in range(n-1): if k == 0: break pos = i for j in range(i+1, n): if j - i > k: break if arr[j] < arr[pos]: pos = j temp = arr[pos] for j in range(pos, i, -1): arr[j] = arr[j-1] arr[j-1] = temp k -= pos-i def main(args): arr = [7, 6, 9, 2, 1] n = len(arr) k = 3 minimizeWithKSwaps(arr, n, k) for i in range(n): print(arr[i], end=' ') if __name__ == '__main__': import sys ret=main(sys.argv)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n\n\n\n\nif\n(j - i > k) \n\nbreak\n; \n\n\n\n\n\n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n\n\n\n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n\n\n\n\nk -= pos-i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n}", "index": 487, "complexity": "3"}
{"back-translation": "class\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\ntemp = array[position1]; \n\n\n\n\n\n\narray[position1] = array[position2]; \n\n\n\n\n\n\narray[position2] = temp; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n\n\n\n\n\n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n\n\n\n\n\n\n\n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n\n\n\n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "src": "class\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\ntemp = array[position1]; \n\n\n\n\n\n\narray[position1] = array[position2]; \n\n\n\n\n\n\narray[position2] = temp; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n\n\n\n\n\n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n\n\n\n\n\n\n\n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n\n\n\n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 488, "complexity": "3"}
{"back-translation": "class Graph:\n    def __init__(self, v):\n        self.V = v\n        self.adj = [list() for _ in range(v)]\n\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n\n    def greedyColoring(self):\n        result = [-1] * self.V\n        available = [True] * self.V\n\n        for u in range(1, self.V):\n            it = iter(self.adj[u])\n            for i in it:\n                if result[i] != -1:\n                    available[result[i]] = False\n                    cr = 0\n            while not available[cr]:\n                cr += 1\n            result[u] = cr\n            available = [True] * self.V\n\n        for u in range(self.V):\n            print(\"Vertex \", u, \" ---> Color \", result[u])\n\n\ndef main(args):\n    g1 = Graph(5)\n    g1.addEdge(0, 1)\n    g1.addEdge(0, 2)\n    g1.addEdge(1, 2)\n    g1.addEdge(1, 3)\n    g1.addEdge(2, 3)\n    g1.addEdge(3, 4)\n    print(\"Coloring of graph 1\")\n    g1.greedyColoring()\n\n    print()\n\n    g2 = Graph(5)\n    g2.addEdge(0, 1)\n    g2.addEdge(0, 2)\n    g2.addEdge(1, 2)\n    g2.addEdge(1, 4)\n    g2.addEdge(2, 4)\n    g2.addEdge(4, 3)\n    print(\"Coloring of graph 2 \")\n    g2.greedyColoring()\n\nmain([])", "src": "class\nGraph \n{ \n\nprivate\nint\nV; \n\n\nprivate\nLinkedList<Integer> adj[]; \n\n\n\n\n\nGraph(\nint\nv) \n\n{ \n\nV = v; \n\nadj = \nnew\nLinkedList[v]; \n\nfor\n(\nint\ni=\n0\n; i<v; ++i) \n\nadj[i] = \nnew\nLinkedList(); \n\n} \n\n\n\n\nvoid\naddEdge(\nint\nv,\nint\nw) \n\n{ \n\nadj[v].add(w); \n\nadj[w].add(v); \n\n\n} \n\n\n\n\n\n\nvoid\ngreedyColoring() \n\n{ \n\nint\nresult[] = \nnew\nint\n[V]; \n\n\n\n\nArrays.fill(result, -\n1\n); \n\n\n\n\nresult[\n0\n] = \n0\n; \n\n\n\n\n\n\n\n\nboolean\navailable[] = \nnew\nboolean\n[V]; \n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n\n\n\nfor\n(\nint\nu = \n1\n; u < V; u++) \n\n{ \n\n\n\n\n\nIterator<Integer> it = adj[u].iterator() ; \n\nwhile\n(it.hasNext()) \n\n{ \n\nint\ni = it.next(); \n\nif\n(result[i] != -\n1\n) \n\navailable[result[i]] = \nfalse\n; \n\n} \n\n\n\n\nint\ncr; \n\nfor\n(cr = \n0\n; cr < V; cr++){ \n\nif\n(available[cr]) \n\nbreak\n; \n\n} \n\n\nresult[u] = cr; \n\n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n} \n\n\n\n\nfor\n(\nint\nu = \n0\n; u < V; u++) \n\nSystem.out.println(\n\"Vertex \"\n+ u + \n\" ---> Color \"\n\n+ result[u]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGraph g1 = \nnew\nGraph(\n5\n); \n\ng1.addEdge(\n0\n, \n1\n); \n\ng1.addEdge(\n0\n, \n2\n); \n\ng1.addEdge(\n1\n, \n2\n); \n\ng1.addEdge(\n1\n, \n3\n); \n\ng1.addEdge(\n2\n, \n3\n); \n\ng1.addEdge(\n3\n, \n4\n); \n\nSystem.out.println(\n\"Coloring of graph 1\"\n); \n\ng1.greedyColoring(); \n\n\nSystem.out.println(); \n\nGraph g2 = \nnew\nGraph(\n5\n); \n\ng2.addEdge(\n0\n, \n1\n); \n\ng2.addEdge(\n0\n, \n2\n); \n\ng2.addEdge(\n1\n, \n2\n); \n\ng2.addEdge(\n1\n, \n4\n); \n\ng2.addEdge(\n2\n, \n4\n); \n\ng2.addEdge(\n4\n, \n3\n); \n\nSystem.out.println(\n\"Coloring of graph 2 \"\n); \n\ng2.greedyColoring(); \n\n} \n}", "index": 489, "complexity": "3"}
{"back-translation": "ERROR", "src": "class\nGFG \n{ \n\n\n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n\n\n\n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n\n\n\n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n\n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n\n\n\n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n\n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n\n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n\n\n\n\n\n\n\n\n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n\n\n\n\nint\namount[]=\nnew\nint\n[N]; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n\n\nminCashFlow(graph); \n\n} \n}", "index": 490, "complexity": "3"}
{"back-translation": "class Main: def min_abs_sum_pair(arr, arr_size): inv_count = 0 min_sum = sum = min_l = min_r = 0 if arr_size < 2: print('Invalid Input') return min_l = 0 min_r = 1 min_sum = arr[0] + arr[1] for l in range(arr_size - 1): for r in range(l + 1, arr_size): sum = arr[l] + arr[r] if abs(min_sum) > abs(sum): min_sum = sum min_l = l min_r = r print(' The two elements whose ' + 'sum is minimum are ' + arr[min_l] + ' and ' + arr[min_r]) def main(args): arr = [1, 60, -10, 70, -80, 85] min_abs_sum_pair(arr, 6)", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 491, "complexity": "3"}
{"back-translation": "class GFG: def printPrevSmaller(arr, n): print('_, ', end='') for i in range(1, n): for j in range(i - 1, -1, -1): if arr[j] < arr[i]: print(arr[j], ', ', end='') break if j == -1: print('_, ', end='') def main(args): arr = [1, 3, 0, 2, 5] n = len(arr) printPrevSmaller(arr, n) main([])", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n\n\n\n\nSystem.out.print( \n\"_, \"\n); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n}", "index": 492, "complexity": "3"}
{"back-translation": "arr=[int(input()) for _ in range(int(input()))]; k=min([min(arr[i], arr[j])//abs(i-j) for i in range(len(arr)) for j in range(i+1, len(arr)) if i!=j]); print(k)", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "index": 493, "complexity": "3"}
{"back-translation": "def hi():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = int(1e9)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(min(arr[i], arr[j]) / abs(i-j))\n            if a < k:\n                k = a\n    print(k)\n\nhi()", "src": "public class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }", "index": 494, "complexity": "3"}
{"back-translation": "class PartySweet:\n    def __init__(self):\n        self.br = None\n        self.tokenizer = None\n\n    def main(self):\n        self.br = BufferedReader(InputStreamReader(System.in))\n        n = self.nextInt()\n        m = self.nextInt()\n        b = [0] * n\n        g = [0] * m\n        for i in range(n):\n            b[i] = self.nextInt()\n        for i in range(m):\n            g[i] = self.nextInt()\n        total = 0\n        max_val = 0\n        max2_val = 0\n        for i in range(n):\n            if b[i] > b[max_val]:\n                max2_val = max_val\n                max_val = i\n            elif b[max2_val] < b[i]:\n                max2_val = i\n        total += b[max_val] - b[max2_val]\n        for i in range(n):\n            for j in range(m):\n                if b[i] > g[j]:\n                    print(-1)\n                    return\n                if i != max_val:\n                    total += b[i]\n                else:\n                    total += g[j]\n        print(total)\n\n    def next(self):\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            line = self.br.readLine()\n            if line is None:\n                raise IOException\n            self.tokenizer = StringTokenizer(line)\n        return self.tokenizer.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n\n    def nextDouble(self):\n        return float(self.next())\n", "src": "public class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "index": 495, "complexity": "3"}
{"back-translation": "class Main:\n    def main(args: List[str]) -> None:\n        br = BufferedReader(InputStreamReader(in))\n        st = StringTokenizer(br.readLine().trim())\n        n = int(st.nextToken())\n        k = int(st.nextToken())\n        str = br.readLine().trim()\n        arr = [0] * n\n        adjlist = [LL() for _ in range(n)]\n        for i in range(n):\n            x = ord(str[i]) - ord('a') + 1\n            arr[i] = x\n            adjlist[i] = LL()\n        arr.sort()\n        for i in range(n):\n            for j in range(i+1, n):\n                a = arr[i]\n                b = arr[j]\n                if b - a >= 2:\n                    adjlist[i].add(Pair(j, arr[j], 1))\n        list = LinkedList()\n        tmpList = LinkedList()\n        ans = float('inf')\n        for i in range(n):\n            list.clear()\n            list.append(Pair(i, arr[i], 0))\n            for j in range(k):\n                tmpList.clear()\n                while list:\n                    cur = list.popleft()\n                    if j == k - 1:\n                        ans = min(cur.val, ans)\n                    for adj in adjlist[cur.idx]:\n                        tmpList.append(Pair(adj.idx, adj.val + cur.val, cur.val + 1))\n                if not tmpList:\n                    break\n                else:\n                    list.extend(tmpList)\n        if ans == float('inf'):\n            out.println(-1)\n        else:\n            out.println(ans)\n    class LL(LinkedList):\n        pass\n    class Pair:\n        val: int\n        idx: int\n        ctr: int\n        def __init__(self, a: int, b: int, c: int) -> None:\n            self.idx = a\n            self.val = b\n            self.ctr = c\n        def __lt__(self, p) -> bool:\n            if self.ctr == p.ctr:\n                if self.val == p.val:\n                    return self.idx - p.idx\n                return self.val - p.val\n            return p.ctr - self.ctr\n        def __str__(self) -> str:\n            return str(self.val) + ', '\n", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 496, "complexity": "3"}
{"back-translation": "data = input()\ndata = data.split()n = int(data[0])k = int(data[1])s = data[2]wtArray = [ord(char) - 96 for char in s]for i in range(1, n):    for j in range(0, n - i):        if wtArray[j] > wtArray[j + 1]:            wtArray[j], wtArray[j + 1] = wtArray[j + 1], wtArray[j]sum = wtArray[0]k -= 1temp = sumfor i in range(1, n):    if k != 0 and (wtArray[i] - temp > 1):        sum += wtArray[i]        k -= 1        temp = wtArray[i]if k != 0:    sum = -1print(sum)", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 497, "complexity": "3"}
{"back-translation": "{'src': 'class Main: def __init__(self): self.br = BufferedReader(InputStreamReader(System.in)); self.st = StringTokenizer(self.br.readline()); def next(self): if self.st.hasMoreTokens(): return self.st.nextToken(); self.st = StringTokenizer(self.br.readline()); return self.st.nextToken(); def nextInt(self): return int(self.next()); def nextLong(self): return int(self.next()); def nextDouble(self): return float(self.next()); def nextLine(self): line = ''; if self.st.hasMoreTokens(): line = self.st.nextToken(); else: line = self.br.readline(); while self.st.hasMoreTokens(): line += ' ' + self.st.nextToken(); return line; class FastScanner: def __init__(self): pass; def main(): sc = FastScanner(); pw = PrintWriter(System.out); n = sc.nextInt(); m = sc.nextInt(); ans = 0; a = [0] * 101; for i in range(m): a[sc.nextInt()] += 1; for i in range(1, 101): y = 0; for x in a: y += x // i; if y >= n: ans = i; pw.println(ans); pw.close();', 'complexity': '3', 'index': 498}", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 498, "complexity": "3"}
{"back-translation": "class G: \n    def main(): \n        n, m = map(int, input().split()) \n        a = [int(input()) for _ in range(m)] \n        a.sort() \n        map = {} \n        for i in a: \n            if i in map: \n                map[i] += 1 \n            else: \n                map[i] = 1 \n        list = [] \n        for key, value in map.items(): \n            list.append(Food(key, value)) \n        list.sort(key=lambda x: x.num) \n        min_num = 1 \n        max_num = list[-1].num \n        res = 0 \n        for i in range(min_num, max_num + 1): \n            total = 0 \n            for food in list: \n                served = food.num // i \n                if served >= 1: \n                    total += served \n                    if total >= n: \n                        res = max(res, i) \n                        break \n        print(res) \n\n\nclass Food: \n    def __init__(self, id, num): \n        self.id = id \n        self.num = num \n    def __str__(self): \n        return f'Food{{id={self.id}, num={self.num}}}' \n\nif __name__ == '__main__': \n    main()", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 499, "complexity": "3"}
{"back-translation": "{'src': 'public class Solution {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner sc = new Scanner(System.in);\\n\\t\\tSolution ss = new Solution();\\n\\t\\tss.test(sc);\\n\\t}\\n\\t\\n\\tvoid test(Scanner sc){\\n\\t\\tint LEN = sc.nextInt();\\n\\t\\tint[] a = new int[LEN];\\n\\t\\tint[] b = new int[LEN];\\n\\t\\tfor (int i = 0; i < b.length; i++) {\\n\\t\\t\\ta[i] = sc.nextInt();\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < b.length; i++) {\\n\\t\\t\\tb[i] = sc.nextInt();\\n\\t\\t}\\n\\t\\tArrays.sort(a);\\n\\t\\tArrays.sort(b);\\n\\t\\t\\n\\t\\tint ia=0, ib=0;\\n\\t\\twhile(ia<LEN && a[ia]==0) ia++;\\n\\t\\twhile(ib<LEN && b[ib]==0) ib++;\\n\\t\\tif(ib==LEN){\\n\\t\\t\\tSystem.out.println('Yes');\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ia==LEN){\\n\\t\\t\\tSystem.out.println('No');\\n\\t\\t\\treturn;\\n\\t\\t}\\t\\t\\n\\t\\tboolean out = True;\\n\\t\\twhile(ia<LEN && ib<LEN){\\n\\t\\t\\tif(a[ia]==b[ib]){\n\\t\\t\\t\\tia++;\n\\t\\t\\t\\tib++;\n\\t\\t\\t}else{\n\\t\\t\\t\\tif(a[ia]>b[ib]){\n\\t\\t\\t\\t\\twhile(ib<LEN && b[ib]!=a[ia]){\n\\t\\t\\t\\t\\t\\tib++;\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(ib==LEN){\n\\t\\t\\t\\t\\t\\tout=False;\n\\t\\t\\t\\t\\t\\tbreak;\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(out){\\n\\t\\t\\tSystem.out.println('Yes');\\n\\t\\t}else{\\n\\t\\t\\tSystem.out.println('No');\\n\\t\\t}\\n\\t}\\n\\n}', 'complexity': '3', 'index': 500}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 500, "complexity": "3"}
{"back-translation": "{'src': 'public class TestClass {\\n    \\n    public static int set_size(int[] a, int N){\\n        HashSet<Integer> newset = new HashSet<Integer>();\\n        int i = 0;\\n        while(i<N){\\n            newset.add(a[i++]);\\n        }\\n        int v = newset.size();\\n        return v;\\n    }\\n    public static void main(String args[] ) throws Exception {\\n       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n       StringTokenizer tk = new StringTokenizer(br.readLine());\\n       int N = Integer.parseInt(tk.nextToken());\\n       int x = Integer.parseInt(tk.nextToken());\\n       \\n       int[] a = new int[N];\\n       int[] b = new int[N];\\n       StringTokenizer tb = new StringTokenizer(br.readLine());\\n       for(int i=0; i<N; i++){\\n           a[i] = Integer.parseInt(tb.nextToken());\\n       }\\n       if(set_size(a, N) < N){\\n           System.out.print('0');\\n           System.exit(0);\\n       }\\n       int num = 0;\\n       while(num++<4){\\n           for(int i=0; i<N; i++){\\n               if((a[i]&x) == a[i])\\n                   continue;\\n               else{\\n                   for(int j=0; j<N; j++){\\n                       if(i==j){\\n                           b[i] = (a[i]&x);\\n                       }\\n                       else{\\n                           b[j] = a[j];\\n                       }\\n                   }\\n                   int s = set_size(b, N);\\n                   if(s<N){\\n                       System.out.print(num);\\n                       System.exit(0);\\n                   }\\n               }\\n           }\\n           for(int i=0; i<N; i++)\\n               a[i] = b[i];\\n       }\\n       System.out.print('-1');\\n       System.exit(0);\\n   }\\n}', 'complexity': '3', 'index': 501}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 501, "complexity": "3"}
{"back-translation": "class Cr500:\n    def main(args):\n        scanner = Scanner(System.in)\n        n, x, status = -1\n        a, bitA = set(), set()\n        al, bl = [], []\n        n = scanner.nextInt()\n        x = scanner.nextInt()\n\n        for i in range(n):\n            v = 0\n            if (v := scanner.nextInt()) in a:\n                print(0)\n                return\n\n            if (v & x) in bitA:\n                status = 2\n\n            al.append(v)\n            bl.append(v & x)\n\n        if contains(al, bl):\n            print(1)\n            return\n\n        print(status)\n\n\ndef contains(a, b):\n    for i in range(len(a)):\n        v1 = a[i]\n        for j in range(len(b)):\n            v2 = b[j]\n            if i != j and v1 == v2:\n                return True\n    return False", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 502, "complexity": "3"}
{"back-translation": "{'src': 'public class B {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int x = scanner.nextInt();\\n        int[] a = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = scanner.nextInt();\\n        }\\n        Arrays.sort(a);\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(a[i]);\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (a[i] == a[i + 1]) {\\n                System.out.println(0);\\n                return;\\n            }\\n        }\\n        for (int i = n - 1; i > 0; i--) {\\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\\n                System.out.println(2);\\n                return;\\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\\n                System.out.println(1);\\n                return;\\n            }\\n        }\\n        System.out.println(-1);\\n    }\\n}', 'complexity': '3', 'index': 503}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 503, "complexity": "3"}
{"back-translation": "{'src': 'public class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        int n = in.nextInt();\\n        int m = in.nextInt();\\n        int[] v = new int[n];\\n        int[] ans = new int[n];\\n        long s = 0;\\n        int t;\\n        for(int i=0; i<n;i++) {\\n            v[i] = in.nextInt();\\n            s+=v[i];\\n        }\\n\\n        for(int i=0; i<n-1;i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (v[j] > v[i]) {\\n                    t = v[i];\\n                    v[i] = v[j];\\n                    v[j] = t;\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<n-1; i++){\\n            if(v[i] > v[i+1]){\\n                    ans[i] = v[i]-v[i+1];\\n            }\\n\\n            if(v[i] == v[i+1] && v[i]!=1){\\n                ans[i]=1;\\n                v[i+1]--;)\\n            }\\n\\n            if(v[i] < v[i+1]){\\n                ans[i]=1;\\n                v[i+1] = v[i]-1;\\n                if(v[i+1] == 0){\\n                    v[i+1] = 1;\\n                }\\n            }\\n            if(v[i] == 0 || v[i] == 1){\\n                ans[i] = 1;\\n                v[i] = 1;\\n            }\\n        }\\n        if (v[n-1] > 1){\\n            ans[n-1] = v[n-1];\\n        }\\n        else{\\n            ans[n-1] = 1;\\n        }\\n\\n        for (int i=0; i<n; i++){\\n                s-=ans[i];\\n\\n        }\\n        System.out.print(s);\\n\\n\\n    }\\n}', 'complexity': '3', 'index': 504}", "src": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "index": 504, "complexity": "3"}
{"back-translation": "{'src': 'public class Main {\\n\\n    public static void main(String[] args) {\\n       Scanner s = new Scanner(System.in);\\n       int n = s.nextInt();\\n       int m = s.nextInt();\\n       m = 0;\\n       long sum = 0;\\n       int[] expon = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            expon[i] = s.nextInt();\\n            m = Math.max(expon[i], m);\\n            sum += expon[i];\\n        }\\n        HashSet<Integer> levels = new HashSet<>();\\n\\n\\n        int amount = 0;\\n        for (int i = 0; i < n; i++) {\\n            int currentHigh = expon[i];\\n            for (int j = currentHigh; j >= 1; j--) {\\n                if(!levels.contains(j)) {\\n                    levels.add(j);\\n                    amount++;\\n                    break;\\n                }\\n                if(j == 1){\\n                    amount++;\\n                }\\n            }\\n        }\\n        System.out.println((sum - amount) - (m - levels.size()));\\n    }\\n}', 'complexity': '3', 'index': 505}", "src": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "index": 505, "complexity": "3"}
{"back-translation": "class GFG: def answerQuery(a, n, l, r): count = 0 l = l - 1 for i in range(l, r): element = a[i] divisors = 0 for j in range(l, r): if a[j] % a[i] == 0: divisors += 1 else: break if divisors == (r - l): count += 1 return count def main(args): a = [1, 2, 3, 5] n = len(a) l, r = 1, 4 print(answerQuery(a, n, l, r)) l, r = 2, 4 print(answerQuery(a, n, l, r)) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nanswerQuery(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n{ \n\n\n\nint\ncount = \n0\n; \n\n\n\n\nl = l - \n1\n; \n\n\n\n\nfor\n(\nint\ni = l; i < r; i++) \n\n{ \n\nint\nelement = a[i]; \n\nint\ndivisors = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = l; j < r; j++) \n\n{ \n\n\n\nif\n(a[j] % a[i] == \n0\n) \n\ndivisors++; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nif\n(divisors == (r - l)) \n\ncount++; \n\n} \n\n\n\n\nreturn\ncount; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = { \n1\n, \n2\n, \n3\n, \n5\n}; \n\nint\nn = a.length; \n\n\nint\nl = \n1\n, r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n\n\nl = \n2\n; r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n} \n}", "index": 506, "complexity": "3"}
{"back-translation": "{'src': 'public class main {\\nstatic\\tclass Interval{\\n\\t\\tint start;\\n\\t\\tint end;\\n\\t\\tpublic Interval(start:int,end:int) {\\n\\t\\t\\tthis.start=start;\\n\\t\\t\\tthis.end=end;\\n\\t\\t}\\n\\t}\\nstatic class FastReader \\n{ \\n    BufferedReader br; \\n    StringTokenizer st; \\n\\n    public FastReader() \\n    { \\n        br = new BufferedReader(new\\n                 InputStreamReader(System.in)); \\n    } \\n\\n    String next() \\n    { \\n        while (st == null || !st.hasMoreElements()) \\n        { \\n            try\\n            { \\n                st = new StringTokenizer(br.readLine()); \\n            } \\n            catch (IOException  e) \\n            { \\n                e.printStackTrace(); \\n            } \\n        } \\n        return st.nextToken(); \\n    } \\n\\n    int nextInt() \\n    { \\n        return Integer.parseInt(next()); \\n    } \\n\\n    long nextLong() \\n    { \\n        return Long.parseLong(next()); \\n    } \\n\\n    double nextDouble() \\n    { \\n        return Double.parseDouble(next()); \\n    } \\n\\n    String nextLine() \\n    { \\n        String str = ''; \\n        try\\n        { \\n            str = br.readLine(); \\n        } \\n        catch (IOException e) \\n        { \\n            e.printStackTrace(); \\n        } \\n        return str; \\n    } \\n} \\n\\tstatic long mod = 1000000007;\\n\\tpublic static void main(String[] args) {\\n\\t\\t\\n\\t\\tFastReader in = new FastReader();\\n\\t\\tlong intervals = in.nextInt();\\n\\t\\tlong x = in.nextInt();\\n\\t\\t long y = in.nextInt();\\n\\t\\tInterval []ints = new Interval[(int)(int) intervals];\\n\\t\\tfor(int i = 0;i<intervals;i++) {\\n\\t\\t\\tints[i] = new Interval(in.nextInt(),in.nextInt());\\n\\t\\t}\\n\\t\\tints.sort((a,b)->a.start-b.start);\\n\\t\\tlong count = 0;\\n\\t\\tfor(int i = 0;i<ints.length;i++) {\\n\\t\\t\\tif(i>=0&&ints[i]!=null) {\\n\\t\\t\\tInterval cur1 = ints[i];\\n\\t\\t\\tfor(int j = i+1;j<ints.length;j++) {\\n\\t\\t\\t\\tif(ints[j]!=null) {\\n\\t\\t\\t\\tInterval cur2 = ints[j];\\n\\t\\t\\t\\tif(y*(cur2.start-cur1.end)<x) {\\n\\t\\t\\t\\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\\n\\t\\t\\t\\t\\tcur1.end=cur2.end;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tints[j]=null;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tcount = (count + x) % mod;\\n\\t\\t\\tcount += (y*(cur1.end-cur1.start)%mod);\\n\\t\\t\\tcount%=mod;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\tSystem.out.println(count);\\n\\t}\\n\\n}', 'complexity': '3', 'index': 507}", "src": "public class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\n\n\n\n\n\n\n\t\tSystem.out.println(count);\n\t}\n\n}", "index": 507, "complexity": "3"}
{"back-translation": "class TaxiDriversAndLyft:\n\n    class Resident:\n        def __init__(self, index, type):\n            self.index = index\n            self.type = type\n            self.requests = 0\n\n        def __str__(self):\n            if self.type == 0:\n                return f'Rider at index : {self.index}'\n            else:\n                return f'Driver at index : {self.index}, Requests: {self.requests}'\n\n    residents = []\n    drivers_indexes = []\n\n    n, m = map(int, input().split())\n    length = n + m\n\n    coordinates = [int(x) for x in input().split()]\n    types = [int(x) for x in input().split()]\n\n    for i in range(length):\n        if types[i] == 1:\n            drivers_indexes.append(i)\n        residents.append(Resident(i, types[i]))\n\n    for i in range(length):\n        current = residents[i]\n        if current.type == 0:\n            left, right = i - 1, i + 1\n            while left >= 0 or right < length:\n                if left >= 0 and residents[left].type == 1:\n                    residents[left].requests += 1\n                    break\n                elif right < length and residents[right].type == 1:\n                    residents[right].requests += 1\n                    break\n                left -= 1\n                right += 1\n\n    for index in drivers_indexes:\n        print(residents[index].requests, end=' ')\n", "src": "public class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t\n\t\tInteger type;\t\t\t\n\t\tInteger requests;\t\t\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}", "index": 508, "complexity": "3"}
{"back-translation": "class Lyft:\n    scan = FastScanner(sys.stdin)\n    pr = PrintWriter(sys.stdout)\n    n, m, taxistNumber, noTaxistNumber = 0, 0, 0, 0\n    peoples, taxist, noTaxist = [], [], []\n\n    def main(self, args):\n        self.n = self.scan.nextInt()\n        self.m = self.scan.nextInt()\n        self.peoples = [people(self.scan.nextInt()) for _ in range(self.n + self.m)]\n        self.noTaxist = [person for person in self.peoples[:self.n]]\n        self.taxist = [person for person in self.peoples[self.n:]]\n\n        for i in range(len(self.peoples)):\n            if self.scan.nextInt() == 1:\n                self.peoples[i].taxi = True\n                self.peoples[i].passangers = 0\n                self.taxist[self.taxistNumber] = self.peoples[i]\n                self.taxistNumber += 1\n            else:\n                self.noTaxist[self.noTaxistNumber] = self.peoples[i]\n                self.noTaxistNumber += 1\n\n        for i in self.noTaxist:\n            for ii in self.taxist:\n                if ii.taxi:\n                    if i.nearestTaxist is None:\n                        i.nearestTaxist = ii\n                        ii.passangers += 1\n                    elif i.coord - i.nearestTaxist.coord > ii.coord - i.coord:\n                        i.nearestTaxist.passangers -= 1\n                        i.nearestTaxist = ii\n                        i.nearestTaxist.passangers += 1\n\n        for i in self.taxist:\n            self.pr.print(str(i.passangers) + ' ')\n\n        self.pr.close()\n\n\nclass FastScanner:\n    bufferSize = 64 * 1024\n\n    def __init__(self, inputStream):\n        self.reader = BufferedReader(InputStreamReader(inputStream), self.bufferSize)\n        self.tokenizer = None\n\n    def nextToken(self):\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            line = self.reader.readLine()\n            if line is None:\n                self.tokenizer = None\n                return None\n            self.tokenizer = StringTokenizer(line)\n        return self.tokenizer.nextToken()\n\n    def readIntArray(self, n):\n        a = [self.nextInt() for _ in range(n)]\n        return a\n\n    def readLongArray(self, n):\n        a = [self.nextLong() for _ in range(n)]\n        return a\n\n    def nextInt(self):\n        return int(self.nextToken())\n\n    def nextLong(self):\n        return int(self.nextToken())\n\n    def nextDouble(self):\n        return float(self.nextToken())\n\n    def nextLine(self):\n        self.tokenizer = None\n        return self.reader.readLine()\n\n\nclass people:\n    def __init__(self, coord):\n        self.coord = coord\n        self.taxi = False\n        self.nearestTaxist = None\n        self.passangers = -1", "src": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for(int i = 0; i < peoples.length; i++){\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples){\n            if(scan.nextInt() == 1){\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist){\n                for (people ii: taxist){\n                    if(ii.taxi){\n                       if(i.nearestTaxist == null){\n                           i.nearestTaxist = ii;\n                           ii.passangers++;\n                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){\n                           i.nearestTaxist.passangers--;\n                           i.nearestTaxist = ii;\n                           i.nearestTaxist.passangers++;\n                       }\n                    }\n                }\n        }\n        for (people i : taxist){\n                pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}", "index": 509, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}", "index": 510, "complexity": "3"}
{"back-translation": "{'src': 'public class RookHome {\\n\\tstatic long MAX = 1_000_000_000;\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner s = new Scanner(new BufferedInputStream(System.in));\\n\\t\\tint n = s.nextInt();\\n\\t\\tint m = s.nextInt();\\n\\t\\tlong[] vert = new long[n + 2];\\n\\t\\tvert[0] = 1;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tvert[i] = s.nextLong();\\n\\t\\t}\\n\\t\\tvert[n + 1] = MAX;\\n\\t\\tlong[][] hor = new long[m][2];\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\thor[i][0] = s.nextLong();\\n\\t\\t\\thor[i][1] = s.nextLong();\\n\\t\\t\\ts.nextLong();\\n\\t\\t}\\n\\t\\tlong min = Long.MAX_VALUE;\\n\\t\\tint count;\\n\\t\\tfor(int i = 0; i < vert.length - 1; i++) {\\n\\t\\t\\tcount = 0;\\n\\t\\t\\tfor(int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmin = Math.min(min, i + count);\\n\\t\\t}\\n\\t\\tSystem.out.println(min);\\n\\t}\\n}', 'complexity': '3', 'index': 511}", "src": "public class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 511, "complexity": "3"}
{"back-translation": "{'src': 'public class Main:\\n    static int n, m\\n    static int[] vert, group\\n    static int[][] horiz\\n    static boolean ok(int a, int b, g):\\n        int start, end\\n        if g == 0:\\n            start = 1\\n            end = vert.length > 0 ? vert[0] : (10 ** 9)\\n        elif g == len(group) - 1:\\n            start = vert[g - 1]\\n            end = (10 ** 9)\\n        else:\\n            start = vert[g - 1]\\n            end = vert[g]\\n        return a <= start and b >= end\\n    static void main(String[] args):\\n        n, m = map(int, input().split())\\n        vert = [int(x) for x in input().split()]\\n        horiz = [[int(x) for x in input().split()] for _ in range(m)]\\n        group = [0] * (n + 1)\\n        for i in range(m):\\n            a, b, _ = horiz[i]\\n            for j in range(len(group)):\\n                if ok(a, b, j):\\n                    group[j] += 1\\n        min_val = min([group[i] + i for i in range(len(group)])\\n        print(min_val)'}, 'complexity': '3', 'index': 512}", "src": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "index": 512, "complexity": "3"}
{"back-translation": "{'src': 'public class Tokitsukaze {\\n\\n\\n    public static void main(String[] args) {\\n        Scanner sc =new Scanner(System.in);\\n        int n = sc.nextInt();\\n        int m = sc.nextInt();\\n        long k =sc.nextLong();\\n        double[]p=new double[m];\\n        for(int i = 0;i<m;i++){\\n            p[i]=sc.nextDouble();\\n        }\\n        int c=0;\\n        int used=0;\\n        for(int i = 0;i<m;){\\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\\n            long high=low+k;\\n            for(int j=i;j<m;j++){\\n                if(p[j]>=low&&p[i]<=high){\\n                    i++;\\n                }\\n            }\\n            c++;\\n        }\\n        System.out.println(c);\\n\\n    }\\n    \\n}', 'complexity': '3', 'index': 513}", "src": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "index": 513, "complexity": "3"}
{"back-translation": "class CF_573_D1_A:  \n    def __init__(self):  \n        self.verb = True  \n     \n    def log(self, X):  \n        if self.verb:  \n            print(X, file=sys.stderr)  \n     \n    def log_array(self, X):  \n        if self.verb:  \n            print(*X, file=sys.stderr)  \n     \n    def log_int_array(self, X):  \n        if self.verb:  \n            print(*X, file=sys.stderr)  \n     \n    def log_int_array_limit(self, X, L):  \n        if self.verb:  \n            print(*X[:L], file=sys.stderr)  \n     \n    def log_long_array(self, X):  \n        if self.verb:  \n            print(*X, file=sys.stderr)  \n     \n    def logWln(self, X):  \n        if self.verb:  \n            print(X, end='', file=sys.stderr)  \n     \n    def info(self, o):  \n        print(o)  \n     \n    def output(self, o):  \n        self.outputWln(str(o) + '\\n')  \n     \n    def outputWln(self, o):  \n        try:  \n            sys.stdout.write(str(o))  \n        except Exception as e:  \n            pass  \n     \n    mod = 998244353  \n    CX = 64  \n     \n    out = None  \n    reader = None  \n     \n    def process(self):  \n        sys.stdout = io.StringIO()  \n        self.reader = self.InputReader(sys.stdin)  \n         \n        n = int(input())  \n        m = int(input())  \n        k = int(input())  \n        p = [int(input()) - 1 for _ in range(m)]  \n         \n        pid = -1  \n        rem = m  \n        win = 0  \n        mx = k - 1  \n        res = 0  \n        idx = 0  \n         \n        while rem > 0:  \n            while p[idx] > mx:  \n                mx += k  \n                if mx >= n - 1:  \n                    mx = n - 1  \n                 \n            nxt = idx  \n            while nxt + 1 < m and p[nxt + 1] <= mx:  \n                nxt += 1  \n            nb = nxt - idx + 1  \n            rem -= nb  \n            mx += nb  \n            idx = nxt + 1  \n            res += 1  \n         \n        self.output(res)  \n         \n    if __name__ == '__main__':  \n        obj = CF_573_D1_A()  \n        obj.process()", "src": "public final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; \n\t\tlong mx=k-1; \n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "index": 514, "complexity": "3"}
{"back-translation": "class MinimumDistance: def minDist(arr, n, x, y): i, j = 0, 0 min_dist = sys.maxsize for i in range(n): for j in range(i+1, n): if (x == arr[i] and y == arr[j] or y == arr[i] and x == arr[j]) and min_dist > abs(i - j): min_dist = abs(i - j) return min_dist def main(args): min = MinimumDistance() arr = [3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3] n = len(arr) x, y = 3, 6 print('Minimum distance between ' + str(x) + ' and ' + str(y) + ' is ' + str(min.minDist(arr, n, x, y)))", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 515, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 516, "complexity": "3"}
{"back-translation": "def main(args):\n    n, k = map(int, input().split())\n    s = input()\n    wtArray = [ord(char) - 96 for char in s]\n    for i in range(1, n):\n        for j in range(n-i):\n            if wtArray[j] > wtArray[j+1]:\n                wtArray[j], wtArray[j+1] = wtArray[j+1], wtArray[j]\n    sum = wtArray[0]\n    k -= 1\n    temp = sum\n    for i in range(1, n):\n        if k != 0 and wtArray[i] - temp > 1:\n            sum += wtArray[i]\n            k -= 1\n            temp = wtArray[i]\n    if k != 0:\n        sum = -1\n    print(sum)\n\nif __name__ == '__main__':\n    main()", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 517, "complexity": "3"}
{"back-translation": "{'src': 'public class Main {\\n\\n\\tstatic class FastScanner {\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastScanner() {\\n            try {\\n                br = new BufferedReader(new InputStreamReader(System.in));\\n                st = new StringTokenizer(br.readLine());\\n            } catch (Exception e){e.printStackTrace();}\\n        }\\n\\n        public String next() {\\n            if (st.hasMoreTokens()) return st.nextToken();\\n            try {st = new StringTokenizer(br.readLine());}\\n            catch (Exception e) {e.printStackTrace();}\\n            return st.nextToken();\\n        }\\n\\n        public int nextInt() {return Integer.parseInt(next());}\\n\\n        public long nextLong() {return Long.parseLong(next());}\\n\\n        public double nextDouble() {return Double.parseDouble(next());}\\n\\n        public String nextLine() {\\n            String line = \\", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 518, "complexity": "3"}
{"back-translation": "class G:\n\n    def main(self):\n        n, m = map(int, input().split())\n        a = [int(input()) for _ in range(m)]\n        a.sort()\n        map = {}\n        for i in a:\n            if i not in map:\n                map[i] = 1\n            else:\n                map[i] += 1\n        list = []\n        for key, value in map.items():\n            list.append(Food(key, value))\n        list.sort(key=lambda x: x.num)\n        min_val = 1\n        max_val = list[-1].num\n        res = 0\n        for i in range(min_val, max_val+1):\n            temp = 0\n            for food in list:\n                given = food.num // i\n                if given >= 1:\n                    temp += given\n                    if temp >= n:\n                        res = max(res, i)\n                        break\n        print(res)\n\n\nclass Food:\n    def __init__(self, id, num):\n        self.id = id\n        self.num = num\n\n    def __str__(self):\n        return f'Food{{id={self.id}, num={self.num}}}'\n\n\ng = G()\ng.main()", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 519, "complexity": "3"}
{"back-translation": "class Solution:\n\n    def main(self, args):\n        sc = Scanner(System.in)\n        ss = Solution()\n        ss.test(sc)\n    \n    def test(self, sc):\n        LEN = sc.nextInt()\n        a = [0] * LEN\n        b = [0] * LEN\n        for i in range(len(b)):\n            a[i] = sc.nextInt()\n        for i in range(len(b)):\n            b[i] = sc.nextInt()\n        a.sort()\n        b.sort()\n        \n        ia = 0\n        ib = 0\n        while ia < LEN and a[ia] == 0:\n            ia += 1\n        while ib < LEN and b[ib] == 0:\n            ib += 1\n        if ib == LEN:\n            print(\"Yes\")\n            return\n        if ia == LEN:\n            print(\"No\")\n            return\n        \n        out = True\n        while ia < LEN and ib < LEN:\n            if a[ia] == b[ib]:\n                ia += 1\n                ib += 1\n            else:\n                if a[ia] > b[ib]:\n                    while ib < LEN and b[ib] != a[ia]:\n                        ib += 1\n                    if ib == LEN:\n                        out = False\n                        break\n        \n        if out:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 520, "complexity": "3"}
{"back-translation": "class GFG: def maxSum(arr, n): res = float('-inf') for i in range(n): curr_sum = 0 for j in range(n): index = (i + j) % n curr_sum += j * arr[index] res = max(res, curr_sum) return res def main(args): arr = [8, 3, 1, 2] n = len(arr) print(maxSum(arr, n)) if __name__ == '__main__': import sys ret=main(sys.argv)", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 521, "complexity": "3"}
{"back-translation": "{'src': 'public class TestClass {\\n    \\n    public static int set_size(int[] a, int N){\\n        HashSet <Integer> newset = new HashSet <Integer>();\\n        int i=0;\\n        while(i<N){\\n            newset.add(a[i++]);\\n        }\\n        int v = newset.size();\\n        return v;\\n    }\\n    public static void main(String args[] ) throws Exception {\\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n       StringTokenizer tk = new StringTokenizer(br.readLine());\\n            int N = Integer.parseInt(tk.nextToken());\\n            int x = Integer.parseInt(tk.nextToken());\\n            \\n            int[] a = new int[N];\\n            int[] b = new int[N];\\n            StringTokenizer tb = new StringTokenizer(br.readLine());\\n            for(int i=0; i<N; i++){\\n                a[i] = Integer.parseInt(tb.nextToken());\\n            }\\n            if(set_size(a, N) < N){\\n                System.out.print(\\\"0\\\");\\n                System.exit(0);\\n            }\\n            int num=0;\\n        while(num++<4){\\n            for(int i=0; i<N; i++){\\n                if((a[i]&x) == a[i])\\n                    continue;\\n                else{\\n                    for(int j=0; j<N; j++){\\n                        if(i==j){\\n                            b[i] = (a[i]&x);\\n                        }\\n                        else{\\n                            b[j] = a[j];\\n                        }\\n                    }\\n                    int s = set_size(b, N);\\n                    if(s<N){\\n                        System.out.print(num);\\n                        System.exit(0);\\n                    }\\n                }\\n            }\\n            for(int i=0; i<N; i++)\\n                a[i] = b[i];\\n        }\\n        System.out.print(\\\"-1\\\");\\n        System.exit(0);\\n    }\\n}', 'complexity': '3', 'index': 522}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 522, "complexity": "3"}
{"back-translation": "{'src': 'public class Cr500 {\\n    public static void main(String args[]) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n, x, status = -1;\\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\\n        n = scanner.nextInt();\\n        x = scanner.nextInt();\\n\\n        for(int i = 0; i < n; i++) {\\n            int v;\\n            if(!a.add(v = scanner.nextInt())) {\\n                System.out.println(0);\\n                return;\\n            }\\n\\n            if(!bitA.add(v & x)) {\\n                status = 2;\\n            }\\n            al.add(v);\\n            bl.add(v & x);\\n        }\\n\\n        if(contains(al, bl)) {\\n            System.out.println(1);\\n            return;\\n        }\\n\\n        System.out.println(status);\\n    }\\n\\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\\n        for(int i = 0; i < a.size(); i++) {\\n            int v1 = a.get(i);\\n            for(int j = 0; j < b.size(); j++) {\\n                int v2 = b.get(j);\\n                if(i != j && v1 == v2) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}', 'complexity': '3', 'index': 523}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 523, "complexity": "3"}
{"back-translation": "{'src': 'public class B {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int x = scanner.nextInt();\\n        int[] a = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = scanner.nextInt();\\n        }\\n        Arrays.sort(a);\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(a[i]);\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (a[i] == a[i + 1]) {\\n                System.out.println(0);\\n                return;\\n            }\\n        }\\n        for (int i = n - 1; i > 0; i--) {\\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\\n                System.out.println(2);\\n                return;\\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\\n                System.out.println(1);\\n                return;\\n            }\\n        }\\n        System.out.println(-1);\\n    }\\n}', 'complexity': '3', 'index': 524}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 524, "complexity": "3"}
{"back-translation": "a=[0]*(m+1)\\nfor i in range(n):\\n    l,r=map(int,input().split())\\n    for j in range(l,r+1):\\n        if a[j]!=1:\\n            a[j]=1\\n            c+=1\\nprint(m-c)\\nfor i in range(1,m+1):\\n    if a[i]==0:\\n        print(i,end=' ')", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "index": 525, "complexity": "3"}
{"back-translation": "class GFG:\n\n    def minJumps(arr, n):\n        jumps = [0] + [float('inf')] * (n-1)\n        for i in range(1, n):\n            for j in range(i):\n                if i <= j + arr[j] and jumps[j] != float('inf'):\n                    jumps[i] = min(jumps[i], jumps[j] + 1)\n        return jumps[n-1]\n\n    def main(args):\n        arr = [1, 3, 6, 1, 0, 9]\n        print(\"Minimum number of jumps to reach end is : \", minJumps(arr, len(arr)))\n\nmain([])", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 526, "complexity": "3"}
{"back-translation": "{'src': 'class DoggoRecoloring:\\n\\t\\n\\t\\ndef main(args):\\n\\t\\tn = nextInt()\\n\\t\\ts = nextString()\\n\\t\\tb = False\\n\\t\\t\\n\\t\\tif n == 1 or n > 26:\\n\\t\\t\\tb = True\\n\\t\\telse:\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(i+1, n):\\n\\t\\t\\t\\t\\tif s[i] == s[j]:\\n\\t\\t\\t\\t\\t\\tb = True\\n\\t\\t\\n\\t\\tprint('Yes' if b else 'No')\\n\\t\\n\\tdef nextLine():\\n\\t\\treturn input()\\n\\n\\tdef nextString():\\n\\t\\twhile st == None or not st:\\n\\t\\t\\tst = input().split()\\n\\t\\treturn st[0]\\n\\n\\tdef nextInt():\\n\\t\\treturn int(nextString())\\n\\n\\tdef nextLong():\\n\\t\\treturn int(nextString())\\n\\n\\tdef intArray(n):\\n\\t\\ta = [(int(x) for x in input().split())]\\n\\t\\treturn a\\n\\n\\tdef intArray(n, m):\\n\\t\\ta = [[int(x) for x in input().split()] for _ in range(n)]\\n\\t\\treturn a\\n\\n\\tdef longArray(n):\\n\\t\\ta = [(int(x) for x in input().split())]\\n\\t\\treturn a\\n'}", "src": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse \n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\t b = true;\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 527, "complexity": "3"}
{"back-translation": "class GFG: def maxSumIS(arr, n): msis = [0] * n for i in range(n): msis[i] = arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]: msis[i] = msis[j] + arr[i] max = 0 for i in range(n): if max < msis[i]: max = msis[i] return max def main(args): arr = [1, 101, 2, 3, 100, 4, 5] n = len(arr) print('Sum of maximum sum increasing subsequence is ' + str(maxSumIS(arr, n)))", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 528, "complexity": "3"}
{"back-translation": "class\nSmallestSubArraySum \n{ \nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \nint\nmin_len = n + \n1\n; \nfor\n(\nint\nstart = \n0\n; start < n; start++) \n{ \nint\ncurr_sum = arr[start]; \nif\n(curr_sum > x) \nreturn\n1\n; \nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n{ \ncurr_sum += arr[end]; \nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \nmin_len = (end - start + \n1\n); \n} \n} \nreturn\nmin_len; \n} \npublic\nstatic\nvoid\nmain(String[] args) \n{ \nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \nint\nx = \n51\n; \nint\nn1 = arr1.length; \nint\nres1 = smallestSubWithSum(arr1, n1, x); \nif\n(res1 == n1+\n1\n) \nSystem.out.println(\n\"Not Possible\"\n); \nelse\nSystem.out.println(res1); \nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \nint\nn2 = arr2.length; \nx = \n9\n; \nint\nres2 = smallestSubWithSum(arr2, n2, x); \nif\n(res2 == n2+\n1\n) \nSystem.out.println(\n\"Not Possible\"\n); \nelse\nSystem.out.println(res2); \nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \nint\nn3 = arr3.length; \nx = \n280\n; \nint\nres3 = smallestSubWithSum(arr3, n3, x); \nif\n(res3 == n3+\n1\n) \nSystem.out.println(\n\"Not Possible\"\n); \nelse\nSystem.out.println(res3); \n} \n}", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\nmin_len = n + \n1\n; \n\n\n\n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n\n\nint\ncurr_sum = arr[start]; \n\n\n\n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n\n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n\n\ncurr_sum += arr[end]; \n\n\n\n\n\n\n\n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 529, "complexity": "3"}
{"back-translation": "{'src': 'public class DivideCandies {\\n\\tpublic static void main(String[] args){\\n\\t\\tScanner input = new Scanner(System.in);\\n\\t\\tlong n = input.nextLong();\\n\\t\\tint m = input.nextInt();\\n\\t\\tlong[] a = new long[m];\\n\\t\\tfor(int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tif(i <= (n%m) && i != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ta[i] = n/m + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ta[i] = n/m;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong result = 0L;\\n\\t\\tfor(int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((i * i + j * j) % m == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult += a[i] * a[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(result);\\n\\t}\\n}', 'complexity': '3', 'index': 530}", "src": "public class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "index": 530, "complexity": "3"}
{"back-translation": "maxi=0\nn= int(input())\nli=[int(input()) for i in range (n)]\nmaxi=0\nc=0\nfor i in range(n):\n    c=0\n    for j in range(i,n):\n        if(j!=n-1 and j!=0 and li[j]-li[j-1]==1 and li[j+1]-li[j]==1):\n            c+= 1\n            i+= 1\n        elif(j!=n-1 and j==0 and li[j+1]-li[j]==1 and li[j]==1):\n            c+= 1\n            i+= 1\n        elif(j==n-1 and j!=0 and li[j]-li[j-1]==1 and li[j]==1000):\n            c+= 1\n            i+= 1\n        else:\n            break\n    if c>maxi:\n        maxi=c\nif c>maxi:\n    maxi=c\nprint(maxi)", "src": ";\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}", "index": 531, "complexity": "3"}
{"back-translation": "print(max(maxx, ans))", "src": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t}\n\t    \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        \n\t        \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\t}\n       System.out.print(maxx);\n\t}\n\n}", "index": 532, "complexity": "3"}
{"back-translation": "class Main: \n    class en: \n        def __init__(self, a, b, c): \n            self.w = a \n            self.h = b \n            self.dex = c \n        def compareTo(self, o): \n            return self.w - o.w \n    import heapq \n    n, ww, hh = map(int, input().split()) \n    num = 0 \n    que = [] \n    for i in range(1, n + 1): \n        a, b = map(int, input().split()) \n        if a > ww and b > hh: \n            heapq.heappush(que, en(a, b, i)) \n            num += 1 \n    dp = [[0, 0] for _ in range(num + 5)] \n    ans = 0 \n    ad = 0 \n    arr = [[0, 0, 0] for _ in range(num + 5)] \n    for i in range(1, num + 1): \n        arr[i][0] = que[0].w \n        arr[i][1] = que[0].h \n        arr[i][2] = heapq.heappop(que).dex \n    for i in range(1, num + 1): \n        te = 0 \n        td = 0 \n        for j in range(1, i): \n            if arr[j][0] < arr[i][0] and arr[j][1] < arr[i][1] and dp[j][0] > te: \n                te = dp[j][0] \n                td = j \n        dp[i][0] = te + 1 \n        dp[i][1] = td \n        if dp[i][0] > ans: \n            ans = dp[i][0] \n            ad = i \n    print(ans) \n    an = [] \n    u = ad \n    while u > 0: \n        an.append(arr[u][2]) \n        u = dp[u][1] \n    for i in range(len(an) - 1, -1, -1): \n        print(an[i], end=' ') ", "src": "public class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}", "index": 533, "complexity": "3"}
{"back-translation": "class GFG: def findMinDiff(arr, n): diff = float('inf') for i in range(n-1): for j in range(i+1, n): if abs((arr[i] - arr[j])) < diff: diff = abs((arr[i] - arr[j])) return diff def main(args): arr = [1, 5, 3, 19, 18, 25] print('Minimum difference is ' + str(findMinDiff(arr, len(arr))) )", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\nif\n(Math.abs((arr[i] - arr[j]) )< diff) \n\ndiff = Math.abs((arr[i] - arr[j])); \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 534, "complexity": "3"}
{"back-translation": "class Test: def __init__(self): self.arr1 = [0, 1, 0, 1, 1, 1, 1] self.arr2 = [1, 1, 1, 1, 1, 0, 1] def longestCommonSum(self, n): max_len = 0 for i in range(n): sum1, sum2 = 0, 0 for j in range(i, n): sum1 += self.arr1[j] sum2 += self.arr2[j] if sum1 == sum2: length = j - i + 1 if length > max_len: max_len = length return max_len def main(args): print('Length of the longest common span with same sum is', longestCommonSum(len(arr1)))", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\nsum1 = \n0\n, sum2 = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\nsum1 += arr1[j]; \n\nsum2 += arr2[j]; \n\n\n\n\n\n\nif\n(sum1 == sum2) \n\n{ \n\nint\nlen = j-i+\n1\n; \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 535, "complexity": "3"}
{"back-translation": "print(len(set(frozenset(input()))))", "src": "public class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "index": 536, "complexity": "3"}
{"back-translation": "class Main:\n    mod = int(1e9+7)\n    \n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n\n    def valid(self, i, j):\n        return i < self.n and j < self.m and i >= 0 and j >= 0\n\n    def main(self, args=None):\n        n = int(input())\n        m = int(input())\n        s = [input() for _ in range(n)]\n        f = 0\n        for i in range(n):\n            for j in range(len(s[i])):\n                val = -1\n                if s[i][j] == '.' :\n                    val = 0\n                elif s[i][j] == '*':\n                    continue\n                else:\n                    val = int(s[i][j])\n                c = 0\n                if self.valid(i-1, j) and s[i-1][j] == '*':\n                    c += 1\n                if self.valid(i-1, j-1) and s[i-1][j-1] == '*':\n                    c += 1\n                if self.valid(i-1, j+1) and s[i-1][j+1] == '*':\n                    c += 1\n                if self.valid(i, j-1) and s[i][j-1] == '*':\n                    c += 1\n                if self.valid(i, j+1) and s[i][j+1] == '*':\n                    c += 1\n                if self.valid(i+1, j) and s[i+1][j] == '*':\n                    c += 1\n                if self.valid(i+1, j+1) and s[i+1][j+1] == '*':\n                    c += 1\n                if self.valid(i+1, j-1) and s[i+1][j-1] == '*':\n                    c += 1\n                if c != val:\n                    f = 1\n                    break\n        if f == 0:\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    Main().main()", "src": "public class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Pair { \n    int x; \n    int y; \n  \n    \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}", "index": 537, "complexity": "3"}
{"back-translation": "class Test: \n\n    arr = [1, 20, 6, 4, 5] \n\n    @staticmethod \n    def getInvCount(n): \n        inv_count = 0 \n        for i in range(n - 1): \n            for j in range(i + 1, n): \n                if Test.arr[i] > Test.arr[j]: \n                    inv_count += 1 \n\n        return inv_count \n\n    @staticmethod \n    def main(args): \n        print('Number of inversions are ' + str(Test.getInvCount(len(Test.arr))))", "src": "class\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n}", "index": 538, "complexity": "3"}
{"back-translation": "class Main: def minAbsSumPair(arr, arr_size): inv_count = 0 min_l, min_r = 0, 1 min_sum = arr[0] + arr[1] for l in range(arr_size - 1): for r in range(l+1, arr_size): sum = arr[l] + arr[r] if abs(min_sum) > abs(sum): min_sum = sum min_l, min_r = l, r print(' The two elements whose ' + 'sum is minimum are ' + str(arr[min_l])+ ' and '+str(arr[min_r])) def main(args): arr = [1, 60, -10, 70, -80, 85] minAbsSumPair(arr, 6) if __name__ == '__main__': import math main(sys.argv) ", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 539, "complexity": "3"}
{"back-translation": "class Main:\n    def main(self):\n        instance = Main()\n        instance.run()\n\n    def __init__(self):\n        self.in = Scanner(System.in)\n        self.out = PrintWriter(System.out)\n\n    def run(self):\n        q = self.in.nextInt()\n        for i in range(q):\n            self.out.println(self.work())\n        self.out.flush()\n\n    def work(self):\n        n = self.in.nextInt()\n        k = self.in.nextInt()\n        str = self.in.next()\n        chs = ['R', 'G', 'B']\n        c1, c2, c3 = 0, 0, 0\n        ret = 99999999\n        for i in range(n):\n            p1, p2, p3 = 0, 1, 2\n            for j in range(3):\n                ch = str.charAt(j)\n                if ch != chs[p1]:\n                    c1 += 1\n                if j >= k:\n                    pre1 = str.charAt(j - k)\n                    pre2 = chs[((p1 - (k % 3)) + 3) % 3]\n                    if pre1 != pre2:\n                        c1 -= 1\n                if j + 1 >= k:\n                    ret = min(ret, c1)\n                if ch != chs[p2]:\n                    c2 += 1\n                if j >= k:\n                    pre1 = str.charAt(j - k)\n                    pre2 = chs[((p2 - (k % 3)) + 3) % 3]\n                    if pre1 != pre2:\n                        c2 -= 1\n                if j + 1 >= k:\n                    ret = min(ret, c2)\n                if ch != chs[p3]:\n                    c3 += 1\n                if j >= k:\n                    pre1 = str.charAt(j - k)\n                    pre2 = chs[((p3 - (k % 3)) + 3) % 3]\n                    if pre1 != pre2:\n                        c3 -= 1\n                if j + 1 >= k:\n                    ret = min(ret, c3)\n        return ret", "src": "public class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        \n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}", "index": 540, "complexity": "3"}
{"back-translation": "{'src': 'def CodeForces():\\n\\tdef get_input():\\n\\t\\tt, n, k = map(int, input().split())\\n\\t\\ts = input()\\n\\t\\treturn t, n, k, s\\n\\tt = CodeForces(input())\\n\\tfor _ in range(t):\\n\\t\\tt, n, k, s = get_input()\\n\\t\\ts1 = 'RGB' * (n // 3) + 'RGB'[:n % 3]\\n\\t\\ts2 = 'GBR' * (n // 3) + 'GBR'[:n % 3]\\n\\t\\ts3 = 'BRG' * (n // 3) + 'BRG'[:n % 3]\\n\\t\\tarr1 = [1 if s[i] != s1[i] else 0 for i in range(n)]\\n\\t\\tarr2 = [1 if s[i] != s2[i] else 0 for i in range(n)]\\n\\t\\tarr3 = [1 if s[i] != s3[i] else 0 for i in range(n)]\\n\\t\\tfor arr in [arr1, arr2, arr3]:\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tarr[i] += arr[i - 1]\\n\\t\\tmin1 = min(arr1[:k])\\n\\t\\tmin2 = min(arr2[:k])\\n\\t\\tmin3 = min(arr3[:k])\\n\\t\\tfor arr in [arr1, arr2, arr3]:\\n\\t\\t\\tfor i in range(k, n):\\n\\t\\t\\t\\tmin_val = min(min_val, arr[i] - arr[i - k])\\n\\t\\tprint(min(min1, min2, min3)\\n'}", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\t\n\t\tint t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];\n\t\tString s;\n\t\tchar[] s1,s2,s3;\n\n\t\tt=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\ts=sc.next();\n\t\t\ts1=new char[n];\n\t\t\ts2=new char[n];\n\t\t\ts3=new char[n];\n\t\t\t\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i%3==0)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='R';\n\t\t\t\t\ts2[i]='G';\n\t\t\t\t\ts3[i]='B';\n\t\t\t\t}\n\t\t\t\tif(i%3==1)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='G';\n\t\t\t\t\ts2[i]='B';\n\t\t\t\t\ts3[i]='R';\n\t\t\t\t}\n\t\t\t\tif(i%3==2)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='B';\n\t\t\t\t\ts2[i]='R';\n\t\t\t\t\ts3[i]='G';\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr1=new int[n];\n\t\t\tarr2=new int[n];\n\t\t\tarr3=new int[n];\n\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)!=s1[i])\n\t\t\t\t\tarr1[i]=1;\n\t\t\t\tif(s.charAt(i)!=s2[i])\n\t\t\t\t\tarr2[i]=1;\n\t\t\t\tif(s.charAt(i)!=s3[i])\n\t\t\t\t\tarr3[i]=1;\n\t\t\t}\n\t\t\tfor(i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tarr1[i]=arr1[i]+arr1[i-1];\n\t\t\t\tarr2[i]=arr2[i]+arr2[i-1];\n\t\t\t\tarr3[i]=arr3[i]+arr3[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tmin1=arr1[k-1];\n\t\t\tmin2=arr2[k-1];\n\t\t\tmin3=arr3[k-1];\n\n\t\t\tfor(i=k;i<n;i++)\n\t\t\t{\n\t\t\t\tif(min1>(arr1[i]-arr1[i-k]))\n\t\t\t\t\tmin1=(arr1[i]-arr1[i-k]);\n\t\t\t\tif(min2>(arr2[i]-arr2[i-k]))\n\t\t\t\t\tmin2=(arr2[i]-arr2[i-k]);\n\t\t\t\tif(min3>(arr3[i]-arr3[i-k]))\n\t\t\t\t\tmin3=(arr3[i]-arr3[i-k]);\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(min1,Math.min(min2,min3)));\n\t\t}\n\t}\n}", "index": 541, "complexity": "3"}
{"back-translation": "class D:\n\n\tdp = [[0, 0, 0] for _ in range(200005)]\n\t\n\tdef main(args):\n\t\tcin = input\n\t\tcout = print\n\t\t\n\t\tq = int(cin())\n\t\ta = [0] * 200005\n\t\tn, k = 0, 0\n\t\twhile q > 0:\n\t\t\tn = int(cin())\n\t\t\tk = int(cin())\n\t\t\tchuoi = cin()\n\t\t\tfor i in range(1, n+1):\n\t\t\t\tch = chuoi[i-1]\n\t\t\t\tif ch == 'R': a[i] = 1\n\t\t\t\tif ch == 'G': a[i] = 2\n\t\t\t\tif ch == 'B': a[i] = 0\n\t\t\t\n\t\t\tfor i in range(1, n+1):\n\t\t\t\tfor x in range(3):\n\t\t\t\t\tdp[i][x] = dp[i-1][x]\n\t\t\t\t\tif a[i] != (x + i) % 3: dp[i][x] += 1\n\t\t\t\n\t\t\tres = 1000000007\n\t\t\tfor i in range(k, n+1):\n\t\t\t\tfor x in range(3):\n\t\t\t\t\tres = min(res, dp[i][x] - dp[i-k][x])\n\t\t\t\t\t\n\t\t\t\tcout(res)\n\t\t\t\tq -= 1\n\t\tq()\n}", "src": "public class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}", "index": 542, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 543, "complexity": "3"}
{"back-translation": "class GFG:\n    @staticmethod\n    def findTriplets(arr, n):\n        found = False\n        arr.sort()\n        for i in range(n-1):\n            l = i + 1\n            r = n - 1\n            x = arr[i]\n            while l < r:\n                if x + arr[l] + arr[r] == 0:\n                    print(x, arr[l], arr[r])\n                    l += 1\n                    r -= 1\n                    found = True\n                elif x + arr[l] + arr[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        if not found:\n            print(\"No Triplet Found\")\n\n    @staticmethod\n    def main(args):\n        arr = [0, -1, 2, -3, 1]\n        n = len(arr)\n        GFG.findTriplets(arr, n)\n\nGFG.main([])", "src": "class\nGFG { \n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n\n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n\n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n\n\n\n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n\n}", "index": 544, "complexity": "3"}
{"back-translation": "class GFG: def binomialCoeff(n, k): C = [0]*(k+1) C[0] = 1 for i in range(1, n+1): for j in range(min(i, k), 0, -1): C[j] += C[j-1] return C[k] def main(args): n, k = 5, 2 print(f\"Value of C(%d, %d) is %d \" % (n, k, binomialCoeff(n, k))) if __name__ == '__main__': import math main(sys.argv)", "src": "class\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n\n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n}", "index": 545, "complexity": "3"}
{"back-translation": "class GFG { static void printArray(int A[], int size) { for (int i = 0; i < size; i++) System.out.print(A[i] + \" \"); System.out.println(\"\"); } static void reverse(int arr[], int l, int r) { if (l < r) { arr = swap(arr, l, r); reverse(arr, ++l, --r); } } static void merge(int arr[], int l, int m, int r) { int i = l; int j = m + 1; while (i <= m && arr[i] < 0) i++; while (j <= r && arr[j] < 0) j++; reverse(arr, i, m); reverse(arr, m + 1, j - 1); reverse(arr, i, j - 1); } static void RearrangePosNeg(int arr[], int l, int r) { if (l < r) { int m = l + (r - l) / 2; RearrangePosNeg(arr, l, m); RearrangePosNeg(arr, m + 1, r); merge(arr, l, m, r); } } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } public static void main(String[] args) { int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 }; int arr_size = arr.length; RearrangePosNeg(arr, 0, arr_size - 1); printArray(arr, arr_size); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n\n\nint\nj = m + \n1\n; \n\n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n\n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n\n\n\n\n\n\n\nreverse(arr, i, m); \n\n\n\n\n\n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n\n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n}", "index": 546, "complexity": "3"}
{"back-translation": "class\nGFG:\n    def minJumps(arr, n):\n        jumps = [0] * n\n        jumps[n - 1] = 0\n        for i in range(n - 2, -1, -1):\n            if arr[i] == 0:\n                jumps[i] = float('inf')\n            elif arr[i] >= n - i - 1:\n                jumps[i] = 1\n            else:\n                min_val = float('inf')\n                for j in range(i + 1, n):\n                    if j <= arr[i] + i:\n                        if min_val > jumps[j]:\n                            min_val = jumps[j]\n                jumps[i] = min_val + 1 if min_val != float('inf') else min_val\n        return jumps[0]\n    def main(args):\n        arr = [1, 3, 6, 1, 0, 9]\n        size = len(arr)\n        print(\"Minimum number of jumps to reach end is \" + str(minJumps(arr, size)))\nmain([])", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 547, "complexity": "3"}
{"back-translation": "class GFG: def minJumps(arr, n): jumps = [0] * n jumps[n - 1] = 0 for i in range(n - 2, -1, -1): if arr[i] == 0: jumps[i] = float('inf') elif arr[i] >= n - i - 1: jumps[i] = 1 else: min_val = float('inf') for j in range(i + 1, n): if min_val > jumps[j]: min_val = jumps[j] if min_val != float('inf'): jumps[i] = min_val + 1 else: jumps[i] = min_val return jumps[0] def main(arr): size = len(arr) print('Minimum number of jumps to reach end is ' + str(minJumps(arr, size))) arr = [1, 3, 6, 1, 0, 9] main(arr)", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 548, "complexity": "3"}
{"back-translation": "{'src': 'public\\nclass\\nGfG{ \\n\\n\\n\\npublic\\nstatic\\nvoid\\nrearrangeArr(\\nint\\narr[], \\n\\nint\\nn) \\n\\n{ \\n\\n\\n\\nint\\nevenPos = n // \\n2\\n; \\n\\n\\n\\nint\\noddPos = n - evenPos; \\n\\n\\nint\\n[] tempArr = \\nnew\\nint\\n[n]; \\n\\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i++) \\n\\ntempArr[i] = arr[i]; \\n\\n\\n\\nArrays.sort(tempArr); \\n\\n\\nint\\nj = oddPos - \\n1\\n; \\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i += \\n2\\n) { \\n\\narr[i] = tempArr[j]; \\n\\nj--; \\n\\n} \\n\\n\\nj = oddPos; \\n\\n\\n\\n\\nfor\\n(\\nint\\ni = \\n1\\n; i < n; i += \\n2\\n) { \\n\\narr[i] = tempArr[j]; \\n\\nj++; \\n\\n} \\n\\n\\n\\nfor\\n(\\nint\\ni = \\n0\\n; i < n; i++) \\n\\nSystem.out.print(arr[i] + \\n\" \"\\n); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String argc[]){ \\n\\nint\\n[] arr = \\nnew\\nint\\n[]{ \\n1\\n, \\n2\\n, \\n3\\n, \\n4\\n, \\n5\\n, \\n\\n6\\n, \\n7\\n}; \\n\\nint\\nsize = \\n7\\n; \\n\\nrearrangeArr(arr, size); \\n\\n\\n} \\n}', 'complexity': '5', 'index': 549}", "src": "public\nclass\nGfG{ \n\n\n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\nint\nevenPos = n / \n2\n; \n\n\n\n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n\n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n}", "index": 549, "complexity": "5"}
{"back-translation": "{'src': 'public class ladder {\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int problems = sc.nextInt();\\n        for (int i = 0; i < problems; i++) {\\n            int numPlanks = sc.nextInt();\\n            solve(numPlanks, sc);\\n        }\\n\\n    }\\n    public static void solve(int numPlanks, Scanner sc) {\\n        int answer;\\n        ArrayList<Integer> planks  = new ArrayList<>();\\n        for (int i = 0; i < numPlanks; i++) {\\n            planks.add(sc.nextInt());\\n        }\\n\\n        Collections.sort(planks);\\n\\n        planks.remove(numPlanks - 1);\\n        planks.add(planks.get(numPlanks - 2));\\n        int base = planks.get(numPlanks - 1) - 1;\\n        if ((numPlanks - 2) > base) {\\n            answer = base;\\n        }\\n        else {\\n            answer = numPlanks - 2;\\n        }\\n        if (base == 0) {\\n            answer = 0;\\n        }\\n        System.out.println(answer);\\n    }\\n}', 'complexity': '5', 'index': 550}", "src": "public class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "index": 550, "complexity": "5"}
{"back-translation": "class Main:\n    \n    @staticmethod\n    def merge(arr, l, m, r):\n        n1 = m - l + 1\n        n2 = r - m\n        L = [arr[l + i] for i in range(n1)]\n        R = [arr[m + 1 + j] for j in range(n2)]\n        i = j = 0\n        k = l\n        while i < n1 and j < n2:\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    \n    @staticmethod\n    def sort(arr, l, r):\n        if l < r:\n            m = (l + r) // 2\n            Main.sort(arr, l, m)\n            Main.sort(arr, m + 1, r)\n            Main.merge(arr, l, m, r)\n    \n    @staticmethod\n    def main(args):\n        import sys\n        input_lines = sys.stdin.read().strip().split('\\n')\n        q = int(input_lines[0])\n        current_line = 1\n        for _ in range(q):\n            n = int(input_lines[current_line])\n            a = list(map(int, input_lines[current_line + 1].split()))\n            Main.sort(a, 0, n - 1)\n            p = a[n - 2] - 1\n            if n - 2 >= p:\n                print(p)\n            elif n - 2 == 0:\n                print(0)\n            else:\n                print(n - 2)\n            current_line += 2\nif __name__ == '__main__':\n    import sys\n    Main.main(sys.argv[1:])", "src": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        \n  \n        \n        int i = 0, j = 0; \n  \n        \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        while(q>0)\n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(i=0;i<n;i++)\n                a[i]=sc.nextInt();\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "index": 551, "complexity": "5"}
{"back-translation": "import sys\nfrom queue import PriorityQueue\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    ts = PriorityQueue()\n    for i in range(1, n):\n        ts.put(a[i] - a[i-1])\n    sum = 0\n    for i in range(n-k):\n        sum += ts.get()\n    print(sum)\n\nif __name__ == '__main__':\n    main()", "src": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "index": 552, "complexity": "5"}
{"back-translation": "{'src': 'public final class Cf { public static void main(String[] args) { FastReader ob = new FastReader(); { int n = ob.nextInt(); int k = ob.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) { a[i] = ob.nextInt(); } int x = a[n - 1] - a[0]; ArrayList<Integer> b = new ArrayList<>(); for (int i = 0; i < n - 1; i++) { b.add(-a[i + 1] + a[i]); } Collections.sort(b); for (int i = 0; i < k - 1; i++) { x += b.get(i); } System.out.println(x); } } } }', 'complexity': '5', 'index': 553}", "src": "public final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        \n        \n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "index": 553, "complexity": "5"}
{"back-translation": "class GfG { public static int minMaxProduct( int arr1[], int arr2[], int n1, int n2) { Arrays.sort(arr1); Arrays.sort(arr2); return arr1[n1 - 1] * arr2[0]; } public static void main(String argc[]) { int[] arr1= new int[]{ 10, 2, 3, 6, 4, 1}; int[] arr2 = new int[]{ 5, 1, 4, 2, 6, 9}; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } } ", "src": "class\nGfG \n{ \n\n\n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\n\n\n\n\n\nreturn\narr1[n1 - \n1\n] * arr2[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, \n\narr2, \n\nn1, n2)); \n\n} \n}", "index": 554, "complexity": "5"}
{"back-translation": "class GFG : def findMaxSubarraySumUtil(A, B, n, m): max_so_far, curr_max = float('-inf'), 0 for i in range(n): if B.count(A[i]) > 0: curr_max = 0 continue curr_max = max(A[i], curr_max + A[i]) max_so_far = max(max_so_far, curr_max) return max_so_far def findMaxSubarraySum(A, B, n, m): B.sort() maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m) if maxSubarraySum == float('-inf'): print('Maximum subarray sum cant be found') else: print('The Maximum subarray sum = ' + str(maxSubarraySum)) def main(args): A = [3, 4, 5, -4, 6] B = [1, 8, 5] n = len(A) m = len(B) findMaxSubarraySum(A, B, n, m) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = Integer.MIN_VALUE, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\nif\n(Arrays.binarySearch(B, A[i]) >= \n0\n) \n\n{ \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\nArrays.sort(B); \n\n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == Integer.MIN_VALUE) \n\n{ \n\nSystem.out.println(\n\"Maximum subarray sum cant be found\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.println(\n\"The Maximum subarray sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = {\n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = {\n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 555, "complexity": "5"}
{"back-translation": "class GFG: def maxTripletSum(arr, n): arr.sort() return arr[n - 1] + arr[n - 2] + arr[n - 3] def main(args): arr = [1, 0, 8, 6, 4, 2] n = len(arr) return maxTripletSum(arr, n) print(main([]))", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nreturn\narr[n - \n1\n] + arr[n - \n2\n] + arr[n - \n3\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 556, "complexity": "5"}
{"back-translation": "class GFG: def maximum(a, b, c): return max(max(a, b), c) def minimum(a, b, c): return min(min(a, b), c) def smallestDifferenceTriplet(arr1, arr2, arr3, n): arr1.sort() arr2.sort() arr3.sort() res_min, res_max, res_mid = 0, 0, 0 i, j, k = 0, 0, 0 diff = 2147483647 while i < n and j < n and k < n: sum_ = arr1[i] + arr2[j] + arr3[k] max_ = maximum(arr1[i], arr2[j], arr3[k]) min_ = minimum(arr1[i], arr2[j], arr3[k]) if min_ == arr1[i]: i += 1 elif min_ == arr2[j]: j += 1 else: k += 1 if diff > (max_ - min_): diff = max_ - min_ res_max = max_ res_mid = sum_ - (max_ + min_) res_min = min_ print(res_max, res_mid, res_min) if __name__ == '__main__': arr1 = [5, 2, 8] arr2 = [10, 7, 12] arr3 = [9, 14, 6] n = len(arr1) smallestDifferenceTriplet(arr1, arr2, arr3, n)", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nmaximum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.max(Math.max(a, b), c); \n\n} \n\n\n\n\nstatic\nint\nminimum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.min(Math.min(a, b), c); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nsmallestDifferenceTriplet(\nint\narr1[], \n\nint\narr2[], \nint\narr3[], \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n\n\nint\nres_min=\n0\n, res_max=\n0\n, res_mid=\n0\n; \n\n\n\n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\n\n\nint\ndiff = \n2147483647\n; \n\n\nwhile\n(i < n && j < n && k < n) \n\n{ \n\nint\nsum = arr1[i] + arr2[j] + arr3[k]; \n\n\n\n\nint\nmax = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n\n\nint\nmin = minimum(arr1[i], arr2[j], arr3[k]); \n\nif\n(min == arr1[i]) \n\ni++; \n\nelse\nif\n(min == arr2[j]) \n\nj++; \n\nelse\n\nk++; \n\n\n\n\n\n\nif\n(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n\n\nSystem.out.print(res_max + \n\", \"\n+ res_mid \n\n+ \n\", \"\n+ res_min); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\narr1[] = {\n5\n, \n2\n, \n8\n}; \n\nint\narr2[] = {\n10\n, \n7\n, \n12\n}; \n\nint\narr3[] = {\n9\n, \n14\n, \n6\n}; \n\n\nint\nn = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n}", "index": 557, "complexity": "5"}
{"back-translation": "class GFG: static R,C = 4,4 def first(arr, low, high): if high >= low: mid = low + (high - low) // 2 if ((mid == 0 or (arr[mid - 1] == 0)) and arr[mid] == 1): return mid elif arr[mid] == 0: return first(arr, (mid + 1), high) else: return first(arr, low, (mid - 1)) return -1 def rowWithMax1s(mat): max_row_index, max = 0, -1 for i in range(R): index = first(mat[i], 0, C - 1) if index != -1 and C - index > max: max = C - index max_row_index = i return max_row_index def main(args): mat = [ [0, 0, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0] ] print('Index of row with maximum 1s is ' + str(rowWithMax1s(mat)))", "src": "class\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n\n\nint\nmid = low + (high - low) / \n2\n; \n\n\n\n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n\n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n\n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n\n\n\n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n}", "index": 558, "complexity": "5"}
{"back-translation": "class GFG: def rearrangeArray(arr, n): arr.sort() tempArr = [0] * n arrIndex = 0 for i, j in zip(range(n // 2), reversed(range(n // 2, n))): if arrIndex < n: tempArr[arrIndex] = arr[i] arrIndex += 1 if arrIndex < n: tempArr[arrIndex] = arr[j] arrIndex += 1 for i in range(n): arr[i] = tempArr[i] def main(args): arr = [5, 8, 1, 4, 2, 9, 3, 7, 6] n = len(arr) rearrangeArray(arr, n) for i in range(n): print(arr[i], end=' ') if __name__ == '__main__': import sys; main(sys.argv)", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\n\nint\nArrIndex = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 559, "complexity": "5"}
{"back-translation": "{'src': 'class LinkedList { static Node head; static class Node { int data; Node next, prev; Node(int d) { data = d; next = prev = None; } } def print(node): temp = node; print(\\", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\n\n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n\n\n\n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n\n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n\n\nreturn\nmerge(node, second); \n\n} \n\n\n\n\nNode merge(Node first, Node second) { \n\n\n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n\n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n\n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n}", "index": 560, "complexity": "5"}
{"back-translation": "class GenerateBNo: def generatePrintBinary(n): from queue import Queue q = Queue() q.put('1') while n > 0: s1 = q.queue[0] q.get() print(s1) s2 = s1 q.put(s1 + '0') q.put(s2 + '1') def main(args): n = 10 generatePrintBinary(n) if __name__ == '__main__': import sys main(sys.argv)", "src": "public\nclass\nGenerateBNo \n{ \n\n\n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n\n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n\n\nq.add(\n\"1\"\n); \n\n\n\n\n\n\nwhile\n(n-- > \n0\n) \n\n{ \n\n\n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n\n\nString s2 = s1; \n\n\n\n\nq.add(s1 + \n\"0\"\n); \n\n\n\n\n\n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n}", "index": 561, "complexity": "5"}
{"back-translation": "class LIS: def CeilIndex(A, l, r, key): while r - l > 1: m = l + (r - l) // 2 if A[m] >= key: r = m else: l = m return r def LongestIncreasingSubsequenceLength(A, size): tailTable = [0] * size len = 1 tailTable[0] = A[0] for i in range(1, size): if A[i] < tailTable[0]: tailTable[0] = A[i] elif A[i] > tailTable[len - 1]: tailTable[len] = A[i] len += 1 else: tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i] return len def main(args): A = [2, 5, 3, 7, 11, 8, 10, 13, 6] n = len(A) print('Length of Longest Increasing Subsequence is ' + str(LongestIncreasingSubsequenceLength(A, n))) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nLIS { \n\n\n\n\n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n\n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n\n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n\n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n\n\ntailTable[len++] = A[i]; \n\n\nelse\n\n\n\n\n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n}", "index": 562, "complexity": "5"}
{"back-translation": "class GFG: import math def maxSumPairWithDifferenceLessThanK(arr, N, K): arr.sort() dp = [0] * N dp[0] = 0 for i in range(1, N): dp[i] = dp[i-1] if arr[i] - arr[i-1] < K: if i >= 2: dp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]) else: dp[i] = max(dp[i], arr[i] + arr[i-1]) return dp[N - 1] def main(): arr = [3, 5, 10, 15, 17, 12, 9] N = len(arr) K = 4 print(maxSumPairWithDifferenceLessThanK(arr, N, K)) if __name__ == '__main__': main()", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n\n\n\n\ndp[i] = dp[i-\n1\n]; \n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n\n\n\n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n\n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n}", "index": 563, "complexity": "5"}
{"back-translation": "{'src': 'class\\nGFG { \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nmaxSumPairWithDifferenceLessThanK(\\nint\\narr[], \\n\\nint\\nN, \\nint\\nk) \\n\\n{ \\n\\nint\\nmaxSum = \\n0\\n; \\n\\n\\n\\n\\nArrays.sort(arr); \\n\\n\\n\\n\\n\\n\\nfor\\n(\\nint\\ni = N-\\n1\\n; i > \\n0\\n; --i) \\n\\n{ \\n\\n\\n\\n\\n\\n\\n\\n\\n\\nif\\n(arr[i] - arr[i-\\n1\\n] < k) \\n\\n{ \\n\\n\\n\\nmaxSum += arr[i]; \\n\\nmaxSum += arr[i-\\n1\\n]; \\n\\n\\n\\n--i; \\n\\n} \\n\\n} \\n\\n\\nreturn\\nmaxSum; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain (String[] args) { \\n\\n\\nint\\narr[] = {\\n3\\n, \\n5\\n, \\n10\\n, \\n15\\n, \\n17\\n, \\n12\\n, \\n9\\n}; \\n\\nint\\nN = arr.length; \\n\\nint\\nK = \\n4\\n; \\n\\n\\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \\n\\narr, N, K)); \\n\\n} \\n}', 'complexity': '5', 'index': 564}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nk) \n\n{ \n\nint\nmaxSum = \n0\n; \n\n\n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = N-\n1\n; i > \n0\n; --i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < k) \n\n{ \n\n\n\nmaxSum += arr[i]; \n\nmaxSum += arr[i-\n1\n]; \n\n\n\n\n--i; \n\n} \n\n} \n\n\nreturn\nmaxSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n} \n}", "index": 564, "complexity": "5"}
{"back-translation": "class GFG: def kthSmallest(arr, k): arr.sort() return arr[k-1] def main(args): arr = [12, 3, 5, 7, 19] k = 2 print('K\\'th smallest element is ' + str(kthSmallest(arr, k)))", "src": "class\nGFG \n{ \n\n\n\n\n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n}", "index": 565, "complexity": "5"}
{"back-translation": "class GFG: def find_max(A, N, K): Count = {} for i in range(K - 1): if A[i] in Count: Count[A[i]] += 1 else: Count[A[i]] = 1 Myset = set() for x in Count.items(): if int(x[1]) == 1: Myset.add(int(x[0])) for i in range(K - 1, N): if A[i] in Count: Count[A[i]] += 1 else: Count[A[i]] = 1 if int(Count[A[i]]) == 1: Myset.add(A[i]) else: Myset.remove(A[i]) if len(Myset) == 0: print('Nothing') else: print(sorted(Myset)[-1]) x = A[i-K+1] Count[x] -= 1 if int(Count[x]) == 1: Myset.add(x) if int(Count[x]) == 0: Myset.remove(x) def main(): a = [1, 2, 2, 3, 3] n = len(a) k = 3 find_max(a, n, k) if __name__ == '__main__': main()", "src": "class\nGFG { \n\n\nstatic\nvoid\nfind_max(\nint\n[] A, \nint\nN, \nint\nK) \n\n{ \n\n\n\n\n\nHashMap<Integer, Integer> Count = \nnew\nHashMap<>(); \n\nfor\n(\nint\ni = \n0\n; i < K - \n1\n; i++) \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nTreeSet<Integer> Myset = \nnew\nTreeSet<Integer>(); \n\nfor\n(Map.Entry x : Count.entrySet()) { \n\nif\n(Integer.parseInt(String.valueOf(x.getValue())) == \n1\n) \n\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()))); \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = K - \n1\n; i < N; i++) { \n\n\n\n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(A[i]))) == \n1\n) \n\nMyset.add(A[i]); \n\nelse\n\nMyset.remove(A[i]); \n\n\n\n\n\n\nif\n(Myset.size() == \n0\n) \n\nSystem.out.println(\n\"Nothing\"\n); \n\n\n\n\n\n\nelse\n\nSystem.out.println(Myset.last()); \n\n\n\n\n\n\nint\nx = A[i - K + \n1\n]; \n\nCount.put(x, Count.get(x) - \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n1\n) \n\nMyset.add(x); \n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n0\n) \n\nMyset.remove(x); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] a = { \n1\n, \n2\n, \n2\n, \n3\n, \n3\n}; \n\nint\nn = a.length; \n\nint\nk = \n3\n; \n\nfind_max(a, n, k); \n\n} \n}", "index": 566, "complexity": "5"}
{"back-translation": "class GFG: def pairs(arr, n, k): smallest = min(arr) count=0 for i in range(n): for j in range(i+1, n): if abs(arr[i] + arr[j] - k) < smallest: smallest = abs(arr[i] + arr[j] - k) count = 1 elif abs(arr[i] + arr[j] - k) == smallest: count += 1 print('Minimal Value = ', smallest) print('Total Pairs = ', count) def main(): arr = [3, 5, 7, 5, 1, 9, 9] k = 12 n = len(arr) pairs(arr, n, k) main()", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\npairs(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nint\nsmallest = Integer.MAX_VALUE; \n\nint\ncount=\n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n( Math.abs(arr[i] + arr[j] - k) < \n\nsmallest ) \n\n{ \n\nsmallest = Math.abs(arr[i] + arr[j] \n\n- k); \n\ncount = \n1\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(Math.abs(arr[i] + arr[j] - k) \n\n== smallest) \n\ncount++; \n\n} \n\n\n\n\nSystem.out.println(\n\"Minimal Value = \"\n+ \n\nsmallest); \n\nSystem.out.println(\n\"Total Pairs = \"\n+ \n\ncount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n5\n, \n7\n, \n5\n, \n1\n, \n9\n, \n9\n}; \n\nint\nk = \n12\n; \n\nint\nn = arr.length; \n\npairs(arr, n, k); \n\n} \n}", "index": 567, "complexity": "5"}
{"back-translation": "class ActivitySelection: def printMaxActivities(s, f, n): i, j = 0, 0 print('Following activities are selected : ') print(i, end=' ') for j in range(1, n): if s[j] >= f[i]: print(j, end=' ') i = j def main(): s = [1, 3, 0, 5, 8, 5] f = [2, 4, 6, 7, 9, 9] n = len(s) printMaxActivities(s, f, n) if __name__ == '__main__': main()", "src": "class\nActivitySelection \n{ \n\n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n\n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n\n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n}", "index": 568, "complexity": "5"}
{"back-translation": "class DisjointSet: def __init__(self, n): self.parent = [i for i in range(n + 1)] def find(self, s): return s if s == self.parent[s] else self.parent[s] = self.find(self.parent[s]) def merge(self, u, v): self.parent[v] = u class Job: def __init__(self): pass def __init__(self, id, deadline, profit): self.id = id self.deadline = deadline self.profit = profit @staticmethod def findMaxDeadline(arr): ans = min(arr, key=lambda x: x.deadline).deadline return ans @staticmethod def printJobScheduling(arr): arr.sort(key=lambda x: x.profit, reverse=True) maxDeadline = Job.findMaxDeadline(arr) dsu = DisjointSet(maxDeadline) for temp in arr: availableSlot = dsu.find(temp.deadline) if availableSlot > 0: dsu.merge(dsu.find(availableSlot - 1), availableSlot) print(temp.id, end=' ') print() def compare(j1, j2): return -1 if j1.profit > j2.profit else 1 if __name__ == '__main__': arr = [Job('a', 2, 100), Job('b', 1, 19), Job('c', 2, 27), Job('d', 1, 25), Job('e', 3, 15)] print('Following jobs need to be executed for maximum profit') Job.printJobScheduling(arr)", "src": "class\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n\n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n\n\nint\nfind(\nint\ns) \n\n{ \n\n\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n\n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n\n\n\n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n\n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n\n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n\n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n\n\n\n\nCollections.sort(arr, \nnew\nJob()); \n\n\n\n\n\n\n\n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n\n\nfor\n(Job temp : arr) \n\n{ \n\n\n\n\n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n\n\n\n\nif\n(availableSlot > \n0\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n\nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n}", "index": 569, "complexity": "5"}
{"back-translation": "class GFG: def find3largest(arr): arr.sort() n = len(arr) check = 0 count = 1 for i in range(1, n+1): if count < 4: if check != arr[n-i]: print(arr[n-i], end=' ') check = arr[n-i] count += 1 else: break def main(args): obj = GFG() arr = [12, 45, 1, -1, 45, 54, 23, 5, 0, -10] obj.find3largest(arr) if __name__ == '__main__': main() ", "src": "class\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n\n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n}", "index": 570, "complexity": "5"}
{"back-translation": "class\nHuffmanNode:\n    def __init__(self):\n        self.data = 0\n        self.c = ''\n        self.left = None\n        self.right = None\n\nclass MyComparator:\n    def compare(self, x, y):\n        return x.data - y.data\n\n\nclass Huffman:\n    @staticmethod\n    def printCode(root, s):\n        if root.left is None and root.right is None and root.c.isalpha():\n            print(root.c + ':' + s)\n            return\n        Huffman.printCode(root.left, s + '0')\n        Huffman.printCode(root.right, s + '1')\n\n    @staticmethod\n    def main(args):\n        import queue\n        n = 6\n        charArray = ['a', 'b', 'c', 'd', 'e', 'f']\n        charfreq = [5, 9, 12, 13, 16, 45]\n        q = queue.PriorityQueue(n)\n\n        for i in range(n):\n            hn = HuffmanNode()\n            hn.c = charArray[i]\n            hn.data = charfreq[i]\n            hn.left = None\n            hn.right = None\n            q.put(hn)\n\n        root = None\n        while q.qsize() > 1:\n            x = q.queue[0]\n            q.get()\n            y = q.queue[0]\n            q.get()\n            f = HuffmanNode()\n            f.data = x.data + y.data\n            f.c = '-'\n            f.left = x\n            f.right = y\n            root = f\n            q.put(f)\n\n        Huffman.printCode(root, '')\n", "src": "class\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n\n\n\n\nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n\n\n\n\n\n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n\n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n\n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n\n\n\n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n\n\n\n\nq.add(hn); \n\n} \n\n\n\n\nHuffmanNode root = \nnull\n; \n\n\n\n\n\n\n\n\n\n\nwhile\n(q.size() > \n1\n) { \n\n\n\n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n\n\n\n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n\n\nf.left = x; \n\n\n\n\nf.right = y; \n\n\n\n\nroot = f; \n\n\n\n\nq.add(f); \n\n} \n\n\n\n\nprintCode(root, \n\"\"\n); \n\n} \n}", "index": 571, "complexity": "5"}
{"back-translation": "class Graph: class Edge: def __init__(self): self.src, self.dest, self.weight = 0, 0, 0 def compareTo(self, compareEdge): return self.weight - compareEdge.weight class subset: def __init__(self): self.parent, self.rank = 0, 0 def __init__(self, v, e): self.V, self.E = v, e self.edge = [Edge() for i in range(e)] def find(self, subsets, i): if subsets[i].parent != i: subsets[i].parent = self.find(subsets, subsets[i].parent) return subsets[i].parent def Union(self, subsets, x, y): xroot = self.find(subsets, x) yroot = self.find(subsets, y) if subsets[xroot].rank < subsets[yroot].rank: subsets[xroot].parent = yroot elif subsets[xroot].rank > subsets[yroot].rank: subsets[yroot].parent = xroot else: subsets[yroot].parent = xroot subsets[xroot].rank += 1 def KruskalMST(self): result = [Edge() for i in range(self.V)] e = 0 i = 0 edge.sort(key=lambda x: x.weight) subsets = [subset() for i in range(self.V)] for i in range(self.V): subsets[i].parent = i subsets[i].rank = 0 while e < self.V - 1: next_edge = edge[i] i += 1 x = self.find(subsets, next_edge.src) y = self.find(subsets, next_edge.dest) if x != y: result[e] = next_edge e += 1 self.Union(subsets, x, y) print(f'Following are the edges in the constructed MST') for i in range(e): print(result[i].src, '--', result[i].dest, '==', result[i].weight) if __name__ == '__main__': V = 4 E = 5 graph = Graph(V, E) graph.edge[0].src = 0 graph.edge[0].dest = 1 graph.edge[0].weight = 10 graph.edge[1].src = 0 graph.edge[1].dest = 2 graph.edge[1].weight = 6 graph.edge[2].src = 0 graph.edge[2].dest = 3 graph.edge[2].weight = 5 graph.edge[3].src = 1 graph.edge[3].dest = 3 graph.edge[3].weight = 15 graph.edge[4].src = 2 graph.edge[4].dest = 3 graph.edge[4].weight = 4 graph.KruskalMST()", "src": "class\nGraph \n{ \n\n\n\nclass\nEdge \nimplements\nComparable<Edge> \n\n{ \n\nint\nsrc, dest, weight; \n\n\n\n\n\n\npublic\nint\ncompareTo(Edge compareEdge) \n\n{ \n\nreturn\nthis\n.weight-compareEdge.weight; \n\n} \n\n}; \n\n\n\n\nclass\nsubset \n\n{ \n\nint\nparent, rank; \n\n}; \n\n\nint\nV, E; \n\n\nEdge edge[]; \n\n\n\n\n\nGraph(\nint\nv, \nint\ne) \n\n{ \n\nV = v; \n\nE = e; \n\nedge = \nnew\nEdge[E]; \n\nfor\n(\nint\ni=\n0\n; i<e; ++i) \n\nedge[i] = \nnew\nEdge(); \n\n} \n\n\n\n\n\n\nint\nfind(subset subsets[], \nint\ni) \n\n{ \n\n\n\nif\n(subsets[i].parent != i) \n\nsubsets[i].parent = find(subsets, subsets[i].parent); \n\n\nreturn\nsubsets[i].parent; \n\n} \n\n\n\n\n\n\nvoid\nUnion(subset subsets[], \nint\nx, \nint\ny) \n\n{ \n\nint\nxroot = find(subsets, x); \n\nint\nyroot = find(subsets, y); \n\n\n\n\n\n\nif\n(subsets[xroot].rank < subsets[yroot].rank) \n\nsubsets[xroot].parent = yroot; \n\nelse\nif\n(subsets[xroot].rank > subsets[yroot].rank) \n\nsubsets[yroot].parent = xroot; \n\n\n\n\n\n\nelse\n\n{ \n\nsubsets[yroot].parent = xroot; \n\nsubsets[xroot].rank++; \n\n} \n\n} \n\n\n\n\nvoid\nKruskalMST() \n\n{ \n\nEdge result[] = \nnew\nEdge[V]; \n\n\nint\ne = \n0\n; \n\n\nint\ni = \n0\n; \n\n\nfor\n(i=\n0\n; i<V; ++i) \n\nresult[i] = \nnew\nEdge(); \n\n\n\n\n\n\n\n\nArrays.sort(edge); \n\n\n\n\nsubset subsets[] = \nnew\nsubset[V]; \n\nfor\n(i=\n0\n; i<V; ++i) \n\nsubsets[i]=\nnew\nsubset(); \n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; ++v) \n\n{ \n\nsubsets[v].parent = v; \n\nsubsets[v].rank = \n0\n; \n\n} \n\n\ni = \n0\n; \n\n\n\n\n\nwhile\n(e < V - \n1\n) \n\n{ \n\n\n\n\n\nEdge next_edge = \nnew\nEdge(); \n\nnext_edge = edge[i++]; \n\n\nint\nx = find(subsets, next_edge.src); \n\nint\ny = find(subsets, next_edge.dest); \n\n\n\n\n\n\n\n\nif\n(x != y) \n\n{ \n\nresult[e++] = next_edge; \n\nUnion(subsets, x, y); \n\n} \n\n\n\n} \n\n\n\n\n\n\nSystem.out.println(\n\"Following are the edges in \"\n+ \n\n\"the constructed MST\"\n); \n\nfor\n(i = \n0\n; i < e; ++i) \n\nSystem.out.println(result[i].src+\n\" -- \"\n+ \n\nresult[i].dest+\n\" == \"\n+ result[i].weight); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\nint\nV = \n4\n; \n\n\nint\nE = \n5\n; \n\n\nGraph graph = \nnew\nGraph(V, E); \n\n\n\n\ngraph.edge[\n0\n].src = \n0\n; \n\ngraph.edge[\n0\n].dest = \n1\n; \n\ngraph.edge[\n0\n].weight = \n10\n; \n\n\n\n\ngraph.edge[\n1\n].src = \n0\n; \n\ngraph.edge[\n1\n].dest = \n2\n; \n\ngraph.edge[\n1\n].weight = \n6\n; \n\n\n\n\ngraph.edge[\n2\n].src = \n0\n; \n\ngraph.edge[\n2\n].dest = \n3\n; \n\ngraph.edge[\n2\n].weight = \n5\n; \n\n\n\n\ngraph.edge[\n3\n].src = \n1\n; \n\ngraph.edge[\n3\n].dest = \n3\n; \n\ngraph.edge[\n3\n].weight = \n15\n; \n\n\n\n\ngraph.edge[\n4\n].src = \n2\n; \n\ngraph.edge[\n4\n].dest = \n3\n; \n\ngraph.edge[\n4\n].weight = \n4\n; \n\n\ngraph.KruskalMST(); \n\n} \n}", "index": 572, "complexity": "5"}
{"back-translation": "class prims: def __init__(self, a, b): self.dest = a self.weight = b class Graph: def __init__(self, e): self.V = e self.adj = [list() for _ in range(e)] class node: pass class comparator: def compare(self, node0, node1): return node0.key - node1.key def addEdge(graph, src, dest, weight): node0, node = prims(dest, weight), prims(src, weight) graph.adj[src].append(node0) graph.adj[dest].append(node) def prims_mst(graph): mstset, e, parent = [False] * graph.V, [node() for _ in range(graph.V)], [-1] * graph.V for o in range(graph.V): e[o].key, e[o].vertex, parent[o] = float('inf'), o, -1 mstset[0], e[0].key = True, 0 queue = {e[i] for i in range(graph.V)} while queue: node0 = queue.pop() mstset[node0.vertex] = True for iterator in graph.adj[node0.vertex]: if not mstset[iterator.dest]: if e[iterator.dest].key > iterator.weight: queue.discard(e[iterator.dest]) e[iterator.dest].key = iterator.weight queue.add(e[iterator.dest]) parent[iterator.dest] = node0.vertex for o in range(1, graph.V): print(parent[o], ' - ', o) def main(args): V, graph, e = 9, Graph(V), prims() e.addEdge(graph, 0, 1, 4) e.addEdge(graph, 0, 7, 8) e.addEdge(graph, 1, 2, 8) e.addEdge(graph, 1, 7, 11) e.addEdge(graph, 2, 3, 7) e.addEdge(graph, 2, 8, 2) e.addEdge(graph, 2, 5, 4) e.addEdge(graph, 3, 4, 9) e.addEdge(graph, 3, 5, 14) e.addEdge(graph, 4, 5, 10) e.addEdge(graph, 5, 6, 2) e.addEdge(graph, 6, 7, 1) e.addEdge(graph, 6, 8, 6) e.addEdge(graph, 7, 8, 7) e.prims_mst(graph)", "src": "public\nclass\nprims { \n\nclass\nnode1 { \n\n\n\n\nint\ndest; \n\n\n\n\nint\nweight; \n\n\n\n\nnode1(\nint\na, \nint\nb) \n\n{ \n\ndest = a; \n\nweight = b; \n\n} \n\n} \n\nstatic\nclass\nGraph { \n\n\n\n\nint\nV; \n\n\n\n\nLinkedList<node1>[] adj; \n\n\n\n\nGraph(\nint\ne) \n\n{ \n\nV = e; \n\nadj = \nnew\nLinkedList[V]; \n\nfor\n(\nint\no = \n0\n; o < V; o++) \n\nadj[o] = \nnew\nLinkedList<>(); \n\n} \n\n} \n\n\n\n\n\n\n\n\nclass\nnode { \n\nint\nvertex; \n\nint\nkey; \n\n} \n\n\n\n\n\n\n\n\n\n\nclass\ncomparator \nimplements\nComparator<node> { \n\n\n@Override\n\npublic\nint\ncompare(node node0, node node1) \n\n{ \n\nreturn\nnode0.key - node1.key; \n\n} \n\n} \n\n\n\n\n\n\nvoid\naddEdge(Graph graph, \nint\nsrc, \nint\ndest, \nint\nweight) \n\n{ \n\n\nnode1 node0 = \nnew\nnode1(dest, weight); \n\nnode1 node = \nnew\nnode1(src, weight); \n\ngraph.adj[src].addLast(node0); \n\ngraph.adj[dest].addLast(node); \n\n} \n\n\n\n\nvoid\nprims_mst(Graph graph) \n\n{ \n\n\n\n\nBoolean[] mstset = \nnew\nBoolean[graph.V]; \n\nnode[] e = \nnew\nnode[graph.V]; \n\n\n\n\nint\n[] parent = \nnew\nint\n[graph.V]; \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\ne[o] = \nnew\nnode(); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) { \n\n\n\n\nmstset[o] = \nfalse\n; \n\n\n\n\ne[o].key = Integer.MAX_VALUE; \n\ne[o].vertex = o; \n\nparent[o] = -\n1\n; \n\n} \n\n\n\n\nmstset[\n0\n] = \ntrue\n; \n\n\n\n\n\n\n\n\ne[\n0\n].key = \n0\n; \n\n\n\n\nTreeSet<node> queue = \nnew\nTreeSet<node>(\nnew\ncomparator()); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\nqueue.add(e[o]); \n\n\n\n\nwhile\n(!queue.isEmpty()) { \n\n\n\n\nnode node0 = queue.pollFirst(); \n\n\n\n\nmstset[node0.vertex] = \ntrue\n; \n\n\n\n\nfor\n(node1 iterator : graph.adj[node0.vertex]) { \n\n\n\n\nif\n(mstset[iterator.dest] == \nfalse\n) { \n\n\n\n\n\n\n\n\n\nif\n(e[iterator.dest].key > iterator.weight) { \n\nqueue.remove(e[iterator.dest]); \n\ne[iterator.dest].key = iterator.weight; \n\nqueue.add(e[iterator.dest]); \n\nparent[iterator.dest] = node0.vertex; \n\n} \n\n} \n\n} \n\n} \n\n\n\n\nfor\n(\nint\no = \n1\n; o < graph.V; o++) \n\nSystem.out.println(parent[o] + \n\" \"\n\n+ \n\"-\"\n\n+ \n\" \"\n+ o); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nV = \n9\n; \n\n\nGraph graph = \nnew\nGraph(V); \n\n\nprims e = \nnew\nprims(); \n\n\ne.addEdge(graph, \n0\n, \n1\n, \n4\n); \n\ne.addEdge(graph, \n0\n, \n7\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n2\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n7\n, \n11\n); \n\ne.addEdge(graph, \n2\n, \n3\n, \n7\n); \n\ne.addEdge(graph, \n2\n, \n8\n, \n2\n); \n\ne.addEdge(graph, \n2\n, \n5\n, \n4\n); \n\ne.addEdge(graph, \n3\n, \n4\n, \n9\n); \n\ne.addEdge(graph, \n3\n, \n5\n, \n14\n); \n\ne.addEdge(graph, \n4\n, \n5\n, \n10\n); \n\ne.addEdge(graph, \n5\n, \n6\n, \n2\n); \n\ne.addEdge(graph, \n6\n, \n7\n, \n1\n); \n\ne.addEdge(graph, \n6\n, \n8\n, \n6\n); \n\ne.addEdge(graph, \n7\n, \n8\n, \n7\n); \n\n\n\n\ne.prims_mst(graph); \n\n} \n}", "index": 573, "complexity": "5"}
{"back-translation": "class GFG:\n    def MaxSumDifference(a, n):\n        finalSequence = []\n        a.sort()\n        for i in range(n // 2):\n            finalSequence += [a[i], a[n - i - 1]]\n        MaximumSum = 0\n        for i in range(n - 1):\n            MaximumSum += abs(finalSequence[i] - finalSequence[i + 1])\n        MaximumSum += abs(finalSequence[n - 1] - finalSequence[0])\n        return MaximumSum\n    def main(args):\n        a = [1, 2, 4, 8]\n        n = len(a)\n        print(MaxSumDifference(a, n))\nmain([])", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n\n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n\n\n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n\n\n\n\n\n\nint\nMaximumSum = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n\n\n\n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n\n\nreturn\nMaximumSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n}", "index": 574, "complexity": "5"}
{"back-translation": "class MaxSum: def maxSum(arr, n): sum = 0 arr.sort() for i in range(0, n//2): sum -= (2 * arr[i]); sum += (2 * arr[n - i - 1]); return sum def main(arr): n = len(arr) print(maxSum(arr, n)) arr = [4, 2, 1, 8] main(arr)", "src": "class\nMaxSum \n{ \n\n\n\n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n}", "index": 575, "complexity": "5"}
{"back-translation": "class GFG: \n    @staticmethod \n    def maxLevel(boxes, n): \n        boxes.sort() \n        ans = 1 \n        prev_width = boxes[0] \n        prev_count = 1 \n        curr_count = 0 \n        curr_width = 0 \n        for i in range(1, n): \n            curr_width += boxes[i] \n            curr_count += 1 \n            if curr_width > prev_width and curr_count > prev_count: \n                prev_width = curr_width \n                prev_count = curr_count \n                curr_count = 0 \n                curr_width = 0 \n                ans += 1 \n        return ans \n    @staticmethod \n    def main(args): \n        boxes = [10, 20, 30, 50, 60, 70] \n        n = len(boxes) \n        print(GFG.maxLevel(boxes, n)) \n", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxLevel(\nint\n[]boxes, \nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(boxes); \n\n\nint\nans = \n1\n; \n\n\n\n\n\n\n\n\n\nint\nprev_width = boxes[\n0\n]; \n\nint\nprev_count = \n1\n; \n\n\n\n\n\n\nint\ncurr_count = \n0\n; \n\n\n\n\nint\ncurr_width = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\ncurr_width += boxes[i]; \n\ncurr_count += \n1\n; \n\n\n\n\n\n\n\n\nif\n(curr_width > prev_width && \n\ncurr_count > prev_count) \n\n{ \n\n\n\n\n\n\n\n\nprev_width = curr_width; \n\nprev_count = curr_count; \n\n\n\n\n\n\n\n\ncurr_count = \n0\n; \n\ncurr_width = \n0\n; \n\n\n\n\n\n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]boxes = {\n10\n, \n20\n, \n30\n, \n50\n, \n60\n, \n70\n}; \n\nint\nn = boxes.length; \n\nSystem.out.println(maxLevel(boxes, n)); \n\n} \n}", "index": 576, "complexity": "5"}
{"back-translation": "class GFG:\n    @staticmethod\n    def maxDifference(arr, N, k):\n        M, S, S1, max_difference = 0, 0, 0, 0\n        for i in range(N):\n            S += arr[i]\n        for i in range(N):\n            for j in range(i + 1, N):\n                if arr[i] < arr[j]:\n                    arr[i], arr[j] = arr[j], arr[i]\n        M = max(k, N - k)\n        for i in range(M):\n            S1 += arr[i]\n        max_difference = S1 - (S - S1)\n        return max_difference\n\n    @staticmethod\n    def main(args):\n        arr = [8, 4, 5, 2, 10]\n        N = len(arr)\n        k = 2\n        print(GFG.maxDifference(arr, N, k))\n", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxDifference(\nint\narr[], \nint\nN, \nint\nk) \n{ \n\nint\nM, S = \n0\n, S1 = \n0\n, max_difference = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nS += arr[i]; \n\nint\ntemp; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\n{ \n\nif\n(arr[i] < arr[j]) \n\n{ \n\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n} \n\n\nM = Math.max(k, N - k); \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nS1 += arr[i]; \n\n\n\n\nmax_difference = S1 - (S - S1); \n\nreturn\nmax_difference; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n8\n, \n4\n, \n5\n, \n2\n, \n10\n}; \n\nint\nN = arr.length; \n\nint\nk = \n2\n; \n\nSystem.out.println(maxDifference(arr, N, k)); \n} \n}", "index": 577, "complexity": "5"}
{"back-translation": "class GFG: def findElements(arr, n): arr.sort() for i in range(n - 2): print(arr[i], end=' ') def main(args): arr = [2, -6, 3, 5, 1] n = len(arr) findElements(arr, n) if __name__ == '__main__': import sys main(sys.argv)", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n}", "index": 578, "complexity": "5"}
{"back-translation": "class MinSum:\n    @staticmethod\n    def find_min_sum(a, b, n):\n        a.sort()\n        b.sort()\n        sum_val = 0\n        for i in range(n):\n            sum_val += abs(a[i] - b[i])\n        return sum_val\n\n    @staticmethod\n    def main(args):\n        a = [4, 1, 8, 7]\n        b = [2, 3, 6, 5]\n        n = len(a)\n        print(MinSum.find_min_sum(a, b, n))\n\nMinSum.main([])", "src": "class\nMinSum \n{ \n\n\n\n\n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "index": 579, "complexity": "5"}
{"back-translation": "class MinSum:\n    @staticmethod\n    def solve(a):\n        pq = PriorityQueue()\n        num1 = StringBuilder()\n        num2 = StringBuilder()\n        for x in a:\n            pq.put(x)\n        while not pq.empty():\n            num1.append(str(pq.get()) + '')\n            if not pq.empty():\n                num2.append(str(pq.get()) + '')\n        sum = int(num1.to_string()) + int(num2.to_string())\n        return sum\n\n    @staticmethod\n    def main(args):\n        arr = [6, 8, 4, 5, 2, 3]\n        print('The required sum is ' + str(MinSum.solve(arr)))", "src": "class\nMinSum \n{ \n\n\n\n\n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n\n\n\n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n\n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n\n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n\n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n}", "index": 580, "complexity": "5"}
{"back-translation": "class GFG: def DecreasingArray(a, n): sum = 0, dif = 0 pq = [] for i in range(n): if pq and pq[0] < a[i]: dif = a[i] - pq[0] sum += dif pq.pop(0) pq.append(a[i]) pq.append(a[i]) return sum def main(args): a = [3, 1, 2, 1] n = len(a) print(DecreasingArray(a, n))", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n}", "index": 581, "complexity": "5"}
{"back-translation": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n}", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n\n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n}", "index": 582, "complexity": "5"}
{"back-translation": "class GFG: def ifPossible(arr, n): copy = arr.copy() copy.sort() for i in range(n): if not (arr[i] == copy[i]) and not (arr[n - 1 - i] == copy[i]): return False return True def main(args): arr = [1, 7, 6, 4, 5, 3, 2, 8] n = len(arr) if ifPossible(arr, n): print('Yes') else: print('No') if __name__ == '__main__': main(None)", "src": "class\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n\n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 583, "complexity": "5"}
{"back-translation": "class GFG: def MaxTotalRectangleArea(a, n): import numpy as np a.sort() sum = 0 flag = False len = 0 for i in range(n): if (a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and not flag: flag = True len = a[i + 1] i += 1 elif (a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and flag: sum = sum + a[i + 1] * len flag = False i += 1 return sum def main(args): a = np.array([10, 10, 10, 10, 11, 10, 11, 10, 9, 9, 8, 8]) n = len(a) print(MaxTotalRectangleArea(a, n)) if __name__ == '__main__': import numpy as np main(sys.argv[1:])", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n\n\n\n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n\n\n\n\n\n\nflag = \ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlen = a[i + \n1\n]; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n\n\n\n\nsum = sum + a[i + \n1\n] * len; \n\n\n\n\n\n\n\n\n\n\nflag = \nfalse\n; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n}", "index": 584, "complexity": "5"}
{"back-translation": "class ItemValue: def __init__(self, wt, val, ind): self.wt = wt self.val = val self.ind = ind self.cost = float(val / wt) def getMaxValue(wt, val, capacity): iVal = [ItemValue(wt[i], val[i], i) for i in range(len(wt))] iVal.sort(key=lambda x: x.cost, reverse=True) totalValue = 0 for i in iVal: curWt = int(i.wt) curVal = int(i.val) if capacity - curWt >= 0: capacity -= curWt totalValue += curVal else: fraction = float(capacity / curWt) totalValue += (curVal * fraction) capacity = int(capacity - (curWt * fraction)) break return totalValue wt = [10, 40, 20, 30] val = [60, 40, 100, 120] capacity = 50 maxValue = getMaxValue(wt, val, capacity) print('Maximum value we can obtain = ' + str(maxValue))", "src": "public\nclass\nFractionalKnapSack \n{ \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n\n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n\n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n\n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n\n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n\n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n\n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n}", "index": 585, "complexity": "5"}
{"back-translation": "class GFG: def findMinimum(arr, n, k): res = 0 for i in range(n): res += arr[i] n = n - k return res def findMaximum(arr, n, k): res = 0 index = 0 for i in range(n-1, index-1, -1): res += arr[i] index += k return res def main(args): arr = [3, 2, 1, 4] n = len(arr) k = 2 arr.sort() print(findMinimum(arr, n, k), findMaximum(arr, n, k)) if __name__ == '__main__': main(None)", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n}", "index": 586, "complexity": "5"}
{"back-translation": "class GFG: def calculate(a, n): s = [] for i, j in zip(range(0, n), range(n-1, 0, -1)): s.append(a[i] + a[j]) mini = min(s) maxi = max(s) return abs(maxi - mini) def main(args): a = [2, 6, 4, 3] n = len(a) print(calculate(a, n)) if __name__ == \"__main__\": main([])", "src": "class\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n\n\nArrays.sort(a); \n\nint\ni,j; \n\n\n\n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n}", "index": 587, "complexity": "5"}
{"back-translation": "class\nMinHeap:\n\n    def __init__(self, a, size):\n        self.heap_size = size\n        self.capacity = size\n        self.harr = a\n        i = (self.heap_size - 1) // 2\n        while i >= 0:\n            self.MinHeapify(i)\n            i -= 1\n\n    def MinHeapify(self, i):\n        l = self.left(i)\n        r = self.right(i)\n        smallest = i\n        if l < self.heap_size and self.harr[l] < self.harr[i]:\n            smallest = l\n        if r < self.heap_size and self.harr[r] < self.harr[smallest]:\n            smallest = r\n        if smallest != i:\n            self.swap(i, smallest)\n            self.MinHeapify(smallest)\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left(self, i):\n        return 2 * i + 1\n\n    def right(self, i):\n        return 2 * i + 2\n\n    def extractMin(self):\n        if self.heap_size <= 0:\n            return float('inf')\n        if self.heap_size == 1:\n            self.heap_size -= 1\n            return self.harr[0]\n\n        root = self.harr[0]\n        self.harr[0] = self.harr[self.heap_size - 1]\n        self.heap_size -= 1\n        self.MinHeapify(0)\n\n        return root\n\n    def insertKey(self, k):\n        if self.heap_size == self.capacity:\n            print('Overflow: Could not insertKey')\n            return\n\n        self.heap_size += 1\n        i = self.heap_size - 1\n        self.harr[i] = k\n\n        while i != 0 and self.harr[self.parent(i)] > self.harr[i]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n\n    def isSizeOne(self):\n        return self.heap_size == 1\n\n    @staticmethod\n    def minCost(lengths, n):\n        cost = 0\n        minHeap = MinHeap(lengths, n)\n\n        while not minHeap.isSizeOne():\n            min_val = minHeap.extractMin()\n            sec_min_val = minHeap.extractMin()\n            cost += (min_val + sec_min_val)\n\n            minHeap.insertKey(min_val + sec_min_val)\n\n        return cost\n\n\nlengths = [4, 3, 2, 6]\nsize = len(lengths)\nprint('Total cost for connecting ropes is', MinHeap.minCost(lengths, size))", "src": "class\nMinHeap { \n\nint\n[] harr; \n\n\nint\nheap_size; \n\n\nint\ncapacity; \n\n\n\n\n\n\n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n\n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n\n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n\n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n\n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n\n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n\n\n\n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n\n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n\n\n\n\n\n\n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n\n\nwhile\n(!minHeap.isSizeOne()) { \n\n\n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n\n\n\n\n\n\n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n\n\n\n\nreturn\ncost; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n};", "index": 588, "complexity": "5"}
{"back-translation": "class GFG:\n    @staticmethod\n    def minCost(coin, n, k):\n        coin.sort()\n        coins_needed = int((n + k) / (k + 1))\n        ans = 0\n        for i in range(coins_needed):\n            ans += coin[i]\n        return ans\n\n    @staticmethod\n    def main(args):\n        coin = [8, 5, 3, 10, 2, 1, 15, 25]\n        n = len(coin)\n        k = 3\n        print(GFG.minCost(coin, n, k))\n", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\n\n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n\n\n\n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n}", "index": 589, "complexity": "5"}
{"back-translation": "{'src': 'public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\n\\nstatic\\nvoid\\npreprocess(\\nint\\n[]coin, \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\nArrays.sort(coin); \\n\\n\\n\\nfor\\n(\\nint\\ni = \\n1\\n; i <= n - \\n1\\n; i++) \\n\\ncoin[i] += coin[i - \\n1\\n]; \\n\\n} \\n\\n\\n\\n\\n\\n\\nstatic\\nint\\nminCost(\\nint\\n[]coin, \\nint\\nn, \\nint\\nk) \\n\\n{ \\n\\n\\n\\nint\\ncoins_needed = (\\nint\\n) Math.ceil(\\n1.0\\n\\n* n / (k + \\n1\\n)); \\n\\n\\n\\nreturn\\ncoin[coins_needed - \\n1\\n]; \\n\\n} \\n\\n\\n\\nstatic\\npublic\\nvoid\\nmain (String[] args) \\n\\n{ \\n\\nint\\n[]coin = {\\n8\\n, \\n5\\n, \\n3\\n, \\n10\\n, \\n2\\n, \\n1\\n, \\n15\\n, \\n25\\n}; \\n\\nint\\nn = coin.length; \\n\\n\\npreprocess(coin, n); \\n\\n\\nint\\nk = \\n3\\n; \\n\\nSystem.out.println(minCost(coin, n, k)); \\n\\n\\nk = \\n7\\n; \\n\\nSystem.out.println( minCost(coin, n, k)); \\n\\n} \\n}', 'complexity': '5', 'index': 590}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n\n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n}", "index": 590, "complexity": "5"}
{"back-translation": "class\nGFG:\n    @staticmethod\n    def findPlatform(arr, dep, n):\n        arr.sort()\n        dep.sort()\n        plat_needed = 1\n        result = 1\n        i = 1\n        j = 0\n        while i < n and j < n:\n            if arr[i] <= dep[j]:\n                plat_needed += 1\n                i += 1\n                if plat_needed > result:\n                    result = plat_needed\n            else:\n                plat_needed -= 1\n                j += 1\n        return result\n    @staticmethod\n    def main(args):\n        arr = [900, 940, 950, 1100, 1500, 1800]\n        dep = [910, 1200, 1120, 1130, 1900, 2000]\n        n = len(arr)\n        print(\"Minimum Number of Platforms Required = \", findPlatform(arr, dep, n))", "src": "class\nGFG { \n\n\nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n\n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n\n\n\n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n\n\n\n\nwhile\n(i < n && j < n) \n\n{ \n\n\n\n\n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n\n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n\n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n}", "index": 591, "complexity": "5"}
{"back-translation": "class GFG: def getMinDiff(arr, n, k): if n == 1: return 0 arr.sort() ans = arr[n-1] - arr[0] small = arr[0] + k big = arr[n-1] - k temp = 0 if small > big: temp = small; small = big; big = temp for i in range(1, n-1): subtract = arr[i] - k add = arr[i] + k if subtract >= small or add <= big: continue if big - subtract <= add - small: small = subtract else: big = add return min(ans, big - small) def main(args): arr = [4, 6] n = len(arr) k = 10 print(\"Maximum difference is \" + str(getMinDiff(arr, n, k)))", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 592, "complexity": "5"}
{"back-translation": "class GFG { static int minOps(int arr[], int n, int k) { Arrays.sort(arr); int max = arr[arr.length - 1]; int res = 0; for (int i = 0; i < n; i++) { if ((max - arr[i]) % k != 0) return -1; else res += (max - arr[i]) / k; } return res; } public static void main(String[] args) { int arr[] = {21, 33, 9, 45, 63}; int n = arr.length; int k = 6; System.out.println(minOps(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n\n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n}", "index": 593, "complexity": "5"}
{"back-translation": "class\nGFG:\n\n    @staticmethod\n    def minElements(arr, n):\n        halfSum = 0\n        for i in range(n):\n            halfSum = halfSum + arr[i]\n        halfSum = halfSum / 2\n\n        arr.sort()\n        res = 0\n        curr_sum = 0\n        for i in range(n-1, -1, -1):\n            curr_sum += arr[i]\n            res += 1\n            if curr_sum > halfSum:\n                return res\n        return res\n\n    @staticmethod\n    def main(args):\n        arr = [3, 1, 7, 1]\n        n = len(arr)\n        print(GFG.minElements(arr, n))\n\nGFG.main([])", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n\n\n\n\n\n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n\n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n}", "index": 594, "complexity": "5"}
{"back-translation": "class Main: def minAbsSumPair(arr, n): sum, min_sum = 999999 l, r = 0, n-1 min_l, min_r = l, n-1 if n < 2: print('Invalid Input') return arr.sort() while l < r: sum = arr[l] + arr[r] if abs(sum) < abs(min_sum): min_sum = sum min_l = l min_r = r if sum < 0: l += 1 else: r -= 1 print(' The two elements whose ' + 'sum is minimum are ' + str(arr[min_l])+ ' and '+ str(arr[min_r])) def main(args): arr = [1, 60, -10, 70, -80, 85] n = len(arr) minAbsSumPair(arr, n) def partition(arr, low, high): pivot = arr[high] i = low-1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 def sort(arr, low, high): if low < high: pi = partition(arr, low, high) sort(arr, low, pi-1) sort(arr, pi+1, high)", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 595, "complexity": "5"}
{"back-translation": "class GFG: def kLargest(arr, k): arr.sort(reverse=True) for i in range(k): print(arr[i], end=' ') def main(): arr = [1, 23, 12, 9, 30, 2, 50] k = 3 kLargest(arr, k) if __name__ == '__main__': main()", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n\n\n\n\n\n\n\n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n}", "index": 596, "complexity": "5"}
{"back-translation": "class GFG { public static int kthSmallest(Integer [] arr, int k) { Arrays.sort(arr); return arr[k-1]; } public static void main(String[] args) { Integer arr[] = new Integer[]{12, 3, 5, 7, 19}; int k = 2; System.out.print( \"K'th smallest element is \"+ kthSmallest(arr, k) ); } }", "src": "class\nGFG \n{ \n\n\n\n\n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n}", "index": 597, "complexity": "5"}
{"back-translation": "{'src': 'class Fly: \\n    ERROR = 0.0000001\\n\\n    def main():\\n        n, m = map(int, input().split())\\n        a = [int(input()) for _ in range(n)]\\n        b = [int(input()) for _ in range(n)]\\n        b.append(b[0])\\n\\n        max_val = 1000000000\\n        min_val = 0\\n        found = False\\n        while max_val >= min_val:\\n            mid = (max_val + min_val) / 2\\n            v = is_valid(a, b, m, n, mid)\\n            if v:\\n                max_val = mid\\n            else:\\n                min_val = mid\\n            if max_val - min_val <= ERROR and v:\\n                found = True\\n                break\\n            if max_val == min_val:\\n                break\\n\\n        if found:\\n            print(max_val)\\n        else:\\n            print(-1)\\n\\n\\n    def is_valid(a, b, m, n, fuel):\\n        total = m + fuel\\n        for i in range(n):\\n            lost = total / a[i]\\n            total -= lost\\n\\n            lost = total / b[i+1]\\n            total -= lost\\n            if (total - m) < 0:\\n                return False\\n        if (total - m) < 0:\\n            return False\\n        return True\\n', 'complexity': '5', 'index': 598}", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 598, "complexity": "5"}
{"back-translation": "{'src': 'public class BigInteger7 {\\n    public static void main(String[] args) {\\n        \\n        Scanner scanner = new Scanner(System.in);\\n        BigInteger n = scanner.nextBigInteger();\\n        BigInteger k = scanner.nextBigInteger();\\n        scanner.nextLine();\\n        String string = scanner.nextLine();\\n        char ch[] = string.toCharArray();\\n        BigInteger ans = BigInteger.ZERO;\\n        BigInteger number = BigInteger.ZERO;\\n        Arrays.sort(ch);\\n        int prev = 0;\\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\\n            if (i == 0) {\\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\\n                prev = i;\\n                number = number.add(BigInteger.ONE);\\n            } else {\\n                if (ch[i] - ch[prev] > 1) {\\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\\n                    prev = i;\\n                    number = number.add(BigInteger.ONE);\\n                }\\n            }\\n            if (number.equals(k)) {\\n                break;\\n            }\\n        }\\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\\n            System.out.println(-1);\\n        } else {\\n            System.out.println(ans);\\n        }\\n    }\\n}', 'complexity': '5', 'index': 599}", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 599, "complexity": "5"}
{"back-translation": "import array as arr\n\ndef SQR(a):\n    return a * a\n\nn, k = map(int, input().split())\nstr = input()\ns = arr.array('u', str)\ns = sorted(s)\nstr = ''.join(s)\nd = 0\nans = 0\nfor i in range(len(str)):\n    x = ord(str[i]) - ord('a')\n    if k == 0:\n        continue\n    if x >= d:\n        ans += x + 1\n        d = x + 2\n        k -= 1\nif k > 0:\n    ans = -1\nprint(ans)", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 600, "complexity": "5"}
{"back-translation": "class GFG: static k = 16 static N = 100000 static table = [[0 for _ in range(k + 1)] for _ in range(N)] def buildSparseTable(arr, n): for i in range(n): table[i][0] = arr[i] for j in range(1, k + 1): for i in range(n - (1 << j) + 1): table[i][j] = table[i][j - 1] + table[i + (1 << (j - 1))][j - 1] def query(L, R): answer = 0 for j in range(k, -1, -1): if L + (1 << j) - 1 <= R: answer += table[L][j] L += 1 << j return answer arr = [3, 7, 2, 5, 8, 9] n = len(arr) buildSparseTable(arr, n) print(query(0, 5)) print(query(3, 5)) print(query(2, 4))", "src": "class\nGFG \n{ \n\n\nstatic\nint\nk = \n16\n; \n\n\nstatic\nint\nN = \n100000\n; \n\n\n\nstatic\nlong\ntable[][] = \nnew\nlong\n[N][k + \n1\n]; \n\n\nstatic\nvoid\nbuildSparseTable(\nint\narr[], \n\nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntable[i][\n0\n] = arr[i]; \n\n\nfor\n(\nint\nj = \n1\n; j <= k; j++) \n\nfor\n(\nint\ni = \n0\n; i <= n - (\n1\n<< j); i++) \n\ntable[i][j] = table[i][j - \n1\n] + \n\ntable[i + (\n1\n<< (j - \n1\n))][j - \n1\n]; \n} \n\n\n\nstatic\nlong\nquery(\nint\nL, \nint\nR) \n{ \n\n\n\n\n\nlong\nanswer = \n0\n; \n\nfor\n(\nint\nj = k; j >= \n0\n; j--) \n\n{ \n\nif\n(L + (\n1\n<< j) - \n1\n<= R) \n\n{ \n\nanswer = answer + table[L][j]; \n\n\n\n\n\n\nL += \n1\n<< j; \n\n} \n\n} \n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n3\n, \n7\n, \n2\n, \n5\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nbuildSparseTable(arr, n); \n\n\nSystem.out.println(query(\n0\n, \n5\n)); \n\nSystem.out.println(query(\n3\n, \n5\n)); \n\nSystem.out.println(query(\n2\n, \n4\n)); \n} \n}", "index": 601, "complexity": "5"}
{"back-translation": "class loser:\n    class InputReader:\n        def __init__(self, stream):\n            self.br = BufferedReader(InputStreamReader(stream), 32768)\n            self.token = None\n\n        def next(self):\n            while self.token is None or not self.token.hasMoreTokens():\n                try:\n                    self.token = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n            return self.token.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n    class card:\n        def __init__(self, s, i):\n            self.s = s\n            self.l = i\n\n    class sort:\n        def compare(self, o1, o2):\n            if o1.l != o2.l:\n                return o1.l - o2.l\n            else:\n                return ord(o1.s) - ord(o2.s)\n\n    def shuffle(a):\n        l = []\n        for i in a:\n            l.append(i)\n        random.shuffle(l)\n        for i in range(len(a)):\n            a[i] = l[i]\n\n    class Pair:\n        def __init__(self, a, b):\n            self.a = a\n            self.b = b\n\n    def main(args):\n        sc = InputReader(System.in)\n        n = sc.nextInt()\n        m = {}\n        for i in range(n):\n            t = sc.next()\n            if t in m:\n                m[t] += 1\n            else:\n                m[t] = 1\n        ans = 0\n        for i in range(n):\n            t = sc.next()\n            if t in m and m[t] > 0:\n                m[t] -= 1\n                ans += 1\n        print(n - ans)\n", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 602, "complexity": "5"}
{"back-translation": "class Fly:\n\n    ERROR = 0.0000001\n\n    def main(self):\n        n = int(input())\n        m = int(input())\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        for i in range(n):\n            a[i] = int(input())\n\n        for i in range(n):\n            b[i] = int(input())\n        b[n] = b[0]\n\n        max_val = 1000000000\n        min_val = 0\n        found = False\n        while max_val >= min_val:\n            mid = max_val + min_val\n            mid /= 2\n            v = self.is_valid(a, b, m, n, mid)\n            \n            if v:\n                max_val = mid\n            else:\n                min_val = mid\n            if max_val - min_val <= self.ERROR and v:\n                \n                found = True\n                break\n            if max_val == min_val:\n                break\n        \n        if found:\n            print(max_val)\n        else:\n            print(-1)\n\n\n    def is_valid(self, a, b, m, n, fuel):\n        total = m + fuel\n        for i in range(n):\n            lost = total\n            lost /= a[i]\n            total -= lost\n\n            lost = total\n            lost /= b[i + 1]\n            total -= lost\n            if total - m < 0:\n                return False\n        if total - m < 0:\n            return False\n        return True\n", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 603, "complexity": "5"}
{"back-translation": "import sys\nfrom array import array\n\ninput = sys.stdin.readline\n\ndef main():\n    n, k = map(int, input().split())\n    s = input().strip()\n    ch = array('u', s)\n    ans = 0\n    number = 0\n    ch.sort()\n    prev = 0\n    for i in range(n):\n        if i == 0:\n            ans += ord(ch[i]) - ord('a') + 1\n            prev = i\n            number += 1\n        else:\n            if ord(ch[i]) - ord(ch[prev]) > 1:\n                ans += ord(ch[i]) - ord('a') + 1\n                prev = i\n                number += 1\n        if number == k:\n            break\n    if number < k:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    main()", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 604, "complexity": "5"}
{"back-translation": "def SQR(a):\n    return a * a\n\nn, k = map(int, input().split())\nstr = input()\ns = sorted(list(str))\nstr = ''.join(s)\nd = 0\nans = 0\n\nfor i in range(len(str)):\n    x = ord(str[i]) - ord('a')\n    if k == 0:\n        continue\n    if x >= d:\n        ans += x + 1\n        d = x + 2\n        k -= 1\n\nif k > 0:\n    ans = -1\n\nprint(ans)", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 605, "complexity": "5"}
{"back-translation": "class GFG: def getMinDiff(arr, n, k): if n == 1: return 0 sorted_arr = sorted(arr) ans = sorted_arr[n - 1] - sorted_arr[0] small = sorted_arr[0] + k big = sorted_arr[n - 1] - k if small > big: small, big = big, small for i in range(1, n - 1): subtract = sorted_arr[i] - k add = sorted_arr[i] + k if subtract >= small or add <= big: continue if big - subtract <= add - small: small = subtract else: big = add return min(ans, big - small) def main(args): arr = [4, 6] n = len(arr) k = 10 print('Maximum difference is ' + str(getMinDiff(arr, n, k))) if __name__ == '__main__': main(sys.argv[1:])", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 606, "complexity": "5"}
{"back-translation": "class Main: def func(): class InputReader: def __init__(self, stream): self.stream=stream def read(self): if self.numChars==-1: raise InputMismatchException(); if self.curChar>=self.numChars: self.curChar=0; try: self.numChars=self.stream.read(self.buf); except IOException as e: raise InputMismatchException(); if self.numChars<=0: return -1; return self.buf[self.curChar++]; def nextLine(self): str=''; try: str=br.readLine(); except IOException as e: e.printStackTrace(); return str def nextInt(self): c=self.read(); while isSpaceChar(c): c=self.read(); sgn=1; if c=='-': sgn=-1; c=self.read(); res=0; while !isSpaceChar(c): if c<'0' or c>'9': raise InputMismatchException(); res*=10; res+=c-'0'; c=self.read(); return res*sgn def nextLong(self): c=self.read(); while isSpaceChar(c): c=self.read(); sgn=1; if c=='-': sgn=-1; c=self.read(); res=0; while !isSpaceChar(c): if c<'0' or c>'9': raise InputMismatchException(); res*=10; res+=c-'0'; c=self.read(); return res*sgn def nextDouble(self): c=self.read(); while isSpaceChar(c): c=self.read(); sgn=1; if c=='-': sgn=-1; c=self.read(); res=0; while !isSpaceChar(c) and c!='.': if c=='e' or c=='E': return res*Math.pow(10,nextInt()); if c<'0' or c>'9': raise InputMismatchException(); res*=10; res+=c-'0'; c=self.read(); if c=='.': c=self.read(); m=1; while !isSpaceChar(c): if c=='e' or c=='E': return res*Math.pow(10,nextInt()); if c<'0' or c>'9': raise InputMismatchException(); m/=10; res+=(c-'0')*m; c=self.read(); return res*sgn def readString(self): c=self.read(); while isSpaceChar(c): c=self.read(); res=''; do: res.appendCodePoint(c); c=self.read(); while !isSpaceChar(c); return res def isSpaceChar(self, c): if self.filter!=None: return filter.isSpaceChar(c); return c==' ' or c=='\\n' or c=='\\r' or c=='\\t' or c==-1 def next(self): return self.readString() def func2(): Thread(null, Main(), 'Main', 1<<26).start() def run(self): sc=InputReader(System.in); w=PrintWriter(System.out); n=sc.nextInt(); s=sc.nextLong(); arr=[0]*n; i=0; for i in range(n): arr[i]=sc.nextLong(); Arrays.sort(arr); count=0; if arr[n//2]==s: w.print(0); else: temp=n//2; if arr[temp]>s: while arr[temp]>s: count+=arr[temp]-s; temp--; if temp<0: break; else: while arr[temp]<s: count+=s-arr[temp]; temp++; if temp>=n: break; w.print(count); w.close(); func(); func2()", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            \n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "index": 607, "complexity": "5"}
{"back-translation": "class gambling:\n    def main(args):\n        rd = Reader()\n        out = PrintWriter(System.out)\n        n = rd.nextInt()\n        a = [int]*n\n        b = [int]*n\n        for i in range(n):\n            a[i] = rd.nextInt()\n        for i in range(n):\n            b[i] = rd.nextInt()\n        solve(n, a, b, out)\n        out.flush()\n        out.close()\n\ndef solve(n, a, b, out):\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    aP = 0\n    bP = 0\n    aScore = 0\n    bScore = 0\n    for i in range(n * 2):\n        if i % 2 == 0:\n            if bP == n or (aP < n and a[aP] > b[bP]):\n                aScore += a[aP]\n                aP += 1\n            else:\n                bP += 1\n        else:\n            if aP == n or (bP < n and b[bP] > a[aP]):\n                bScore += b[bP]\n                bP += 1\n            else:\n                aP += 1\n    out.println(aScore - bScore)\n\nclass Reader:\n    BUFFER_SIZE = 1 << 16\n\n    def __init__(self):\n        self.din = DataInputStream(System.in)\n        self.buffer = [0] * self.BUFFER_SIZE\n        self.bufferPointer = 0\n        self.bytesRead = 0\n\n    def readLine(self):\n        buf = [0] * 64\n        cnt = 0\n        c = self.read()\n        while c != -1:\n            if c == ord('\\n'):\n                break\n            buf[cnt] = c\n            cnt += 1\n        return bytes(buf[:cnt])\n\n    def nextInt(self):\n        ret = 0\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = (c == ord('-'))\n        if neg:\n            c = self.read()\n        while c >= ord('0') and c <= ord('9'):\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n        if neg:\n            return -ret\n        return ret\n\n    def nextLong(self):\n        ret = 0\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = (c == ord('-'))\n        if neg:\n            c = self.read()\n        while c >= ord('0') and c <= ord('9'):\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n        if neg:\n            return -ret\n        return ret\n\n    def nextDouble(self):\n        ret = 0\n        div = 1\n        c = self.read()\n        while c <= ord(' '):\n            c = self.read()\n        neg = (c == ord('-'))\n        if neg:\n            c = self.read()\n        while c >= ord('0') and c <= ord('9'):\n            ret = ret * 10 + c - ord('0')\n            c = self.read()\n        if c == ord('.'):  \n            while True:\n                c = self.read()\n                if not (c >= ord('0') and c <= ord('9')):\n                    break\n                ret += (c - ord('0')) / div\n                div *= 10\n        if neg:\n            return -ret\n        return ret\n\n    def fillBuffer(self):\n        self.bytesRead = self.din.read(self.buffer, self.bufferPointer, self.BUFFER_SIZE)\n        if self.bytesRead == -1:\n            self.buffer[0] = -1\n\n    def read(self):\n        if self.bufferPointer == self.bytesRead:\n            self.fillBuffer()\n        self.bufferPointer += 1\n        return self.buffer[self.bufferPointer - 1]\n\n    def close(self):\n        if self.din is None:\n            return\n        self.din.close()\n", "src": "public class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "index": 608, "complexity": "5"}
{"back-translation": "class cf:\n    class FastScanner:\n        def __init__(self, in):\n            self.br = BufferedReader(in)\n            self.st = None\n        \n        def next(self):\n            while self.st is None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n \n        def nextInt(self):\n            return int(self.next())\n        \n        def nextLong(self):\n            return int(self.next())\n        \n        def nextDouble(self):\n            return float(self.next())\n        \n        def nextLine(self):\n            str = \"\"\n            try:\n                str = self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str\n        \n        def nextIntArray(self, n):\n            a = [int(self.nextInt()) for _ in range(n)]\n            return a\n\n    mod = 1000000007\n    \n    def main(self, args):\n        sc = FastScanner()\n        pw = PrintWriter(System.out)\n\n        n, k = sc.nextInt(), sc.nextInt()\n        a = [0] * (n+1)\n\n        for i in range(n):\n            a[i] = sc.nextInt()\n        a[n] = 0\n        a.sort()\n\n        for i in range(1, n+1):\n            if k == 0:\n                break\n            if a[i] != a[i-1]:\n                k -= 1\n                pw.println(a[i] - a[i-1])\n        for i in range(k):\n            pw.println(0)\n        pw.close()", "src": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}", "index": 609, "complexity": "5"}
{"back-translation": "{'src': 'class bOX:\\n\\n    def main(ars):\\n\\n        s = input().split()\\n        n = int(s[0])\\n        max = 0\\n\\n        map = {}\\n\\n        for i in range(n):\\n            x = int(input().split()[0])\\n            if x not in map:\\n                map[x] = 1\\n                max = max(max,1)\\n            else:\\n                map[x] += 1\\n                max = max(max,map[x])\\n\\n        print(max)\\n    \\nif __name__ == '__main__':\\n    main(None)', 'complexity': '5', 'index': 610}", "src": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}", "index": 610, "complexity": "5"}
{"back-translation": "class GFG:\n    def findMinDiff(arr, n):\n        arr.sort()\n        diff = float('inf')\n        for i in range(n-1):\n            if arr[i+1] - arr[i] < diff:\n                diff = arr[i+1] - arr[i]\n        return diff\n\n    def main(args):\n        arr = [1, 5, 3, 19, 18, 25]\n        print('Minimum difference is ' + str(findMinDiff(arr, len(arr)))\n\nmain([])", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 611, "complexity": "5"}
{"back-translation": "class RadioStation:\n    def __init__(self):\n        self.st = None\n\n    def main(self):\n        n = self.nextInt()\n        m = self.nextInt()\n        map = {}\n        for i in range(n):\n            s = self.nextString()\n            t = self.nextString()\n            map[t] = s\n        for i in range(m):\n            s = self.nextString()\n            t = self.nextString()\n            print(s + ' ' + t + ' #' + map[t[:-1]])\n\n    def nextLine(self):\n        return input()\n\n    def nextString(self):\n        if self.st is None or not self.st.hasMoreTokens():\n            self.st = input().split()\n        return self.st.pop(0)\n\n    def nextInt(self):\n        return int(self.nextString())\n\n    def nextLong(self):\n        return int(self.nextString())\n\n    def intArray(self, n):\n        return [self.nextInt() for _ in range(n)]\n\n    def intArray(self, n, m):\n        return [[self.nextInt() for _ in range(m)] for _ in range(n)]\n\n    def longArray(self, n):\n        return [self.nextLong() for _ in range(n)]\n}", "src": "public class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 612, "complexity": "5"}
{"back-translation": "class AlternativeString: def alternateSort(arr, n): arr.sort() i, j = 0, n-1 while i < j: print(arr[j], end=' ') print(arr[i], end=' ') if n % 2 != 0: print(arr[i]) def main(args): arr = [1, 12, 4, 6, 7, 10] n = len(arr) alternateSort(arr, n) main([])", "src": "class\nAlternativeString \n{ \n\n\n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\n\n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n}", "index": 613, "complexity": "5"}
{"back-translation": "{'src': 'public class Main {\\n    public static void main(String[] args) {\\n        InputStream inputStream = System.in;\\n        OutputStream outputStream = System.out;\\n        InputReader in = new InputReader(inputStream);\\n        PrintWriter out = new PrintWriter(outputStream);\\n        TaskA solver = new TaskA();\\n        solver.solve(1, in, out);\\n        out.close();\\n    }\\n\\n    static class TaskA {\\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\\n            int height = in.nextInt();\\n            int width = in.nextInt();\\n            int n1 = in.nextInt();\\n            int n2 = in.nextInt();\\n            int v = in.nextInt();\\n            int[] p1 = new int[n1];\\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\\n            int[] p2 = new int[n2];\\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\\n            int nq = in.nextInt();\\n            for (int iq = 0; iq < nq; ++iq) {\\n                int r1 = in.nextInt();\\n                int c1 = in.nextInt();\\n                int r2 = in.nextInt();\\n                int c2 = in.nextInt();\\n                if (r1 == r2) {\\n                    out.println(Math.abs(c1 - c2));\\n                } else {\\n                    long res = Long.MAX_VALUE;\\n                    int pos = Arrays.binarySearch(p1, c1);\\n                    if (pos < 0) pos = -(pos + 1);\\n                    if (pos >= 0 && pos < p1.length) {\\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\\n                    }\\n                    --pos;\\n                    if (pos >= 0 && pos < p1.length) {\\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\\n                    }\\n                    pos = Arrays.binarySearch(p2, c1);\\n                    if (pos < 0) pos = -(pos + 1);\\n                    if (pos >= 0 && pos < p2.length) {\\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\\n                    }\\n                    --pos;\\n                    if (pos >= 0 && pos < p2.length) {\\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\\n                    }\\n                    out.println(res);\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    static class InputReader {\\n        public BufferedReader reader;\\n        public StringTokenizer tokenizer;\\n\\n        public InputReader(InputStream stream) {\\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\\n            tokenizer = null;\\n        }\\n\\n        public String next() {\\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\\n                try {\\n                    tokenizer = new StringTokenizer(reader.readLine());\\n                } catch (IOException e) {\\n                    throw new RuntimeException(e);\\n                }\\n            }\\n            return tokenizer.nextToken();\\n        }\\n\\n        public int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n    }\\n}', 'complexity': '5', 'index': 614}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "index": 614, "complexity": "5"}
{"back-translation": "class GFG : def rearrange(arr, n, x): m = {} for i in range(n): diff = abs(x - arr[i]) if diff in m: m[diff].append(arr[i]) else: m[diff] = [arr[i]] index = 0 for key, value in sorted(m.items()): for i in range(len(value)): arr[index] = value[i] index += 1 def printArray(arr, n): for i in range(n): print(arr[i], end=' ') if __name__ == '__main__': arr = [10, 5, 3, 9, 2] n = len(arr) x = 7 rearrange(arr, n, x) printArray(arr, n)", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n\n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n}", "index": 615, "complexity": "5"}
{"back-translation": "{'src': 'public class LessorEqual_CodeForces {\\n\\t\\n\\t\\n\\tpublic static void main(String[] args) throws IOException {\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n\\t\tString temp[]=br.readLine().split(' ');\\n\\t\tint n = Integer.parseInt(temp[0]);\\n\\t\tint k = Integer.parseInt(temp[1]);\\n\\t\ttemp=br.readLine().split(' ');\\n\\t\tint [] num = new int[n];\\n\\n\\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \\n\\t\tfor(int i=0;i<n;i++){\\n\\t\\t\\tnum[i]=Integer.parseInt(temp[i]);\\n\\t\\t\\tpq.add(num[i]);\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(k==0){\\n\\t\\t\\tint y= pq.poll();\\n\\t\\t\\tif(y==1){\\n\\t\\t\\t\\tSystem.out.println(-1);\\n\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.println(y-1);\\n\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tint max=0;\\n\\t\\twhile (!pq.isEmpty()){\\n\\t\\t\\tint x = pq.poll();\\n\\t\\t\\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\\n\\t\\t\\t\\tpq.poll();\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\tcount++;\\n\\t\\t\\tmax=x;\\n\\t\\t\\tif(count==k)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tif(count==k){\\n\\t\\t\\tif(!pq.contains(max+1)&& max<1e9)\\n\\t\\t\\t\\tSystem.out.println(max+1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tSystem.out.println(max);\\n\\t\\t\\t}\\n\\t\\telse \\n\\t\\t\\tSystem.out.println(-1);\\n \\n\\t\\t\\n\\t}\\n\\n}', 'complexity': '5', 'index': 616}", "src": "public class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}", "index": 616, "complexity": "5"}
{"back-translation": "{'src': 'public class JavaApplication7 {\\n\\n    public static void main(String[] args) {\\n        Scanner sc=new Scanner(System.in);\\n        int n= sc.nextInt();\\n        int m=sc.nextInt();\\n        long sum=0;\\n        long []d=new long[n];\\n        long[]ds=new long[n];\\n        for(int i =0;i<n;i++){\\n            d[i]=sc.nextLong();\\n            sum+=d[i];\\n            ds[i]=sum;\\n        }\\n        long[]le=new long[m];\\n        for(int i =0;i<m;i++){\\n            le[i]=sc.nextLong();\\n        }\\n        int l=0;\\n        int h=n;\\n        int k=(h-l)//2;\\n        k+=l;\\n        for(int i=0;i<m;i++){\\n        l=0;\\n        h=n;\\n        k=(h-l)//2;\\n        k+=l;\\n            for(;l<=h;){\\n                k=(h-l)//2;\\n                k+=l;\\n                if(ds[k]<le[i]){\\n                    l=k+1;\\n                }\\n                else if(ds[k]==le[i]){break;}\\n                else{\\n                    h=k-1;\\n                }\\n            }\\n            \\n            if(ds[k]<le[i]){\\n                    k++;\\n                }\\n          if(k==0){\\n              System.out.println((int)(k+1)+\" \"+le[i]);\\n           }\\n            else{\\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\\n           }\\n        }\\n        \\n    }\\n    \\n}', 'complexity': '5', 'index': 617}", "src": "public class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        for(int i =0;i<n;i++){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n        }\n        long[]le=new long[m];\n        for(int i =0;i<m;i++){\n            le[i]=sc.nextLong();\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        for(int i=0;i<m;i++){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[i]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[i]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            \n            if(ds[k]<le[i]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[i]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\n           }\n        }\n        \n    }\n    \n}", "index": 617, "complexity": "5"}
{"back-translation": "import java.util.*;\n\nclass Codeforces {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            int temp = sc.nextInt();\n            list.add(temp);\n        }\n        Collections.sort(list);\n        if (n % 2 == 0)\n            System.out.println(list.get((n / 2) - 1));\n        else\n            System.out.println(list.get(n / 2));\n    }\n}", "src": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}", "index": 618, "complexity": "5"}
{"back-translation": "{'src': 'def main():\\n\\tn = int(input())\\n\\tp = [int(input()) for i in range(n // 2)]\\n\\tprint(solve(p))\\n\\n\\ndef solve(p):\\n\\treturn min(compute_move_num(p, 1), compute_move_num(p, 2))\\n\\n\\ndef compute_move_num(p, offset):\\n\\tp.sort()\\n\\treturn sum([abs(p[i] - (i * 2 + offset)) for i in range(len(p))])\\n\\n\\nif __name__ == '__main__':\\n\\tmain()\\n', 'complexity': '5', 'index': 619}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}", "index": 619, "complexity": "5"}
{"back-translation": "class Sol:\n    def main():\n        sc = MyScanner()\n        out = PrintWriter(BufferedOutputStream(System.out))\n        n = sc.nextInt()\n        k = sc.nextInt()\n        l = sc.nextInt()\n        a = [0] * n*k\n        for i in range(n*k):\n            a[i] = sc.nextInt()\n        a.sort()\n        if a[n - 1] - a[0] > l:\n            out.println(0)\n        else:\n            maxPos = n*k - 1\n            for i in range(n*k):\n                if a[i] - a[0] > l:\n                    maxPos = i-1\n                    break\n            o = a[0]\n            s = 0\n            t = 1\n            for i in range(1, maxPos+1):\n                if s < k - 1 and maxPos-i+1 > n-t:\n                    s += 1\n                else:\n                    s = 0\n                    t += 1\n                    o += a[i]\n            out.println(o)\n        out.close()\n\n    class MyScanner:\n        def __init__(self):\n            self.br = BufferedReader(InputStreamReader(System.in))\n            self.st = None\n\n        def next(self):\n            while self.st == None or not self.st.hasMoreElements():\n                try:\n                    self.st = StringTokenizer(self.br.readLine())\n                except IOException as e:\n                    e.printStackTrace()\n            return self.st.nextToken()\n\n        def nextInt(self):\n            return int(self.next())\n\n        def nextLong(self):\n            return int(self.next())\n\n        def nextDouble(self):\n            return float(self.next())\n\n        def nextLine(self):\n            str = \"\"\n            try:\n                str = self.br.readLine()\n            except IOException as e:\n                e.printStackTrace()\n            return str\n\n    def out(): pass", "src": "public class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tInteger[] a = new Integer[n*k];\n\t\tfor(int i = 0; i < n*k; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (a[n - 1] - a[0] > l) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint maxPos = n*k - 1;\n\t\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\t\tif (a[i] - a[0] > l) {\n\t\t\t\t\tmaxPos = i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong o = a[0];\n\t\t\tint s = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i <= maxPos; i++) {\n\t\t\t\t\n\t\t\t\tif (s < k - 1 && maxPos-i+1 > n-t) {\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ts = 0;\n\t\t\t\t\tt++;\n\t\t\t\t\to += a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(o);\n\t\t}\n\t\tout.close();\n\t}\n\n\t\n\tpublic static PrintWriter out;\n\n\t\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t\n}", "index": 620, "complexity": "5"}
{"back-translation": "{'src': 'public class MicroWorld {\\n    public static void main(String[] args) {\\n        List<Integer> a = new ArrayList<Integer>();\\n        Scanner sc = new Scanner(System.in);\\n\\n        int n = sc.nextInt();\\n        int k = sc.nextInt();\\n        for(int i=0; i<n; i++) {\\n            a.add(sc.nextInt());\\n        }\\n\\n        Collections.sort(a);\\n\\n        int count = 1;\\n        int remaining = n;\\n        for(int i=0; i<n-1; i++) {\\n            if(a.get(i) == a.get(i+1)) {\\n                count++;\\n                continue;\\n            }\\n            if((a.get(i) + k) >= a.get(i+1)) {\\n                remaining -= count;\\n            }\\n            count = 1;\\n        }\\n        System.out.println(remaining);\\n    }\\n}', 'complexity': '5', 'index': 621}", "src": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}", "index": 621, "complexity": "5"}
{"back-translation": "class gr1:\n    class InputReader:\n        def __init__(self, stream):\n            self.br = BufferedReader(InputStreamReader(stream), 32768)\n            self.token = None\n        def next(self):\n            while self.token is None or not self.token.hasMoreTokens():\n                try:\n                    self.token = StringTokenizer(br.readLine())\n                except IOException as e:\n                    raise RuntimeException(e)\n                return self.token.nextToken()\n        def nextInt(self):\n            return int(self.next())\n        def nextLong(self):\n            return int(self.next())\n        def nextDouble(self):\n            return float(self.next())\n    class card:\n        def __init__(self, a, cnt, i):\n            self.a = a\n            self.cnt = cnt\n            self.i = i\n    class ascend:\n        def compare(self, o1, o2):\n            if o1.b != o2.b:\n                return int(o1.b - o2.b)\n            else:\n                return int(o1.a - o2.a)\n    class extra:\n        @staticmethod\n        def shuffle(a):\n            l = [i for i in a]\n            random.shuffle(l)\n            for i in range(len(a)):\n                a[i] = l[i]\n        @staticmethod\n        def gcd(a, b):\n            return a if b == 0 else extra.gcd(b, a % b)\n        @staticmethod\n        def valid(i, j, r, c):\n            return True if 0 <= i < r and 0 <= j < c else False\n        v = [False] * 100001\n        l = []\n        t = 0\n        @staticmethod\n        def seive():\n            for i in range(2, 100001):\n                if not extra.v[i]:\n                    extra.t += 1\n                    extra.l.append(i)\n                    for j in range(2 * i, 100001, i):\n                        extra.v[j] = True\n        @staticmethod\n        def binary(a, val, n):\n            l, r, ans = 0, n - 1, 0\n            while l <= r:\n                mid = (l + r) >> 1\n                if a[mid].a == val:\n                    r, ans = mid - 1, mid\n                elif a[mid].a > val:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n                    ans = l\n            return ans\n    class pair:\n        def __init__(self, a, n):\n            self.a = a\n            self.b = n\n    sc = InputReader(System.in)\n    out = PrintWriter(System.out)\n    def main(args):\n        s = solver()\n        t = 1\n        while t > 0:\n            s.solve()\n            t -= 1\n    class solver:\n        def solve(self):\n            n = sc.nextInt()\n            a = [0] * n\n            sum_var = 0\n            for i in range(n):\n                a[i] = sc.nextInt()\n                sum_var += a[i]\n            a.sort()\n            k = int(round(4.5 * n)) - sum_var\n            if k <= 0:\n                print(0)\n            else:\n                p, ans = 0, 0\n                for i in range(n):\n                    if a[i] != 5:\n                        p += 5 - a[i]\n                        if p >= k:\n                            ans += 1\n                            print(ans)\n                            break\n                        ans += 1\n}", "src": "public class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    \n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           \n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 622, "complexity": "5"}
{"back-translation": "class Test:\n    @staticmethod\n    def mergeSort(arr, array_size):\n        temp = [0] * array_size\n        return Test._mergeSort(arr, temp, 0, array_size - 1)\n    @staticmethod\n    def _mergeSort(arr, temp, left, right):\n        inv_count = 0\n        if right > left:\n            mid = (right + left) // 2\n            inv_count = Test._mergeSort(arr, temp, left, mid)\n            inv_count += Test._mergeSort(arr, temp, mid + 1, right)\n            inv_count += Test.merge(arr, temp, left, mid + 1, right)\n        return inv_count\n    @staticmethod\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid\n        k = left\n        inv_count = 0\n        while i <= mid - 1 and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                k += 1\n                j += 1\n                inv_count = inv_count + (mid - i)\n        while i <= mid - 1:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        return inv_count\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    print(\"Number of inversions are \" + str(Test.mergeSort(arr, 5)))", "src": "class\nTest { \n\n\n\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n\n\nmid = (right + left) / \n2\n; \n\n\n\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n\n\nj = mid; \n\n\nk = left; \n\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n}", "index": 623, "complexity": "5"}
{"back-translation": "ERROR", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 624, "complexity": "5"}
{"back-translation": "{'src': 'public class Test {\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\\n        String[] line = reader.readLine().split(\" \");\\n        int w = Integer.valueOf(line[0]);\\n        int h = Integer.valueOf(line[1]);\\n        int n = Integer.valueOf(line[2]);\\n\\n        Request[] requests = new Request[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            line = reader.readLine().split(\" \");\\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\\n        }\\n\\n        for (long e : solve(h, w, requests))\\n            System.out.println(e);\\n\\n\\n\\n\\n\\n\\n    }\\n\\n    private static Request[] generate(int w, int h, int n) {\\n        Request[] requests = new Request[n];\\n        Random rnd = new Random();\\n\\n        for (int i = 0; i < n; i++) {\\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\\n        }\\n\\n        return requests;\\n    }\\n\\n    private static long[] solve(int h, int w, Request[] requests) {\\n        TreeSet<Integer> hTree = new TreeSet<>();\\n        TreeSet<Integer> wTree = new TreeSet<>();\\n\\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\\n\\n        hTree.add(0);\\n        hTree.add(h);\\n        wTree.add(0);\\n        wTree.add(w);\\n\\n        hHeap.add(new CoordinateWithSize(0, h));\\n        wHeap.add(new CoordinateWithSize(0, w));\\n\\n        long[] res = new long[requests.length];\\n        for (int i = 0; i < requests.length; i++) {\\n            Request request = requests[i];\\n\\n            switch (request.type) {\\n                case \"H\": {\\n                    if (!hTree.contains(request.coordinate)) {\\n                        int higher = hTree.higher(request.coordinate);\\n                        int lower = hTree.lower(request.coordinate);\\n\\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\\n\\n                        hTree.add(request.coordinate);\\n                    }\\n\\n                    break;\\n                }\\n                case \"V\": {\\n                    if (!wTree.contains(request.coordinate)) {\\n                        int higher = wTree.higher(request.coordinate);\\n                        int lower = wTree.lower(request.coordinate);\\n\\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\\n\\n                        wTree.add(request.coordinate);\\n                    }\\n\\n                    break;\\n                }\\n                default:\\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\\n            }\\n\\n            while (true) {\\n                CoordinateWithSize c = hHeap.peek();\\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\\n                    break;\\n                hHeap.remove();\\n            }\\n\\n            while (true) {\\n                CoordinateWithSize c = wHeap.peek();\\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\\n                    break;\\n                wHeap.remove();\\n            }\\n\\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\\n        }\\n\\n        return res;\\n    }\\n\\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\\n\\n        private final int coordinate;\\n\\n        private final int size;\\n\\n        public CoordinateWithSize(int coordinate, int size) {\\n            this.coordinate = coordinate;\\n            this.size = size;\\n        }\\n\\n        @Override public int compareTo(CoordinateWithSize o) {\\n            return Integer.compare(o.size, size);\\n        }\\n    }\\n\\n    private static class Request {\\n\\n        private final String type;\\n\\n        private final int coordinate;\\n\\n        public Request(String type, int coordinate) {\\n            this.type = type;\\n            this.coordinate = coordinate;\\n        }\\n    }\\n}', 'complexity': '5', 'index': 625}", "src": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n        }\n\n        for (long e : solve(h, w, requests))\n            System.out.println(e);\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "index": 625, "complexity": "5"}
{"back-translation": "class Main:\n    def main(*args):\n        inputStream = System.in\n        outputStream = System.out\n        in_ = InputReader(inputStream)\n        out = InputReader.OutputWriter(outputStream)\n\n        n = in_.nextInt()\n        s = in_.nextInt()\n        lifts = [Lift(in_.nextInt(), in_.nextInt()) for _ in range(n)]\n        lifts.sort(key=lambda x: x.getLevel(), reverse=True)\n\n        ans = 0\n        for lift in lifts:\n            current = lift\n            ans += s - current.getLevel()\n            if current.getTime() > ans:\n                ans += current.getTime() - ans\n            s = current.getLevel()\n\n        ans += s\n        out.println(ans)\n        out.flush()\n\n\nclass Lift:\n    def __init__(self, level, time):\n        self.level = level\n        self.time = time\n\n    def getLevel(self):\n        return self.level\n\n    def getTime(self):\n        return self.time\n\n\nclass InputReader(BufferedReader):\n    def __init__(self, inputStream):\n        super().__init__(InputStreamReader(inputStream), 32768)\n        self.tokenizer = None\n\n    def next(self):\n        while self.tokenizer is None or not self.tokenizer.hasMoreTokens():\n            try:\n                self.tokenizer = StringTokenizer(self.readLine())\n            except IOException as e:\n                raise RuntimeException()\n        return self.tokenizer.nextToken()\n\n    def nextInt(self):\n        return int(self.next())\n\n    def nextLong(self):\n        return int(self.next())\n\n    class OutputWriter(PrintWriter):\n        def __init__(self, outputStream):\n            super().__init__(outputStream)\n\n        def close(self):\n            super().close()", "src": "public class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "index": 626, "complexity": "5"}
{"back-translation": "class Main: def __init__(self): self.br = BufferedReader(InputStreamReader(System.in)); self.st = StringTokenizer(self.br.readLine()) def next(self): if self.st.hasMoreTokens(): return self.st.nextToken() try: self.st = StringTokenizer(self.br.readLine()) except Exception as e: e.printStackTrace() return self.st.nextToken() def nextInt(self): return int(self.next()) def nextLong(self): return int(self.next()) def nextDouble(self): return float(self.next()) def nextLine(self): line = \"\" if self.st.hasMoreTokens(): line = self.st.nextToken() else: try: return self.br.readLine() except IOException as e: e.printStackTrace() while(self.st.hasMoreTokens()): line += \" \" + self.st.nextToken() return line class Pair: def __init__(self, a, b): self.a = a self.b = b if __name__ == \"__main__\": sc = Main() pw = PrintWriter(System.out) n = sc.nextInt() floor = sc.nextInt() time = 0 arr = [] for i in range(n): arr.append(Pair(sc.nextInt(), sc.nextInt())) arr.sort(key=lambda x: x.a, reverse=True) for i in range(n): time += floor - arr[i].a floor = arr[i].a time = max(time, arr[i].b) time += arr[n-1].a pw.println(time) pw.close()", "src": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            \n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}", "index": 627, "complexity": "5"}
